<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>有向图的拓扑序列</title>
      <link href="/posts/ef6a4cd7f55c/"/>
      <url>/posts/ef6a4cd7f55c/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-848-有向图的拓扑序列"><a href="#AcWing-848-有向图的拓扑序列" class="headerlink" title="[AcWing.848. 有向图的拓扑序列]"></a><a href="https://www.acwing.com/problem/content/850/">[AcWing.848. 有向图的拓扑序列]</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的有向图，点的编号是 <code>1</code> 到 <code>n</code>，图中可能存在重边和自环。</p><p>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 <code>-1</code>。</p><p>若一个由图中所有点构成的序列 <code>A</code> 满足：对于图中的每条边 <code>(x, y)</code>，<code>x</code> 在 <code>A</code> 中都出现在 <code>y</code> 之前，则称 <code>A</code> 是该图的一个拓扑序列。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <code>n</code> 和 <code>m</code>。</p><p>接下来 <code>m</code> 行，每行包含两个整数 <code>x</code> 和 <code>y</code>，表示存在一条从点 <code>x</code> 到点 <code>y</code> 的有向边 <code>(x, y)</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</p><p>否则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n,m &lt; 10^5</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 3<br>1 2<br>2 3<br>1 3<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1 2 3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>首先，存在拓扑序列，必定是<code>有向无环图</code>，如果是<code>有向有环图一定没有拓扑序列</code>，无向图更别说了。</p><p><code>核心思想</code>：</p><ol><li>n个节点，将入度为0的节点全部入队</li><li>删除掉所有入度为0的节点，在这个过程中，被删掉的节点不妨设为<code>t</code></li><li>遍历<code>t</code>节点的邻边节点，让<code>t</code>节点的所有邻边节点<code>入度减1</code>，如果<code>邻边节点入度被减之后恰好为0</code>，则入队</li></ol><p>此题，n的数量达到了10^5。所以需要使用邻接表，当然邻接矩阵算法也写下来，用于借鉴。<br>时间复杂度分别为<code>o(n + m)</code>和<code>o(n^2)</code>。</p><p><code>需要注意的是</code>：<br>邻接矩阵的重边造成的影响需要在加边的时候进行判断，维护入度，不让重边的出现导致入度混乱。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!g[a][b])&#123;<br>    <span class="hljs-comment">// 加边</span><br>&#125;<br></code></pre></td></tr></table></figure><br>或者，在topsort的时候将重边一起删掉，也意味着重边入度也要减少<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(g[t][j]) --g[t][j],--d[j];<br></code></pre></td></tr></table></figure><br><code>使用邻接表</code>就不需要加判断了，因为邻接表在加边的时候，重边不仅加进去了，在<code>topsort</code>的时候<br>它会处理重边，所以入度一直是正确的。</p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 最大节点的数量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-comment">// 节点数，边数</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> id;<br>    Node * next;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _id): <span class="hljs-built_in">id</span>(_id), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<br>&#125; * head[N]; <span class="hljs-comment">// 邻接表</span><br><br><span class="hljs-comment">// 入度，队列</span><br><span class="hljs-type">int</span> d[N], q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 有向图头插法加边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-comment">// 创建b节点</span><br>    Node * p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(b);<br>    <span class="hljs-comment">// b节点的next指向原来节点a指向的next</span><br>    p -&gt; next = head[a];<br>    <span class="hljs-comment">// 节点a指向节点b</span><br>    head[a] = p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 将所有入度为0的节点加入队列之中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span>(!d[i])<br>            q[++tt] = i;<br>            <br>    <span class="hljs-comment">// 删除掉所有入度为0的节点</span><br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh++];<br>        <br>        <span class="hljs-comment">// 遍历t节点的邻边节点</span><br>        <span class="hljs-keyword">for</span>(Node * p = head[t]; p; p = p -&gt; next)&#123;<br>            <span class="hljs-comment">// 周边节点入度-1，如果入度为0，则加入队列</span><br>            <span class="hljs-keyword">if</span>(--d[p -&gt; id] == <span class="hljs-number">0</span>)&#123;<br>                q[++tt] = p -&gt; id;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// n个节点都应该被删掉一次，那么tt达到 n - 1</span><br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-comment">// a -&gt; b</span><br>        <span class="hljs-built_in">add</span>(a, b);<br>        d[b]++; <span class="hljs-comment">// b的入度+1</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果图有环</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">topsort</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 合法拓扑序列恰好是 0 ~ tt，这里写成 &lt; n也无妨，输出那n个节点(0 ~ n - 1)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>; <span class="hljs-comment">// 假设最多有1000个顶点</span><br><br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">// 邻接矩阵表示图</span><br><span class="hljs-type">int</span> d[N]; <span class="hljs-comment">// 入度数组</span><br><span class="hljs-type">int</span> q[N], tt = <span class="hljs-number">-1</span>, hh = <span class="hljs-number">0</span>; <span class="hljs-comment">// 队列及其指针</span><br><span class="hljs-comment">// 节点数、边数</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 遍历所有节点，入度为0的点全部入队</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!d[i]) &#123;<br>            q[++tt] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 装填完毕，删除当前节点，周边节点的入度-1，看是否为0，如果满足它们也入队</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt) &#123;<br>        <span class="hljs-type">int</span> t = q[hh++];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (g[t][j]) &#123; <span class="hljs-comment">// 如果存在边t-&gt;j</span><br>                <span class="hljs-comment">// 由于重边的影响，比如两次 2 -&gt; 3</span><br>                <span class="hljs-comment">// 需要一口气将3的入度-2</span><br>                <span class="hljs-keyword">while</span>(g[t][j]) --g[t][j],--d[j];<br>                <br>                <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">0</span>) &#123;<br>                    q[++tt] = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        g[a][b]++; <span class="hljs-comment">// 边数+1</span><br>        d[b]++; <span class="hljs-comment">// b的入度+1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">topsort</span>()) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n ; i++) &#123;<br>            cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴素邻接矩阵版Dijkstra求最短路</title>
      <link href="/posts/6d0f7c8cf39d/"/>
      <url>/posts/6d0f7c8cf39d/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-849-Dijkstra求最短路-I"><a href="#AcWing-849-Dijkstra求最短路-I" class="headerlink" title="[AcWing.849. Dijkstra求最短路 I]"></a><a href="https://www.acwing.com/problem/content/851/">[AcWing.849. Dijkstra求最短路 I]</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 <code>1</code> 号点到 <code>n</code> 号点的最短距离，如果无法从 <code>1</code> 号点走到 <code>n</code> 号点，则输出 <code>-1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>n</code> 和 <code>m</code>。</p><p>接下来 <code>m</code> 行每行包含三个整数 <code>x,y,z</code>，表示存在一条从点 <code>x</code> 到点 <code>y</code> 的有向边，边长为 <code>z</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 <code>1</code> 号点到 <code>n</code> 号点的最短距离。</p><p>如果路径不存在，则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 500</code>,<br><code>1 &lt; m &lt; 10^5</code>,<br>图中涉及边长均不超过10000。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 3<br>1 2 2<br>2 3 1<br>1 3 4<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>朴素Dijkstra</code>可以用来求<code>有向图</code>的<code>单源最短路</code>(一个点到其余点的最短距离，一般默认是求起点1到其余点的距离)，<code>无向图</code>可以看作特殊的<code>有向图</code>，只需要建图的时候<code>建两条边</code>即可。</p><p><code>邻接矩阵</code>版，主要变量名解释:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 最大点、边的数组容量、正无穷</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">100010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-comment">// 点、边</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-comment">// 使用邻接矩阵表示图</span><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-comment">// 源点距离其它点的距离</span><br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-comment">// 该点是否已经属于最短路集合中</span><br><span class="hljs-type">bool</span> st[N];<br></code></pre></td></tr></table></figure></p><p><code>易错点：</code></p><ol><li>main函数一开始<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 很重要的一点！一开始就将邻接矩阵的距离都初始化为无穷大</span><br><span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br></code></pre></td></tr></table></figure></li><li>dijkstra函数内一开始<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化源点距离数组为无穷大</span><br><span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br></code></pre></td></tr></table></figure></li><li>dijkstra逻辑细节别都嵌套到for循环里面去了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 枚举所有点（这层循环要求点的编号也能对应上，从1开始）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>    <span class="hljs-comment">// 如果这个点还没有被纳入最短路集合里面</span><br>    <span class="hljs-comment">// t是-1，或者 有点j存在使得 有更短的路径</span><br>    <span class="hljs-comment">// 更新 t</span><br>    <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))&#123;<br>        t = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 确定这个t点是最短路集合里面的点</span><br>st[t] = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 由于t这个点加入，需要更新一下距离</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>    <span class="hljs-comment">// g[t][j]是边权</span><br>    dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 最大点、边的数组容量、正无穷</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">100010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-comment">// 点、边</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-comment">// 使用邻接矩阵表示图</span><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-comment">// 源点距离其它点的距离</span><br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-comment">// 该点是否已经属于最短路集合中</span><br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 初始化源点距离数组为无穷大</span><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    <span class="hljs-comment">// 源点距离源点它自己的距离为0，源点默认为1</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 枚举所有点（n次），虽然dist[1] = 0，但实际上它还没加入最短路集合中。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-comment">// 保存当前循环，距离最短的点</span><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-comment">// 枚举所有点（这层循环要求点的编号也能对应上，从1开始）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-comment">// 如果这个点还没有被纳入最短路集合里面</span><br>            <span class="hljs-comment">// t是-1，或者 有点j存在使得 有更短的路径</span><br>            <span class="hljs-comment">// 更新 t</span><br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))&#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 确定这个t点是最短路集合里面的点</span><br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 由于t这个点加入，需要更新一下距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-comment">// g[t][j]是边权</span><br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 从源点到终点的距离</span><br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-comment">// 很重要的一点！一开始就将邻接矩阵的距离都初始化为无穷大</span><br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <br>    <span class="hljs-comment">// 建图</span><br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-comment">// 保证没有重边，如果有重边，保留一个最小的边就行</span><br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 求最短路</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">dijkstra</span>();<br>    <br>    <span class="hljs-comment">// 如果结果是正无穷，输出-1，否则输出结果</span><br>    <span class="hljs-keyword">if</span>(res == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十四周总结(7/01 - 7/07)与下周规划</title>
      <link href="/posts/db40b2dad0b6/"/>
      <url>/posts/db40b2dad0b6/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="d4f5909a4a47e7f79a6e41ddcffdd7c8da6b518b693b103a4adff9b5668ab0f9">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08147c59532d54d08f48755ebc43be9739e8ff98267cb1bed9efe9c4b40f47e84b22cf58a8f15cc8c52a2cd7e58f2b15aff58daf2425eedca3f9aed9e40db2d22eb050eea48a82cb726c40209a0a25d470b0002aa3e0ff848b07644019e9ee5f35426ffe3535dd0a39f3aad1bb140b33856c2f85ac3a1587ec10fd7ee7908d14381699f2284632748cc65165c7a2cc916b6f937f088c7e4f8686b9f06f8e488b70e8bc0072b313ae1bfc32f09e648860374c11051d94a934d680e302d8f7863bc15d6b47bcbb45c1dcb8863456c23b47323798f033fcaff831603a4cb12250db1834a15fba84c2ac8529fc8bc841c8e83578182235a9eb8e4cd0f95c840a4cbd8fdbd30bb832e1857c0b4efb36e98d09a53ad9e8a696acf266b7453867064b3f023eca715f0e7ff08bd0a034656044f43436a4c56b8ca52ffbdfc0badf7b3143926ddce53a3127b253028b94bb2e740ea831697936c1e4e0bacd6a3cf5ee8a98319419666cfdff3dff8dae70c62dcb8f529916f2f7be0331fff0f9ee02b34e2ff7c346305a0512a936da714ce702606c720d15774d1da274bed6ad97604fda1c384ee19c3929048ec5b99d37a691f92d02a52938205db27fa0701d426a6a960c2d4095b996ff15abc75b1548686bfa7e5babac8c83032a1752ec07400ee5079537b594451c17c10b902f37eeb75e2fcf11f6a4060c5f14e733ed92197c536743dc823faf46338f14073474c7ff74ad5841acbeeab3770335922dcd26e6f4a463bda94b1167bdfb83fda96494e622c8bfb94d462741f315cc4f6ff3d9c9aaa541abc92ae12e5603b7d7fbdc877c2252968c631e236b9fa325210aad50a310faff8348133714910018af4b122c388f41c5235d9d66760701df6a1bbed9cbbf37c1d6f5fc057f79fc741108ea0f0d14366213012c85b331a9cdf0498bc2b58cb4f4931b50875e1bc5656ae1dc1267ff0f3693bfe6263be8b75cd26cce4bceb1c787cd541ab992b577dd9944d0b05710d10d79963177cd1c85db1d86425352dd5ad048bfa80f50c74b3d21f38d003a6e651774796c0d1a87b70fd68f004fcfd934737e6a4e042e2b6f378f16ec20a85781a0040e2a29c957c95e6cafc9ed25be63b8d3d8b92930e60a35b01864ce74ce8f93e204f53ab72b580f86d2ea1fb65bb4ae034159bc8e7898616bb9efc333a035fc5d8bbdff30207265042ff664e798f762016a8267ce0e7c36f24408505cf33a8af7632cb52f655564e377855bbf5e4853024da75d60bd50cbb1b86440e72562f1eded2ff6d582c9df44b1abaabdca96b43cde6c09c187b16b0204d9fc0cd8af9a91f94913bd2e18368f778854329f29b92da523443e29957b73af36774c2885efb1ea39f051ea98fe8d8226b22d4a9ab90f28b4eb26563d4a5e7f0900c3b308c03c7a7e2dd95dd643dcffb572ebdda5582d68de87c34925dba62902ad59d36219d4c245179e006fcf1e0ef7d393cad00e6d3961a335760f4e6c0ed148681e2220c00a5d24df9e9d88f625c11fed88d7f2dc0f30ead32d2655f9e1c63fa36503b0315817de84af6494ab51a9faf223c128c16e27a8e4d247a3b7b2865fa3b39d0cfba28d22e5519161f603051363340cff64d9c127350eb5924f9b199767d3250a8876f51fb5542e643d2774684b02aa24eca4feeafc26815b47a71ffdcb0bcce51dd7a4e3751fed67a07cfeda8291ff6c797b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏（约瑟夫）</title>
      <link href="/posts/08d4ec6ea429/"/>
      <url>/posts/08d4ec6ea429/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing3253-游戏"><a href="#AcWing3253-游戏" class="headerlink" title="[AcWing3253. 游戏]"></a><a href="https://www.acwing.com/problem/content/3256/">[AcWing3253. 游戏]</a></h1><p>有 <code>n</code> 个小朋友围成一圈玩游戏，小朋友从 <code>1</code> 至 <code>n</code> 编号，<code>2</code> 号小朋友坐在 <code>1</code> 号小朋友的顺时针方向，<code>3</code> 号小朋友坐在 <code>2</code> 号小朋友的顺时针方向，……，<code>1</code> 号小朋友坐在 <code>n</code> 号小朋友的顺时针方向。</p><p>游戏开始，从 <code>1</code> 号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加 <code>1</code>。</p><p>若一个小朋友报的数为 <code>k</code> 的倍数或其末位数（即数的个位）为 <code>k</code>，则该小朋友被淘汰出局，不再参加以后的报数。</p><p>当游戏中只剩下一个小朋友时，该小朋友获胜。</p><p>例如，当 <code>n=5, k=2</code> 时：</p><ul><li><code>1</code> 号小朋友报数 <code>1</code>；</li><li><code>2</code> 号小朋友报数 <code>2</code> 淘汰；</li><li><code>3</code> 号小朋友报数 <code>3</code>；</li><li><code>4</code> 号小朋友报数 <code>4</code> 淘汰；</li><li><code>5</code> 号小朋友报数 <code>5</code>；</li><li><code>1</code> 号小朋友报数 <code>6</code> 淘汰；</li><li><code>3</code> 号小朋友报数 <code>7</code>；</li><li><code>5</code> 号小朋友报数 <code>8</code> 淘汰；</li><li><code>3</code> 号小朋友获胜。</li></ul><p>给定 <code>n</code> 和 <code>k</code>，请问最后获胜的小朋友编号为多少？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一行，包括两个整数 <code>n</code> 和 <code>k</code>，意义如题目所述。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行，包含一个整数，表示获胜的小朋友编号。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于所有评测用例，<code>1 ≤ n ≤ 1000</code>，<code>1 ≤ k ≤ 9</code>。</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 2<br></code></pre></td></tr></table></figure><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">7 3<br></code></pre></td></tr></table></figure><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">4<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>这是经典的<code>约瑟夫问题</code>。采用数组模拟，但要注意：没有环，但是怎么实现环的效果呢？<br><code>采用重新入队的方式</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, k;<br>    <br>    <span class="hljs-comment">// n个小朋友，幸运数字k</span><br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-comment">// 小朋友排队等待枪毙</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) q[++tt] = i;<br>    <br>    <span class="hljs-comment">// 编号</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// n个小朋友枪毙 n - 1 个,枪毙的号码是幸运数字的k的倍数或末尾数为k，剩下一个</span><br>    <span class="hljs-comment">// 以小朋友剩下个数为循环跳出条件 tt - hh = 0的情况代表队列还有一个小朋友</span><br>    <span class="hljs-keyword">while</span>(tt - hh &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 如果当前编号的小朋友不该枪毙</span><br>        <span class="hljs-keyword">if</span>(j % k &amp;&amp; j % <span class="hljs-number">10</span> != k)&#123;<br>            <span class="hljs-comment">// 重新排队</span><br>            q[++tt] = q[hh];<br>            ++hh;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ++hh; <span class="hljs-comment">// 该枪毙就枪毙</span><br>        &#125;<br>        j++;<br>    &#125;<br>    <span class="hljs-comment">// 输出剩下的唯一一个在队首的小朋友</span><br>    cout &lt;&lt; q[hh] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十三周总结(6/24 - 6/30)与下周规划</title>
      <link href="/posts/d5f2e2961333/"/>
      <url>/posts/d5f2e2961333/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="09f894fe7ec59ac6645c91ea07b7a111a7a3798f069806cdac791ec924e6c7a9">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08140bf1b865a9bb93d44a17eb956a683bb8b5bd30e57ee3a4cc89c4a5728505ffc646f33f78a2bc0245e60f7b2c80a47000fbf0a2fef7cd843b851041c54b3d9a0ed35e4abc888a7693654c9a78fc8d65caa651593b2ed8f6668429cde5394266dc4987c4d4da136c446db5babc754301104691ca2447db7b170bec4ca925b9ed716081a4327be6c230823f8f586bd9f0051587645bdb8d8e2161b940ef0ffeaa416e09c6c86d0344a605665336d48a68fcbe82175e5b7b9f569ccc95e8884d87e34ee47ed82180612bd4046015bdb7cb8dfa9f2fb4ea8b313ab3edf1ba4843abbd14d7eb86940a153e86eeec225af50b4630c9138f2a63ce2bec40a8e7caf6be409d60752221b6ae2bc205d081d4a8d3a7bb127ee89b7004f30dce9b66e4beb44e817eb2716a5b71ab6509213225c215906272774dc36363997e7e6a493cd4319a2004d76b7fb082d613f841494c8512cee586c05f9b9eae91adcfcb43375dc3abc9fa4bb0340e6b4e29911b3b510b4463e57bf938d8203b47549a3d9c571a1767719a8ccf294216f952806f0e85c069f5ed7ba87f7d093aff00c254747167f40a4aa498c6e1ac0a5e3248d74352d23a18aac0da098635a081842d8bf634cf629cec3f5cafbcf78d915bd18ef2a7ecbbe55d6d2149cdc0747aa58a9f0baa1fe6b7294f47840f4770a08db905e0f0027561ed7cfcc3f0d0eacaa5607dfc26fd7d2765a9b21d7c615aea9c49a7d16072a504815cc35b012509818c33c68d34cdd708553b9c5c0ef9d9317104a89537f1b757cd491e0867d8ab33a8b08b3b3cb76b70661da9c47e7a4a84445584300d95baf1c23a1da840d0a8a843e2950207e2e3fce87a15c71117d36d663f15f5355133505decd493a28c588f1dee18145fa3434752ec73da7d23f7d9b2fac38a889f938f2d4c90e1626b39e53225f221313839c565368bc988153637a100f751dfcb7791723bce5642bd7437762861a05549cef7a737ebdbce5ff2e4db9be3cadb293a42155aeb0ff5fb6ae20230012fb703a302092f88d4e295200d3baf4a026394a75973e8f84f6ef1ad09ef2c128e6a7114304fdda1f4d3ec7e39377b0a1c8b28553ea76e34437b70d3ca8579002486f725e427364021c6622e99e53716ca11520fee474e65ee163706f353d3e37785627418908ab14eb28de56b42ce3cdd0e330d1aa1f4a954c8cd23a35813dbe6479185ade435557c3a82d957c774c944daf300f5c118c3f99cb916ad2440bf22ea76b2e50521c81b6b6c488d3cc99475c9de363d90ab149fa12fb52026de0eda3d9ffeb7b99721d025fe768e85b4947dfb230c44724accbea69c9cff1af6c6ef28e68fd9c74a63402c23ed84a0e05f857f1f18ff3d9cfd6dad6f13eba54063300ee7200247efce1098b643cc6852d2c1b2f36c4f533a48eb9715a451e953e04cdbe04b77972c36c25f3874f95a402566ff6a9dcc0ef273b547adf98ff43df1f2879b4b3ef410577b9f8eefcbf88bcafb41a9d973f227539218af1534b9b7057971dec016f5c2581903c6f4e420db6a2a0f281bcb76450b0dc975301b6750161dda64a78e6d7ef05bcb5de4a12a059bf3fdc443f054ce4c61928f86e42bad1372bf67a309eb82341114b17ad040ea5b5eeea066cd</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口内求最大值和最小值</title>
      <link href="/posts/37333600838e/"/>
      <url>/posts/37333600838e/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-154-滑动窗口内求最大值和最小值"><a href="#AcWing-154-滑动窗口内求最大值和最小值" class="headerlink" title="[AcWing. 154. 滑动窗口内求最大值和最小值]"></a><a href="https://www.acwing.com/problem/content/156/">[AcWing. 154. 滑动窗口内求最大值和最小值]</a></h1><p>给定一个大小为 <code>n &lt; 10^6</code> 的数组。</p><p>有一个大小为 <code>k</code> 的滑动窗口，它从数组的最左边移动到最右边。</p><p>你只能在窗口中看到 <code>k</code> 个数字。</p><p>每次滑动窗口向右移动一个位置。</p><p>以下是一个例子：</p><p>该数组为 <code>[1 3 -1 -3 5 3 6 7]</code>，<code>k</code> 为 <code>3</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">窗口位置</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th></tr></thead><tbody><tr><td style="text-align:center">[1 3 -1] -3 5 3 6 7</td><td style="text-align:center">-1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1 [3 -1 -3] 5 3 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1 3 [-1 -3 5] 3 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">1 3 -1 [-3 5 3] 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">1 3 -1 -3 [5 3 6] 7</td><td style="text-align:center">3</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">1 3 -1 -3 5 [3 6 7]</td><td style="text-align:center">3</td><td style="text-align:center">7</td></tr></tbody></table></div><p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含两行。</p><p>第一行包含两个整数 <code>n</code> 和 <code>k</code>，分别代表数组长度和滑动窗口的长度。</p><p>第二行有 <code>n</code> 个整数，代表数组的具体数值。</p><p>同行数据之间用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出包含两个。</p><p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p><p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">8 3<br>1 3 -1 -3 5 3 6 7<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1 -3 -3 -3 3 3</span><br>3 3 5 5 6 7<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>滑动窗口，每次滑动一个单位，<code>窗口内求最大最小值</code>。</p><p>借图：</p><p><img src="https://cdn.acwing.com/media/article/image/2022/03/05/55289_0923cf569c-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.PNG" alt="滑动窗口"></p><p><code>题外话</code>：在一个从小到大排列的数列中，若左边的数比右边的数大，就称作逆序数啊，如：1，3，5，4，6 中，5就是逆序数啊，看看5在题目中有没有用，若是没有用，那该题就有单调性。</p><ol><li><p>使用双端单调队列：利用双端单调队列来高效维护滑动窗口的最小值和最大值。</p></li><li><p>维护窗口边界：在每次滑动时，检查队列头部的元素是否已经滑出窗口范围，如果是则移除。</p></li><li><p>保持单调性：<br>对于最小值，保持队列单调递增，移除队列中比当前元素大的元素。<br>对于最大值，保持队列单调递减，移除队列中比当前元素小的元素。<br>插入新元素：将当前元素的索引插入队列。</p></li><li><p>输出结果：当窗口大小达到要求时，队首元素即为当前窗口的最小值或最大值。</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-comment">// 数组和双端单调队列</span><br><span class="hljs-type">int</span> a[N], q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 数组元素个数和滑动窗口的长度</span><br><span class="hljs-type">int</span> n, k;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br><br>    <span class="hljs-comment">// 输入元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br><br>    <span class="hljs-comment">// 求滑动窗口的最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 维护窗口，i - k + 1 是窗口的左边界</span><br>        <span class="hljs-comment">// 如果队首元素的索引已经小于当前窗口的左边界</span><br>        <span class="hljs-comment">// 说明该元素已经滑出窗口，需要将队首指针 hh 向后移动以排除这个元素</span><br>        <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) ++hh;<br>        <br>        <span class="hljs-comment">// 保持队列单调递增，排除不可能的最小值</span><br>        <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) --tt;<br>        <br>        <span class="hljs-comment">// 当前元素入队</span><br>        q[++tt] = i;<br><br>        <span class="hljs-comment">// 输出当前窗口的最小值</span><br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= k) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 重置队列指针</span><br>    hh = <span class="hljs-number">0</span>;<br>    tt = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">// 求滑动窗口的最大值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 维护窗口，i - k + 1 是窗口的左边界</span><br>        <span class="hljs-comment">// 如果队首元素的索引已经小于当前窗口的左边界</span><br>        <span class="hljs-comment">// 说明该元素已经滑出窗口，需要将队首指针 hh 向后移动以排除这个元素</span><br>        <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) ++hh;<br><br>        <span class="hljs-comment">// 保持队列单调递减，排除不可能的最大值</span><br>        <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) --tt;<br><br>        <span class="hljs-comment">// 当前元素入队</span><br>        q[++tt] = i;<br><br>        <span class="hljs-comment">// 输出当前窗口的最大值</span><br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= k) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十二周总结(6/17 - 6/23)与下周规划</title>
      <link href="/posts/a2f37b955b1d/"/>
      <url>/posts/a2f37b955b1d/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ad25a5db3d4c415dbd1b34b8825422846845a22dbb31a514a09e779f110114ef">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08146a9702094cd1a87e411844db555d73d0d99577c1ad9192add1e11493d1c76a7191b633bdc9d9aa5df18e842899784479f8bba74239f5d00921a78e4546707d54def317dd8679f14d5bdf60d3e0bc4ba8cab6453e59c2ebcded5b7ccbd6c117516ff3bf706e19766ce97c4e694461b07d7451a1129e843298860d835d7916d23eccbbad19246234795e44a96eb8e78c9fdc24c03b3052438c34253c3e71064ea8e3ec5d6fa13c84e18496b5ec1e1781b5aa61e9343dc5dc5fa6d4a2164cdc753410f081a5adc3b345c142d25ccf6063800728650b787c54ad0b2df2ac185480f1bfb7125ad8ad7140a5b126a085450379c2f7cb7bb9ebdb91e73cbc514e31bf6e11df2be3b92bd99a29e9145a76ed8e4ea91558c2864bb0a0cb85ead8ec7ceaa1324888d9706276eba597567083868431124639f7daefc373cd48e57eb5c48d373cf081c9ccbfbea848760f4386ecb581fc34aee73a613765befb1187e8f68b103f8720e98b4e6ae3c02de4b49cc8de65547b88daf197dcd76e9fff56e0afd7bad82f68bc02047d1c59068dc2c914d8c05848516da156315099fcdac6a37e5d12e257d43e3ec518743a62a03a516f863d07225e9311edde5f681542e96d709e915b1ac43752c1169dc6da36ed5908ec0e7810383a82d3b8fb80ca74f40e1fcc065de3dd09a4125019897fbfb40279c3bab43a56ab2e861a3a56a2db24b7695af338e08f49a539838d8b9117bc7159e1018ca6ccb5b24c9042e67aa4cc40f352f805bd4f77dfcb45ec693bc895fbc0169eeed7aadf3debd6991f5d5ce798ad253c8380697288c3cb31cc6e80bb3a2b52f8811cd0408840a6b9a5bb4c774f4aee25f4fc0814401afb664efc2dee616ce63ec99a5c455322ae2cf159af06386fd4614d94511b2d252058c8003bcf4e157aa45f5bc4f20178b2285c7d70c5f199231e9e6ba4734662412308dbf2e50e2e36bb63b4ef05c31b79a78d94598e44339c609da9cc0ee0f33821e25b48d73c381e2c46ef645b18c90fd71400d25bf160244da0ff038ea010fa0240edb573a773efaa86b407dea9c5dd1f122389cceb5ac7f0e1422281a5dfabbde836609ba4a407a7bed81f72e7f7fae331082f94043f5264f71b45d14c0c78f8adb6bcbb4d2cf0df42c4a8ca5fe165af913608b6df4bd92996d9f9ea0ee115ddc2b9e96744f8745537337d1978749ce2d9b9fafab574a4f121cdaea092140ac70af03466c15cebcbef12c61e0bc54f870ecd82eea28e904f329c9fdeec726f2d9b0b3d90b136879513b32db196a2333001826d196d065f16a010335d87e8f252e4f41418b66a1f492c2c81512d0778ef2ffbdaaa90897c07a4516b85b9d4ced8a14d6e40d91b4ffdf123762f86e1b22e8d0aff63deba99cc303ec1225d8bcfcfcaf1574d33167f273216f203541de0e9805e9bba5609ccdfe314720bd8c4815a4ecab64157eaa9d5926a3030151fd8a5e3f8af2e37b5481789ec41c9eb84b1d20a8f310f2c7e30f7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用两个栈实现队列</title>
      <link href="/posts/3be02f72e427/"/>
      <url>/posts/3be02f72e427/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-20-用两个栈实现队列"><a href="#AcWing-20-用两个栈实现队列" class="headerlink" title="[AcWing. 20. 用两个栈实现队列]"></a><a href="https://www.acwing.com/problem/content/36/">[AcWing. 20. 用两个栈实现队列]</a></h1><p>请用栈实现一个队列，支持如下四种操作：</p><ul><li>push(x) – 将元素x插到队尾；</li><li>pop() – 将队首的元素弹出，并返回该元素；</li><li>peek() – 返回队首元素；</li><li>empty() – 返回队列是否为空；</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用栈的标准操作：<code>push to top</code>，<code>peek/pop from top</code>, <code>size</code> 和 <code>is empty</code>；</li><li>如果你选择的编程语言没有栈的标准库，你可以使用list或者deque等模拟栈的操作；</li><li>输入数据保证合法，例如，在队列为空时，不会进行<code>pop</code>或者<code>peek</code>等操作；</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>每组数据操作命令数量 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyQueue queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyQueue</span>();<br><br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>queue.<span class="hljs-built_in">peek</span>();  <span class="hljs-comment">// returns 1</span><br>queue.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// returns 1</span><br>queue.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// returns false</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2024/06/11/66684222ae1fc.png" alt="image-20240611202459520"></p><p><img src="https://bu.dusays.com/2024/06/11/666842358a6bf.png" alt="image-20240611202525947"></p><p>借助辅助栈，可以让<code>主栈只剩下一个元素</code>，然后拿一个变量保存它后执行<code>pop</code>或者<code>peek</code>逻辑返回它。</p><p>过程中，拿变量保存它之后，需要<code>将辅助栈中的元素们回到主栈中</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 存放数字的主栈</span><br>    <span class="hljs-type">int</span> stk[<span class="hljs-number">100010</span>];<br>    <span class="hljs-comment">// 辅助栈</span><br>    <span class="hljs-type">int</span> tmp_stk[<span class="hljs-number">100010</span>];<br>    <span class="hljs-comment">// 主栈的</span><br>    <span class="hljs-type">int</span> tt;<br>    <span class="hljs-comment">// 辅助栈的</span><br>    <span class="hljs-type">int</span> tmp_tt;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br>        tt = <span class="hljs-number">0</span>;<br>        tmp_tt = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        stk[tt++] = x;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 存放数字的栈只剩下一个元素，其它的全部入栈辅助栈里面</span><br>        <span class="hljs-keyword">while</span>(tt)&#123;<br>            tmp_stk[tmp_tt++] = stk[--tt];<br>        &#125;<br>        <span class="hljs-comment">// 被删除的元素</span><br>        <span class="hljs-type">int</span> k = stk[tt];<br>        --tt;<br>        <br>        <span class="hljs-comment">// 然后将辅助栈内的元素移回去</span><br>        <span class="hljs-keyword">while</span>(tmp_tt)&#123;<br>            stk[tt++] = tmp_stk[--tmp_tt];<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 存放数字的栈只剩下一个元素，其它的全部入栈辅助栈里面</span><br>        <span class="hljs-keyword">while</span>(tt)&#123;<br>            tmp_stk[tmp_tt++] = stk[--tt];<br>        &#125;<br>        <span class="hljs-comment">// 此时栈顶元素</span><br>        <span class="hljs-type">int</span> k = stk[tt];<br>        <span class="hljs-comment">// 将辅助栈内的元素移回去</span><br>        <span class="hljs-keyword">while</span>(tmp_tt)&#123;<br>            stk[tt++] = tmp_stk[--tmp_tt];<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !tt;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * bool param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十一周总结(6/10 - 6/16)与下周规划</title>
      <link href="/posts/9289cdf65c7c/"/>
      <url>/posts/9289cdf65c7c/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="26acdd6576cffb00f722a00e85d9401b49488f76c3ebac4cf745830086eec53a">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08147449db493c1f9e603c98a3b5133ce4de802616652d3f205977b31755f193b35ba184f76bc90f80929641f24f6b91e895a765e7d8e4403777988edcec349e04f5571adcf038631137f1f40ff2c1a607071c06052e689aa7fd460c4bf34e06596844db7515db5bd8181668fa6d121bc8800e28aea4c193c09ed8b1d37d89d434178db3f51f67da77b3d69bf02f3a8306fe7a9ff4c1d538c162f56c034c9d5d1dd4c0daba590d9ff30aefa71d02cb4fc38c78b11bf8258fa0730330b547fd5c49dc16e4e0aeccbe1717e50bd63b126b45422fafc40ec9ee96dea81017a543a48baa2244a0bbcdbf09df392328fd9d051ae9e65a479e696875ca13d7b64613b589bfd9efb1d533527efcdc2032746ad305240093b86ccb0c3a74d57ac096ae1b830549d7e0f8e913b331df1e479667022bb2a28a03d7a384f525f0a5083102d6dd3e418d59d1b7edbc0122c4cbcc25bcc053c39058cf2af4e6f813adb027378e46a0deab289cddf2b756a99ec43b6082df3182e3fd92ad4de202a4791cf714ed4b96c2f3763ceb5661fb71a63cc73af4e2bd089ed2e6980311f613354be4961b2ccaff9949b12c8a67368d05b107b8e15256431d561d233d51cd58ddbcb16ed1cf7be6253cca030d4ddd0da13485121a65391f34a9716bd417fed2dadf723d2ba9f7045890679eb1d4bc56626cc7722fa0f1833e001364f1870f111390e6701a639509b7c55883f5e2cf7f63f0c0f27f5b5c7ace70f638b27481dfdf971688162990a1f7c81c70701c04797bffbb9dfd1ceec871f8dfbd71d8cebc394edbb51c04172e8c30d2e31c53d60e737faa9977f662b9272f57646d5896452dafa06c60d09f3b0ed69d56808164be825db84446638cc7851c797c40a0ef597f933110b18773442fa0c02735a7c1e3a6f9591ed975250ec8cb9f2a4eff19a4f7594542c1aa3b902532886354a506090474476c98b5710ea2dbe581e1c48a212296523b95dce1201c9854a77a7213176ab3cb4a78ea01bf628c9465b68d628733c2de4ccdae2ec5304a65112b5de905a0907a3b50e208f6935c90df08d4ae5118dce2f67e9e4d101aac6c0313624aa662049e912f905f88adbaa40fcbe8082781cc99a9b8ac221ed6679b5b7ffdb261c2b42bbb77d307bd04a9df86655d42011060cff589e5d261cb3153f7b80589ade19ae650209a20c77696bb96e1b700d701bc14ba707dc40ac281f810bf18c8309490630e9e205aa05d0f5f9a0bb633a290542a416823d0b82ada65ff48720be4d6cd7877ba9f0b04cb94f9ac542cafc35cc79615a1e265ad70daaebdf96e8ec40d1bd83a908065</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直方图中最大矩形</title>
      <link href="/posts/410b68f36e34/"/>
      <url>/posts/410b68f36e34/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-131-直方图中最大的矩形"><a href="#AcWing-131-直方图中最大的矩形" class="headerlink" title="[AcWing]131. 直方图中最大的矩形"></a><a href="https://www.acwing.com/problem/content/description/133/">[AcWing]131. 直方图中最大的矩形</a></h1><p>直方图是由在公共基线处对齐的一系列矩形组成的多边形。</p><p>矩形具有相等的宽度，但可以具有不同的高度。</p><p>例如，图例左侧显示了由高度为 <code>2,1,4,5,1,3,3</code> 的矩形组成的直方图，矩形的宽度都为 <code>1</code>：</p><p><img src="https://cdn.acwing.com/media/article/image/2019/01/14/19_eac6c46017-2559_1.jpg" alt="2559_1.jpg"></p><p>通常，直方图用于表示离散分布，例如，文本中字符的频率。</p><p>现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。</p><p>图例右图显示了所描绘直方图的最大对齐矩形。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含几个测试用例。</p><p>每个测试用例占据一行，用以描述一个直方图，并以整数 <code>n</code> 开始，表示组成直方图的矩形数目。</p><p>然后跟随 <code>n</code> 个整数 <code>h_1，…，h_n</code>。</p><p>这些数字以从左到右的顺序表示直方图的各个矩形的高度。</p><p>每个矩形的宽度为 <code>1</code>。</p><p>同行数字用空格隔开。</p><p>当输入用例为 <code>n=0</code> 时，结束输入，且该用例不用考虑。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。</p><p>每个数据占一行。</p><p>请注意，此矩形必须在公共基线处对齐。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 100000</code>,<br><code>0 &lt; h_i &lt; 1000000000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">7 2 1 4 5 1 3 3<br>4 1000 1000 1000 1000<br>0<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">8<br>4000<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>对于每个矩阵，基于单调栈的算法，<code>从左往右，从右往左，可以算出各自矩阵的最近且最小的矩阵位置是多少</code>。</p><p><img src="https://bu.dusays.com/2024/06/09/6665b6961d895.png" alt="image-20240609203648376"></p><p><img src="https://bu.dusays.com/2024/06/10/666703e9110d9.png" alt="image-20240610214630320"></p><p>边界预处理在这里的作用主要是为了避免在处理第一个和最后一个矩形时出现特殊情况。具体来说，当你从左到右遍历矩形并尝试找到它们的左边界时，对于第一个矩形（i=1），如果没有额外的预处理，你就没有办法找到一个左侧比它矮的矩形来确定其左边界，因为 h[0] 不存在。同样地，当你从右到左遍历矩形并尝试找到它们的右边界时，对于最后一个矩形（i=n），如果没有额外的预处理，你也没有办法找到一个右侧比它矮的矩形来确定其右边界，因为 h[n+1] 不存在。</p><p>具体来说：</p><p>当从左到右遍历时，对于第一个柱子 h[1]，如果没有 h[0] 作为哨兵，并且 h[1] 是所有柱子中最高的，那么 l[1] 将不会被正确设置（因为没有比它矮的柱子在左侧）。但是，由于我们设置了 h[0] = -1（一个比所有实际柱子都小的值），l[1] 就会被正确地设置为 0（或者说，没有柱子在 h[1] 的左侧）。<br>当从右到左遍历时，对于最后一个柱子 h[n]，如果没有 h[n+1] 作为哨兵，并且 h[n] 是所有柱子中最高的，那么 r[n] 将不会被正确设置（因为没有比它矮的柱子在右侧）。但是，由于我们设置了 h[n+1] = -1，r[n] 就会被正确地设置为 n+1（或者说，没有柱子在 h[n] 的右侧）。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 爆int</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-comment">// h装每个矩形的高，l装每个矩形的左边界，r装每个矩形的右边界</span><br><span class="hljs-comment">// q是双端单调队列</span><br><span class="hljs-type">int</span> h[N], l[N], r[N], q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    <br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n, n)&#123;<br>        <span class="hljs-comment">// 输入每个矩形的高</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; h[i];<br>        <br>        <span class="hljs-comment">// 让h[0]和h[n + 1]值为 -1，这样就不用处理边界问题了（什么边界问题？）</span><br>        h[<span class="hljs-number">0</span>] = h[n + <span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br>        q[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 开始维护单调队列，从左往右</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-comment">// 维护</span><br>            <span class="hljs-keyword">while</span>(tt &amp;&amp; h[i] &lt;= h[q[tt]]) tt--;<br>            <span class="hljs-comment">// 左边界</span><br>            l[i] = q[tt];<br>            q[++tt] = i;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 准备维护单调队列，从右往左</span><br>        tt = <span class="hljs-number">0</span>;<br>        q[<span class="hljs-number">0</span>] = n + <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i ; i--)&#123;<br>            <span class="hljs-comment">// 维护</span><br>            <span class="hljs-keyword">while</span>(tt &amp;&amp; h[i] &lt;= h[q[tt]]) tt--;<br>            <span class="hljs-comment">// 右边界</span><br>            r[i] = q[tt];<br>            q[++tt] = i;<br>        &#125;<br>        <br>        ll res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, (ll)h[i] * (r[i] - l[i] - <span class="hljs-number">1</span>));<br>        &#125;<br>        <br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 单调队列 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/posts/c2dbcb3c40df/"/>
      <url>/posts/c2dbcb3c40df/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-830-单调栈"><a href="#AcWing-830-单调栈" class="headerlink" title="[AcWing]830. 单调栈"></a><a href="https://www.acwing.com/problem/content/832/">[AcWing]830. 单调栈</a></h1><p>给定一个长度为 <code>N</code> 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 <code>-1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>N</code>，表示数列长度。</p><p>第二行包含 <code>N</code> 个整数，表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 <code>N</code> 个整数，其中第 <code>i</code> 个数表示第 <code>i</code> 个数的左边第一个比它小的数，如果不存在则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; N &lt; 10^5</code><br><code>1 &lt; 数列中元素 &lt; 10^9</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5<br>3 4 2 7 5<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1 3 -1 2 2</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>给定一个序列，求每一个数的左边离它最近的<code>小于等于</code>或<code>大于等于</code>它的数是什么。<br><code>单调栈需要维护一个单调的栈</code>。</p><p>注意：插入元素时需要与栈顶元素比较，<code>以单调增为例子</code>。<br><code>更小则取而代之全部</code>，否则，<code>正常入栈</code>。</p><ol><li><code>筛选操作</code>：先保证栈顶元素就是新插入元素离得最近且最小的元素</li><li><code>输出操作</code>：输出离x最近且最小的元素，如果没有就输出-1</li><li><code>入栈操作</code>：x入栈，栈从数组下标1开始使用</li></ol><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(n --)&#123;<br>        <span class="hljs-type">int</span> x; cin &gt;&gt; x;<br>        <br>        <span class="hljs-comment">// 维护栈，单调递增</span><br>        <span class="hljs-comment">// 单调栈不为空且压栈元素x比栈顶元素小，则删除它们</span><br>        <span class="hljs-keyword">while</span>(tt &amp;&amp; x &lt;= stk[tt]) tt--;<br>        <br>        <span class="hljs-comment">// 单调栈顶剩下的总是离x最近的，比x小的数</span><br>        <span class="hljs-comment">// 单调栈里面还有元素</span><br>        <span class="hljs-keyword">if</span>(tt) cout &lt;&lt; stk[tt] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <br>        stk[++tt] = x;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码实现2（单调队列）"><a href="#代码实现2（单调队列）" class="headerlink" title="代码实现2（单调队列）"></a>代码实现2（单调队列）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> a[N], q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n; cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-comment">// 维护单调队列</span><br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) --tt;<br>        <br>        <span class="hljs-comment">// 如果单调队列不为空，队尾是最近的，比当前更小的元素</span><br>        <span class="hljs-keyword">if</span>(hh &lt;= tt) cout &lt;&lt; a[q[tt]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;-1 &quot;</span>;<br>        <br>        q[++tt] = i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 单调队列 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包含min函数的栈</title>
      <link href="/posts/9c0080b038b9/"/>
      <url>/posts/9c0080b038b9/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-41-包含min函数的栈"><a href="#AcWing-41-包含min函数的栈" class="headerlink" title="[AcWing 41. 包含min函数的栈]"></a><a href="https://www.acwing.com/problem/content/90/">[AcWing 41. 包含min函数的栈]</a></h1><p>设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。</p><ul><li>push(x)–将元素x插入栈中</li><li>pop()–移除栈顶元素</li><li>top()–得到栈顶元素</li><li>getMin()–得到栈中最小元素</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>操作命令总数 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">MinStack minStack = new MinStack();<br>minStack.push(-1);<br>minStack.push(3);<br>minStack.push(-4);<br>minStack.getMin();   --&gt; Returns -4.<br>minStack.pop();<br>minStack.top();      --&gt; Returns 3.<br>minStack.getMin();   --&gt; Returns -1.<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>普通栈：<code>来者不拒</code><br>这种情况的单调栈：<code>只接受不大于栈顶的元素</code></p><p>单调栈的栈顶永远是最新的最小值。</p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">/** initialize your data structure here. */</span>  <br>    <span class="hljs-type">int</span> stk[<span class="hljs-number">100010</span>];  <br>    <span class="hljs-type">int</span> stk_min[<span class="hljs-number">100010</span>];  <br>    <span class="hljs-type">int</span> tt;  <span class="hljs-comment">// 用于 stk 数组的栈顶指针  </span><br>    <span class="hljs-type">int</span> tt_min;  <span class="hljs-comment">// 用于 stk_min 数组的栈顶指针，它总是指向当前最小值  </span><br>      <br>    <span class="hljs-built_in">MinStack</span>() &#123;  <br>        tt = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化栈为空  </span><br>        tt_min = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化最小栈也为空  </span><br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;  <br>        stk[++tt] = x; <br>        <span class="hljs-comment">// 单调栈为空或者压栈的元素不大于栈顶元素</span><br>        <span class="hljs-keyword">if</span>(!tt_min || x &lt;= stk_min[tt_min]) &#123;  <br>            stk_min[++tt_min] = x;  <br>        &#125;  <br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">if</span>(stk[tt] == stk_min[tt_min]) &#123;  <br>            tt_min--;  <br>        &#125;  <br>        tt--;  <br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> stk[tt];  <br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> stk_min[tt_min];  <br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-comment">// 普通栈</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; stackValue;<br>    <span class="hljs-comment">// 单调栈，只放入不大于栈顶的元素</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; stackMin;<br>    <br>    <span class="hljs-built_in">MinStack</span>() &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 普通栈来者不拒</span><br>        stackValue.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-comment">// 单调栈只接受不大于栈顶的元素，除非一个都没有</span><br>        <span class="hljs-keyword">if</span> (stackMin.<span class="hljs-built_in">empty</span>() || x &lt;= stackMin.<span class="hljs-built_in">top</span>())<br>            stackMin.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 要弹出的元素和单调栈的栈顶元素相同，那么同时弹出，否则只弹出普通栈的</span><br>        <span class="hljs-keyword">if</span> (stackMin.<span class="hljs-built_in">top</span>() == stackValue.<span class="hljs-built_in">top</span>()) stackMin.<span class="hljs-built_in">pop</span>();<br>        stackValue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackValue.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackMin.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十周总结(6/03 - 6/09)与下周规划</title>
      <link href="/posts/0a859ba849e1/"/>
      <url>/posts/0a859ba849e1/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="dfac9c66e127ca62388030cd503a80e2068589524f343742de4dc74deebefba1">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b081456281f2c01e4e1c6dd2c48af7d023157575d46a0949c2fa1f81762e092a7613379916b95be85df407c438133ae7bab74dd25ee3075a11ba0b566f8b78d6d143f9eb214759f3ba39a567b35948cd9418aec66de3b9da4f25e1f1ab0709739a5ec4d5f9cea67ee771fa57ca7a240f5e2a2babee79ff899d7905c9294e7d130535b84f17b1377dfe343c7feb6aa19e744d68b9f487bfbfce3b3ea53b68663de5ea7851e7451ae3b2b71a7f23cb4a4b7c1c9adfffb49643fdfe338cbc798ccc7077df099cc0022517c845830610baa108e852737f83e807e3244dc6154cea74371bae1f27498db6f15df23afc3c015d49d4cbcedfa8f584aa91f3ce6aadfed721927dcd922fb24e397c302c5590cd1f8cce6426fc921c088f9f75aea4966dabf966431978fb94d6702b1f842461f84a585e51f03ccae7da76c37a32d0f27de307ea7d15a55aa45536cd8a94838904496f81be912933fb156a147e489ace1b61c4a093982dcdd94b394fc15f8d0f32bde29088dab9c94fc83b50afd0834da0dd65d3b78bd8e048ec9229af2685ee7633cea8afd403be23790a6c1dd2078ccdc1b780e9d188da6d1e1fcdb11cba58666c7d054f347af1174073785f94e932ff4b7baacecc1de1d80feaddfcb7731c0e7278fced2963b9e657699570146ed26f717226a13190cc127f0fddf2d505ca77c9f0c5472601db549807d1c4990554ffee0abd0062348e8bf3e366df8ed7bcbb981a708fd20e43527d33eba98a070b4a63411e54d626cc4a87109acb3f44b1b33b57ce064fa6d14d71c7c6381479eb4d4ccb1fae87bed6af6512af3b412b4eb8cc314f34d5053cc32a8e988e0e289c1b88ffeab7796c4c53f4bfc2358e2a2f02c329e9ba36addbe0c8d2c65ef79f3c10c062497bbbb1bec14a2546bf2ba4887ae345411b3e87bca32eed0626d8625e5b611df646cf3ac77d1558642d2333dfdb5f83004d617ea139cb0d2fe2c1edf37986b3e1032f92a2c26a106aea3ede691c55d8a0409415d32d830b9f21fcacc56a9a4f1f9b8f9688d63eb1bc3c85346329fa7ce5e6c98109695953ff91f3c216fb92ce5dfe48fcb43e01827481298bf1b9faed60aa75ef4d7549725b7780c3a563985cf28fb99ee71729ecfae21457d117776601ec72281a60c83c24fa0a93582cb2174b9259148d9010637d976dd728adb0d19cb31e1c77a2775e519855e1f1cf27610cf45253d8c0a229c0074e2f9b49f7156cadcbc50d98a59ccd6bd1be82edf25f1bc7caa3fe4f56b627c3688322986a72a87b833527c9b97ab8652802fa6781ddd34eaf99b913b565900200a619bfe0da0ff3eec3f6494bae0e8baf7a0217d37f95a70dd2c9d24c5379a7195a536afeb07782ec3379c7aed9e7560b1be9374d90bee3b835adcf0f1e0bfefe89854df5a9f5f5c382101fcd92cdc2e64752bc441036c5946808ffba6579d19bae919c478b0a7d1393cd91ae1e3a40825a4bb7d69cabc8a85b432e14fdd9419ed1f161a7cf5a7b668be93af4cfd5ace2a597b7677ca1d1e9b9bf28fbccafd9de0e32370f65c214ce7e43dbba8c6dc2fdd40cfcb562fb5278fb67a3bc67aef3618da8234c5890fffaf6fb78d20b8e6eaa46692ae005780dc36f89420071fb7608f75ac4e0175d0a8173a433c2309dadf5a3420c06a5f44ab12eb22bc824413a8862262cc1820b3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九周总结(5/27 - 6/02)与下周规划</title>
      <link href="/posts/c2105732bf66/"/>
      <url>/posts/c2105732bf66/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6c6fedf055c6ce4e46cf2ea1b0be891c619d7e8e3eccf2f7ee6db10de8f41ff9">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08148cf6dcb42af7797b6d01e75b6cf044093e979b81a2f60dde267d9c3b86e9a47aa9be9d8578b305af0cdab91dc7dfc6d952c517b0ca8d56c450bc8d2940a3cfdd4caa239302df946ef7c0919a6b41f42980d8a9d7c8de8f2038a91eb486803d528b7075906c68bef55c0e7d8208b45dcd28358d968714c0d220a24a586c9fb907e1561931b4bc50f563ed52d765f26144b21f9bdbf1014ff307cc7bc19a1ad01d26e55a5722834c799e18288def744c78b5b27c2a2f57da11b78fd90d485c054dc2d30f28d6ebc91da508fef116baf912eb5b2bc519872781b5c76ce3dad2d22159ae333da74901ea86432d9937fdf3169cc9aa08310d5fdb98a28ecf506bee51672503fb29b6aa339df55278fcf0ccb413c1f4a26ddfb3e371cc0277654b8f95a14dce9dc8c864cae54876e6459595440e51a61c007042287f9a7814806fd1e781341cf0e18945fca687cfc113dce2756da0b914959af71f527abe6d21c855b55cf717a3e693d69f8b8e392a7029ffdafd23ed9965775eb5465c2d8efd099b169c9582350702878efcee7b7d5f53957bcddbdb6a2f9b4d3aef8b645f699e33993601f1ad41440cf35d43a90e9b21f8be8219762661e74fc5836f79980b3e72aac26fe408f59606ad020f1f15a1ffd1bd51ce157c6a985fdcaf6e34036f766ac492a7c8a360528d846170dc45960558de19252a7b45c0ecce3e5443bb59e68a8585c232b1a0351e492515cc38fcc9d424b48798f2678432d634fc7e857102662a16d66e41503881d97660a5e77f73490d9f5bcf956f5d27e15db64e269e73b1bb8a95bee3b040960c524f090f178d6fda8ee7eec1c1074c2b343ba8bb37ba49353475d8dea1197149b93d71150c6a093127a2ee020668bed2aa85cfbe25769b9f33a67676843c940b8631ba1113c4aa2f45757e095715167aad449bf8e18999ae3a90c3e4248185a34f3a59f6e1ece222090f32e7233728809b8e4b33faee8121b2188ede9a89e08ac28609272b70da83b28d05725f1fe91b64effde810a9ba175487b870423c66079e84c48141d0541f85228442b82ce6ed5c959dcbc9482ca85a86ab2e37df5c0c68c5c4174f1fb33faa401385d58624e9dcd0a1a5be369dc8d20a97bee0ded866670ad98ba241313329df694be09d92572287a0a390cb0751f03bf2f5b553c932821ebcd6723ddd67f7cd659e49cbf0c49418f01b1a37f2dcc49fab8aa0ef20c44147e9ce5f173049bec5c4835869edecf1b8b9dcbb3ffe1762f2f7ff0ac457fd40e8d35c1fd440c824eacd3ae9430c0d4ca18a82baf66b43ac7ca07d2b392af9a705190a4c0a142ec51b5bef566bfdbc965d31246c411f1202fc5653fa12a6f38436175829bb400abbaa09024b72d40799af10b6e27894d7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八周总结(5/20 - 5/26)与下周规划</title>
      <link href="/posts/e00fcfa54b2c/"/>
      <url>/posts/e00fcfa54b2c/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="05fa4451d83a051b19c8d1ab593483d316ab199530e626db9f4044e23f1df7ae">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08146e5d80279bfc5b7c843ef5834902ee6f904c219358a09c8c1e1c121f4f6661093f4613885d4e54d31998c24a60ba8aecc2daa47404a0382222359da04367570b0d2d4de51823a997490772d04d27dab26d54f1c1a1fe60496f1e0090044ac961953dfaf3b9e7082484f474b31f2542c000f9e8dcdd62e0a41906af1cb69fde596f60c8db2753e4d89effd8ad57da12d06d3f0d40ac52c9464e1739d1e4cdfb0a0d280e7b0a2de74ef2373be97050217653cfe53d554af4447b9505edc9626f0512645fcfe125fe02715ab5505eddb5894e2b4114eaa31bb753642ee35db3bbc7cab983ed9d5a0156f9ab971e5642fa29fd2d784862d5e0e89a45f9930bcf0b5b672b494b1fa61d8b4365db3a9f6700b0d7759bcac0a7e16f96baf377079dd738f3056125abd404f3c62e60fc05f7790b9130592673e24afd1aad966dc1b740d286487f94af838fff5d8d31e83c270b93a07d3676dacde8a32fb7c054be223ee3d81b67dc9e090c8b3efda1c5e6aa6e9bfd54a72aebf9b290af33bf413043eeb2c4efbc383cbcf20471fe49bf880f9b5acfaf6a65b3fbab157f7828732d0b14782760fde76e5c1f8f0e449c6baa0ae5cbbe7bde9b33babbdb81c8a53fb3688bc87197204968c050f8c779b6880a1b5945212a9a7995baceb44d08884fbe47a4c08d6c67d263eca3f51283c25b10825543a5f645aae0c83fb81399b5be3b948adfe46af1a988ff0154adc511452a654c91d8761c71c8936478fe088612afb24bea6eb6c89c48680b85e612c5616d6d6cb3c1bd27da65c03f8d1eb872612d9ca00d26815937579fa885e0d7849d29fcc142be8049259d584fe28b51a9a02cf2beb48faf59c4a260bdb2b60a6fd984e779e7822571583d2da97e66a48046515b0894f2ce4d39dd23e31b048ba021ea1995c1388cc2e7fb6b967199d516f5103f9232a723542acfff3cc09c237c47757a75fe637d8e25c2d6f27fae986a579ff92580c3f72e7c2c371dce119c113b71613a8e70b0c1e4a14d5130d6f838efd0e55568488918c78635af52107920c9fe3195285a45f135327fe8566ff5bac1e8464dbfb57fa3f25a34e93df5bbbc5d3e58744ac975a67ccb5a9d3bfec8418c74161c78caf047dfd86b6a9a15201872dadbbfa8a2756e122411d8fe8de26247b58747ab146088eef7a2a64f13f736f9593929b6c1034150fc0483f4e89b3a34dfeb0b0780f40757857060d7543d23e3d3b08fcf44bbee47f2cb5399b47854c2119e5ac8583d26e4ea490f8873235de0e90992c8e8509fe7ab2e72af01a525085b2903ddbf48d994d4f8ce39c77a28329e3b3b6a3d31485b2e15eeff15b9287bedea6c0330d33e0a7c62a95d60ab33ddc5355a3637e2e793492d9318ea0eec67b0624c6189204370eae4e3188f974ed39ad8893082048632a0289607a3e3897583286c910f4291e48b429582e69afd16143590ea6000101405e4a6db00c1585652de94d7339f98da0fbd491506d8b384adad9792980c64b0d7f0960843387c6897bc2a59cd1ddd39e2d137d4b9d7e7101879940166d1a462dea192abddc275043230f961f0b2680971d7c34de23908a016f7ec736d863c22516eb9e3725429585cd0b8195c0eac48249221a24e9c212b486b2dd5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]3757. 重排链表</title>
      <link href="/posts/15cb5950f25b/"/>
      <url>/posts/15cb5950f25b/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-3757-重排链表"><a href="#AcWing-3757-重排链表" class="headerlink" title="[AcWing]3757. 重排链表"></a><a href="https://www.acwing.com/problem/content/3760/">[AcWing]3757. 重排链表</a></h1><p>一个包含 <code>n</code> 个元素的线性链表 <code>L = (a_1,a_2,…,a_&#123;n-2&#125;,a_&#123;n-1&#125;,a_n)</code>。</p><p>现在要对其中的结点进行重新排序，得到一个新链表 <code>L’ = (a_1,a_n,a_2,a_&#123;n-1&#125;,a_3,a_&#123;n-2&#125;…)</code></p><h4 id="样例1："><a href="#样例1：" class="headerlink" title="样例1："></a>样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;2-&gt;3-&gt;4<br><br>输出：1-&gt;4-&gt;2-&gt;3<br></code></pre></td></tr></table></figure><h4 id="样例2："><a href="#样例2：" class="headerlink" title="样例2："></a>样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;2-&gt;3-&gt;4-&gt;5<br><br>输出：1-&gt;5-&gt;2-&gt;4-&gt;3<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 1000</code>,<br><code>1 &lt; a_i &lt; 10000</code></p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2024/05/14/66435bd78bd41.png" alt="image-20240514204050974"></p><p><code>将链表分成左右两部分，右边那一部分进行逆置，然后将两个链表合并</code>。</p><p>前半段是较长的，切断点应该是向上取整，尽可能让前半段长。</p><p><img src="https://bu.dusays.com/2024/05/14/66435c81b8b12.png" alt="image-20240514204345071"></p><p>选其中一种情况讨论。</p><p><img src="https://bu.dusays.com/2024/05/14/6643611cc4cc8.png" alt="image-20240514210325505"></p><p><code>step1是合并链表的过程</code>。</p><p><code>s</code>节点是需要提前保存的，用来维护<code>q</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rearrangedList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 题目说链表节点满足：1≤n≤1000，只有一个节点，则什么也不做</span><br>        <span class="hljs-keyword">if</span>(!head -&gt; next) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 先计算分割点</span><br>        <br>        <span class="hljs-comment">// 求长度</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(ListNode * p = head; p ; p = p -&gt; next) len++;<br>        <br>        <span class="hljs-comment">// 向上取整</span><br>        <span class="hljs-type">int</span> left = (len + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// 找到分割点处的尾节点</span><br>        ListNode * a = head;<br>        <span class="hljs-comment">// 移动 left - 1 次</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) a = a -&gt; next;<br>        <br>        <span class="hljs-comment">// 右边的链表，由于要进行翻转因此有两个指针</span><br>        ListNode * b = a -&gt; next, * c = b -&gt; next;<br>        <br>        <span class="hljs-comment">// 先置空</span><br>        a -&gt; next = <span class="hljs-literal">NULL</span>; b -&gt; next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// 进行反转</span><br>        <span class="hljs-keyword">while</span>(c)&#123;<br>            <span class="hljs-comment">// 记录排头兵的next，方便维护b</span><br>            ListNode * p = c -&gt; next;<br>            <span class="hljs-comment">// 反转</span><br>            c -&gt; next = b;<br>            b = c; c = p;<br>        &#125;<span class="hljs-comment">// 跳出循环, b就是反转后第一个节点</span><br>        <br>        <span class="hljs-comment">// 合并链表</span><br>        ListNode * p = head, * q = b;<br>        <span class="hljs-comment">// 选 q，是因为 q 比较短</span><br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            <span class="hljs-comment">// 提前备份，维护q</span><br>            ListNode * s = q -&gt; next;<br>            <span class="hljs-comment">// 合并</span><br>            q -&gt; next = p -&gt; next;<br>            p -&gt; next = q;<br>            <span class="hljs-comment">// 新的开始</span><br>            p = q -&gt; next;<br>            q = s;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七周总结(5/13 - 5/19)与下周规划</title>
      <link href="/posts/18dce1045e76/"/>
      <url>/posts/18dce1045e76/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="be23e89b95f5745738aae2478d786862b2b5b1b7e21991b2941ed1a61997148d">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814cfa77eab28e95f83ea7aea878afae15fad98aff38f6f399a48e8c2f97bf75cac877f7546d614d49ec38eb5221108a411ccb11bb60f246ecb18aeea3b62b05b7c15f35f2de669450cf88414a96ccf0065acd319d65aa3d73cbc0d697a153fc64d5c1032fdc09e92eb73a91aa0acd65130cb5827d7e429e70061fac1e1a07e2966363901d827259668497fb1b49a207d4b4230affc6ce758a058b94fa01d250b3e7c3f7e265b5ae028a1662a67d25c8a8f902312bf9609b9c7d1b0241eb84dcd1301d6ccfbe100a3a350d21eeb5967b0ca0cb60e4c680de2a0742a5390bc13ad6ec464dfdee422e0f26607c37cd2c16e7e13dc0b3361514c13604f7ff74c6f8d57aee576e341e6c14c0dbc9bedc554cd92df2d7520427221b01771800336a6d2cbb680068fe5936c23b3685f0c977724277c1160704df1c9fbab60ed7a66341297cf803b14733ddc73676d0df294c177868ceb18360e12b6e9495d226829fea442642e93d6c5598230e2c84628af82e744b6b2ff8a230261848b90968a1029656784881d5a0c1d919c5efecd4ecaa023e4b45a677ff7adeb1981c85510cfa60b554cd1918184dd747ab827f39f60c3f469bf8a1c8a58ac953a05ba31bf4f5f7d548ba9ff2c6e31e9c3fa4bcf8c4c1fbf39d214fbd746d627ddc1b1002796de8328c83832d744e305d86540cd6075fb4897a848d4be686ed8e4b153cc5bfe43d0a61c5c0c83c09fa39cfce3befad521bbc7a3eddd8d70f58dee192e32898a432825c1182d91b6392d063c57b3dd37700a8e0c829779735d7ffb3bb46226404f2c40ab1e4bf6159130484a35e5dbd5845839ff590b8b41ac83e984658159e3503a1732e0fac343e0161fdfdf51020a7ce6e3ec56d1755871e36c924cf06d767dc66b560dfaed2e9690e37324e41adfea89664ee49764d95db6f2eb4c7c26ab5929782cd79bebe3d2d4bc66213749856055d934ed833b86a1dd87532fceafd87a2cc35559a47075844f2a7688dab1322a7a1b5600f305fefb61d00cf85293ec88dff66e062d8e9c7312d552f407143a10cdf57572e5cdfb324ed1f0d41fc4aaef6714566acf8be605d44ab58f0231d96f3a9a64114ac31f61e3b9b1781784aca179e165c7a2cc333fddcd3b24c02f1220592f6d27e5d7e9ede888a0cf1f9441ea6afa1c91c1f6d016a9a5c6e9f116d5c6d2e7e5c0c0aabb8d9d90c6de56440ae94f3bcdede8cac6e20e311fc6d5e8a98007add58366dac951b3d3059a39ad3e68d68b226a78a9aa19b53eebef9ede1d377c0f1c8a76a0e6bd75035d99b39426db267466b230621435c09bf33bb62d43073b73e574a79677463bf052663b68d75e452afa1926a6b9748b971d45b8a76a2369f42fb3582ab83cd3abf30d43a5e53ebf9eaa6371233f3c67fbb733d836c1e823a4d3b7fb4b81105ddb42c24107bdef3cc39afc111fdb061bc6e85b28eebd413fc80457ea98dc5fd2b844135a9432ec788aeae5b3e3a7954ee77e43add723ad3a1cf4f22d3928245aaa1cc82da88f3da4d7195b9c580f7613f7ede3cbf5b94779a684ac419b5a5b9ec0f7643cdd7e53f976c1c9d242ab371b540d4ef0242c03df23d125046ec2a8342fdeffdf98f73fee7959eafba28c106bc7b66ae4aa42d5a1059d26ff0eef7b1c9c29133fbef80f0e1ec88ecfd486edf7dc0a497dad5c1ecefe639055d5ec9968096f0fc389d0474adb75ddffa9749cb03f5d0b0ab673b3f299bab676db085b34386af17a936c13faf99cb5bf8f55304af7bd500c1083bbe864ee2ee1d0a437144fc845862737293ae8254353fc8da7898a0d4f2408cf47929c45cd52392fbeaae743c48381cb6acc011c3f5760460bfa6c24a4425401920ea5e967bd37d886697c8ebbc77b6d448bbe8c9f68965c256184eafeee270311acd5a553b6d2f8354c9f300a78af6ca1ba2e797686803866f15f44fd04678c8d6e14ff66b5e8ca110853ec26dee0663073c4ef4a1b98a0863ecc7c9bcece115d616d58bb21d747fa122bf5ae601ea65bf36940dca5ef1e636ca1ad807ed0189171c6f62ce73b05bef1e32dfa009fa661ccc853e579c0095a7d593f6170738d589447a121d2d4cdad0af7aa1fdf83d79913da2853847b224392672c29e6d9c2c224dd19f9a83d2ec606a373a9c80c4f2f82b460c05412e54be71e270fb7e1cb94ac8dde8b55cdb79ee4d8d55015bc47c3238cbf515976279130a5cbb60ffb20ca62b7ac4c5e5213c337ce8c22391033fb32384dceffa808fd1fd4e74b3e7df222ee26738077075d18f9cf189e4cf89df8e475fc150d382aa3ed6e6f1ad9d08de8d612</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing] 66. 两个链表的第一个公共节点</title>
      <link href="/posts/0a6333a85e34/"/>
      <url>/posts/0a6333a85e34/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-66-两个链表的第一个公共节点"><a href="#AcWing-66-两个链表的第一个公共节点" class="headerlink" title="[AcWing] 66. 两个链表的第一个公共节点"></a><a href="https://www.acwing.com/problem/content/62/">[AcWing] 66. 两个链表的第一个公共节点</a></h1><p>输入两个链表，找出它们的第一个公共结点。</p><p>当不存在公共节点时，返回空节点。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>链表长度 <code>[1,2000]</code>。<br>保证两个链表不完全相同，即两链表的头结点不相同。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">给出两个链表如下所示：<br>A：        a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗            <br>B:     b1 → b2 → b3<br><br>输出第一个公共节点c1<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>两个链表，两种情况，<code>相交</code>和<code>不相交</code>。</p><h4 id="相交"><a href="#相交" class="headerlink" title="相交"></a>相交</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32ff3099be.png" alt="两个链表的第一个公共节点"></p><p><code>a + c + b</code> = <code>b + c + a</code>，它们相遇的时候一定是两个链表的第一个公共节点。</p><h3 id="不相交"><a href="#不相交" class="headerlink" title="不相交"></a>不相交</h3><p><img src="https://bu.dusays.com/2023/08/09/64d330de84da4.png" alt="两个链表的第一个公共节点2"></p><p><code>a + b</code> = <code>b + a</code>，下一步它们都会走向<code>NULL</code>，而<code>NULL === NULL</code>。看作相遇。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">findFirstCommonNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode * p = headA, * q = headB;<br>        <br>        <span class="hljs-comment">// p从headA开始走，走完从headB开始走</span><br>        <span class="hljs-comment">// q从headB开始走，走完从headA开始走</span><br>        <br>        <span class="hljs-comment">// 不管两个链表相交还是不相交. 根据 a + c + b = b + c + a 原理</span><br>        <span class="hljs-comment">// 它们一定相交</span><br>        <span class="hljs-keyword">while</span>(p != q)&#123;<br>            <span class="hljs-comment">// 如果p走到末尾</span><br>            <span class="hljs-keyword">if</span>(!p) p = headB;<br>            <span class="hljs-keyword">else</span> p = p -&gt; next;<br>            <br>            <span class="hljs-comment">// 如果q走到末尾</span><br>            <span class="hljs-keyword">if</span>(!q) q = headA;<br>            <span class="hljs-keyword">else</span> q = q -&gt; next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]3756. 筛选链表</title>
      <link href="/posts/5a709920de81/"/>
      <url>/posts/5a709920de81/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-3756-筛选链表"><a href="#AcWing-3756-筛选链表" class="headerlink" title="[AcWing]3756. 筛选链表"></a><a href="https://www.acwing.com/problem/content/3759/">[AcWing]3756. 筛选链表</a></h1><p>一个单链表中有 <code>m</code> 个结点，每个结点上的元素的绝对值不超过 <code>n</code>。</p><p>现在，对于链表中元素的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。</p><p>请输出筛选后的新链表。</p><p>例如，单链表 <code>21 -&gt; -15 -&gt; -15 -&gt; -7 -&gt; 15</code>，在进行筛选和删除后，变为 <code>21 -&gt; -15 -&gt; -7</code>。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：21-&gt;-15-&gt;-15-&gt;-7-&gt;15<br><br>输出：21-&gt;-15-&gt;-7<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; m &lt; 1000</code>,<br><code>1 &lt; n &lt; 10000</code></p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>如果要筛选掉重复的元素，那么必须要有记录每个数字是否出现过的<code>bool st[N]</code>。</p><p>而且链表中的第1个元素一定是没出现过的，可以直接标记<code>st</code>为<code>true</code>。</p><p><img src="https://bu.dusays.com/2024/05/08/663b74242dace.png" alt="image-20240508204615900"></p><p>对于<code>p</code>和<code>q</code>，删除点有讲究，如果是删除<code>q</code>，那么成本小得多。</p><p>所以<code>q</code>就作为被检查节点</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">filterList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 标记该数字是否已经出现过了</span><br>        <span class="hljs-type">bool</span> st[<span class="hljs-number">10010</span>] = &#123;&#125;;<br>        <br>        <span class="hljs-comment">// 第1个元素一定没有出现过</span><br>        st[ <span class="hljs-built_in">abs</span>(head -&gt; val) ] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 当前没重复元素的最后一个节点的地址</span><br>        ListNode * p = head;<br>        <span class="hljs-comment">// 当前被检查的节点存在</span><br>        <span class="hljs-keyword">while</span>(p -&gt; next)&#123;<br>            <span class="hljs-comment">// 当前正在被检查的节点</span><br>            ListNode * q = p -&gt; next;<br>            <br>            <span class="hljs-keyword">if</span>(st[<span class="hljs-built_in">abs</span>(q -&gt; val)])&#123;<br>                <span class="hljs-comment">// 如果出现过了，删除</span><br>                p -&gt; next = q -&gt; next;<br>                <span class="hljs-keyword">delete</span> q;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 如果没有出现过</span><br>                st[<span class="hljs-built_in">abs</span>(q -&gt; val)] = <span class="hljs-literal">true</span>;<br>                p = p -&gt; next;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六周总结(5/06 - 5/12)与下周规划</title>
      <link href="/posts/a395edc2fc97/"/>
      <url>/posts/a395edc2fc97/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="72fbfab78a350ffcf08d36f00df4c78945e0677809efcf441993cbdfbbce1bfb">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b081447d9b719472bd5775668a255d225b23d438f1a71fbc386340f8f54f64e69f613c8fba85fa24fa98799869a309cab3465099a986368de14b981d817357654a9f6a41178c10bc425825db9852a0014c379de9db8bb49852180e57b06cb94bef8bdd4faa062bce36065914b1e4d92bfefb86611685a234cb1efbb68825526b2d9c41eeb8edeb1e21517ae269aa5cbcb1baae8dbac5223501967e134c96f384146525fffc0a82ebde5665cd91defb7cd454d566e36b1ec3fce46270b6ca9c913825ba1a53291fcb3732db836afceac4b752ccf782a8ec60093b5660e42253adbe1e40931dc23fcde98992382bef19895b680ffa0307c0f8554b2815c324b1282f79bd446d1102f63970efca2d911bb65db1db07ffc4d222159c1a40232b7235d218be157c6e77cb3ace1d18184828d63550443c19d16ae1b9419c6f8de3fccd75601cca48f39fd3bb6e933190271938d8205095f2731d7c1f38144de83efbd489bfe49ee7bbd85dd8d2f5c2986f0b46f99a0ae6aef5dce39e61164ee947352eb5b0d0c146b7b08f503b4c9d24bb9455e22d4715667f78081ba0fce08543b3c5e4715dd6302f81a5aa96c43bbf6e05a5827d85d63993ba82a7f1176cf41855d7d2d6682ac7cd599ab5d2e8f05fd29a856f1909ab1de80f326eab27ce50231e460aefa70c14714d35dad01d1e2d0faeb951f7ac78b043e1aac53b342091de77946fa03ab9860ecfdf062b41f23623260b4d5241bb1a08eb99da57aa6e27684ed45b04b5545b59c7c11aa015a45ca1818cec5af5e5002c8f372c524bdd8443f85f8fc5acafe07122f5217bf7c9d6c062db43d0ad3896b3b3ac67324ad53c341b311dcb03db7f9fa762c3032722dd57cef8c83751729fbb91affd39ad49c5789af87653818b9d42d3159de8799648b09f6c3ab29a511d6d3cf8b8471efbda234fcded546f1ca7d174b732267f30997b5434fb87aaffa4fd490ab5034f7395a27ab80c8789c706ea625204fb016565943dd42b6935afaddb3139d322ddffe4bb187b31def7b03b080231a8ffcf2e3644e7eb44a6f5b43acbc28b39cd54eebb2c4a14250a27e359116e38aaf99d642ecc66277417dfc69500a687c60d217a81cacdb940f561c08a48970b029b1c06bc5b1bfb804e468f31584e596e44cda6d58381e7edc744debf76982c89196a19364c20b563bcb5e7c2a161bb0c37de8a37ee676faeb685169d7ea2eea56961e79252ffe6049d30858e9272473b0281f47e3bcdfcc910ac868be7a043d6451ddba539d69701490d83a0d0c43e90c2d1e9d80328bddb54f48efa1907b5f1ebbcee5b83f5d3f810f68e09088c9d1850b90f023253830ee1fc16f8ca71d9d8b78384db1b6ff8b9d2ace2ef6bcd0b8f47ff0f8edd81468b03514decc5466432322ea71698d83d9fdeecfb5555159fff302e154a9998fff4f18fb9cb1eb1d4ff337b011ddc16430c0092d551978686771fc829b0c593e0d9359faecbd37bb14424b5d037dc363760dba8e67491d7e1d926c82b0291ed8065a30e0a4f0b2727b99020d139fa3566dcc21c510035a79f9603af6a6ef30f6952e62bf38fff582eaee5453afbcbaedc2675a305f954f2d847a28faa3cb1a58191086e4a3a328adf4e1b7f19ab469fbe9c31fff860f59d591b7d85790e234d7f2160e3739fcae2dc8cc7403d65fb7dd0409193f9ce364f6c84f109e12d65422dd724e6746139256061a0290070f2b7de3882d3017ccc94c5a4d3dcf72043604b5b0ac36cd5a8cacc6a818d17e948f410a3cb9635ef5f1cd15f92d4d6d65c5eb1b196ca6f8e6b8f804b493de77a59fb2e78f528aa7fd587f547e00b4131bf5dfc2fcd6904939ba328bc45463163f304eb556e5eaeb460dff005ba4cc3a2ccde498e98c5abc071addd2a43c09acc2624af722d3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]35. 反转链表</title>
      <link href="/posts/2097c5abe775/"/>
      <url>/posts/2097c5abe775/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-35-反转链表"><a href="#AcWing-35-反转链表" class="headerlink" title="[AcWing]35. 反转链表"></a><a href="https://www.acwing.com/problem/content/33/">[AcWing]35. 反转链表</a></h1><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p><p><strong>思考题：</strong></p><ul><li>请同时实现迭代版本和递归版本。</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>链表长度 <code>[0,30]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入:<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-literal">NULL</span><br><br>输出:<span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>先分析理想情况</p><p><img src="https://bu.dusays.com/2024/05/03/6634df9defdf9.png" alt="image-20240503205906942"></p><p>分析较为苛刻的情况</p><p><img src="https://bu.dusays.com/2024/05/03/6634e0232c079.png" alt="image-20240503210127943"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 只有当链表一个元素都没有才返回空</span><br><span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 只有当链表一个元素都没有才返回空</span><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 迭代版本</span><br>        ListNode * p = head;<br>        ListNode * q = head -&gt; next;<br>    <br>        <span class="hljs-comment">// 当q不为空，则可以一直反转</span><br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            ListNode * t = q -&gt; next;<br>            q -&gt; next = p;<br>            p = q;<br>            q = t;<br>        &#125;<br>        <br>        head -&gt; next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// q为空，p是原来链表中的最后一个元素</span><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五周总结(4/29 - 5/05)与下周规划</title>
      <link href="/posts/85a455bed5d5/"/>
      <url>/posts/85a455bed5d5/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="119c3e33974b5bc638c4883c92d80c7812602266195769950c12ea008c792151">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08149440b265571a5a7ec46d02fbd8532beeb82a238ea588828539567ce9a75dc174b49773c4aa6b00588a520d0915ca8e3f54793cfd93f33c0a4eee66004549ad97e4fa2e967f3318874369148cbed3863b3ce275b16fc419fcc5f542e74b188a2309b8323a25e7315092778008831571e8c9ba3ecdad9ffd3127c25c7099abacd7385ee48de3dc0ce644425469d8bd051c1ac810d9d17999878d51068493b0bcc96eaa7eebb38e1c5cc50bf5791ae3b8f56fccd3417213f17917ba9dd6cd5357d9f9b5a2e5b61fdf48db4ed61341dd00b2ac501b236fcf12f501c67763163144195544f38824f72631b598eac4fea9539885015414a9a3d66d4fbd1cf16e956c75ab17359945cdb4e99252fe0be9d3e610c712b1b5f5e5c7e93f9075579b2e38533b3bd8583199f4059da85afb7766142198e3ada491d3368b94d2d58147aae3a1ff4f73e48619f49a7363bc3120cb328c4e690b97d042c52a8557311bffd94bf2a7d3df59b3d4c5615d8f766b85a7dd5dc38fbf4e6c41c9fdd0d64ebe448be031d54ee5b4958666771ac029a2c8ebf7118a8b86aa6ad37843c9874be6e05eee76902469e8c5079a57439f12bb7c893bd5c82da30282668aae8616799fab66ae2932e815b04ec3f44dda059df3d80f851b472e9b8d33ad59aea3f80323262f39f05e27a135e7613beff1299469c0c6bfb13e98d2edb7722bcbd52c033ee18336b146755711f70b9a732384fabcbe8de8ef9379b1c5c241c5450d92e52a0373258bb3c9cca18a67bd8658441c7a623420bd921fd7624d99745e5fb71f68a15336182ae565d9fe8f621b21ce3e794ef6ac19dae5c2a159d2db412d90ff044beb0f4441ae36d1ba74ae7e2a6cabedaf958f0ad52576f520f7e91d819ff12757760a233d57c40714d51b4ef9ee999fe15d4a0502eb8196a40af473512b3593ee37f9c5b4fe4f27df88b4407ee0f7ccf9a61f91b3ecca896152499c758b1b1185d75fb248581b229f6443bd334e0e9693ff57455654883a72a3877542acb2a09442050c3133fa3058facfcefcfd7848eef9a2d93d685e19c6a6d7041e7d7c369c0636d8b968c60b12c03c29be35b2fbd05ffe286284d332e30f3038f96d20e61a836c5883bb82fdc95dde28e4e385857e8c8084ef53eca9b90dd720aedf1aced6a8ba232450dc541b80d912f68d3b9e9eae39c805d2b5b9bbfd07c8c4ea43dcb7e50a39e8b64ba3d11c1dab5658ab0179820fb94a8ce1aa699957d52460fdf3c908994fe8af89c9be86c9b1756243cd2bfca2716dc7a1b6c4320ed0cec7d122ca8bd88814e246baf8eb02014b81dd36af7cc393944e6cf8b57b243f9cddf1f0f49fbaaa16c723969b22ac5b29a6e54483370b09cbcf9f8082fba2dffe6496e430e7248ad750f61f941aa13f841c65c3dc4918ac3c5843ab0b1dad217942f3590fe33c09aaba8705293346ea1141fa6a5325e24edc6e6c5f9cf9146cb31c4d4e5722a61bf17ae97ddfd51425462151119133a97f123db796b779dffc8bd30ab89d034ca62c98ffb4d1ee8e4e699dfaf2b43eaeb06d65d050bdf3ef18ad2920c43a6463a1f802dee7c3d542eb602fa9efaf19d988bb5933a0a0c65b8463c4f9fe80a95b9657d837b904a08ddc6f20f1d88edea8a8d93101c79bd3a51351d55c3b30cf9b4d0fae3580a2384af788eea296f4f00a893ea9f3afa91da0474bd867ddc79b91289a73e13f1459d17e170324e471ddacc6316486ca2365c213a15d3ab90a6c11d36e6322694fc3b7597847b0fdd17ef540d106d4c6c8fa0575b2567b7a15b1eaf2ba4c9fa12fd8aa934cb12fcc09436f3a4fde3058626b8b0a87ac00aca66f8fb2e084632ff4f3f75bf3ed454f4e1cdce53a7d64e3ebc524cd835c6a313c55114ffded1226c2532297c7a5b19caf102dcc60243fcfa530cf4568df2e0409402f6ea61e6397e65fd1a9b16e50440481e4beeacd9c0bc0c84e64743ef093f51d965883f2c0a82c11621a462e4c2c122e9a38aed7511c3a9bd68743233795a2e55d5de4a886b6b5213525137f42f3fda1d947df7b2fc8648ea6ea86bb75785ef6eb9e4b4a587a270e53f27cf9abc7a06d3260e0cb366287993d522ae504e7329a8d6f3070d2ab0bb5568fbcc1cddea74228a19f75f5b529b23c406d81acb21fa42550a527621d60a9e23cf5e3aebe897be285d096d977262d494d1efc316c44acc332bd67c715572e83bd68619bf63e7703125829aae7f89dd64153fb6cfb55bb7f4bad7ac1402d7d534505632654d3fa434c14e0b3e7b977f9b726aec97978a4960c7041a6e87d9ddcebe732e832ea72ce9c5bd5e745b5c01fea7c485f7b81584e324f1d9b8b70480903ee30e34f4125084bad79f7d3f8cc6c09bcb80345f9dc00bdbfe4c736944713fc519f9e336ddbc6b631b615062ec427b27b2da802ced0bd8d3ec48a79853c222ec266a35c9b2d0f23019f002ded200a5fdaa56d74c7ead97d3a6d593201af450ab5bde47c884e5e599eb07bcdec913af970b2226434ef3112ac51ded3e94af1d7997742eb874cd9de90cb9ad323d54c7ab44310d3d3211b33760a622d97516a36a5cbebdb8a6046751d992c8935d36cb80fa3adc015fd3199c107d340d6e9eb8a7089c38f1a4cd2bcf36d1866db0b4fa6ad99baf40b4af93979884b5197b83664fc98cfc4085c6d4f804a06c8861b5a21efccb4a72d50d28ca6be86078422d00db550896f69c28d4e44d667aa513906c3f539d38f95de329b16f91caf0e18def03dde40ecfbad095874b1a91761a6bda7473784175a0361778f7ae706c844cc924a23580bb6eada715d37973197b80eebafcb80748faaeec545b8c2c5ee9541511a16d8a3a0d2a8fec30f64cdfdd8675464c434f9320e55d0372c1569cc75c7e468e21656c7e108722b006b8dff6342494ac4b7e26bc5514ab65c29d70efe6b41b0185d6a80c8d032459f60e1dce2dcab1d035d85ef7c7a72a2d8bd6edf4eaf2203ea2af684ebaa9b60f528f7b5ff937225ed9195bcaec6fd446e2ad92b8092b2d33801dd8d56ae79024dbba2c4e18a62347d1b4dbcb23f6d874f4dbd74c798480b36d108772c6302</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四周总结(4/22 - 4/28)与下周规划</title>
      <link href="/posts/e67d1afdd8f3/"/>
      <url>/posts/e67d1afdd8f3/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="028ffd2e0fc6afe4ebf9836bd1666d5a32b0eb0fcdae0f066a826f662322d5b8">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814dd28c6c18edca31e1555a8485cd273625e25395c9f1c3aea939741d0bfa2f12a0aeb4c1d8cc993704f2a677a3202850096330a427b75265891b1a548643f6866a2af112c9c35c420c639b21c412b0a309a6c516de92c941c8b5f75a220e6dc3c472b304eae7cdefa406c0769129f0eabf84ac5ce473a55fefb13320b8b35a288ba2ce2409078c405a791a52b8c6208996435723bb5a8702b9e928a187ceb98d5e3bdd7cd8483f34496f283cb4a10f3e45dbb744c8b968194b575695a51d47c4f2e28e534556c5f5df69844c3eb61f0b0b17ac7fe3b67a5c1c83bcf626c57954584e4b49e0c2e66d95148ed7ac80a4327ca27c4aab8246a73ef3a41c645939fe58d430d7c7c75f8408b0e53bfc632de8ffa343607066a76b2238da758611feb2bab70c2c9f85732c132affb395bd427ba38b3f658cc5e2ffcbe86ae3132bfd99697b1dba1b87f0f0097eba194fc7ffef7015b34700485afea89ba7ba7d04e8585ce8fb1cd9e48b69fd72f0f01bfe3781d01c74086401dfc9818435f1d979831c0f276414304e4c22418ecb28dd5722219c73d435b4b1fc6adcc43f9bcbe58e9db1c490f841ab3a9686c7fda8fdc13860ada1286184bdf0e71c630c5763cf988d2673a209eee41eb9d11120e6d0e61e052498e574ee87c16021b41729634752cc2bc5abf028b00682d0431ed977b41442730e6198c131a225a2e2de0072da2ab48edf003cd808ac10868d837f3e6eb7854cbd2d3dc7b772b13d2dcbf8ce740b870f9aa5241e68d6e3a4409a571bd71f58a36fa8a1e8011401419d5fc569c8e8de99aeeb5e570efa0fde28fc0c3db9da3946c3536fc9d92e9cb123659994df584ef38a38d4a6287744fa562e78cfaa29bec80c1b4866cac6f7ec7a880b52381996915395a5b3b0e176a56531db74e4d620f3e1042ac52cbeeeb4f5e5abba6a6b6870d68ef16a7349b897bc35918035d06a858dd1732a60df2d2b2dbaadd719e0eee2ddec5897a30cef5452f6c68791861f8ec8833466cd8ebec43347e62fab76258e2b0bd133d4aa1a3394b53580342a741a6a5a54c64b9c503aca650797685ffa4769a7844ddef7ea5f62ff0a9422b4978f2daf4da1c50129188a78c29855b16960eb1609ae398ebd78691cb6f3affe227f114be5e0037fa44394597cd9aa53b6444c5d9151b938a3e1f503672fa3f8a934442b218dbf4c5eba56dad9339fb4011ab43d5ced978fd446c9987a7f9fb419fb31679914f0d536e09813879613a26dfa42ffc7c8ba8875ed4759bba5ae221360459fc5a2cb959525abc35295e77e8a213fa5e3272b5ac1800faf3e96a8f561eaa6b776a30ff151d4a42830c99f8936ba9770a6f554d1b9a96e38977f7e7d9d550cc6d59a83589b49fb8571a7f4aef86c17ee8484c12357d3207afa1af7ea57d4519202fa670baacd417ba8a3a6f828dba4ea2a98260a4c96a423c42b8aa44119f00f5b5dc04991a835850874a0813e935ffc51414447e8c0a73db49b7b086333573f1d14c5a40e6824b86a52974b3eedde0d8529648b526925d6c6463f4a299af9a86c55c8faea01bd51ed7589cb39a2f2a1ed941bdcf8699251158b969a9ec7a65d5e1714d10eb425cd90f8817608b55d64d9bcf34dbf718c4aab804866b4ed2e79c4bc3bebd5e8a233e3900f8c86b353332a08f60827a5c9df2ea84a91e39afb4a64818c012855aabb334b4d292f1e477512af03a8902c5a233c58062f532f631315da35486bef7695c65251649ff9a1a680051c7239eab223441c9e7fc20aab541ccf84be64fd050d5aa48af6eb096ba4b927809bea632b86af5762836872361a95a16c2774ecd0bffba5f1d7d29669bfe9a504b36d2f4cfb98f737182e73e8248272a6db51632ab3bcff68095badfd988d1597fef34ce6a3e8d31cf1bafc74e9f89a64c75b20695dd23ce95e6781d8477df4c6271fb65e673b292be9c5c4d325c54b9a9474432fc73757118ab541c2aa9cf27876826812b81db5c8ad218718ea89a98eaea93dd73aeb963d934e9d069a392230d55044356713872c3f5c3e1f1feac2e664025033657e630d788bff791873bb082326885716377f6ad6d960661cfbb6fe801f960b901e2eb923d0100cc82860588e356cb0e030aa75905f58cb6a7b1c87507b3446f2c6c0e042759b6a8748e35bf11b0a67ad96ef8ad97b109be497be9d17a5cc2f5cc5d4f2264fc1a527b30fa81e5186baef53dcdbdcc65271165efd58a7c228dfe95c30b6c93db966849c5a2d9aa3e2c2e7dbe7b47adc70ab8b6f7a3d887d5dff2dde55b1ebe5766e62fcd61bb8c4b7119e25cf4f0d4bf1733d527a14c066290a2c20cf11dd99af20b95b9e531e11119491a9ab41f1a902daed890d27ce51141b2fd91131156f2c84fbe02fa4b3ceeaa4c7fb80d44e4d63e0870636af64aa0a9abbc5ff0771ffabbe90c38a76ae9bc6fe21c6fb49f7273167ec551f5d57779d0c68c35eb245f9dba863df082c4cfb3b3c4477ff855ea6fb7382952982cdf390a3c3f92c0d2b5c0fb3d30637b9bd35b41588287d267dec3d53ea319c13aecdc24b8e694976a2d6449e68068d222d9cd08e3a055ddc42c5767968161e62e5ebc3449d73bb525833b2eebbb60fa8be7a7217ff8cdaf1746a1f122185abb6a6bb9e06e753456db872c0f99cc4ad9b79f2e0446214b9fe10645c6fbc9ce10edb58d0869d6d359acfb103a34cd08d7ce997bddb44ebeb6923b9becda5e85ec509e6d3eb2c04a21940b5395de8755c03cfb920b84e8b20074cf96b87265900c11f50cf86f1af154aea48a55f057397c1bed1c0705096346ef798a446d7d2789c6686bb3ba458bd600a803b547c32a48bfc2a6dd6f2cfc0acab3f873e7d794cd355f16ceff04c1661b7e6084fe1a406675daa8a268e925f85a77d968e4a8467abae314b06bc5e354ae4cdb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]842. 全排列数字</title>
      <link href="/posts/2eede509a240/"/>
      <url>/posts/2eede509a240/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-842-全排列数字"><a href="#AcWing-842-全排列数字" class="headerlink" title="[AcWing]842. 全排列数字"></a><a href="https://www.acwing.com/problem/content/844/">[AcWing]842. 全排列数字</a></h1><p>给定一个整数 <code>n</code>，将数字 <code>1 ~ n</code> 排成一排，将会有很多种排列方法。</p><p>现在，请你按照字典序将所有的排列方法输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个整数 <code>n</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>按字典序输出所有排列方案，每个方案占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 7</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>此题，适合用来理解<code>DFS</code>。<code>DFS</code>可以用<code>树</code>模型来理解。</p><p><img src="https://bu.dusays.com/2024/04/19/6622634b9d95a.png" alt="image-20240419202755100"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 从1开始全排列的数字长度</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-comment">// 数字是否被用过了</span><br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-comment">// 值</span><br><span class="hljs-type">int</span> path[N];<br><br><span class="hljs-comment">// 关于数字1的全排列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-comment">// 数字u 为 n + 1说明 1~n 已经进行全排列了，此时直接输出</span><br>    <span class="hljs-keyword">if</span>(u &gt; n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            cout &lt;&lt; path[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 进行全排列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-comment">// 如果这个数字还没用过</span><br>            <span class="hljs-keyword">if</span>(!st[i])&#123;<br>                <span class="hljs-comment">// 就用一下这个数字</span><br>                st[i] = <span class="hljs-literal">true</span>;<br>                path[u] = i;<br>                <span class="hljs-comment">// u + 1 数字的全排列</span><br>                <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 恢复现场</span><br>                st[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-comment">// 使用的path空间下标1开始，同时也是从1开始全排列</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]3766. 二叉树的带权路径长度</title>
      <link href="/posts/6049e4bb40ad/"/>
      <url>/posts/6049e4bb40ad/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-3766-二叉树的带权路径长度"><a href="#AcWing-3766-二叉树的带权路径长度" class="headerlink" title="[AcWing]3766. 二叉树的带权路径长度"></a><a href="https://www.acwing.com/problem/content/3769/">[AcWing]3766. 二叉树的带权路径长度</a></h1><p>二叉树的带权路径长度(WPL)是二叉树中所有叶结点的带权路径长度之和，也就是每个叶结点的深度与权值之积的总和。</p><p>给定一棵二叉树 <code>T</code>，请你计算并输出它的 WPL。</p><p>注意，根节点的深度为 <code>0</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">输入：二叉树[<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]如下图所示：<br>    <span class="hljs-number">8</span><br>   / \<br>  <span class="hljs-number">12</span>  <span class="hljs-number">2</span><br>     / \<br>    <span class="hljs-number">6</span>   <span class="hljs-number">4</span><br><br>输出：<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>二叉树结点数量不超过 <code>1000</code>。<br>每个结点的权值均为不超过 <code>100</code> 的非负整数。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>从根结点到各叶结点的路径长度</code> * <code>相应叶节点权值</code> 之和。</p><p><img src="https://bu.dusays.com/2024/04/17/661fc561aba08.png" alt="image-20240417204932311"></p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 只有叶子节点才承载有效的信息</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;<br>            ans += depth * root -&gt; val;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 否则dfs</span><br>            <span class="hljs-built_in">dfs</span>(root -&gt; left, depth + <span class="hljs-number">1</span>);            <br>            <span class="hljs-built_in">dfs</span>(root -&gt; right, depth + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 只结算叶子结点的</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right) <span class="hljs-keyword">return</span> depth * root -&gt; val;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root -&gt; left, depth + <span class="hljs-number">1</span>) + <span class="hljs-built_in">dfs</span>(root -&gt; right, depth + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三周总结(4/15 - 4/21)与下周规划</title>
      <link href="/posts/e3b1009c0e89/"/>
      <url>/posts/e3b1009c0e89/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="889028f094df5c939f4119464b37a90c4f3c744f2967972bdf73dcb2153d99e6">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814d2b442d5d57a8a1951978d9635e2a48b4ded424e00212e73fc5a3d8aba0ecae59698a3711542c20c3ddcab60165cfc56be82b5c60b0812e64082439dc1fdd18fe5db88e3baba417f4a1537df105e8702028de40e40817343b03654b548d7079c96160c52d602c9e2bdafeeb15e69919d159096053356a84a17c8833b394fa79d06932aa0d4979f14e1a11ce96fe9f29d398054b676644f7b3105e64a9ef1153818f9eb19cad9deabad3579d8cf2cda24525d34fbf4132c2195bdfa591a786f06cd4883b750a10e1e75b3107d92ebe01cccce7b36e2f6d7de0b2d6fef14b49b4a352373cea646ec8b7c5bcf94228a261f24fb036e4c25db5758d72924878ce91e1930a454ee0ef97c926dbf965e1ded2bffd86de66984127894ca8ebc7576fbf6fc1a13af54d3bd1fbcff9e4dbb51be0a6ccc189b08f6566e7ada89682b2006e300f7fc661e9a2cdae977c0ce163f8832c52405b82aa98bad124ad852b619364c5af4d34a1da58caf436ab5156a60e46518ef07e49f265f7fe822326d692d3c4e1b3b9cf3bbfaf912ab50eaa5b422f163bb3cad0192f44122dd37246a8b5326f0fa6a682a875fb461e72809b8777f2a5c76c75957f032338edeb590626dd02e63128536f6cc847e62cb7356c92ff3c9b74a6ae26d8f7dd6d2905a325c7afab5a9f2aa412f81d88dcbbe350129360f101c76ad4192453224987161f718151a0a4f77dd4b7a6331966b45707daec6f243aced6c6acd7ea5e15823b3b7ad56ec90dd5cafae95be2e4515956ff180775c5f347aa38ace25fd8139b8b034d26d1e953fe2c18bfd22321f6eda1ea552608564745cd925f3bdf1c7dc11f909e5bfec206519383f2733b81ba9e73a8723a5eda47ffca8b28e80af63e71c5fb4514a05cab3af59c5d0bb09ded30c8880b8920968f6e88c5d95c255ebefce94c004b45cf26db2e25a839b86e5f03921aecd17eeb67d5474fb05b10390556734ad897d27d68b1471f43c57fb5a34b839e87ff9b015fb8dd0c788c3d47db0a12d537c3f74f3e946ecceed521d74679cca5c187a8f0cbec116f7d025e51422ff859e50dd13ef5936d354345c042b732f651a58a9f2634777408db0d526908d65596306f3ab2fa11a253b1bb62a77bedb02d642b657ebe178dfa0b1a66b5384d7c7b6e10a0c11ed938b37a817b1768c83d8468542795d98b55cd60cbb9cd8ac0ef5675a3b50125efeb023a76b14fa4ba1f4b42c8d4e029e822529bc5c5f8b99412e981368225d222f305d63b32b51920e4cfe018e6dd73d48b060bc321688df2d97b949c3c5760655a46aec1fa32da01cd3f1526d70273734d4ebf18bb15b53febe57f0b45775bc1f20b9f185a5cf99e98829de089e4fb24cd425d0912d94512f4c6937846bb0c9772b02d26ebae11ef5d84afb85cdaeefef71cb3212997875755cf6fe552d17940a1c1c0d454067e1983daa2aabcb20b855ef0ecbe21fa26f34e970e22c060c04f329053c299e3ad28617f36abc235604a4691ca7a33d6db0a94432530d2d2e0d11d7655f2d30fc5967e8fefd513a4b706c12c93c7bc2144af605a5edcc9e5a8951ba90e2cfbd5d076ea9cb9218d78ed15ab1e837f1750dd626292f67267d57a6cd1bf2ca28eeaaa6e48523f0c8bf4b17b972495730418bec6821710075cf2910fa8772cae7d9550da9cdab124c1876ba6caeb1840b70e1f80ab56731f4bd82a694fc1567cebc73bae0d37dfba3f78e29d1767cfe6a9b3eca0d8928e6e2ed30a905f33e47ea97c9c9fb47fc982ed4695d39f2039daa1815f6e2398ce8c551ee29bd805dfdc24ef5de8fe0eb38f52da5ec942af292be0867aa6c919ff3579d4c0243ce3fe50e5630455399638226c74b824a443e194cf097bf1b5e103ed573061ec03affbcd43b2ee54e3b83ffd52880f7de3af0f935fa1862951adfaab2150033b5371ab52d4ba7b623bf018af295eba0d4401d28724ada9435662568af085deedaa1c1ecf3782a5c0ecd667069d08faefd08df091c00a1466f64692eb321b0cb13fd8df1d41ab4b5551336bdcbbfd9cde398d02620c20b94ad68999d5518456509f63c165e6260d5c402dbbb5a6452e429cf24df0cd6bc2b1187d8a49ea96e6a734ad03e53edf161516f4b51af0861b582c32af60134762c53f64d14ce5173b21ec110b737e6ffa3bf21fcc19943b2ba81683d15669849b06ef6873a3a128427b09e9b26d7a14f13ec48a6ee637c1de932461a817f5fe84964bf122c970832ae70e0a927fa0af3f4a5730059c9a127776133e4d3a37e4c42f2978435fbbfabe1deb617c27e3172f44b5c9c0c56507f8231ef60da3cbfad4db2da21286a85095ce4f3d1479eb0e4aeef427026dff40c7f5746a42557d19358a15eebed1ce59f3e8ca6a01a42c79b078711a00eca2fcc4d9c76398182b70b5ed3a946f073652e5b2a91acc3a0af094f9d45a3e60afc899112d175bbf5e1caaccb53828322e7df22600ef5e743a714e084eeb87adc1ef006f55471409c5e988515215f714ff36f54b16be8abc92f871cf9047b296cf19f866f8efee0f98b43fc38ba82a54c63940fcd97a802f34ffdbf96ed2260c0b18551fa40f0f844d58ea12f720436014e0da9655632da6283557207dfd54f79b86ee4e83985a33abef998e95a4f6704d6a7939d8d2b1a37e40c820993ff7bbb90f0b6465ffe8e0bc75b7eb84fdc386011d70f6abe93cef24d38e5fa0226b548fd73f9ead572b517209743c4afb0297142bf6763e971d2e3e13f8012d7457cc1c552d41f1e6d95f9a5e1034e248288e764d9a59586f20bd555dbe371297d3c43888d25</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二周总结(4/8 - 4/14)与下周规划</title>
      <link href="/posts/132dfe66ee9d/"/>
      <url>/posts/132dfe66ee9d/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="54fe2eb614a4591dc0cd6fe3205b343a0602da356c2f286c39f766fb72e3c01d">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b081440615059111ca942f2f251783284cea21ced08223624de214a5926aa8247bbc65092b6fa39ead19508aadcef5c3ee7a74d96a50ab26d770064aaf5ad89e02666fd3875200aac86754786dc68c87fd99773d3ed6484b498670cf5bab6d4ca163cc26468b034a4cbf9a4075d9008f2a1be4e9bebec9471a0ba8f5c7019651ee02b12603bbad4d408b406e6192cd007e1df7ecca6b62378ea269660b3068680d556b08d2ea294f6a5cf704345237f062cfbf0d3bb5e12ef0e47483a84aca890060f153846ab2f8a2d8a3358bed91fd2d70b1241960386a35b583260aa91fa52afa1af665824335ed939705d8960ea0a1f2fc21ec127c74686bf1979993b38d73f52457fe101003e6337aefea82aec510888f2eeb4a6c64cb48584c10e4ca84f7975e7718d2bb6602075350dac64ef0d41b22c4453d794b235d72d73ffb98cab0e6d1c8622900282a552f4604ca8c55927ae18111e59a94af7758324519ac76f91d15072b8d1b1a485845dbf258d5c705a01f77a7b26bfb3852637fa8ee0568f4fea2578678cc7b707381a6ba27929616dcb0fb95abbd1e5216db5406c3fe0a24c85cba8f849138361e4fd4ffb02802936fdfacfbeb34357e12479a176b0888dd600577468b45198139b891c74ec7897ba18c866518c0af7f0c13e7e8bb9ddac70d064e569ac7c6005f531f9c0c5902a6a23b803d82585662fbd9e7007f1cd07461ac1cb0e4963afe83ec972e91d09a436de834061fafeecd29614325152dc873ff173a0045797dcf08cec55c074ba7c2e48e364c5311700af4e267a7042f04444e8070556b0ff5c9c5b3d62fe55b6fc12f1bc7aa47ec066203f5b9be0b563c29edd4c6ed120c2e63ed274a0945416d412f69dd888dfe48e1301b704268702837b5d80ba7fb30000b0468c00fec10cf527d8fb9ae5747bb6d3c51325ea3b80427f381a06b5dbb8c190fe265cde516e6aa8f6a371d39f80783c1c97070f9a1eea37378ad83e1c7b18ff07b6ee1623ab7b397072fd5777a5154d18bd52277eca8917ddea946f592743fc9f0557a9ce95519c69f062e541cf274783a83db2855f4efc5d73b240ee9f4661a9dc1a01c3a5169af7548bbf94c86ff4c7b8b56c0b954a5fc037e762a74a803d8f3cb96389cdb5e58a67dc952310e8298eee4af7537001d8e98fa3ba51ce71e6b79703922f44e8942e2760d2635d39ecf87d2b449fee0969aa14a9a7526bd258326b7cdee8820331f9d37553b660aa77885d9e5d8bbae44656834d8345771d085568fdaca22028219602963d2c599cea4939c4ada03b623c94a7186d1d04fc25d0916f45ccf1204c7e5b96b4ea44eec17eafc64ba79d02bb1861486f0298878891775f43808d0499467c7c007daa13a08ab54f53206d233c9bb4e7efe52f1f6a907c80f55bab2608dfb075ef06ae600119e9b5050f2c18d143e84ad399cdfe5be3ca1d6e36263c633a1184af2d0b4e0c461d20d345e25a32b55508724f1ad2a72be4988d3ee4abb24aaf10e2652de0849a846b1cede2c62ff7a597100260f672b6842858ccdb15043f493c3bb80985e4e177413e11ea6f27a3e638bbd0f66e4ad8c97750da1544f9ff299e41cb6c24e34ac1501c39b64063d966112e48ff1e7219feeb0ab993e54503090296a2ff964423e1efe583a0d207916e24268849d92418011169a4d575aecbec61fdf1258dc5c86ef6025e471e645d76d47fa099ab51ddec424af319ee9e9511642c3123a1bba417e13f332256e592f43de9fa4be10a13e8e7f8269957a75a9f80212f7c82605770862ac9984f56a5c1e86797d6748f998ab8834c784fe49669d2a9e04bf102f855ff62bbd0a3bb32cdc331e3c3c04c9d097933d5cd3e2a38a04519ae0f70b381ef9332c95ae89d6a2f28834c5fd2f5883d3faa55e03bb7d7149da6a926a915962eeca8052de806383d32b7e7c2f422c7717d3116cf43c347c4f0440f202431c07fb2ab9019dcaf8357008940df91f5d0c3d6039a1271edbbf0988a7dae9fee20838e712884bfa3f9089b75ea4c6dda9565f5c1801e4deabe393699132ef06f5bab8c5f92165a9abbd1627140647656be6965df2779cd967aeed81d3f3001b206cc458363488e0e0ce420bd3d6f08736187d90d35ed0e69cbcaa5847a3ec508adc18d5993329801150c66198b764c1a2bacb01a08234c916733bcec55d03f0ad872d39852fa08c6956696f536d160c3b747d070d875f4529cc35b4bd9f12befd915fb245dc3aedfea68ce449a74f15b88dca186bb014581461b6a4242b0ae2273645388b138cf7e4de58e70c0da7440b36457d699de671f073f3ca3c4b6d045f9acbe1cbfa343efb61c9333e8099d56176a8c04d201cfffa7c5120871a7ca3e04b9184a928a9d6c80b1ffc1538c638cbfa6fb20233a30ab1fbc8a1e1b9e4ef6657aee2aa8727415f0ca0d3aff4533bc47a938519c513bdbf0b347713457dc0d8a3da2fb3c2643e37dab70a5896221ffbaac1d7d1c7db0d0a679eae65d600bfafa3bcdd83fd11b1cf689d3550b458acf78d19b6d06b672b05201cad5553e8135d259bc311a31ca9c08779d6aa8a2ae18f94b82b3f5788fe3a7133332905d9af2ae3ee409277e3e6e6384c96dc52a10660460f04c5cca986c6c734064643276bb165567df21301186d2cb9424d8af44c80421a1d0245840841d06803a3ccf08a1c15b6e9795994f73ae5e9f108ec753f7e62a8e8bbe67e12e0e6d1f88607e7554b1729389e7b5bb1e772e52e6659a64c3746f59bfb474de41a2990e00da0f4b4e7279df56b84cec0aa101a409009ca6a738f97751ed1e57db5a3983a94072514dafc4f6c946fe82f5113bccdef304e9e9a8826ec785bd9cc7a091278dbbba6634d3a5d977d11178677a28641ebb24a2ec196ef256a2ec1f41865b28ed56962e270a0de0e077a12b9be6bce7ed33b41e166b8a69774e331680a456dfbbc5ae781ec09e0acd1df726f482b322de99c4734cfdccd384329cdf5f4d620040d8bd8226871538aa805f3e82a75f7ae508d0db8f236f110076a5ae35b6c4c2bbb2a51478de6338554ccf5983bbb8b2e01ca733f737a87773389c7363337a6ae75eb2c074f2b963e418a8f52cb108dd8cf3cd4016e6651b3883b034e2ce966afbeeb3738bf4820a4f8bbe640e4a817e676f925b6c7967530b3c8eddc5b6976c85a65f58936a895243fe8fe5d010f1679988a7d371a2bb5482332529466e3f3b767479fc0f18ffee2c109214c9e701d2114dd8a50802af2ca42e00a081007eec36cd229604002ad85e617b4013ad3bcc47d96020fa7a109379c7db93bf0e43367dd333c779472b2634e8eab0663364d1c36189f55a8ef8c28fd2bea3eaad11da958373f0c4ceac6de422f90666c203604ff386f79d6b43aa0623656bfa1910ec823a0c21b1bcd2356a11950435f6a9f69e733eaab9ce12fb5c09b31ba859072c8127107a820f0246d67ed962eebc7aaf9ada4683730012d6e28c99f918ba4df68d5a1d43ec1c91f841ae0a7f53e6ecb1406bb0cb6882831d03519be1bbd3c59eed93b6f252774683e75d448d5e39246465d942931eebd3d04c845c3807a33282b7e8fe6847dda7e591421ef46258fb18c5254883608c9d08f4618bdff30929178c68521858d35b13a4a8c6e91e888dfccdc7b964d1df1b80d3a6a345660382ef4b99628a858e98495c87be8d3f300e0fa466a61c9e999d278dc7f98fb316ef4220393b917b153d43f51fd78462c8d1f74bc9e1092bcbc972f72fdaffafe675709ba29866e6736aeed1b0f1045f16deeb8df7937f76ba739fd07d36bf42bb3cc52c073d4092e90254140f989ff7ab5a9ec438e1eea29a0f4b0577ef6f975d6dd306119d2a52f346464dac4d10f915ce70a3cf174a7a40d709ebf56f26e0f3bb1771b65bb887664be161cf07322ea171279ecc45d813dcbc09360f8c4728fcaa435ceb8d74c936730bd8f3bd10960879e91a3b49b9f5dcabe369555ac4d1fc23108fec294da25dbc9cd4218d001068e74af077f57c20d23ca4fd500a776a9eea66e7231c05f473b781c9dcbf3bd6a876ac78a043932eeea47f4170e7b7d873a5ff4a487e9a072155871d586607f2a0de5dba4e2e876c0ead06c46c111e2c10cab8ec3c9c05ba6905c13861149285a0447c97e221d0123e99a5ac0c6262c4d7168cce0dc058601744258155f29ea66517b421f114d4553f99992fa2e72af5ac384f71631a61cfe2cdc50e1f7143cedcea599f59772342780c60e6fc5e4ee9267cce6440a1a81e6b4a10e05b1ecc0f9573ef12f36b7e5247cd54d9b2b15734ea95d014d7baa76e4f2d53b8dcddf07013175371b748da7f3ba8607b63bae07a41835b99c393d0a40947af1d28e34079dd8a987c64259c214eff4e940b502a8cc45283299ae3753af178e3c13291790742269b927c752ae91fdac1ae5c3fbc03a70d7716da5da65c8b4fe5f7b803b587e694c49b2d0c1c2ddd7cdd51d5a160c3f6eaa08201af37abf31f09426644f917c5b2c71379d947eca8edd94f72e0342e89b687859843c8b5e2c4aa223e42da03948907eeba994bd808606e7f4408e1282855283df579f6ad695a1f19e88f173ab8e33098da2415d813f570064d60e3c79a0cf537eb0901de1cbd8443b4b956d09919cbbf90c52fc732879c15b36c8b44421f600ab45f46204f38a3064d10e56b6516ad3feccee903004c1917f33c4b1521c94d83e26ac2f79a221ecfb06cda65ca67951296d024f799c0ca63be49df268265351735a2a3a16b8add3685cd9a0dc623d539f2db894588f8e74ffb4fc0cc382f91616c1d6b5e3a223e7f13ef1b748c7cc841e02447eb0092adb0f3c5689b9852b1d6644955124507a314558d36d8db50e54381c829136a49152c1642031648d58981afac98fdd68b263db1a79faf5d0662f5c3b0f81f798153ab03286d302978accb33428e20b3c4b01d1e56f59c72ab3ac985fdf4c7148f7b8f70cfb1e7fdbba9f3a5bc0e6f53f008b5194791f6aa5afefbc8b0a0310bc5b51c5bf9b648e2588aa604c583a960cdcae4214283a1397df8a7b901f413dcce91811d72d47c6b8afdb6315b78be3dc3e8a7183ec87630fe054d52b0f6ac0a9d1d4080a0caaa36e2256dd254850eb4d285fefc2cf2abc029d2ef5ee0fdaab1336b1aa413ae3fafec79ef08497ef26b0ce7234cdc0e77bc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]3765. 表达式树</title>
      <link href="/posts/4d1178f3e0bb/"/>
      <url>/posts/4d1178f3e0bb/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-3765-表达式树"><a href="#AcWing-3765-表达式树" class="headerlink" title="[AcWing]3765. 表达式树"></a><a href="https://www.acwing.com/problem/content/3768/">[AcWing]3765. 表达式树</a></h1><p>请设计一个算法，将给定的表达式树(二叉树)转换为等价的中缀表达式(通过括号反映操作符的计算次序)并输出。</p><p>例如，当下列两棵表达式树作为算法的输入时：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c3f2bab7.png" alt="QQ截图20210708095213.png"></p><p>输出的等价中缀表达式分别为 <code>(a+b)*(c*(-d))</code> 和 <code>(a*b)+(-(c-d))</code>。</p><p><strong>注意</strong>：</p><ul><li>树中至少包含一个运算符。</li><li>当运算符是负号时，左儿子为空，右儿子为需要取反的表达式。</li><li>树中所有叶节点的值均为非负整数。</li></ul><h4 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">输入：二叉树[+, <span class="hljs-number">12</span>, *, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]如下图所示：<br>    +<br>   / \<br>  <span class="hljs-number">12</span>  *<br>     / \<br>    <span class="hljs-number">6</span>   <span class="hljs-number">4</span><br><br>输出：<span class="hljs-number">12</span>+(<span class="hljs-number">6</span>*<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>给定二叉树的非空结点数量保证不超过 <code>1000</code>。</p><p>给定二叉树保证能够转化为合法的中缀表达式。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>很容易想到这是基于树的<code>中序遍历</code>的算法，难点在于加括号的时机。</p><p>通过观察发现，除了根节点，每棵子树都一直在重复做的事情：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c45e6e6b.png" alt="image-20240404195438756"></p><p>那么就会有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">ans += <span class="hljs-string">&quot;(&quot;</span>;<br><span class="hljs-built_in">dfs</span>(root -&gt; left);<br>ans += root -&gt; val;<br><span class="hljs-built_in">dfs</span>(root -&gt; right);<br>ans += <span class="hljs-string">&quot;)&quot;</span>;<br></code></pre></td></tr></table></figure><p>在中序遍历之前需要加上括号。</p><p>可是，有特殊情况：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c5cd7fef.png" alt="image-20240404201019068"></p><p>那么就需要特殊处理。</p><p>当碰到叶子结点的时候就不需要加括号了，直接输出结点值就行。<br>也就是说：<code>只有叶子结点两边不加括号</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     string val；</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string ans;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 遇到叶子结点</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;<br>            ans += root -&gt; val;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 非叶子结点</span><br>            ans += <span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>            ans += root -&gt; val;<br>            <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>            ans += <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">expressionTree</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理根节点的特殊情况，直接处理左右子树</span><br>        <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>        ans += root -&gt; val;<br>        <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一周总结(4/1 - 4/7)与下周规划</title>
      <link href="/posts/216a02683518/"/>
      <url>/posts/216a02683518/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0e0c679d7feafcc9d0c2aa66f93997a13d827a30477d5d0f72ff0812234a3cb6">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814870b88c966fecb0cc2e967028af3411eee7300cb80bbf274f423dd19658f7505c530642711d548c2dc40e28f93eae2df7482b8d7f287346b0700bc0a6340105e6ea3aede3f037af485f18b8b3bed1367387e302de213c7661d9311e5de8feb9732ca67c4573b20edc8ef5bc3525464e85c21b047d751374412e1463cf3a1916e8dc86e753f6a76827c450ce814391ede13b13708368897ddf751d3ad12d75ab7133e419f45a4daba29d4481590da59f287b85f357d28fca03170453ea227274644608fd462f2583ae33283f8743e5b57ebae9650ba1c2c522a73c49277e7f818b4431fbe5ff793fea52c249e7afcef85a308419edb0fefad03f15809f45519fe8c7a8708c35d74100c7086b7ad28972b1e75ca4016ebebf8ddae22c333e262e490409525fb7934949c1986f5bf59394f88d55a073260d2e9b32bad061280a3c3f7547da3daf47cc63cb300bee14abb49bcd0f7bd1f45058ce82fd0046ac77c135f286d65eaf6d5ed12ed7924e83ad033f13b2385c6fb254d67f5bb56f986d6920740ed912071ee156e64bdc2b418fe3a02f1d35744e03b1643bac3e1f27329e2b2c087e123e026353bf929e9e6606b5f7dbf9dac23db4275a990b4f63f422a32d1c82c115b6f038cf05bdb7d0b63e1af02405c17e5b5afcbdcbe549229ee0dfd451cf3a4da25d9f9b857eab388167c95d0396598c5e8da793e6889421792e10ee2a97328e78910dc679a18fd4ee0caca158b028754a4a0eae729875bffa3313f6f74dc7f3ac84d2dd6a1dddeadd6254eff498178e35afc40bbb0ed400aba75744d10837c389dfbb2313239650c73edaa70eb81b48c2929d57e7cb58888ee62da4a49d54745011b231d6913f20f4b4aad9755bc5ffe1322783604e37930b4125a7b12d0a397946f687a57cbee171764684ea69c1d0f7f1ac89d2929449466af2c2a90ee603de2c8547af4249ce635ce40ab3f9a509e5ca2cdfbabfb6f486f17f5033203745892373a04bb569a30b14e2d4bd5d5cbe2d53bd24edd801a51b06bbd28189e8c41ef9b2ec399a8fab257c23bbe98ec4d70f688b1d59c40eb229ac8aaeabdd02733ae8e083a1ff7b1dc9e58dbb4d9dcca755c95b39d01e057f06e24faabcb8fed7ab3758adc9013dfb9c1c8b9a4f28fae3dca392cfd84f7eb96a2d5849295e77c2d2f5b0a042d88dbb9db9e1d9d6376f8fe4775e1feb304dc9cd17672d9b90660b3936554039277744e40d248b436296ee908fecc9a2399d97e31d0318488deb60437a0ac1f1cf87d716c2df7fb79138188ea830dc4190da8139ef770a591f99bb8c4101872f9cb49de48b7470d64e17509d117a02420badf97e2a6785abb3433ebe1516912c02bc897956f2bf9a582534892ff7ad14bc4b8a936f36a60bd0f3cbf29118f4354127c00d1a1e9112f1e062551e3adcea9cb59e17349194e2f6a5467260be116b37a19ff20fddd3488f3231ef37859c69eddef5444225941eca15cce22dfd117a18d4cfa0d916584169a7602ce347edda5a803d76c2cb9ff7ff9b407a6c89d04227d896dd0694e676540ffc43d99606c194bc843c3283205f188834040d1b8f67f118fc7a53fbd1a92d62af6de5725cf3cca1942a2233e595be09e68d43afe709f1ac6c4c782c27f1c338f8cb1d91e354986a867def22dbd2cb6cf362609fabc464e6210a579abeccad63874985184b19ef62703957ab2eb0f20957c6bf1d489b0d2e0b2704bd958c46606e0beb0279cb9c571225a46bd7c1504e878f1822224e394362546d8fdd8ee76f68bd7e75c37ec7e488e25919244030f7cdf67f7bbcb40c6f2828e1967bf9b125d403619a3887af06751dcb3f1860425db9eaad334b330d2cf3674cb7e0e791d50f2e019a7484321be621f9add7aea8c74a90d81405771b067764f85cf874647a419b4957e3411ba824fe80be6fac4591b2ff31d6089edcc32c16d9d682255cf8026a5c3b4d97668b2411ea145e1ba346e8bc442895fb218a970da23c87fed093c33131d21600aca663bdf2f5e95620b857aa13d9d110bd76ed824f3b74d96a495568ff6fbd97d9938656f7b1b99ca3e1f764d228cb603b1ddb83de65353a13b51a118e0cdfbabcba5845577af9d7ff5919b4677afcc898aede7d585f616688a671b594af7afad2918e3b08df08ff2add06b3a23bcd6a7460a49d591905f3ac6dc609c749293025a2aeb20b06757667e2abfc8146cde114763f43c4287c495a4246f48a50c0853ab049bece83cdaed9e536ebb76ae18afb400ab539ad95a81f89f56092e19e9bc77a0bb9fdabf2ec2e949d40d6774deab16cd1ba93293993d4b73e8d4d53ffa347040ba62af15621da3b26f0949e5630e8f7eb58983e681f8774bea20f17e85e6870dd1a16227babe00ae8dc9a6fa4e03ebb07d4affd666b1eae87c79707445102ce2a5f631be9a634ebd95d8fda953feb569fbac61dc05e0fbf54a3624a390170fca78a148a9d01ad3fc3a743e2f4ea1173a9f28b3db4752690517f78e99bf2ac444d10ae0e71f9ec54bf9bce0a5654d0770dcf81f7175e9a7f1d8e9fdf5ba9fefe32f83aa8eaebf056061011b26b59a0e5d6437cae171f8c9febcd1ab79ebcb77329f0689ece6f4c87aba14548466c1f44b6afffa34e94bb1c30fdb7121937840b23ac0e42c2d1ee867821e1a5de98875b60e16b28aad7912e5e088b12ebf6e6c4c3a9d074dc4f3bf96ac79979051a514bd266b7fe07d050380d82d7d0c4355254dbd2569144e8629ac7fe6913db449d28af15846ebfad03b923edb4ec6adcd925f333cbb5a1a42f258e19e0f1f9c0377d75b469daaef5e7e368698aaa0bf5f27711a78684a8b51be1485fb48fbc5bae67682562d43f85dfc56d19e3dd96c926f19a7ab4c5d963b37f1af5bc0d4bce17c09125c6fd6d1336aaed5f02acd1c4b6b5d5dde44f3d01bf806b473661368664fb054cfae7b1552194c3c2335209b5857ff0fe4e8c77e0b655e4fad1b15b0234ddf4a11907af50dd17d7ef9a02e0607bf3c033ca34cc28be0eb849cfb64342ac0728c61562194506803a3082371253e304f4f00da52fb8d1105b13092e9261108446f9ec1f35fa43b49fa138ddc7ad8a3280aa499c9f61c572f8826392061bbc4372174fb6d6f2f6f77adf947fe27634bfa5f16562b78b0bb958f145ef012131f41bba37c1fecda639ccabaf074e890c8c1e6263fae5ae453783fecc511a4f170887fb48ca0eaf3e75205d868a3c788629b8b6000740d98f67a7aa0b550826c06430afbbd6f35877367d3e74ce95397ff6ddf1ed65cee771d9b22a2fe17f97e00fb9d4279657d01cc33cc1331c6c001777cc7892b855d3b14003e1e9df3c65d491ea8c4b58956b2d3b0f4cb6315a3c0cef2a83cbf81c3eb3e5c1ed8a02addbb74d337d9fa40387cdd215e342591eee13c8689e265c38d73c9039bd6267a06fcf8867f038780eb53a04ff743e8433c47f3e4178d2baa5f884e32d0475643e311c08056e820169305c52304db20ee34a1f41d8a8e1edead8eddceef5bf8fc1fb6f850c62605749c32d428925839cbd398b183cf22cf0bea285b8bcc524b2aee6c5c9daca2e82fc306accdbb8bd41c2c9e3841a99b7fda56ca282cb7863df41153c95d55e19dcc9397681945bf44d34809b8a10ad5f4a956758847b26453558ba1503e180be88c70adc465690d3fc9268db6f324cceef38a4e4de46fadcd687680956171035015b5283adfbc70563eb42fc38317ed2f588c56f39ee21bc2c54b3188cbd4cdb12e3cc59995d2677353ff823b1f3319f232e740c3de89f0cafc44e62b48865154188c7143a952d83f858408506600d648c9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美好的每一天～不连续存在～</title>
      <link href="/posts/ca2f7778875d/"/>
      <url>/posts/ca2f7778875d/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="abc5a3e1a7b3bd861d63d171f24fa37e5346de5b574ddba3498b807ede30caec">e673c8ca06aefc9fd566f76e908c7073bf122394db4047bcd924ce9ea37328240a38cdea58412a376dfb2c4084c8672e19e7fec2a499cc6cfafe0f544c575fc22968d157ace4fc995bc36c6fc521fa9124d0e79762ed71cfa3cbcfcd4f2370559b60818db7bb6248fa9ec9043fefa6ddd9daae6953ba901f3b971678481dcee18d8daf0ac7723ec4c6d75bd89eed1d0a412283dfa80c544c420848ec6e9fc99124af8be4886935cb501f9db6576e580896822a177488b13344cbe30dfba927d897325dc4022790033e25c591904be1df6fc7ee1bd9b5f749b77535e7366c738aacd54aeb2bf21fccde4a0cd781fcffd0dc7daf88aa6ea273e5b2266b7cb4c78797d9f6be5eb47c23de4376b90dc48d2aed910a6be7a50b220417c46744a667a892e61cef34ab5057f6e515b2dcf560718cb3effbf20e3c067a49347db45f8f5b57d402ce663479d1e0d1607aa3bfd828239abd7a12aeef22b45f0b983d398b1a7d2c00b8b54d656ffb02ec9e5e4d90467bf3b81fc7215f111ae8d884293ff3c71a73897e130586d9e21f2fcd7287516527fd266456ff23af8b8ac60d337fa5f735d2b611f008c2cc9d42048ee535424119eda8e6a0d2879d12c3359c0cdb39ba6ab5d1a08493c05427f2ce9bbb44181c951741fc7b13790d151c52e8fe1eae76b9c74d2c1373df9b46cca6b4719ba00fc5fff1a3fe868118c40fc30ee68b49131e09f1c6ce560475f3da5e5c3e1a6af7c9ae1dd601bd0732b1fdec3a290b596735a49874204e10b5d487a3579488483d877a181fb770da9e1a070e53c07afde5b1fd9eca186a03517ad667716967362b86afccd80ef336a17813cd24998d1fb32c54ad52027b320d832bd303d46c82e88a625393200449e12d7a931bacb15bf89c6003ff926830f5cf88251910125a258dcd93a455a950daa4b35da90a1ead9fecb6d8ff480dd60ce6825d4f4af7747db5c6a8f05d52ffa88e2ee8babdaeb7f8d9f2e461fdd8b408d6aed3d3bdb8930fb96def25fba37b963651e822a0a3a337e01cf4ea7d974f9f57b7edc75fa22b176700bbf08ccdb0ad0a77088c9599b586b06652e4c99ed355fda734ef967396c8264ee17ffddbdd53ca0509f7b761b3390f78502a2b9f4dc27e2d7a37de84b8e0233d40e34ef9932c86f751d7e413a4467ca9defc298127471e84d788d14d12b038220a06260c0278a5cc059b34ce0a7135744e4f100dc122440518371a057808baaf9b1f7213a7e453f6ab3d21e5f14c919a3a98b0f28cc1b5128d83b02854f181399cdd8fae0edf3ef6757683b06d7c8bec4c2a747323a44590cad0352715ecbac6dba69c90c2a781cb81b8fe846a4444aec5ea11d3b8a4df4bb5aa4a2d4b95aa8ef97b340c40b27983ffe49ebfcfe396f75b8031223ef2fa63c90f6124f4fb42cb859896f47f92f37ddf1c2baa86ce21f7bbbd7c8d7e211775f9bd54a89839f57fff1a312557f054ea88908c1ea457accdbdb847a6bb835b835f014ea9af49b512fdae0cf5ffe91936a041daa1af46731cd2fb6754d9ef1b4b04783684f7eda2d817186ea4292825aeaf4cb3a06a4d3707cf970bfc37618bdb7ea682165a3653fc733c3e51ccf464a9458cb849ae4549384dc0d3fd7106c1638304fa70377931090864774f5addd95a672515f09be3ad822b2f9a921c0f1bed1a40e6f79270cb0d24132a8d45254303285febf0bb8d1d2a653f23e5c91c7daa2c870ea68f5b3f900bd2684dac6364501a8dbcb9dee85c2fb57de277aa147a52e1e76964a676172aca82d5654fa64bef5a649467a21801d5f78149701e4d744fc19d783b91b70d6b62396492033bb473aff401867efbdb4007bf7abbfa8b1b5f2474f2016069f2f0b6089f28ec6dfb2fed5e90077b9ffaf6521e6177d65c31ec8c2639c665ccbc5557e04805fe034c16d48d150d6ed62e088c13d8df55e5b74f854900770420a675ac8fb08c56fc5f9c74d55a9617dc707c06bdea03435b4d4df8b0bffa767aa3678379c30f4de386b231cb2747af2d8bc8c8d4c0fb789a3ea674794b0582c86110966be5b55fc5eb10fa8aa6afd3d3ffd806e7f52c4dd1cfee302136870c119b8a977050fd619098298bbf50f91c1d9b0e722bb8953a99ac19e47f1cf0c88c6606b1b9a80e349e82bfe23458d2a376386a569fc58df74ab497c50f2682d821400601573c24a6e905deec5198147e4ed395496af94cfbd95a680816a7377a1840dfb79046e12ae0f1a1b9b332799e8cd77799bd97d0ccf856578cd63f90a5a37df784d8fbff7f31a182e985c6a0b2422d2f3f73c0884f6f8d8eb88bbd7a2b6e27028068ee8d5300d46a6bca488b7571ba2a69838a4ccc880d60e951794c163268cf94439f90bf5082f8bd72e2dd886c3c7d99285387df3099eda0146a9016f3515e3b16d9a1bd58d366e873de70de1d1f38f469bbf5fc8f64a24f0309ac26818938547569fd75180d59b04d340fac77272d255243a6de95b2e50838accd5ee1ee3bb14fd500255ac693b750ec62b8921293161a2611fe398613d9f74daa7d7abfffe416144e14b22c0a720652f760d90d4aeffc5b828be661a39932f33c4d5f371dbad49cc6e26785a194344389f94597623aaf8284897469dae9de4c0e8e11f08188a90f952125c9004ba823ebcc144dcf5f9afd82a28d1e2929ec3c1af1ef6ccb83c55d4ddf7ebb79e562488afdbca39c0d2845671ab89adee3d8a99eaa65a14c2220404b4e3edd94e175fbb77295c8dfee6ef8a5fc648480da1885d7a067a85a485f4ecf3c01fb2225f06f64e5e51c6b6f369a21477191b5d7f38c191d06db33df883b71585c9582783befa47978f4104a49a221e38c29b6dd151db052e05f2f2798ffb8b5b396b6ad88ea0a22a42424e7630cd347549803732c6e8166b2aac5e3ef7f0d7360c3d7ebe4c8887accf487360aed2e2cebac0116451bc1f32cba5dde222cbc52c83c200d9049b824595749dfad37819a29cee080fe2265dac6213340641c14d46caf3e96e1401fca44f946d2a759b8908256b1bec23697413b1c0a4a9d83c1a8f6ff0ded12f87baf4fdbb09913f7bc08451bac0511aaea333922b134163e097fab217cc379483ede26437bef87ccd488e45ed3772c06393850193163fdae25439da3a7cafc76ec64f739ca5bfe8f8d13adba1ea7774d17db62ec90869f61181907732606793846ad89ed18b60d96e543d67f3b27cdc89d74a4ae19814f3c69834968c04bf22bf84be7be62f0b1bfabcabd9b2bb2ce8ac78214baf18a911f756e44002f2de95f20dd4b3af50211ff0ce285dd01886579f5bf02846d6e44a0aba21b0167f02f37bdf03053e60610b3034d70385c7dab54a84738acb340696fe807aedc11d84bb130283ca53a1c18ed03b466068096ffcc6231c61aa477632f546518cd153f1f3a41a13188ef5070d31787a931cbf6a21708ef87754321b18cb89d97cfb7ac1e0b54982ae5baea1688ae81e0bf1343e525e76fc12b57d36797229b3a758053fa01fb4dfc7f0a56ec158ff63638f3a3e6dd8e8514e37c1ee16ed18d7aed853d6ef3d92169f333d6795e179b092d765e8e256a7225bd2b31d8ae6ee034206337324e4a7fc595dda554b2a5a1a155adb79779d196249ec8e13809080a7bcea3083464d258b3db1e9d0e1086b03dffc1e7c91f94d6f3985d6cf359f03ea7bcd831a294cf88a7b2f4423127058fe74fd7150b433da215929c3f00283e0a88f6838fef2c8abc40cbb41ba50731eec8fdc246731f965124e28ff8c70e1f46fe897cb11b68c2f491e1cd9f7b58a5c0c7c1018b334901264652fdf04375be4a12028b085ab06f43dfac606957747c1db4a0c4543399f3bfbdb28d21c1c16c5a9a765b6f328127ca100a250305c41ef44967a1f03070adda9991c6b5dea304a95a74ade4f4d46ba3b38118e99f696781a769150e235430c71c483bf600098eef61cca0c9af1d2e0bb4abed781b963121df983e69ca5e5fe1ff763eb51d878c1d32389422c84553b0ed0ca501f66b3361aa58dbb3ffcf5fed4e3095adc97a417f96a5f4d914c29a6c2bf7ae25f9e41d3ebd8f9fe77233a015cf6c9cd576eebf47cf82e02bdf6c97cbaa143e45b67d43817fee4804b487801644324d694c90015af6e514d134854a388134764165dad5915adfc4c221090d7554daa93e7ed875c282c5f8427cf78de531777afee9cf537fd925c8baba940ca3e65bcb19d0d4abfac2e7d53ae840801f4cbcbc9a82899cf1888e1c87d30f76a91cf5325a2a881c79224c3d735fdd5761b04acf0684e7bb0478c79ea332e17b7d6f6978e53089d8b588b97cb4935bca6594b39baee4879b5f8302c6e6ea312abff7aa1c8d6ca70eccf41c6e4bb03a5db3487bc27561f89ccefff37b33b4a57972ddf926b9ce1cfb71124177a1a8d98f527bc983aa771b258babc18b9b83937a85b55935e84db1013d8b92036113d584cd4f7b8d1777eaaf685a91c6e6ba398db1f155f79bf800bf16c26a8ddf2cec3fd20fa76c7e9cd185f78934fbfd50f6695cb9011ed41c1b984b4283ab6eeb587e34e25bc232eaeac7565a0bcd4b6337e6483a8a71add41671a97d8a7f6337ae44b1ddab0f2ea9e274a87e8ea70898991c9ddbe3da3feb17f91775fe16f3f67024062068063b922665066a4d7c8c6d163444f8b5572d29cc8c6bcd78305c31f0b0779e38c92b2051a590cba896de17b7f4485249d94a3a879e69ae577d10d912e2433b3057cefc39899c640aa9627138b595a3d450d0b65b081049fbf17da9eeeb1268ed6eac4953b1be33a75895a1f031a562535ccd2588a98133c7c312cdf26229b4c3f15b47a09b399ea1a38056b86ccd3af8f8b900690abccbf1d75d673508ff11a0ba6bcbdb41cd3cda03d66c5fa5d54ead06864b1586cb56b6e828d1b47a83e89d3b5720cef4286ff792d131a663534940a4d7e7678ae2cc22fe430d727999d301e54a4e9c6648742cc9c1531b564050e72c2cb70a3779843c003ba7a5494c79be568f53b4dad19d546ee59118f4f19b3a8fdc0135408b3c798fa40bd456caae9e4a9c794c5dae5631f95b87e6174173ce8c2de6cb1c3b70aa8fb005e14a7906dcdd3c6ca8e3641c125fb6d107b8d31694e01d913fb81813a56b3ffa60ddaa50909ada31ac9d7f0c2265ec24323c0f7fa21e5e6f3af1479aabdd422b5fd14506eb31b3b7f4b0851a7d80bb20b18a8640a7a5a2cbb1e9f5ab6cbccaef2725c8cb67fc3c605db4bab2bd5074846cc7271de29cfb1f1ae0b0284f5714d92ce854cb2b150dcdebe7b4f1977b9881fa84e359ca656dbecc403a4fbf2b22a355fff3f6390b842504a598ce459d729f043fece6d9d3909ea5a0dcba493f54c885a13381706c1fa98097865c12217ff3055676e6edf08e2153de2ed56ab855e82db8936c701e65597f754a7b8f4368f4df18bc25cb1f63871f1e232a4e49bf9a9e57a223a11015a092ce5bde7a72c67adfcb93a3c897bcf67efb9a83ab2a2fe10bec7c08d7c0c3b6b69ebd76c202ddfcd8890ba5d7bdea28ace54b92751690bba41d6845134cc93a51b87e9e18c02fc6e9ad6fc9f46778260b1ff39fc8e56d00c10478937602cc19d95d94531f1b6ee3f9c6a798151e019301138fd732d79011192a6d0958f424a44fd058e469860ffacb77247aca10723ba2b29d39b8caa463e6548f57a89b69c89f127468ff6cba5f695bf2ecfd4a5bc09176b5c6f7fcbf09ee30279eecb86743b659f6c15cc0085d8bd570ada62ec2c07b507b9bff52e50e0ee1f0a283d3b94d9d003df5627dc6446746c406b3168aa349b4aa0fb78d2c1dc0e5be5d1c3909ef4dce0d41cadecba46bf59bf904721998bf3dd942734f9d78b35bdcf76bc1f60ca37e8beea853eb36c032b1204723bf89b5a6630f3a11b45b6dc0e2619cda7e51ae52678ea3c856ace4a1b7fb86e6b3396ac83e625c77821ff5e0fafdbe3cace2dec44bc074deed07238be18474affba018882dc8f2d46df2c1dc2c143f5d9dee8f0c9a2609e67d4b316fa710cce6f82498be55188487ecb19cadccda2efc602802ff12aa07ff860ba01ccb7ff4ba26c44a21ddaf39c6d41f79d405560de253a0fbf6e0469972ba6a5be42b42284ecfe12fcfde085e56c70426f65b3d1c155a71f240247280508ce4750e782103ea6ece34e26251f659c288158b656cf56acbac9247a0a47c1ba2a443dca8b6f7098bd464289f32bd589238e195f251f5f0fd748e61846cdc3a15a8f2bb80a8275b1a93d2bb86cbfe5b792e14aef18e9597fbd5e402c0db54fdd432ba5b41e5c4b12bc4d181a48af12d4af7c712bda7164452c6cb3ab1d3def601576b6644bbe7d08d9a66295755334ea354d0c3dcccd5f97c61f8d617b022b6b4ac9ad2c6f9aaedd8c64461fc23378d7f17e2061e57c5bab450e36899ffba99e453c85bc6a7605e37f9861a4ea4b747d3f488c7adf3653283de736feebffe7b837b62148567c6e81372185bdd747b829f1f510a24b3af76dbdd3483b6ab37c771492db634d5fc5d1d20db50e518ed8e1a8b864d86e6226c170ca59d1a6a5cffeea3831b194981f11b2bfbd6ec218a986120667318606f005f1177f89e2bd6c8ae7012efb91b865671467c45a6821d79b6c4963fe2b9db9f24473880ab5a990be7e9d876e6350e5827db70c8a6e16c697eb479f248d2b8a1a3262d0bd743ef3e15c5b84de2d6207b40ed63abf1ab2455d31466345bd0fdf5685a64c557a6d4cadd1252bd739f149dbdb00bb34cfbdcdb85d8a393192da76d00307df0f1dc8bdfefaaf4b9352140438a74edf035b4aa0c26e512a407f02640c72347f7c8c7928095927233dbb0e7bc2b9a949c25544e8e67495706f78ffbf565bc235aab6b1e7e9db870385ae4acc6a2d735e4785c81e86e420bcfbbdf7938fe45959da8652875652885da3fa49304b34d0c72b679e7dce0d6123e22b4330d97b5539e463ae8e5ce55e6c75a3155fcf7f2eeec64cab34edff056d9e4def0275ea24ab555b8ea2b25601f0a8f2832d76c82c55f77fb0e76ecfec295bf3d41d4df252cd4273d00a026a4ebb52804cd2306eb2876290954fec6cf287c592c9e3ca2a3732ac01e1c39e9ed22a3da8037ad637261f25224d693eff2005bae7150de9c55f125cdacf7cab287bcf700febd378823292846451d18208eeb2031b323ea0077df17fb5ff5fce38dea28f3f50c4f3adcd57aea0f49f7ae541798c03862241520477c8346daf6ae01c8021f54ca372883193acc5530902b783f15aae6e079c81660a40574f359b5e48b16ad6fe39ca37fef1346d10d0d0346c30cee25fbf418371b539618feaf1706eed51c983df2c70b0abd67394b628b74bc9110bbd150198d23693c16f619615c3d738d8f8e0c5bd0a9df156118662f8e3aaac993ef3e497d6f59a51095805bb5303ee7bcf020f3abefcdfd9adb95d3e5ce77e1b80bacda1312f0085b3b6c6a3f2e3dd3fd0e321965bca8c7abfc2ca3116955b2bd185d4fb6502d218d12b4de42b2b28321cc4e8062992de1806bd4cfa6a728be98b45bc1320eeeeeb0ca0b6fb5e430fa237da71776685df764d7dff8a9475abbf1183e67d0106d85a7123ee06556acb19e653cc1a5370a0c7f74e32326240fac8b840a679f55254f1f0da0b88b4c0d0bc892bfd76c926828ccf7bed2d7895a18e859b9cb7a3a66d4c31400f8834ab46dc5558788083ddf3961fa7e8df95940785cd12891c3d705f5bbeebfed3ada4f72d5ddbe09c50a4cf46d79bf68a986c1379bcbc13b83919bd0052615a904c1afb063ec610ee92202bd5b34a44154056cefc0fa0d983566c08caeeedfa32703b06c7fffc279e5667a8fd4c0e39c99814f815fa258eeb66a4d4d936e906dfc4b94cdc8c973f0e419e81917121038a34782fb9ed082f7422230afc8a4a8db25e83c12e52b46df6dd04e960648ae132bd69ec64932630fb84b96269ab4d78864168d12470d5cb0c55547e80db2254d1e22b90548f164408bc51525a1204ab3d3002b31bdbbd30eeeafc587e58d590503151f9d36d30c3abc0eda99b80acce953a48f6c047d902235379d1bfb224c9db5d68e9f94b7ccbaabe4573367e6abd985b0e81025b8d63c65ace54a178710d58cc6732cc735fc6935a1c71699528d1c71c4ea7afd594b68d37d4306fa6cc045a789cc7d0f2a02e9b8fb52944960f6bdad980c9de3ae34d78bb87d784248c8eb013aae6d8eb99dff34bf57f7927f69960f76df72981c4086112ac019b52549dd050e79c3d68c76b670f911be81fb4fca1015861625cb5f5eff228fe84e6567ec0d17c2e3279f4ae492126d795add9a7746b6df4d02845a8d850e02691be53db5f76fac841977c7b3dd74a791dde2e71a3417746cdca8961e56c4438544e850ef20a3fe6c3fcfdf36a651270027d2dd97b8cd6d06ed6f3321c8b4f38ce8d70301365268a548ac77bd3aec5a28f8eaf3dc4c77b9df298fd5d4f56947c40c53e0419f93daf5dbcaf5bb376dcc6c64e8a7a4b8be3115861e81aa5668d11c243a745cd0b9e925843cabee45590b3d98bddcbd0ec108220722892209ba8771a9232e1ec8f6b487d6a6f111280020fb0169338e60db97f0143b5ad8e531703fc55481ac50b975854336769a05d2c7c8c1f80c6bed6d21a79ed94c58f892461e8bfc682aeefa3509d597d67566e2885f143c9a5e3c8a58201d9746ff2bf890e321333ea213496cfac1d52600861ba2f040c83fce3addf2b583c044ee0dfbf6abec022a6fab379b7eb5ee44a8e3d83c19a2f9c4ece6de000ceef36cfe2caa466d24bf5f69f3533706a2ae6308708a00e5a37eaf97f749853d0fb59468c4ee2c29d515a6dff6be0888cf72e64fa938c2b437e0aa1b31d41eed29e4a3efd0ee39a89016136c3a1b134f48aabc41f6cf226da33cfc9e33b783699db4d70156b100337d68512e6f10766fa85926b71422b574eb63b9c3076db9e48396a9d21746ee29644eb006cd87dcd0f67cbdcf21a840892e4a02750b491bd5a52f2ac7661125d153a1a12d965eba5d071af113ac347825c15867d21ccb53eada66ff7910c75f2f972d1e1893a198146be9962815ec883fd2cae3415e91f8ba72815c718de7f2c4d1df770ff45f0fd5739a49e076845ae7bd6d79e8173366b6e250d3ec0d815e27f3881fd06a3363e1c92c1327740060ccd17de9f8613a56ba6581e01d053d77dd202f9cfacbecc2e0632c9a7c0fef840781d89dbbe925e4aaf9ee13f3b19ba57957454b0171dc2dab61c058068e1cef448afdebb720555d5e06fd191fd369fcd7d29c9f95d08d1f4fbb8dbf948d05adc99ebdee290459f528647251ea64d4d8a3d5f0a5186cc073ce55c1330f508ae643418c7059ce389e6efadb35d56fe1781a66203eed1a39742c11f54131e65c797e0d932b9a255d4aeb1b7c9f65c40abcacfb6d10d4b0d4007970d4f0f4e95ad2368944577f8580a07068474781b33b18383b28b72dc9f848fa263a78afd479bd899f9c5918888fa17af9477789f39a613865a6ce8fd4a33d70a9de08bdb741824a4924ba39d5f6d793c4a4edb59d4c30fa52ec992b499aa801924abe3047704406d4e38de2c80b419d5963a588ce2fc758afa6b514a17d2e7e19fda7b4706da6de0ddfd8eed2001987cb834b6e7a48edca147ca6ccdf73219051c4c910fb6d64d152219cda77422992f3d46a921ea468f8c8fd83736d4cde4a7b4f5b3c8cd2846030b048dd836745169cc6f5d483fa2813690ebf5c383668178eb07bd816f420f698227cbf40cd286ad5f935263b440a81965b1782d1a718b10b6ca4d2bfd1f00878740f462e91e1949d8822804276c869b0086c56f96f76b715aaac037f4aecacb250691e9176f60943d4ec64beff9996a573d566714c6843bd56bfc1b14c7d22af4304bad6b0b10c6eea690e3548c64b480304504cf8d7c69bce0cd167b1ef6f8193af615ec44339862e2d20c94f3627a728960538a9f9964a277728cb32aa7e8bf0f5a5caf3ff2b558332447de55bcd227cd362706d34e895f207d963a1f0cf126bb292e4bad21d8ae490b1f475b056b5895a5c02abba071c09a1cd59aa00af23e96a58e8f1997c65e8a1d3280160abb561eb7b1bf932d094d4a2e762027f0956c402369678cc72f8bc99c474c9cb13a189366bbfde5ac58af22499a4527ff07cbc1dbc97470a01f1efc4911383d7ce058ba0aeb3e3e702029eeb719415d2861bbebfa561b1afae9bc301e7d1e19a969654acb2283303ba7a6a9aa6873e19e32753218c21ee2cad15794b3b1c26339808af1bd6b837f25deb88894be05171a0dae179eee94c3587b0c05f69be9157521c8b493afd20e3fe2229822ae99e4304e2e21f70cffb9f24c79005b1af4f401120e3bb4ff58b591f01263fc8cfa5228a992a4e16ea633678d3b78a5b654acb7cedc647854cad60842d60792e8a8cf2bdbf93a1089a80e90bde7a0cd32ace06c915848c771c14da848956e5c854dabdf7e89f8fcbb9a2c8971683fa3a691523c4b935f25e4f551ba00b3f16d6af410c2bca6bec285c786f75b8fe2390a01cff1cebf6a253f6d16139ba663b01c4f6621b5c0f7fb9369a4ff4b7f5a2c7fa7361fa4a8b8aed3e2b5f7cdf7cc4c6bce010fe6bdc2a4406b8216f1747bc4051d7ebd9cc04491b3e2cd788eaa220a8bc13af62e43a81d49a94fa4a27f30d69de0e541862726feb7b0a5ccf3416585dc01c01556ce0c4ce0ba130bb9ad58cd341a88cfbf3b17383f976fe758a87fc38ac604002ca98ad8c543c090cd62d28cc0d2d92e6ca1b9a000c555f671998279e63c8628783721e79fb88fd2c715c05df1dac32d665392e5b6d35597272df6073273dfe773a3e5ef9a269f18c24eff4ba7e2f56d11ec3ec856d45d826a3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周志汇总</title>
      <link href="/posts/acdb8d5c9b7b/"/>
      <url>/posts/acdb8d5c9b7b/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7bca31ff12f124a8e68617959fae7e12297ab2ab2a5c37b82ec4437da8d08ce4">e673c8ca06aefc9fd566f76e908c7073bf122394db4047bcd924ce9ea3732824180a4f1db344e311487ba241f1b16c4587f75b861f83fe634c4c300b5ce9c13f6ab2dc51be3173e872c5b9303aab66b98f2d10c9186f542c60bdf6e9e018902100efec3c9b0d9e25eb662a6738083cac0144094eaf56dff4f3d0dac07a1d8fde55b12b81cafe45e830d294450db7709fb63d8646cd7dbfc68602c1aa7bd817e8af19f77f37b3a9914120c5cb5b0f50da53c2241e20617cb37b4d39a1119beb3e073a03515b4a5930f95ae2a3fcf3e482c62a96ff08658ef5f572c32442201c12f96576e6b29cddc71ec72e7ca496a5ed9674904c3ddfb4040e37bd0457a3a51e7b885dc33f80ae91af49c6cfe9ad3576d9cd6d90c341d4b1473f006a8219a96cb109b928364ee5ea8a84eb1df1aa43f86f1a449ac8807a6cd5d14028ff1a150b0647f7bd953905b24c4ac42666bb5aaad8ae433312519d1d56cbb4be4d33d47f2b8d78626e4ff5b2718b48f105341926a755ecd794ec9be2add66b6d55b256ae426d7119f48550892431893b8fcae2604b2564b58ec667e3e4b72c42eef25bfd98a23196c8740eded952acc5658b5ef37754d78d3c647b0e6d317bf588b11c8cf9ff84ce609261ee78e409009416fcccc4e5fdc8c3a680a44c5409c055733484695491e976fbdee18cb7515bd3061c467670b3fb8a8093a20ec5a5ece65a86ec66f833bd240c1f7228238661bcbc6f9e05daa3a883e5dde4ce6d8f5604040d31a93323ba1bd5e50d88b1ffac77171b85581f985d1382632bf6b0ef47922ec0cb35d4af82457790bf0d03f26659413fa6f0b784adfb1ff73558e8fa6b22bd4d2e14d0c157390459abe61cf994f89277fdb143db2289cb66e64390efe8fde9e637b8711d1d6f4f0a275b9669643e130d89f365ae675bbf12d7aaf612323c649ed16d9ce83f8b5b223097ad5fa6dcf8754b35c36cbf20403ce44a11468acfa670c0c798c89164e0ab0d16e3d2bf3078b496e442775bdd6027d9ca116d2491748c5cdb54a9f9454c7dbceafcbe6e9cbd57557b92b133bc637c2013ddf688badee7608ea3e7b30bab3b2fe86ab267212d2f5587b45e5d4584aae61ea79e09509bf79d18bd96ae8c0d01f4e437f7e7da8c848a5ed75b96cded06f9d01f37584a565edf59a9bd635af25e50b9808e1e9c4fa8058877ed3955cdb4dd9351305e8f07f1bd94d63f3b71caa24e5a175ca7da276119ca15efd3158deba3c1dac6eb4906814702b7f964c5c1ed8465d87c1eac4c78f1b762df5a14f277eaa74321cd1d0e53c7e0405bdf0c1fc7a6ed7ac98380de9cd12bb1684e60f214d2b9c75ca1da20bacebf4728a72e51168c0ade4b06f3b9523cc28419a312d759b278dad4f6fe9e513f06bc762ec0c45d756fd3b4ed57d9bee2ee681cd03d2f92a1a613ca7332f68f9f859ea58dcdf7121b0810159ead34497ef73026785c2491f72df4b5499480401d0d36377e86f33a09945cf17238c3a7ef9285264f084a4d740c56c8d8350a78edb5d20f3de5dccbe6a0ae5044190e064c2c704fa40eef6c701b5c9c72f8f927e2e1cc35cbe8949158c976259571a0ed7adf25d2e8dc75b1b960787ac362fb645bb02d9e255ad872ea4d473e836ec1c62336130848c8a2df23fe2a7ce4aea97a8c44fbe1a8595dfc480666952cb508bcf7b4376920c88c15ab4319e8c61c13f52e066ee257042c34359cf7fd40eabbcbe7be2915bdb490c77c8f68143592e43d6257ff5984be90804b7fceb93eccf2e4978757ad7fac09b4d93b5cc389874e9f6aa18b2bbc404a44c6d0efbab01838ea448a9e3b4b24ad8692b89217807c383b710ae78d877d8ecba78a84387a368329ddf90f0d6b11d3e720f5a696209be02ac4f541dbb2a98da7176ebe34c3bc11d50bc181e1dd16f1fe869cbd1777305c311a1179480401fb3eabb667cd42c9892e541272b18712ffed90ecc25327fd71d437b07fdb9bb98c383e39944821a68f1bcb8ab523265fc3fcc2531e0595d291da6dfa12af364afb53172fc9eabd36cbc18442a4426d496d36d76fe9c8f2479f4a311619a2f4c046e048f8fe9f4aee0c8efc28fc6b9beb2ba1257dd1186be0c119139d9d94a3166ef72711d41d49a1ac6efe1cadf0e837b2f684e5687d144566900fefaef19639f74a6793496eaaed640b35d5665fef39bfe9a432cd582cd7bd610ad3e4d7e1ad1f9b0a3949686a56a2bae498b9037bc5554d12f5019a71359376591df6f30961f5b59d8d7a822ce460a5d5962f0a009d609cd7cb0b8e4e6ad66a9e012bea8cdbf887435027b11f79be29b3e131a24b7c0c30395eabeb5f65bfdaf1fa5a1afd44145c5303e8fdeebf5952d143335a6d503d6833f41ac8d4e608b5dca2a1020e412cf770785216019d8e9b6ae988893f98e18594ae68510ee4fa498a96c4b4f3e8dd24d6b0dc675e7acc62aadd6adbe704ff4e212c730112df05db2c814e985218c778e3084f3509a1d8adfa05b2e58d0994f1b0e1cff80960fbb5a5f4d3a01752c28f4b6fa0d42047c1e091a62105b2b9bb4758df7fa1ee22af4d8029111d4dcb2bd1a42d58c8b4c4fb47d996fbcd858bcfee34f59a9c9e013aaca137d914ac223e77e9c48387386fe8d09384724a8149744d4d0f8c030673a305ea73e064bcb42a713aa4e30d8b4cdc173d3fa9a1021b7451e97b16b99b92d09549afc111e3196ce1bee4c1fa9dcfe1d5ae0b1f4ef78bcd7b9c11cebbc9a45511ee323990a0b8036234b42d6ab2235c2a32ed227d0f22f6524f1dcb1e6aae2c748e9cef273c9688ee311fbcdbeb2ea1aa86c3b110b913a5a7e5ca0720678ab97e47b594887806fb9378ad73097768eaed35bb35348020c3c5ffe6bc6d91a142288290b7e21600f75291f9b6a30aa0b6147ba22e84a9b0b83089fd27babf74f7f85e5625c741d8bccaccae8290a5b923bdcad16fc1649fe36ab9ee8319c39fb4654eeee09b45d35245d063e0eb2970c618b9d4f71e15f1b1ee5d9d70542440f2e8542095705ecc62662ef0c7ec4acec7a8cce9ebefa51e1a79232975fca08accc6bb863e66bfa4070e410ee4cf279a7dbf4c4cd091f3435c182d425fb3322985cd1e1f0cd77d0d0e5565601008d156db72eff4d2a4db6d07b2bb24dbc13f10ba9d6e7a07141c15b2b0b69390eae1bd8ad6fbfba8c83277f0ac4ad85b7cf47c5c2ec0a4774e65f819e0c9daa578cfeaf7e363668e4ce2ed37f72f5113b5fcde096297e41cd37b8dc7d6e32f25a01356a72e24aa31371278cb90733879125f2afb9f819920f8b9871b557366184e17d6f11d036dd5ed8f459fbfe3d4ffbe3cd222cacb8c93dc5f254d9cfa523f9fb9e4e1c27330c89dcda13d2e774724f634bc2722406fab724ae863868756c0d1d8adc2e363db3a60473a75287e2f846f38bba07dab1e263455d66380a7a73fb0b1b32bbe5b4bb95c7644a99a652be3dfffbe6333690fd5a6456604d45f18724c08aa0855d33ce4225275a97efc410f4c17eca946a200fabeb7f18d7403759e1ee66a2fc550bb7b265f5850723a9e0f7084bcb92944fa3dadd31e4dd9a39811fc8de8a0a258764619d9cd227bb9f54ffca75e8fdf973befabc492fb75fd1787b436a4550a033ff4abc6eb7e821c64b58a85a14382c0021c5683ca2a67801b7e65e3980320c12c81b7cdb3d167f33e2d2845c9bc6083c97e21a7afcd55d3a29f1edfcd7ae4f39f02bdcd9f127755873b3f33f63cad8c915cc22506053681529faabda50d947b3cc20bdc8f3e52b1f4e163e90aa884f8192db47618ccbde80ab4a79a49a17636bbedf0913463b57cec21845f2cac28bba5143cf52e3bd911d29857bb2441f77026feb79615b14fecdda467808499dff715eb0f28c554215bf2b5d06f7224ccfca947f2661d727e18d449847d2a8c23bf1cf4249324366df063431e8c1873ed74962de11b171608f96358ea924a4f770344b0990e86b9afcdfd1d0b15f7cb6998b7966a635517707df53f0797929e93aff8129d2d055844adcbbcf621428ad301ce44625b8a9032662a34173e250976e7a8376ce74ab6c9fd9b979aa758498ecc7921b60aa56123b28dff19ba6d263fdcc12ba5766ef4f3bcae962104b0e6b0bcd955ac25c5785eeaa3da952c5463340cf4f4d23c7291eaa995035739290edf2135e82eaf7f88ff61f7a56e787a1ebcebbe6ececd2fc08ea43d4f940f444ffc2b419fa3aa1dde9166a6b64e435a3cd0bfc64e456111cb93e7f271d9d18238abb7d463bd62ce58d6ac66b933ee4bad45a287ef7a2b6fe83f893003868af433e77af7f19c597cc3072f3f73b1c6d0ce5750b3ad1804df92c5076bcd15f6b52262ae5bca650b2ccabff7a80fa06ff51eeea4b1e20f036abbbeec87c2e9d05e5142eb3a2fe7f658c6adfa6b50a0628d658957d839026946a0c1c24ae83bea797b39d56fb18c797015525dd53d4622781c3eee04f98e5fb214ef263c6e0f568ff86dd6176eaef38879e3c29ced1eca6a2a50f060443e8c37c5589e2669b96bbd76e75959adcfb0b264474e821e91195207db8f16352724a60e29b702a417564089d3cf1bcde02b8093172c64264afd2809464b76e2de82f142ec26c4b6fb93f288737be40c05f6f01ba426e0e5bde9e1ff1d264d093278ef960f62f8130cc0b76eed2dbf451d884aa7948f9f83a91f5616426af47d814cf29416b03eb9a473125348cd725e62b66e39bb034db768ca074081881f82dc426b5c734befdc8597db09038bb01d9245af54675b77467c2a1921328369cb653c5251851a82288b3cb0a0f1dda8a5d81ddc8abc6146df1ed4bffaed161382474ae198ca26a1d271b072c406a97cd628a3297bbebe8168647d1db9a0abefd32bbb7ed4bc70c42888b86d16079c97add408a7067052285a85e0727cf959b11234a53a5920076158e279de4490dcfc7b6302eb27b0caa541f5254663a6aeba9f06f6bbbdaac81bd543f277da376bf4f0f55b8c62803f68cebee81fcc60b5c729090e1f194bf25c5fd5416a1ad097b5df35e95eea6248f635a4ab45b6cf51b25005f1bd5d37e30b7e06f6f4131d4a0e51375e77ec9b20b9db2a7b01d624b73cc4ed23d73619158baedf1c256c14ac161b1ed90a3c0c2e4f880da2df48859b947ba9e5ffc26c96268e2475a09bfd20537488c26d42ef5554aef2a7b9a4456dd86d74172aad0e434383d7ae7fa458ef1190a0372744a0feb73fa3d130a9a98b1ab2eab95829e06b703eb6032479c53b5f884dc7dfa1077e64334c3f08d082b15c58c034339044d807b50642935feaf6b3937f176feec217c748d90ef58f3215af62daa9193e1f82394fe6925d46d2d41c9be8fe60af251905e3564ec0d2c6e8f8439e4d21b0dffc23f489cabdf5a2d40d7b693dd7d92822a6dd715b0ca0193b8590bb417429ee19581b4f577ba6873dfe2852c60ab00ece49418559273857b2be143dee5fe8b6535983f3f4fc59476983792bc1f4893c4286e933332e28a045f00307fbc00f0207f776608bf0ba3d45e1c71aecadb618ace3a9526e09c945fd361e63b5f898eafe0d6d19794d66ead3a4f0d0064f514e4ff7adc50b1510135db5e7206bd4a8aa53434396cd7ff4d9d59e1aef339f587933326913fcd9c69676d8be5e65d8b7c8fb77f017537edc3d2724700be45b43a02932031bda721787f9a4ebd65ce3c4072f885c8e3131fff7beab1ca1a3e928db5b7d785c9c681cc17b80d032669e4cb256e80567cd26c2cef4f387954ed7728a03a3d1630bd9fc05ad2b1a37a8b35915cbf25292eace89c02cb50f41872b8f24a43904a9826aa0d6d71697b260ff1ff954843aa70941e0f61d964706fc929abfe66f0e3bb03beabc9cd6458fc2a9e84b49a453f0e43d65db7e1709c0404e754fb4266a13816cbf070ffc5b2190d02f4fef7961b0d35fad90bc7625df7a17ac9fd6b7e02adbdc93970d9e7ab4de63c11b0bfa44a76f43ca4f3a043fe20554aa34035bd3053ab9f80b068e05d78074580c96d46fa9faaff52f19465d84a2110f53ac3c90a48a3e0386481016750ff823528441559a2dafd1df2749e45c7d1f5cbd26ae061b90dbad7b034ef4ce544473745e63dcff852124a91a8602999fe746e421dd570a381189cc64834f3b10499b318f14715fce03587ad2c2b5d71b1b9e6b12bfe6b10264a5ee5d956af2b6663143d80fdef164fc76b7988ab9746f0e2effaae9a784449005a5ac907148d291913c4949b65597d78ad1b23868b337f9efa5a04bd0ee89344fae965a25359fde637498364785596dced7616e930e1df57f0a53901210fad6fc33aab97258e75c02654255fd7cec2279eca9c25967954cef88a9bbb77b445287af518952175f3cdf6c51c748fd4e4010083ae1826b714f5ae016d1c89616a879fe1e0f59f30a966573dc2fc13e7a19f4c2d064ac7d5236f641b00d43c6c9cc191b29781831dfd8dbdd61e8a5a4e46eb2c1cf38f450248ef46ce40468b613466f95cdeab94b65c00ccdfd748dd7fd7e0dc8f94ab6b5c798a716993e7b85540b82bab2b37a9f337633b1fdf87e87facbebeb8fffe95c2c7ff81eb652a13b8a5d63e2e81f35a5635a210881bafda3a73b81768e076ccfc3b72364e0eaf93d652264e7e8c3e42122867e5471338b4c71950b823e56181912f687fc19f88c7364a1fba1ce03e5756070eff113a9f37adad835266510a157bbedaa47c051fa8a60996ddb76f2a3fd9179a262b1fa849da482542303bb4187d6d13b1e47ca71d5419aac11d6a3511d1677a936d7875b5af0328e75e7770d664bd9d7443f2a260f1e960fb480e6bacd004de79d5cd4d1c67e2bcefbdef773c51494106f187330a3e1fe65a3f064a9c6a062a9a0e60dd1f661eca12996773c39ea1c101102b7290290e48166ab6cade6ae751c17b8f464e2e7d480684f7ce0bfe85e692417615c7f37be69a912e2c80ce52fe6c99f3e2c2e157edc779734df67802eb0bb8101bb65ef4b3a546b6fb21a93e2c6776e9fcdd3e57c51569af72032098b1008e58270d559df395d4680457d55eda99004c03bce7a56a097bdd88fab375edbfba8eaae8f38f74bfed95178b5b99c002335252143f78b87effd25638e93edc9a5f55af83fe033eb1e5ff6ab8105f04641b21998a8cf99583bc30b34d3aa94ad44a48e011953d138877f9998773a9d461c6455c0b5668800940d654b164d4fbfee9a984b34cd111dcb4a3fa2fbd3549b461f9923c7860c2ad0e036c17ec456b7983fbb6dbf89a1a5238b63c6ddb952343b5d34aebcd2f233126ff203a441d69909ce680c4924d119c6c9cc3fab57a9c1b4fe0c8fe3dd0838dbdca5ccf7a117e3cbbc0d860d2aee46630948fe16d40660bc4287fcfba0bf5be7c983d99dec6369afa5f354cdade86660148ecb5e7e302baae0cf5b5d1b8c06e88db2afb9d8ef26562881757ca970ab782cae0125e7ced413b9c3f48aa06fc30d38f2802f538400fb1b6834a8f50930744054a50b0f38bc938a0de21e9c18a2399c787698563bc9c1bf57c1297b074b9e412d811d4432386d968ffbfe33d3bc1482e8f866702c998f01182d3469b597f412dc5d5dca8bc33b3febc161b00d32972e941e57d26974ef8cbd158c7b2a372b45781960929d441bbb11e8205b5df8eee86dd8c862867ed31e440cc6d0e2b4e39ab2e72f04439b535d18c3cb315c18b70f31a8e91600a04e175d0c2eead56a62421e72c79a0710345f82f8f930e40b8172cdb88fee4f0a2fa517236a4eb50c7061613e97464318e905432c5b0e4d11c3fa8e03f2754ac3761dbd2fef14194fde685afcf5d97c35712e60d2fe415fe0c1d7b86040fdbb70f2c22d8b20fc2cdba9e7ac75cc3c06a549d1c8003c7bb69f6e208d4206402e0212e1aae9bf058838c037abb0e2ec08076c3173f2bc58101e45e18ef77bf86d8eb3ffa1c96d12e86284bc59bb408be50d1ef2ff64bd0d34b33bf0dea580dd3d78a8742f1107930a57d16293692ddd513523c5dee657f722b7f7980518dd5adbb6251c2a9091684959828070d24954d2ea6e82224cbb54b7a23f422247028b1bded63f2a562934cf1cf55e2fca26276cff971f2ed01f7660e10ab4a04dd626969791c7a69271f45aa9c07a52dbc8153d3186f8bdcbe451996c19c23ec12c8e812f4ac08043f6ff3fc481fd515e718baeac1dc3bbd6bacdad6724aa4602779aa4a70be34453f44931550d3c136b44762baf88bb0bd014504257aabe7d17c4f8f0352fcf350f86123b1fe9432da94bf796814a639ac164161ce0da6c3799457639cee758a278f9bed2c933944824fdc5367ac0a0c1fbb2a2917dccedd5d6dd45efcd81296ff787f052650e8e7aae5312c869dfb6d95b3a9b46002fde1b51f1ee973861bf3697f949db727ac30830ba4166dbcc9ab50fa9a8e90b2b46dfbc0765a9ddc2d7f49c9868c8e76e36e54938ea8fa387bb6b342a55874060bf1d62a40af6f2d8cdf112ed985d8c929a73219241780fbab828590a8cc666f4c768a968d303131db4bd73e7082921631e705735932c31e9af810e10dec75431a7f89440eb2235880bd25c7301b6676578a0b2164a888dc5a375a03e3fc3bc5178955694df1d8f82642b7e13484d1d8d6d934e2144c799a7ccb4d11035996dda1c04154c1460700e6b6adc33a236e3c5c1cf9b1866c837cec754d37d70c3ed9119936fa402e0e70413cb0171a28a5a3d1090ba4828d92e639fdd05c0ac68e46d9fdd928c0019098001cf5fef31a257e9299c84d4e6b7b6097397883563b261358a4eb9c198f4f4ef10fd325a26254af3e2e4f6f408d8fe601e27bef64ba2b13e4afbaaa240edde2e80dea310c981a6c8bbb13ace46199e13c389275bce073e61cc9a417fa7c3740432c9b8970b70f5b0bf3f30b6a33a6bcdc3cd8ead33d71ab8e902e53bc26e5367d1b137e737db3546d2778b94a9ca12564eb279eac9468744673174e1420e2722683fdc3fb7dd61aefffbe420c2485a2fd01dcf0ef48256aeaeca4e6dd1d30599d2746f7ea477182ee25683d4b9ca7a6f2cebc74b0577e845cbc2a4f681da6e93a078042d51a16688514e72466479ef1af339230c36a408e5e127f8a7c9c117b7e554002feab8a993f482c353bc75dbcf00f5c92c378f6d05edef7555adfef3d30a21b076f215471773f6a4002fda78dc6bf9a9828887092406c4387c4f20cd5fa235320ce8c95c77c97b447a676421b9007ce1dcb4d114ee4e245543e919d7d828998e1874dd264778ce879ceb23c92a204cf276bce37009ed8f905965347bed783f33ba0fa288520e2350e09809ef99d1ba2f6f6fc68442b27b3c60f0a2882699eac24ccc240ef185bd1651efe3647b73e3408e237ea8903c0be0e2e7bc2262a8de9f9c36ea4a5d99ef9e3415d2cfa6f3f7e297f195c9f311e2ba1dacb6c571540a13270560b74b20566435ea95e9ede4ed49fa8b38d6012a97a91ca8d04258020c5fe897ec57ac42</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 置顶汇总 </category>
          
          <category> 周志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
            <tag> 置顶汇总 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/posts/00977ebe8687/"/>
      <url>/posts/00977ebe8687/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>使用<code>链式存储</code>。</p><p>因为书上的大题使用的都是<code>链式存储</code>。所以我也采取这样的方式，作为我的算法模板。</p><h3 id="二叉树的类型描述"><a href="#二叉树的类型描述" class="headerlink" title="二叉树的类型描述"></a>二叉树的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br><span class="hljs-type">int</span> data; <span class="hljs-comment">// 数据域</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> * lchild, * rchild; <span class="hljs-comment">// 左、右孩子指针</span><br>&#125;BiTNode, * BiTree;<br></code></pre></td></tr></table></figure><h3 id="先序递归建树"><a href="#先序递归建树" class="headerlink" title="先序递归建树"></a>先序递归建树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序递归建树</span><br><span class="hljs-function">BiTree <span class="hljs-title">CreateBiTree</span><span class="hljs-params">()</span></span>&#123;<br>BiTNode * root = (BiTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br><span class="hljs-type">int</span> ch;<br>cin &gt;&gt; ch;<br><br><span class="hljs-keyword">if</span>(ch == <span class="hljs-number">-1</span>)&#123;<br>root = <span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>root -&gt; data = ch;<br>root -&gt; lchild = <span class="hljs-built_in">CreateBiTree</span>();<br>root -&gt; rchild = <span class="hljs-built_in">CreateBiTree</span>();<br>&#125;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">PreOrder</span>(root -&gt; lchild);<br><span class="hljs-built_in">PreOrder</span>(root -&gt; rchild);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br><span class="hljs-built_in">InOrder</span>(root -&gt; lchild);<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">InOrder</span>(root -&gt; rchild);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br><span class="hljs-built_in">PostOrder</span>(root -&gt; lchild);<br><span class="hljs-built_in">PostOrder</span>(root -&gt; rchild);<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先序遍历的非递归算法"><a href="#先序遍历的非递归算法" class="headerlink" title="先序遍历的非递归算法"></a>先序遍历的非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">// 一路向左</span><br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 出栈，并转向出栈结点的右子树</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>p = p -&gt; rchild;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于先序遍历的非递归算法：<wavy></p><ol><li><code>根左右</code>，先根的性质，决定了在<code>一路向左</code>的过程，是可以<code>边输出边入栈</code>的。</li><li>模拟递归回溯，也就是<code>else</code>部分，此时已经完成了<code>根左</code>。现就只要出栈，并转向出栈结点的右子树。</li></ol><h3 id="中序遍历的非递归算法"><a href="#中序遍历的非递归算法" class="headerlink" title="中序遍历的非递归算法"></a>中序遍历的非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 中序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">// 一路向左</span><br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 出栈，并转向出栈结点的右子树</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br>p = p -&gt; rchild;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于中序遍历的非递归算法：<wavy></p><ol><li>与<code>先序遍历的非递归算法</code>类似，不同的是<code>什么时候访问结点</code>。</li><li><code>左根右</code>，决定了必须要找到最左边的结点再回溯。</li><li><code>else</code>部分，也就是模拟递归回溯过程，必须要先<code>出栈</code>再拿着那个结点的值访问。</li></ol><h3 id="后序遍历非递归算法"><a href="#后序遍历非递归算法" class="headerlink" title="后序遍历非递归算法"></a>后序遍历非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 后序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><span class="hljs-comment">// 还需要借助一个指针r，记录最近访问过的结点</span><br><span class="hljs-comment">// 因为回溯的过程中，可能是从左边回溯，也可能是从右边回溯</span><br><span class="hljs-comment">// 从左边回溯，那么根结点就没被访问过。</span><br><span class="hljs-comment">// 从右边回溯，那么根结点被访问过。</span><br>BiTNode * r = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123; <span class="hljs-comment">// 一路向左</span><br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 转右</span><br><span class="hljs-built_in">GetTop</span>(s, p);<br><span class="hljs-comment">// 右子树存在，且右子树还没被访问过</span><br><span class="hljs-keyword">if</span>(p -&gt; rchild &amp;&amp; p -&gt; rchild != r)&#123;<br>p = p -&gt; rchild;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 否则出栈</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br>r = p; <span class="hljs-comment">// 标记为最近访问过的结点</span><br>p = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 重置p，这样下次循环会直接弹出栈顶元素。</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于后序遍历的非递归算法：<wavy></p><ol><li>指针<code>r</code>：回溯的过程中，可能是从左边回溯，也可能是从右边回溯。<code>∴</code> 从左边回溯，那么根结点就没被访问过。从右边回溯，那么根结点被访问过。根结点被访问过，说明该直接从栈顶弹出一个元素。</li></ol><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 层序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 辅助队列</span><br>SqQueue q; <span class="hljs-built_in">InitQueue</span>(q);<br><br><span class="hljs-built_in">EnQueue</span>(q, root);<br><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">EmptyQueue</span>(q))&#123;<br>BiTNode * t; <span class="hljs-built_in">DeQueue</span>(q, t);<br>cout &lt;&lt; t -&gt; data &lt;&lt; endl;<br><br><span class="hljs-keyword">if</span>(t -&gt; lchild) <span class="hljs-built_in">EnQueue</span>(q, t -&gt; lchild);<br><span class="hljs-keyword">if</span>(t -&gt; rchild) <span class="hljs-built_in">EnQueue</span>(q, t -&gt; rchild);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考研笔试自用算法大题模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研笔试自用算法大题模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序队列</title>
      <link href="/posts/54e3f3a21b91/"/>
      <url>/posts/54e3f3a21b91/</url>
      
        <content type="html"><![CDATA[<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>顺序队列，以<code>循环队列</code>为主。</p><p>因为好写，所以采取它作为我的模板。</p><h3 id="顺序队列的类型描述"><a href="#顺序队列的类型描述" class="headerlink" title="顺序队列的类型描述"></a>顺序队列的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>ElemType data[MaxSize]; <span class="hljs-comment">// 存放队列元素</span><br><span class="hljs-type">int</span> front, rear; <span class="hljs-comment">// 队头、队尾指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化队列 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp; q)</span></span>&#123;<br>q.front = q.rear = <span class="hljs-number">0</span>; <span class="hljs-comment">//初始化队头、队尾指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EmptyQueue</span><span class="hljs-params">(SqQueue q)</span></span>&#123;<br><span class="hljs-keyword">if</span>(q.front == q.rear) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 入队</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp; q, ElemType x)</span></span>&#123;<br><span class="hljs-comment">// 队满,报错</span><br><span class="hljs-keyword">if</span>((q.rear + <span class="hljs-number">1</span>) % MaxSize == q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 入队</span><br>q.data[q.rear] = x;<br>q.rear = (q.rear + <span class="hljs-number">1</span>) % MaxSize;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 出队</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp; q, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 队空, 报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">EmptyQueue</span>(q)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 出队</span><br>x = q.data[q.front];<br>q.front = (q.front + <span class="hljs-number">1</span>) % MaxSize;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获得队头元素"><a href="#获得队头元素" class="headerlink" title="获得队头元素"></a>获得队头元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获得队头元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue q, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 队空，报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">EmptyQueue</span>(q)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 获得队头元素</span><br>x = q.data[q.front];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考研笔试自用算法大题模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研笔试自用算法大题模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序栈</title>
      <link href="/posts/15d79a1a4b3e/"/>
      <url>/posts/15d79a1a4b3e/</url>
      
        <content type="html"><![CDATA[<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><wavy>顺序栈比较好写,因此我使用它作为我的算法模板</wavy><h3 id="顺序栈的类型描述"><a href="#顺序栈的类型描述" class="headerlink" title="顺序栈的类型描述"></a>顺序栈的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>ElemType data[MaxSize]; <span class="hljs-comment">// 存放栈中元素</span><br><span class="hljs-type">int</span> top; <span class="hljs-comment">// 栈顶指针</span><br>&#125; SqStack;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp; s)</span></span>&#123;<br>s.top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化栈顶指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断栈空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack s)</span></span>&#123; <br><span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 入栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp; s, ElemType x)</span></span>&#123;<br><span class="hljs-comment">// 看栈是否已满,报错</span><br><span class="hljs-keyword">if</span>(s.top == MaxSize - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 入栈</span><br>s.data[++s.top] = x;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 成功</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 出栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp; s, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">StackEmpty</span>(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 先出栈，再减</span><br>x = s.data[s.top--];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获得栈顶元素"><a href="#获得栈顶元素" class="headerlink" title="获得栈顶元素"></a>获得栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获得栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack s, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 空栈，报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">StackEmpty</span>(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 获取栈顶元素</span><br>x = s.data[s.top];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考研笔试自用算法大题模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研笔试自用算法大题模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝治光师沃卡74110耶加雪菲手冲咖啡</title>
      <link href="/posts/89001a5236dd/"/>
      <url>/posts/89001a5236dd/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近又买了两款<code>治光师</code>的咖啡豆。</p><p><img src="https://bu.dusays.com/2023/09/11/64ff1c3e0aee9.webp" alt="Screenshot_20230911_214426_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/09/11/64ff1c53bc299.webp" alt="IMG_20230904_174607"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/09/11/64ff1cbb12663.jpg" alt="IMG_20230910_035340"></p><p><img src="https://bu.dusays.com/2023/09/11/64ff1d1fb1cfc.webp" alt="IMG_20230910_035309"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>冲好后，是红茶和柑橘香味。<br>高温表现为：酸质明亮，甜感十足，但还是酸更为突出。</p><p>温度低一点，甜感增强许多。</p><p>低温时，轻微泛苦，甜感更强，但失去香味，茶感还未失去，有点像吃了烂果子的甜感。</p><p>总体评价：中高温很好喝，让人想一直喝。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝辛鹿号码系列手冲咖啡</title>
      <link href="/posts/9d745f9baaa9/"/>
      <url>/posts/9d745f9baaa9/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前买了<code>辛鹿SOE耶加雪菲</code>，然后我去评论了它的风味描述，店家看到了找我售后，表示他们很抱歉。作为顾客，我觉得辛鹿的这个价格，本身我对他家的豆子就不报有很大期望，我基本上是将<code>辛鹿</code>作为行业性价比龙头来看待的，因为学生党时代，我买过辛鹿的咖啡豆，因为便宜，但是味道也就不多提了。</p><p>店家这次给我补偿了一些豆子希望我尝尝，然后表示歉意，所以我还是写一篇评测。</p><p><img src="https://bu.dusays.com/2023/08/08/64d1fa8d9e1e8.png" alt="image-20230808161911377"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p>首先上场的是：<code>辛鹿02意式拼配</code>。</p><p>闻起来就知道是深烘系列了，一如既往的焦味，能喝出些许酸味，整体风味均衡。</p><p>应该算是经典老咖啡风味了。</p><p>总体评价：老咖啡、性价比高。</p><p>然后是：<code>辛鹿04精品罗布斯塔</code>。</p><p>闻起来有种不一样的味道，不是纯烟熏味，更多的是大麦茶的味道，而且气泡超多。</p><p><img src="https://bu.dusays.com/2023/08/08/64d22c610c730.webp" alt="IMG_20230808_194509"></p><p><img src="https://bu.dusays.com/2023/08/08/64d22c60a1944.webp" alt="IMG_20230808_194519"></p><p>喝起来绝了！这尼玛纯纯<code>大麦茶</code>！喝一口，剩下的就不喝了。</p><p>总体评价：大麦茶，不推荐！</p><p>在喝完大麦茶之后，现在是：<code>辛鹿05精选蓝山风味</code>。</p><p>第一口下去纯苦，多喝几口，有浅烘的些许热带水果风味。总体挺均衡，风味不突出。</p><p>总体评价：均衡，均衡得想笑。</p><p>最后，是：<code>辛鹿06精品庄园圆豆</code>。</p><p>闻起来好像是浅烘，呜呜呜，连续喝了那么多深烘，人要死啦。尝尝这个豆子怎么样吧。</p><p>额，喝起来是中烘，风味其实感觉像<code>中烘的耶加雪菲</code>，个人感觉比<code>05</code>好喝，起码这个有风味。</p><p>总体评价：中烘耶加雪菲？性价比高，还行。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝四人咖啡粉红佳人手冲咖啡</title>
      <link href="/posts/b8bb6e256940/"/>
      <url>/posts/b8bb6e256940/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这次事件挺有意思的，起因是我给了<code>四人咖啡果丁丁</code>一个中评，然后客服来问我要不要售后，退货也行，我表示不需要，并且表示下次要购买他家的<code>粉红佳人</code>，他说给我先送点喝喝，我起初以为给我补发<code>30 g</code>豆子尝尝鲜，谁知道他家诚意满满，发了<code>100 g</code>。</p><p>不过喝了之后，我表示很不错，他家也是发了一个修改评价，我也是改成了好评+空评价。</p><p><img src="https://bu.dusays.com/2023/08/08/64d1ed5b9ac47.webp" alt="Screenshot_20230808_151607_com.taobao.taobao"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/08/64d1edc1c17af.webp" alt="Screenshot_20230808_151830_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/08/64d1ede675129.webp" alt="IMG_20230808_145826"></p><p><img src="https://bu.dusays.com/2023/08/08/64d1edd1322eb.webp" alt="IMG_20230808_145904"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>你知道什么是<code>花香</code>吗？你知道什么是<code>蜜桃</code>吗？我小啜第一口，全是<code>蜜桃和花香</code>，而不是<code>酸或甜</code>。我怀疑店家给我的是<code>A1</code>品质的豆子，几乎喝不出什么负面的味道。</p><p>中高温，蜜桃风味明显，随后才是酸和甜的草莓风味。低温，酸味开始突出，但是蜜桃风味不减，甜感增强。</p><p>继治光师伊迪朵水洗耶加雪菲之后，又一让我眼前一亮的豆子，很惊艳。</p><p>总体评价：蜜桃、草莓、高品质、性价比高、推荐。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝治光师野草莓手冲咖啡(整活)</title>
      <link href="/posts/0e42f4daeb32/"/>
      <url>/posts/0e42f4daeb32/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>买了<code>治光师</code>的另一款咖啡豆，这款咖啡豆是意式拼配，中深烘焙的。之前喝的差不多都是浅烘，不知道这下风味转变能不能接受了呢，应该问题不大，毕竟以前黑咖我都是不加糖的，主打一个不怕苦。</p><p><code>治光师</code>店铺也九周年了，送了一些小玩意，虽然没啥用，姑且也算送了？</p><p><img src="https://bu.dusays.com/2023/08/03/64cb3337d9470.webp" alt="IMG_20230801_181148"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/03/64cb32d81bb8a.webp" alt="Screenshot_20230803_114348_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/03/64cb33549edd7.webp" alt="IMG_20230803_114019"></p><p><img src="https://bu.dusays.com/2023/08/03/64cb335dd702a.webp" alt="IMG_20230803_113927"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>豆子看起来棕亮的，冲好之后闻了一下，一股烟熏味，感觉梦回高中了。</p><p>果然，一口下去就知道<code>老咖啡</code>了。整体喝起来十分不错，不对我口味的是那烟熏味！即使是手冲也能感觉到它油脂丰富（别和我说没压就出不来油脂，我说有就有），它入口绵滑，虽然带有烟熏味，但并没有带其它奇奇怪怪的味道，比如<code>焦炭</code>这种。回味能够感受到<code>柑橘</code>风味。草莓酱我倒是没感觉到，不过毕竟是手冲吧。</p><p>这算整活了吧，因为这豆子要用<code>咖啡机</code>来制作，然而我是手冲！因为我现在还没咖啡机，仅仅是手冲爱好者，但是<code>治光师野草莓</code>又十分有名，我抱着试试看的心态买了这款豆子，尝尝鲜。</p><p>总体评价：中深烘焙、油脂丰富、均衡、性价比高。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝四人咖啡果丁丁耶加雪菲手冲咖啡</title>
      <link href="/posts/9c71bc76a9ad/"/>
      <url>/posts/9c71bc76a9ad/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>四人咖啡送了我一些小玩意，还送了我一包<code>花海</code>，之后我再喝。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/01/64c83b62d354b.jpg" alt="Screenshot_20230801_065234_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b71273d0.webp" alt="IMG_20230801_062901"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b8391dae.webp" alt="IMG_20230801_063010"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b951ee47.webp" alt="IMG_20230801_063637"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b9ea4a2d.webp" alt="IMG_20230801_064028"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>偏高温时，第一口居然是莫名其妙的味道，第二口继续确认，出来的是<code>茶感</code>，随后品<code>茶感</code>的时候容易品出<code>木质</code>和<code>涩味</code>，随后感觉像咬到了一颗焦炭豆子一样，口腔开始发苦。</p><p>温度稍微下来，酸味明亮，茶感明显。但后半段伴随着不好的味道，比如：木质、涩味、烟熏、焦炭。</p><p>其中不好的味道比较突出的是：木质、涩味、焦炭。还是那个问题，喝到瑕疵豆了！</p><p>到了中温才能更好喝出它的风味，耶加雪菲的感觉。不过风味变成：柑橘、焦糖了。</p><p>不过它确实能喝出来，水蜜桃的风味，很神奇哦，不过我是在偏中低温情况喝出来的。高温的表现并不好，因为不好的味道突出太明显了。咖啡豆还真就和运气沾点边，我这批次的豆子应该属于不太理想。去除那些瑕疵风味，我想<code>果丁丁</code>一定非常好喝。</p><p>总体评价：耶加雪菲、些许木质、涩、烟熏焦炭、性价比一般。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王道数据结构链表习题</title>
      <link href="/posts/78005f2f1e1c/"/>
      <url>/posts/78005f2f1e1c/</url>
      
        <content type="html"><![CDATA[<h3 id="链表经典大题"><a href="#链表经典大题" class="headerlink" title="链表经典大题"></a>链表经典大题</h3><h4 id="递归删除不带头结点的单链表中所有值为-x-的结点"><a href="#递归删除不带头结点的单链表中所有值为-x-的结点" class="headerlink" title="递归删除不带头结点的单链表中所有值为 x 的结点"></a>递归删除不带头结点的单链表中所有值为 x 的结点</h4><p><img src="https://bu.dusays.com/2023/07/31/64c75c76e2b3a.png" alt="image-20230731150204492"></p><p>题目说了是 L 哦。但是我代码写得是 list。偷懒了。</p><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p>板子</p><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归删除不带头结点单链表中 x 的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del_x</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 出口</span><br><span class="hljs-keyword">if</span>(!list) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list -&gt; data == x)&#123;<br><span class="hljs-comment">// 如果当前递归中的结点是应该被删除的结点</span><br>LNode * p = list;<br>list = list -&gt; next; <span class="hljs-comment">// 指向下一个结点</span><br><span class="hljs-built_in">free</span>(p);<br><span class="hljs-comment">// 继续寻找</span><br><span class="hljs-built_in">Del_x</span>(list, x);<br><br><span class="hljs-comment">// 下面这三行代码是绝对不能写！！！死循环</span><br><span class="hljs-comment">// LNode * p = list -&gt; next;</span><br><span class="hljs-comment">// free(list);</span><br><span class="hljs-comment">// Del_x(p, x);</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是应该被删除的结点</span><br><span class="hljs-built_in">Del_x</span>(list -&gt; next, x);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="附赠无头结点的尾插法代码"><a href="#附赠无头结点的尾插法代码" class="headerlink" title="附赠无头结点的尾插法代码"></a>附赠无头结点的尾插法代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 无头结点尾插法建立单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TailInsert</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-built_in">InitList</span>(list);<br><br>LNode * r;<br><br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">9999</span>)&#123;<br>LNode * s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>s -&gt; data = x;<br>s -&gt; next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">// 是第一个结点</span><br><span class="hljs-keyword">if</span>(!list) list = s;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 平常的尾插</span><br>s -&gt; next = r -&gt; next;<br>r -&gt; next = s;<br>&#125;<br>r = s;<br>cin &gt;&gt; x;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除带头结点的单链表中所有值为-x-的结点"><a href="#删除带头结点的单链表中所有值为-x-的结点" class="headerlink" title="删除带头结点的单链表中所有值为 x 的结点"></a>删除带头结点的单链表中所有值为 x 的结点</h4><p><img src="https://bu.dusays.com/2023/07/31/64c76dedf2ece.png" alt="image-20230731161643650"></p><h5 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h5><p>板子</p><h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除带头结点单链表中 x 的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del_x</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br>LNode * pre = list, * cur = list -&gt; next;<br><br><span class="hljs-keyword">while</span>(cur)&#123;<br><span class="hljs-comment">// 当前结点是应该被删除的结点</span><br><span class="hljs-keyword">if</span>(cur -&gt; data == x)&#123;<br>LNode * q = cur;<br>cur = cur -&gt; next;<br>pre -&gt; next = cur;<br><span class="hljs-built_in">free</span>(q);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 当前结点不是应该被删除的结点</span><br>pre = cur;<br>cur = cur -&gt; next;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="从尾到头反向输出带头结点单链表中每个结点的值"><a href="#从尾到头反向输出带头结点单链表中每个结点的值" class="headerlink" title="从尾到头反向输出带头结点单链表中每个结点的值"></a>从尾到头反向输出带头结点单链表中每个结点的值</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb446b8fd07.png" alt="image-20230803135630640"></p><h5 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h5><p>利用栈的思想</p><h5 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 反向输出链表中每个结点的值</span><br><span class="hljs-comment">// 0.在 main 函数中，调用要注意！</span><br><span class="hljs-comment">// 1.Reverse_Print（list -&gt; next); 带头结点</span><br><span class="hljs-comment">// 2.Reverse_Print（list); 不带头结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reverse_Print</span><span class="hljs-params">(LinkList list)</span></span>&#123;<br><span class="hljs-comment">// 出口</span><br><span class="hljs-keyword">if</span>(!list) <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">// 入栈</span><br><span class="hljs-built_in">Reverse_Print</span>(list -&gt; next);<br><br><span class="hljs-comment">// 出栈</span><br>cout &lt;&lt; list -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除带头结点单链表中的唯一最小值"><a href="#删除带头结点单链表中的唯一最小值" class="headerlink" title="删除带头结点单链表中的唯一最小值"></a>删除带头结点单链表中的唯一最小值</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb4502a04bb.png" alt="image-20230803141117604"></p><h5 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>利用 <code>min_pre</code>、<code>cur</code> 两个指针</li><li>利用线性表寻找最小值算法思想</li><li><code>min_pre</code>用来更新保存，目前已知最小值结点的前一个结点</li></ol><h5 id="核心代码-3"><a href="#核心代码-3" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除单链表中唯一最小值结点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_Min</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 如果是空表或只有头节点</span><br><span class="hljs-keyword">if</span>(!list || !list -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 经典前后指针</span><br>LNode * pre = list, * cur = list -&gt; next;<br>    <span class="hljs-comment">// 保存最小值结点的前一个结点</span><br>LNode * min_pre = list;<br><br><span class="hljs-comment">// 假设最小值是第一个节点</span><br>LNode * t = cur;<br><span class="hljs-comment">// 打擂台</span><br><span class="hljs-keyword">while</span>(cur)&#123;<br><span class="hljs-comment">// 如果发现比最小值还要小的</span><br>         <span class="hljs-comment">// 打赢了，新的当 t</span><br><span class="hljs-keyword">if</span>(cur -&gt; data &lt; t -&gt; data)&#123;<br>t = cur;<br>             <span class="hljs-comment">// pre 作为 新的min_pre</span><br>min_pre = pre;<br>&#125;<br><span class="hljs-comment">// 俩指针后移</span><br>pre = cur;<br>cur = cur -&gt; next;<br>&#125;<br><br><span class="hljs-comment">// 删除擂主</span><br>min_pre -&gt; next = t -&gt; next;<br><span class="hljs-built_in">free</span>(t);<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="带头结点的单链表逆置"><a href="#带头结点的单链表逆置" class="headerlink" title="带头结点的单链表逆置"></a>带头结点的单链表逆置</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb637357a20.png" alt="image-20230803162110380"></p><h5 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h5><p>准备<code>pre</code>、<code>cur</code>、<code>r</code> 3个指针，<code>cur</code>指向<code>pre</code>。</p><h5 id="核心代码-4"><a href="#核心代码-4" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表就地逆置</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reverse_LinkList</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 空表或者只有头结点或者只有一个元素</span><br><span class="hljs-keyword">if</span>(!list || !list -&gt; next || !list -&gt; next -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>LNode * pre = list , * cur = list -&gt; next;<br>LNode * r = cur -&gt; next;<br><span class="hljs-comment">// NULL &lt;- cur &lt;- r</span><br>cur -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">while</span>(r)&#123;<br>pre = cur;<br>cur = r;<br>r = r -&gt; next;<br>cur -&gt; next = pre;<br>&#125;<br><br><span class="hljs-comment">// cur才是真正的主元素，r只是拿来判断的边界条件</span><br>list -&gt; next = cur;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单链表的插入排序"><a href="#单链表的插入排序" class="headerlink" title="单链表的插入排序"></a>单链表的插入排序</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32c0724c39.png" alt="image-20230809140236810"></p><h5 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h5><p><a href="/posts/f7271c1a5982/">跳转链接</a></p><h5 id="核心代码-5"><a href="#核心代码-5" class="headerlink" title="核心代码"></a>核心代码</h5><p><a href="/posts/f7271c1a5982/">跳转链接</a></p><h4 id="两个单链表的公共结点"><a href="#两个单链表的公共结点" class="headerlink" title="两个单链表的公共结点"></a>两个单链表的公共结点</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32d21a0968.png" alt="image-20230809140728686"></p><h5 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h5><p>假设有两个单链表<code>A</code>和<code>B</code>。</p><p>单链表<code>A</code>长度为：a</p><p>单链表<code>B</code>长度为：b</p><p>无非两种情况：<code>相交</code>和<code>不相交</code></p><p><img src="https://bu.dusays.com/2023/08/09/64d32ff3099be.png" alt="image-20230809141931085"></p><p>可以利用<code>a + c + b</code> ＝ <code>b + c + a</code>。求出交点。</p><p>这是<code>不相交</code>的情况。</p><p><img src="https://bu.dusays.com/2023/08/09/64d330de84da4.png" alt="image-20230809142327260"></p><p><code>a + b</code> ＝ <code>b + a</code>。</p><p>相遇为<code>NULL</code>，返回<code>NULL</code>。</p><p><code>公式恒成立</code>。</p><h5 id="核心代码-6"><a href="#核心代码-6" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LNode * <span class="hljs-title">findFirstCommonNode</span><span class="hljs-params">(LinkList headA, LinkList headB)</span> </span>&#123;<br>    LNode * p = headA , * q = headB;<br>    <br>    <span class="hljs-keyword">while</span>(p != q)&#123;<br>        p = p ? p -&gt; next : headB;<br>        q = q ? q -&gt; next : headA;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将原单链表A分裂为：奇A表和偶B表"><a href="#将原单链表A分裂为：奇A表和偶B表" class="headerlink" title="将原单链表A分裂为：奇A表和偶B表"></a>将原单链表A分裂为：<code>奇A表</code>和<code>偶B表</code></h4><p><img src="https://bu.dusays.com/2023/08/09/64d33587565fd.png" alt="image-20230809144319763"></p><h5 id="核心思想-7"><a href="#核心思想-7" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>奇偶序号计数<code>i</code>。</li><li><code>ra</code>和<code>rb</code>尾指针。</li><li>将<code>A</code>的<code>next</code>先<code>置空</code>，后面会通过<code>ra</code>来增加结点。</li><li>根据<code>i</code>的奇偶，在<code>ra</code>或者<code>rb</code>后面增加结点<code>p</code>，再更新<code>ra</code>或<code>rb</code>。</li><li><code>ra</code>和<code>rb</code>的<code>next</code>需要<code>置空</code>。</li></ol><h5 id="核心代码-7"><a href="#核心代码-7" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将原单链表A分裂为：`奇A表`和`偶B表`</span><br><span class="hljs-function">LinkList <span class="hljs-title">Re_Create</span><span class="hljs-params">(LinkList &amp; A)</span></span>&#123;<br><span class="hljs-comment">// 准备B表</span><br>LinkList B = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>B -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 准备工作</span><br>LNode * ra = A , * rb = B; <span class="hljs-comment">// A 和 B 的尾指针</span><br>LNode * p = A -&gt; next; <span class="hljs-comment">// 遍历准备工作</span><br><br><span class="hljs-comment">// A 表断开</span><br>A -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 奇偶序列计数</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p)&#123;<br>i++;<br><span class="hljs-comment">// 奇</span><br><span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span>)&#123;<br>ra -&gt; next = p;<br>ra = p;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 偶</span><br>rb -&gt; next = p;<br>rb = p;<br>&#125;<br>p = p -&gt; next;<br>&#125;<br><span class="hljs-comment">// 尾指针置空</span><br>ra -&gt; next = <span class="hljs-literal">NULL</span>;<br>rb -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> B;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="递增有序的单链表，去除相同的元素"><a href="#递增有序的单链表，去除相同的元素" class="headerlink" title="递增有序的单链表，去除相同的元素"></a>递增有序的单链表，去除相同的元素</h4><p><img src="https://bu.dusays.com/2023/08/09/64d33acd8d1ba.png" alt="image-20230809150548410"></p><h5 id="核心思想-8"><a href="#核心思想-8" class="headerlink" title="核心思想"></a>核心思想</h5><p><a href="448d550da686">跳转链接</a></p><h5 id="核心代码-8"><a href="#核心代码-8" class="headerlink" title="核心代码"></a>核心代码</h5><p><a href="448d550da686">跳转链接</a></p><h4 id="带头结点的循环双链表是否对称"><a href="#带头结点的循环双链表是否对称" class="headerlink" title="带头结点的循环双链表是否对称"></a>带头结点的循环双链表是否对称</h4><p><img src="https://bu.dusays.com/2023/08/09/64d33f2db78aa.png" alt="image-20230809152429784"></p><h5 id="核心思想-9"><a href="#核心思想-9" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>设置两个指针<code>p</code>和<code>q</code>。往两个不同的方向走</li><li>结点数是奇数和偶数，是难点。<code>2n + 1</code>和<code>2n</code>。</li></ol><h5 id="核心代码-9"><a href="#核心代码-9" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Symmetry</span><span class="hljs-params">(DLinkList list)</span></span>&#123;<br>    DNode * p = list -&gt; next , * q = list -&gt; prior;<br>    <span class="hljs-comment">// 第二个条件容易写成 p -&gt; next != q;</span><br>    <span class="hljs-keyword">while</span>(p != q &amp;&amp; q -&gt; next != p)&#123;<br>        <span class="hljs-keyword">if</span>(p -&gt; data == q -&gt; data)&#123;<br>            p = p -&gt; next;<br>            q = q -&gt; prior;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单链表判断是否有环"><a href="#单链表判断是否有环" class="headerlink" title="单链表判断是否有环"></a>单链表判断是否有环</h4><p><img src="https://bu.dusays.com/2023/08/09/64d34b2220fb7.png" alt="image-20230809161529567"></p><h5 id="核心思想-10"><a href="#核心思想-10" class="headerlink" title="核心思想"></a>核心思想</h5><ul><li>慢指针一步一步走，快指针两步两步走</li><li>无环：快指针必定会先到达终点（NULL）</li><li>有环：俩指针会相遇，相遇之后，让慢指针回到起点，再让快慢指针同步速度，一步一步走</li><li>当再次相遇的时候，那个点就是环的入口</li></ul><h5 id="核心代码-10"><a href="#核心代码-10" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">entryNodeOfLoop</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode * slow = head , * fast = head;<br><br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-comment">// 有环，相遇了</span><br>            <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果fast是空，那么代表无环，否则代表有环，并且slow == fast成立</span><br>        <span class="hljs-comment">// 而且，如果while循环条件一开始就没满足，那么代表head是空节点亦或者长度为1</span><br>        <span class="hljs-keyword">if</span>(!fast || !fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// slow == fast ， 有环</span><br>        <span class="hljs-comment">// 让slow回去，fast和slow以同样的速度走，再次相遇就是环的入口结点</span><br>        slow = head;<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            slow = slow -&gt; next;<br>            fast = fast -&gt; next;<br>        &#125;<br>        <span class="hljs-comment">// 再次相遇了</span><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br><br>作者：麦高芬<br>链接：https:<span class="hljs-comment">//www.acwing.com/solution/content/153752/</span><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="单链表倒数第-k-个值"><a href="#单链表倒数第-k-个值" class="headerlink" title="单链表倒数第 k 个值"></a>单链表倒数第 k 个值</h4><p><img src="https://bu.dusays.com/2023/08/09/64d34d9156593.png" alt="image-20230809162553225"></p><h5 id="核心思想-11"><a href="#核心思想-11" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>两个指针<code>p</code>和<code>q</code></li><li>先让它们两个相距<code>k</code></li><li>当<code>q</code>遍历完的时候，<code>p</code>就是倒数第<code>k</code>个节点</li></ol><h5 id="核心代码-11"><a href="#核心代码-11" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_K</span><span class="hljs-params">(LinkList list, <span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-comment">// 计数</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>LNode * p = list -&gt; next, * q = list -&gt; next;<br><br><span class="hljs-keyword">while</span>(q)&#123;<br><span class="hljs-comment">// 先让q走 k 步</span><br><span class="hljs-keyword">if</span>(count &lt; k)&#123;<br>count++;<br>q = q -&gt; next;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>p = p -&gt; next;<br>q = q -&gt; next;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 查找失败</span><br><span class="hljs-keyword">if</span>(count &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h4><p><img src="https://bu.dusays.com/2023/08/09/64d35190e4e8b.png" alt="image-20230809164257287"></p><h5 id="核心思想-12"><a href="#核心思想-12" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>先遍历一遍链表，获取链表的长度。</li><li>根据获取到的链表长度，获取链表中间的结点。(向上取整)</li><li>反转后半段链表。</li><li>合并前半段链表和反转后的后半段链表。</li></ol><h5 id="核心代码-12"><a href="#核心代码-12" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rearrangedList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head-&gt;next) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 获取链表的长度</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = head ; p ; p = p -&gt; next) len++;<br>    <br>        <span class="hljs-comment">// 链表中间的结点</span><br>        <span class="hljs-type">int</span> left = (len + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">auto</span> a = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; left - <span class="hljs-number">1</span> ; i++) a = a -&gt; next;<br>    <span class="hljs-comment">// 反转后半段链表，b在前，c在后  </span><br>        <span class="hljs-keyword">auto</span> b = a -&gt; next , c = b -&gt; next;<br>    <span class="hljs-comment">// a-&gt;next 是为了从中间将链表截断；b-&gt;next 是因为此时的 b 是反转后链表的结尾元素</span><br>        a -&gt; next = b -&gt; next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-keyword">while</span>(c)&#123;<br>            <span class="hljs-keyword">auto</span> p = c -&gt; next;<br>            c -&gt; next = b;<br>            b = c; c = p;<br>        &#125;<br>    <br>        <span class="hljs-comment">// 合并链表，注意此时 b 指向反转链表头部</span><br>        <span class="hljs-keyword">auto</span> p = head;<br>        <span class="hljs-keyword">auto</span> q = b;<br>        <span class="hljs-comment">// o -&gt; o -&gt; o -&gt; NULL (p)</span><br>        <span class="hljs-comment">// o -&gt; o -&gt; o -&gt; NULL (q)</span><br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            <span class="hljs-keyword">auto</span> o = q -&gt; next;<br>            q -&gt; next = p -&gt; next;<br>            p -&gt; next = q;<br>            p = q -&gt; next;<br>            q = o;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 王道数据结构习题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 王道数据结构习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝治光师肯尼亚圆豆手冲咖啡</title>
      <link href="/posts/bb95ebed2e97/"/>
      <url>/posts/bb95ebed2e97/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是治光师会员限购9.9包邮的，肯尼亚FCS合作社顶级圆豆批次，水洗处理的浅烘豆子。</p><p>9.9元30g，不妨让我来试试水。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/30/64c5986ae14d5.webp" alt="Screenshot_20230730_064146_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/07/30/64c5987b1a642.webp" alt="IMG_20230730_063602"></p><p><img src="https://bu.dusays.com/2023/07/31/64c74e7532b67.webp" alt="IMG_20230730_063624"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>一到货熟豆闻起来和之前买的<code>菠萝成子危地马拉瑰夏</code>味道差不多。先养养豆。</p><p>第一口下去是它的酸度和甜度，比较突出，酸度明显高于<code>治光师耶加雪菲</code>，最大的亮点是它真的<code>很甜</code>。喝完后回甘有很久很久，感觉喝了蜂蜜一样，不过对于我这种不太喜欢甜的咖啡的人来说，有点偏齁甜了。它的<code>热带水果风味</code>实在太足了，十分好喝，有轻微涩味，不过太能接受了！</p><p>总体评价：烟熏、涩、果酸和甜感突出、性价比高、推荐。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝治光师伊迪朵耶加雪菲手冲咖啡</title>
      <link href="/posts/32f6f1e29b78/"/>
      <url>/posts/32f6f1e29b78/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这款<code>治光师伊迪朵耶加雪菲</code>是群友推荐的，直接无脑买了。<br>写这篇文章，已经过了好些日子了，这是第二次喝的时候写的评价。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/13/64af5071a51a7.webp" alt="Screenshot_20230713_085908_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf456c60.webp" alt="IMG_20230723_064938"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf52e837.webp" alt="IMG_20230723_065210"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf44e11f.webp" alt="IMG_20230714_081733"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>首先，从豆子品控来看，是十分优秀的。</p><p>高温下，酸很<code>明亮</code>，基本无涩感，值得一提的是<code>茶感</code>很明显，有些许回甘，带<code>清香的甜</code>。</p><p>低温下，酸更加明显，有<code>SeeSaw 甜橙子</code>那味了。<code>茶感</code>更上一层楼。</p><p>目前喝过<code>最棒的耶加雪菲</code>。</p><p>缺点可能就是100g需要45元，喝几次就无了吧。真的，它就是优秀，挑不出什么刺。非要说的话，喝完后还是有些许烟熏感，不过能够接受。</p><p>不过我觉得这种价格配得上这种品质。</p><p>总体评价：浅烘、水果清香、茶感浓郁、性价比适中、推荐回购。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝菠萝成子危地马拉瑰夏手冲咖啡</title>
      <link href="/posts/fcab5f014e92/"/>
      <url>/posts/fcab5f014e92/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>瑰夏！瑰夏！瑰夏！</p><p>啊，我终于也能喝上瑰夏了，不过这款瑰夏不是出自<code>巴拿马的翡翠庄园</code>的瑰夏。</p><p>而是出自<code>危地马拉的庄园</code>。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/22/64bb06f93ff84.jpg" alt="Screenshot_20230722_062419_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/07/22/64bb0705f2398.jpg" alt="IMG_20230713_190844"></p><p><img src="https://bu.dusays.com/2023/07/22/64bb070c95363.jpg" alt="IMG_20230713_200015"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>根据<code>菠萝成子</code>介绍，入手了这款瑰夏，他说这款瑰夏一定是真的瑰夏。</p><p>这款瑰夏是中烘的，开包后香味给我的感觉是没有之前的豆子香，我层怀疑是不是豆子不新鲜了，密封罐好像很容易就打开了，是否起到了密封效果？嚼了两粒，确定一下，是<code>大麦茶</code>的味道，香香脆脆的。</p><p><code>瑰夏</code>为什么是瑰夏呢？不仅是指品种，还有风味。</p><p>即使是中烘，苦味一点儿也不明显，突出的更多是水果风味，属于那种真的很清香的，带草莓的酸的感觉，有焦糖味，有一点红茶茶感，喝完后给我的感觉是很均衡，<code>为什么感觉刚刚喝的是水？</code>。喝完后，还是能够感觉到明显的烘焙味，喉咙还是有点不太舒服，也许这也就是之前口嚼大麦茶味的缘由吧。</p><p>真的！这尼玛就是水吧，尝试了各种不同的水粉比，果然是水…</p><p>和闻起来一样，喝起来也是如此清淡，好喝倒是一言难尽，不过我不喜欢那种喝完后那种喉咙被烟熏的感觉。</p><p>总体评价：中烘、清淡、烟熏、性价比低。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王道数据结构算法设计大题汇总</title>
      <link href="/posts/ba547e211266/"/>
      <url>/posts/ba547e211266/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-线性表"><a href="#第一章-线性表" class="headerlink" title="第一章 线性表"></a>第一章 线性表</h3><ol><li><a href="/posts/f57f98d1b5f4">顺序表</a></li><li><a href="/posts/78005f2f1e1c">链表</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 置顶汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 置顶汇总 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王道数据结构顺序表习题</title>
      <link href="/posts/f57f98d1b5f4/"/>
      <url>/posts/f57f98d1b5f4/</url>
      
        <content type="html"><![CDATA[<h3 id="顺序表经典大题"><a href="#顺序表经典大题" class="headerlink" title="顺序表经典大题"></a>顺序表经典大题</h3><h4 id="删除顺序表中的最小值"><a href="#删除顺序表中的最小值" class="headerlink" title="删除顺序表中的最小值"></a>删除顺序表中的最小值</h4><p><img src="https://bu.dusays.com/2023/07/18/64b6140d7eb70.png" alt="image-20230718122418457"></p><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p>遍历表，查找最小值，并记住位置 </p><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_Min</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> &amp; value)</span></span>&#123;<br><span class="hljs-comment">// 表空</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 假定最小值是第1个元素</span><br>value = list.data[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 遍历表，尝试找到更小的元素（从第2个元素开始找起）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; list.length; i++)&#123;<br><span class="hljs-keyword">if</span>(list.data[i] &lt; value)&#123;<br>value = list.data[i];<br>pos = i;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 题目要求：空出的位置由最后一个元素顶替</span><br>list.data[pos] = list.data[list.length - <span class="hljs-number">1</span>];<br><br>list.length--; <span class="hljs-comment">// 这一步是最最最容易忘记的！！！</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="逆置顺序表"><a href="#逆置顺序表" class="headerlink" title="逆置顺序表"></a>逆置顺序表</h4><p><img src="https://bu.dusays.com/2023/07/18/64b619073eeab.png" alt="image-20230718124559870"></p><h5 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h5><p>算法板子…</p><h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 输入非法</span><br>    <span class="hljs-keyword">if</span>(from &gt;= to) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 向上取整</span><br><span class="hljs-type">int</span> mid = (to - from + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mid; i++)&#123;<br><span class="hljs-type">int</span> temp = list.data[from + i];<br>list.data[from + i] = list.data[to - i];<br>list.data[to - i] = temp;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表批量删除指定值-x-元素"><a href="#顺序表批量删除指定值-x-元素" class="headerlink" title="顺序表批量删除指定值 x 元素"></a>顺序表批量删除指定值 x 元素</h4><p><img src="https://bu.dusays.com/2023/07/18/64b61b50f028c.png" alt="image-20230718125544632"></p><h5 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h5><p>利用变量<code>k</code>，从0开始，遍历表，只保留<code>非 x</code> 元素</p><h5 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_x</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-keyword">if</span>(list.data[i] != x)<br>list.data[k++] = list.data[i];<br><br><span class="hljs-comment">// k 才是有效表长</span><br>list.length = k;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表在某条件下的批量删除"><a href="#顺序表在某条件下的批量删除" class="headerlink" title="顺序表在某条件下的批量删除"></a>顺序表在某条件下的批量删除</h4><p><img src="https://bu.dusays.com/2023/07/18/64b626805f0ac.png" alt="image-20230718134328974"></p><h5 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h5><p>算法板子…</p><p><img src="https://bu.dusays.com/2023/07/18/64b629de5c63b.png" alt="image-20230718135751532"></p><h5 id="核心代码-3"><a href="#核心代码-3" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_range</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 题目要求，非法输入判定</span><br><span class="hljs-keyword">if</span>(s &gt;= t) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(i &lt; list.length)&#123;<br><span class="hljs-comment">// 值在[s,t]这个范围内 k++</span><br><span class="hljs-keyword">if</span>(list.data[i] &gt;= s &amp;&amp; list.data[i] &lt;= t) k++;<br><span class="hljs-keyword">else</span> list.data[i - k] = list.data[i]; <span class="hljs-comment">// 不在这个范围则直接位移</span><br>i++;<br>&#125;<br><br><span class="hljs-comment">// 更新表长，删除了 k 个</span><br>list.length -= k;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除顺序表中重复元素"><a href="#删除顺序表中重复元素" class="headerlink" title="删除顺序表中重复元素"></a>删除顺序表中重复元素</h4><p><img src="https://bu.dusays.com/2023/07/18/64b62c656f8fc.png" alt="image-20230718140838298"></p><h5 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h5><p>经典的双指针算法。</p><h5 id="核心代码-4"><a href="#核心代码-4" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_repeat</span><span class="hljs-params">(SqList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">int</span> i,j;<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; j &lt; list.length; j++)<br><span class="hljs-comment">// 出现不同元素</span><br><span class="hljs-keyword">if</span>(list.data[i] != list.data[j])<br><span class="hljs-comment">// 前移 不能写 i++ 必须要写 ++i ！！！！</span><br>             <span class="hljs-comment">// 不同的元素要放在 i 的下一个位置(保证)</span><br>list.data[++i] = list.data[j];<br><br><br>list.length = i + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线性表的-AB-gt-BA-问题"><a href="#线性表的-AB-gt-BA-问题" class="headerlink" title="线性表的 AB =&gt; BA 问题"></a>线性表的 AB =&gt; BA 问题</h4><p><img src="https://bu.dusays.com/2023/07/18/64b631f37d5fe.png" alt="image-20230718143153144"></p><h5 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h5><p><img src="https://bu.dusays.com/2023/07/18/64b6372246520.png" alt="image-20230718145427110"></p><h5 id="核心代码-5"><a href="#核心代码-5" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 输入非法</span><br><span class="hljs-keyword">if</span>(from &gt;= to) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 向上取整</span><br><span class="hljs-type">int</span> mid = (to - from + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mid; i++)&#123;<br><span class="hljs-type">int</span> temp = list.data[from + i];<br>list.data[from + i] = list.data[to - i];<br>list.data[to - i] = temp;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Converse</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-built_in">Reverse</span>(list, <span class="hljs-number">0</span>, m + n - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">Reverse</span>(list, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">Reverse</span>(list, n, m + n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表的二分查找"><a href="#顺序表的二分查找" class="headerlink" title="顺序表的二分查找"></a>顺序表的二分查找</h4><p><img src="https://bu.dusays.com/2023/07/18/64b6380c82626.png" alt="image-20230718145821268"></p><h5 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h5><p>使用<code>折半查找</code>。</p><h5 id="核心代码-6"><a href="#核心代码-6" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SearchExchangeInsert</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 二分</span><br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = list.length - <span class="hljs-number">1</span>, mid;<br><br><span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br><span class="hljs-comment">// 防溢出</span><br>mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span>(list.data[mid] == x) <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list.data[mid] &lt; x) left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 找到了，与它后面那个元素进行交换（要有的话）</span><br><span class="hljs-keyword">if</span>(list.data[mid] == x &amp;&amp; mid != list.length - <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">swap</span>(list.data[mid],list.data[mid + <span class="hljs-number">1</span>]); <span class="hljs-comment">// 偷懒了</span><br>&#125;<br><br><span class="hljs-comment">// 没找到</span><br><span class="hljs-keyword">if</span>(left &gt; right)&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i = list.length - <span class="hljs-number">1</span>; i &gt; right; i--)&#123;<br>list.data[i + <span class="hljs-number">1</span>] = list.data[i];<br>&#125;<br>list.data[i + <span class="hljs-number">1</span>] = x;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表的主元（摩尔投票法）"><a href="#顺序表的主元（摩尔投票法）" class="headerlink" title="顺序表的主元（摩尔投票法）"></a>顺序表的主元（摩尔投票法）</h4><p>题目太长了，就不给了。</p><p>大概意思是<code>主元的数量大于总数量的一半</code></p><h5 id="核心思想-7"><a href="#核心思想-7" class="headerlink" title="核心思想"></a>核心思想</h5><p>算法板子…</p><h5 id="核心代码-7"><a href="#核心代码-7" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(SqList list)</span></span>&#123;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> val;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++)&#123;<br><span class="hljs-keyword">if</span>(!cnt) val = list.data[i], cnt++;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val == list.data[i]) cnt++;<br><span class="hljs-keyword">else</span> cnt--;<br>&#125;<br><br><span class="hljs-comment">// 如果有主元。统计出主元实际出现次数</span><br><span class="hljs-keyword">if</span>(cnt &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = cnt = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-keyword">if</span>(list.data[i] == val) cnt++;<br>&#125;<br><br><span class="hljs-comment">// 主元超过总元素长度的一半</span><br><span class="hljs-keyword">if</span>(cnt &gt; list.length / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> val;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 不存在主元</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表中未出现的最小正整数"><a href="#顺序表中未出现的最小正整数" class="headerlink" title="顺序表中未出现的最小正整数"></a>顺序表中未出现的最小正整数</h4><p><img src="https://bu.dusays.com/2023/07/18/64b64e770a249.png" alt="image-20230718163359493"></p><h5 id="核心思想-8"><a href="#核心思想-8" class="headerlink" title="核心思想"></a>核心思想</h5><p>桶计数</p><h5 id="核心代码-8"><a href="#核心代码-8" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindMissMin</span><span class="hljs-params">(SqList list)</span></span>&#123;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-type">int</span> * B; <span class="hljs-comment">// 桶</span><br>B = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * list.length);<br><span class="hljs-built_in">memset</span>(B, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * list.length); <span class="hljs-comment">// 赋初始值为0</span><br><br><span class="hljs-comment">// 计数</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-comment">// 合法的范围</span><br><span class="hljs-keyword">if</span>(list.data[i] &gt; <span class="hljs-number">0</span> &amp;&amp; list.data[i] &lt;= list.length)<br>B[list.data[i] - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记出现过</span><br><span class="hljs-comment">// 从桶里面找最小整数</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-keyword">if</span>(!B[i]) <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 王道数据结构习题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 王道数据结构习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝手冲咖啡汇总</title>
      <link href="/posts/7da784530acd/"/>
      <url>/posts/7da784530acd/</url>
      
        <content type="html"><![CDATA[<h3 id="浅尝手冲咖啡汇总"><a href="#浅尝手冲咖啡汇总" class="headerlink" title="浅尝手冲咖啡汇总"></a>浅尝手冲咖啡汇总</h3><ol><li><a href="/posts/8635f45e7775">SeeSaw 甜橙子</a></li><li><a href="/posts/cb40af96710f">八平方 晴天娃娃</a></li><li><a href="/posts/c19e2a8a5f1a">辛鹿 SOE 耶加雪菲</a></li><li><a href="/posts/fcab5f014e92">菠萝成子 危地马拉 瑰夏</a></li><li><a href="/posts/32f6f1e29b78">治光师 伊迪朵 耶加雪菲</a></li><li><a href="/posts/bb95ebed2e97">治光师 肯尼亚圆豆</a></li><li><a href="/posts/9c71bc76a9ad">四人咖啡 果丁丁</a></li><li><a href="/posts/0e42f4daeb32">治光师 野草莓意式拼配咖啡</a></li><li><a href="/posts/b8bb6e256940">四人咖啡 粉红佳人</a></li><li><a href="/posts/9d745f9baaa9">辛鹿 号码系列</a></li><li><a href="/posts/89001a5236dd">治光师 沃卡74110 耶加雪菲</a></li></ol><div class="tip home"><p>最近很忙，暂时停更…</p></div>]]></content>
      
      
      <categories>
          
          <category> 置顶汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 置顶汇总 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环链表</title>
      <link href="/posts/ac441d04cb46/"/>
      <url>/posts/ac441d04cb46/</url>
      
        <content type="html"><![CDATA[<h3 id="循环链表前言"><a href="#循环链表前言" class="headerlink" title="循环链表前言"></a>循环链表前言</h3><p>之前写了，<code>双链表</code>和<code>单链表</code>的代码模板，基于此结构的循环链表代码具体实现想偷懒了，主要是因为我觉得考的可能性不大。</p><h3 id="循环单链表的类型描述"><a href="#循环单链表的类型描述" class="headerlink" title="循环单链表的类型描述"></a>循环单链表的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;    <span class="hljs-comment">//定义循环链表结点类型</span><br><span class="hljs-type">int</span> data;            <span class="hljs-comment">//数据域</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> * next;  <span class="hljs-comment">//指针域</span><br>&#125;LNode, * LinkList;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br>    <span class="hljs-comment">// 头结点初始化</span><br>    list = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LinkList));<br>    list -&gt; next = list; <span class="hljs-comment">// 指向自己</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//判空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">(LinkList list)</span></span>&#123;<br>    <span class="hljs-comment">// 如果头结点的下一个结点，依旧是头结点，那么说明是空表</span><br>    <span class="hljs-keyword">if</span>(list -&gt; next == list) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断表尾节点"><a href="#判断表尾节点" class="headerlink" title="判断表尾节点"></a>判断表尾节点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//判断结点p是否是表尾结点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTail</span><span class="hljs-params">(LinkList list, LNode * p)</span></span>&#123;<br>    <span class="hljs-comment">// 如果是表尾节点，它的next一定指向头结点</span><br>    <span class="hljs-keyword">if</span>(p -&gt; next == list) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>循环单链表的插入、删除算法与单链表几乎一样，不同的是如果在表尾进行，那么要让单链表继续<strong>保持循环的性质</strong>，即<strong>让尾结点的next域指向头结点</strong>。</p><h3 id="循环双链表的类型描述"><a href="#循环双链表的类型描述" class="headerlink" title="循环双链表的类型描述"></a>循环双链表的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DNode</span>&#123;<br>    <span class="hljs-type">int</span> data;  <span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DNode</span> * prior, * next;  <span class="hljs-comment">//前驱和后继指针</span><br>&#125;DNode, * DLinkList;<br></code></pre></td></tr></table></figure><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(DLinkList &amp; list)</span></span>&#123;<br>    list = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>    list -&gt; prior = list;<br>    list -&gt; next = list;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判空-1"><a href="#判空-1" class="headerlink" title="判空"></a>判空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//判空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">(DLinkList list)</span></span>&#123;<br>    <span class="hljs-comment">// 如果头结点的下一个结点，依旧是头结点，那么说明是空表</span><br>    <span class="hljs-keyword">if</span>(list -&gt; next == list) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断表尾节点-1"><a href="#判断表尾节点-1" class="headerlink" title="判断表尾节点"></a>判断表尾节点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//判断结点p是否是表尾结点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTail</span><span class="hljs-params">(DLinkList list, LNode * p)</span></span>&#123;<br>    <span class="hljs-comment">// 如果是表尾节点，它的next一定指向头结点</span><br>    <span class="hljs-keyword">if</span>(p -&gt; next == list) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入和删除-1"><a href="#插入和删除-1" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>循环双链表的插入、删除算法与双链表几乎一样，不同的是如果在表尾进行，那么要让双链表继续<strong>保持循环的性质</strong>，即<strong>让尾结点的next域指向头结点，同时让头结点的prior域指向尾结点</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 考研笔试自用算法大题模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研笔试自用模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双链表</title>
      <link href="/posts/ff21019310ee/"/>
      <url>/posts/ff21019310ee/</url>
      
        <content type="html"><![CDATA[<h3 id="双链表的实现方式"><a href="#双链表的实现方式" class="headerlink" title="双链表的实现方式"></a>双链表的实现方式</h3><p>实现方式：<code>不带头结点</code>和<code>带头结点</code>。</p><p>同理，使用<code>带头结点</code>的策略。</p><wavy>个人认为，双链表考算法大题可能性不大，但是以防万一还是写一个模板</wavy><p>双链表的重难点应该是<code>边界判断</code>，比如它的<code>指定位置插入元素</code>、<code>指定位置删除元素</code>。</p><h3 id="双链表的类型描述"><a href="#双链表的类型描述" class="headerlink" title="双链表的类型描述"></a>双链表的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DNode</span>&#123;<br><span class="hljs-type">int</span> data;<span class="hljs-comment">// 数据域</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DNode</span> * prior,* next;<span class="hljs-comment">// 前驱和后继指针</span><br>&#125;DNode, * DLinkList;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(DLinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 给头结点分配内存</span><br>list = (DNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(DNode));<br><br><span class="hljs-comment">// 张开双手的双链表的空表状态</span><br>list -&gt; prior = <span class="hljs-literal">NULL</span>;<br>list -&gt; next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 空表判断</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">(DLinkList list)</span></span>&#123;<br><span class="hljs-comment">// 如果头结点指向的下一个结点是NULL</span><br><span class="hljs-keyword">if</span>(!list -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后插操作"><a href="#后插操作" class="headerlink" title="后插操作"></a>后插操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将元素x后插到节点p</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InsertNextNode</span><span class="hljs-params">(DNode * p, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 不能插入到NULL后面</span><br><span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 创建元素x的载体，并且初始化</span><br>DNode * s = (DNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(DNode));<br>s -&gt; data = x;<br><br><span class="hljs-comment">// 双链表最后一个节点插入比较特殊，因此需要特判</span><br><span class="hljs-comment">// 只有当不是双链表最后一个节点才操作 p -&gt; next -&gt; prior</span><br><span class="hljs-keyword">if</span>(p -&gt; next) p -&gt; next -&gt; prior = s;<br>s -&gt; next = p -&gt; next;<br>p -&gt; next = s;<br>s -&gt; prior = p;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 尾插法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TailInsert</span><span class="hljs-params">(DLinkList &amp; list)</span></span>&#123;<br><span class="hljs-built_in">InitList</span>(list);<br><br><span class="hljs-comment">// 记录尾指针（一开始是指向头结点）</span><br>DNode * r = list;<br><br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">9999</span>)&#123;<br><span class="hljs-comment">// 1.创建新节点</span><br>DNode * p = (DNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(DNode));<br>p -&gt; data = x;<br><span class="hljs-comment">// 2.插入</span><br>p -&gt; next = r -&gt; next;<br>r -&gt; next = p;<br>p -&gt; prior = r;<br><span class="hljs-comment">// 3.更新尾指针</span><br>r = p;<br>cin &gt;&gt; x;<br>&#125;<br><br><span class="hljs-comment">// 尾指针置空</span><br>r -&gt; next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 按位查找</span><br><span class="hljs-function">DNode * <span class="hljs-title">GetElem</span><span class="hljs-params">(DLinkList list, <span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">// 如果是第0个位置返回头结点</span><br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> list;<br><span class="hljs-comment">// 非法输入</span><br><span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 从第一个节点开始计数（可能为空）</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>DNode * p = list -&gt; next;<br><br><span class="hljs-comment">// 查找（不为空，且小于要找到的位序）</span><br><span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i)&#123;<br>p = p -&gt; next;<br>j++;<br>&#125;<br><span class="hljs-comment">// 如果没那么长，也会返回p，此时p为NULL</span><br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在指定位置插入元素"><a href="#在指定位置插入元素" class="headerlink" title="在指定位置插入元素"></a>在指定位置插入元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在第 i 个位置，插入元素 x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(DLinkList &amp; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 找到第 i - 1 个节点执行后插操作</span><br>DNode * p = <span class="hljs-built_in">GetElem</span>(list, i - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">InsertNextNode</span>(p, x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在指定位置删除元素"><a href="#在指定位置删除元素" class="headerlink" title="在指定位置删除元素"></a>在指定位置删除元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除第 i 个位置的元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(DLinkList &amp; list, <span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">// 删除位置是否合法</span><br><span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; <span class="hljs-built_in">Length</span>(list))&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;delete failed: index is wrong.&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 找到第 i - 1 个元素</span><br>DNode * p = <span class="hljs-built_in">GetElem</span>(list, i - <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 被删除的元素</span><br>DNode * q = p -&gt; next;<br><br><span class="hljs-comment">// 警惕！如果删除的是最后一个节点，那么需要特判</span><br><span class="hljs-comment">// 只有删除的不是最后一个节点</span><br><span class="hljs-keyword">if</span>(q -&gt; next)&#123;<br>q -&gt; next -&gt; prior = p;<br>&#125;<br>p -&gt; next = q -&gt; next;<br><span class="hljs-built_in">free</span>(q);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考研笔试自用算法大题模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研笔试自用算法大题模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝辛鹿SOE耶加雪菲手冲咖啡</title>
      <link href="/posts/c19e2a8a5f1a/"/>
      <url>/posts/c19e2a8a5f1a/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不同品牌的不同耶加雪菲差别是不是很大呢？性价比之王的<code>辛鹿</code>和其它品牌的耶加雪菲差别是不是巨大呢？</p><p>这篇是<code>辛鹿SOE耶加雪菲</code>的评测，这篇只写主观评价，作为以后我是否会回购的依据。</p><p>其它品牌，这里选择了口碑不错的<code>治光师</code>。</p><p><img src="https://bu.dusays.com/2023/07/13/64af5071a51a7.webp" alt="Screenshot_20230713_085908_com.taobao.taobao"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/13/64af50880a611.webp" alt="IMG_20230713_081516"></p><p><img src="https://bu.dusays.com/2023/07/13/64af5091cfebd.webp" alt="IMG_20230713_081713"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p><code>辛鹿耶加雪菲</code>喝起来让我十分不舒服，回味充满了烟熏味，不久这种感觉就能占领你的口腔，令我喉咙十分不舒服。</p><p>有水果风味，但还能感觉到明显涩味和木质感。入口前半段表现还是不错的，但是后半段表现糟糕。不过放冷之后，整体变得比一开始好喝多了。</p><p>个人不喜欢这款<code>辛鹿耶加雪菲</code>，但是考虑到日常提神需求，以及它的价格，会否回购可以进行考虑。</p><div class="tip home"><p>2023年9月27日更新</p></div><p>豆子放置了一个来月，此时表现为，中高温柑橘茶感风味，低温的各种不好的表现出现，其中最主要是木质和涩味。<br>此时我使用的是三段冲法。这个时期我给的评价是：趁热喝还行，埃塞风味，放冷了就是渣。中高温的性价比是极高的。</p><p>总体评价：浅中烘焙、烟熏、木质、涩、性价比高。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝八平方晴天娃娃手冲咖啡</title>
      <link href="/posts/cb40af96710f/"/>
      <url>/posts/cb40af96710f/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是我的第二篇关于咖啡的主观评测。</p><p>这篇文章的意义主要是作为以后我是否会回购的依据。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/09/64aa52eceb0b8.webp" alt="IMG_20230709_135823"></p><p><img src="https://bu.dusays.com/2023/07/09/64aa52f922f15.webp" alt="IMG_20230709_140302"></p><p><img src="https://bu.dusays.com/2023/07/09/64aa53037427f.webp" alt="IMG_20230709_140331"></p><p><img src="https://bu.dusays.com/2023/07/09/64aa530a5b14d.webp" alt="IMG_20230709_140918"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>这次一打开包装，猛吸一口，瞬间是很舒服的咖啡香味，随后带给我的感觉有点刺鼻（吸得太猛了），还有除咖啡豆味其它的味道，是独特的香味。</p><p><code>八平方晴天娃娃</code>的处理法是<code>厌氧日晒</code>处理，第一次喝厌氧日晒处理法的手冲咖啡。</p><p><code>八平方晴天娃娃</code>相比<code>SeeSaw甜橙子</code>，它的酸味并没有那么突出，酸味和苦味是比较均衡的。让我感觉：<code>哦，这款咖啡一定是浅烘的</code>。能明显感受到甜味，不愧是厌氧处理的。</p><p><code>八平方晴天娃娃</code>的缺点也很明显（瑕疵豆有点多，希望是我倒霉吧），喝下去我能明显感受到它的<code>木质感</code>，<code>烟熏味</code>，<code>涩味</code>。因为个人不是很喜欢<code>烟熏味</code>太重的咖啡。</p><p>这次应该翻车了吧，豆子品控不太好，瑕疵豆很影响口感。<code>倘若筛掉瑕疵豆，应该会很好喝</code>。</p><p>总体评价：浅烘、酸质均衡、水果风味、烟熏、性价比低，不推荐。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表</title>
      <link href="/posts/634af820198d/"/>
      <url>/posts/634af820198d/</url>
      
        <content type="html"><![CDATA[<h3 id="单链表的实现方式"><a href="#单链表的实现方式" class="headerlink" title="单链表的实现方式"></a>单链表的实现方式</h3><p>实现方式：<code>不带头结点</code>和<code>带头结点</code></p><p>为了写代码方便，使用<code>带头结点</code>的策略作为我的算法模板</p><h3 id="单链表的类型描述"><a href="#单链表的类型描述" class="headerlink" title="单链表的类型描述"></a>单链表的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> * next;<br>&#125;LNode, * LinkList;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 1. 给头结点分配内存</span><br>list = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br><span class="hljs-comment">// 2. 头结点指向的下一个结点地址为NULL</span><br>list -&gt; next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">(LinkList list)</span></span>&#123;<br><span class="hljs-comment">// 如果头结点下一个结点指向NULL，则为空</span><br><span class="hljs-keyword">if</span>(!list -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后插操作"><a href="#后插操作" class="headerlink" title="后插操作"></a>后插操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在p结点之后插入元素e</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InsertNextNode</span><span class="hljs-params">(LNode * p, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-comment">// 1.不能在NULL后面插入元素</span><br><span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 2.创建新节点承载元素e</span><br>LNode * s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>s -&gt; data = e;<br><span class="hljs-comment">// 3.后插</span><br>s -&gt; next = p -&gt; next;<br>p -&gt; next = s;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="头插法建立单链表"><a href="#头插法建立单链表" class="headerlink" title="头插法建立单链表"></a>头插法建立单链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeadInsert</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 初始化单链表</span><br><span class="hljs-built_in">InitList</span>(list);<br><span class="hljs-comment">// 批量插入</span><br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">9999</span>)&#123;<br><span class="hljs-built_in">InsertNextNode</span>(list, x);<br>cin &gt;&gt; x;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="尾插法建立单链表"><a href="#尾插法建立单链表" class="headerlink" title="尾插法建立单链表"></a>尾插法建立单链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 尾插法建立单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TailInsert</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 初始化单链表</span><br><span class="hljs-built_in">InitList</span>(list);<br><span class="hljs-comment">// 需要一个尾指针指向当前单链表的最后一个有效节点</span><br>LNode * r = list; <span class="hljs-comment">// 最初是头结点</span><br><span class="hljs-comment">// 批量输入</span><br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">9999</span>)&#123;<br>LNode * s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>s -&gt; data = x;<br><span class="hljs-comment">// 在尾指针指向的节点后面插入新元素</span><br>s -&gt; next = r -&gt; next;<br>r -&gt; next = s;<br>r = s; <span class="hljs-comment">// 更新尾指针</span><br>cin &gt;&gt; x;<br>&#125;<br><span class="hljs-comment">// 非常重要！！！！</span><br>r -&gt; next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 尾指针指向的节点的next置空</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 按位查找</span><br><span class="hljs-function">LNode * <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList list, <span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">// 1. 位置判断(0:取出头结点)</span><br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> list;<br><span class="hljs-comment">// 无效非法的位置i</span><br><span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 2. 查找</span><br><span class="hljs-comment">// 计数器</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 第一个元素（可能为空）</span><br>LNode * p = list -&gt; next;<br><br><span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i)&#123; <span class="hljs-comment">// 循环次数为：相距 i - 1 次(从第1位置找到第4位置需要移动3个单位）</span><br>j++;<br>p = p -&gt; next;<br>&#125;<br><br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将x插入到单链表list的第i个位置上</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 插入操作需要先找到第 i - 1 个位置的节点，再插入</span><br>LNode * p = <span class="hljs-built_in">GetElem</span>(list,i<span class="hljs-number">-1</span>);<br><span class="hljs-comment">// 在 p 节点后面插入元素x</span><br><span class="hljs-built_in">InsertNextNode</span>(p, x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将单链表中的第i个结点删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i &gt; <span class="hljs-built_in">Length</span>(list))&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;delete failed: index is wrong.&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 找到第 i - 1 个节点</span><br>LNode * p = <span class="hljs-built_in">GetElem</span>(list,i<span class="hljs-number">-1</span>);<br><span class="hljs-comment">// 删除</span><br>LNode * q = p-&gt;next;<br>p-&gt;next = q-&gt;next;<br><span class="hljs-built_in">free</span>(q);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="另外：前插操作"><a href="#另外：前插操作" class="headerlink" title="另外：前插操作"></a>另外：前插操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前插操作：在p结点之前插入元素e</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InsertPriorNode</span><span class="hljs-params">(LNode * p, <span class="hljs-type">int</span> e)</span></span>&#123;<br>    <span class="hljs-comment">// 不能在NULL之前插入元素</span><br>    <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 前插</span><br>    <span class="hljs-comment">// 创建新节点，在p节点后插</span><br>    LNode * s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next = s;<br>    <span class="hljs-comment">// p给s，e给p</span><br>    s-&gt;data = p-&gt;data;<br>    p-&gt;data = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考研笔试自用算法大题模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研笔试自用算法大题模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表</title>
      <link href="/posts/b854574263bd/"/>
      <url>/posts/b854574263bd/</url>
      
        <content type="html"><![CDATA[<h3 id="顺序表的实现方式"><a href="#顺序表的实现方式" class="headerlink" title="顺序表的实现方式"></a>顺序表的实现方式</h3><p>实现方式：<code>静态分配</code>和<code>动态分配</code></p><wavy>根据观察，包括王道书上的算法设计题，绝大部分使用的是静态分配的顺序表，因此我使用同样的策略作为我的算法模板</wavy><h3 id="顺序表的类型描述"><a href="#顺序表的类型描述" class="headerlink" title="顺序表的类型描述"></a>顺序表的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50; <span class="hljs-comment">//定义最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> data[MaxSize];       <span class="hljs-comment">//“静态”的数组存数据，存int数据</span><br>    <span class="hljs-type">int</span> length;              <span class="hljs-comment">//顺序表的当前长度</span><br>&#125;SqList;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化顺序表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 1.将表中所有元素赋值为0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++)&#123;<br>list.data[i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 2.将表的当前长度赋值为0</span><br>list.length = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在顺序表的第i个(位序)上插入值e</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-comment">// 1.判断插入位置合法性</span><br><span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; list.length + <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 2.判断表是否已经满了</span><br><span class="hljs-keyword">if</span>(list.length &gt;= MaxSize)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 3.合法插入</span><br><span class="hljs-comment">// 3.1 由于传入的是位序，因此插入时是在下标为 i - 1 的地方插入元素</span><br><span class="hljs-comment">// 3.2 将未插入前的表中，从 i - 1 开始，所有元素后移，给新元素腾出位置</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = list.length; j &gt;=i; j--)&#123;<br>list.data[j] = list.data[j - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">// 3.3 此时 i - 1 位置是空的，可以直接插入了</span><br>list.data[i - <span class="hljs-number">1</span>] = e;<br><span class="hljs-comment">// 插入成功，表长+1</span><br>list.length++;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除顺序表中第i个元素并返回其元素值e</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp; e)</span></span>&#123;<br><span class="hljs-comment">// 1.判断删除位置合法性，同时可以判断掉空表可能性</span><br><span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; list.length)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 2.记录删除元素</span><br>e = list.data[i - <span class="hljs-number">1</span>];<br><span class="hljs-comment">// 3.覆盖</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; list.length; j++)&#123;<br>list.data[j - <span class="hljs-number">1</span>] = list.data[j];<br>&#125;<br><span class="hljs-comment">// 4.删除成功</span><br>list.length--;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 按位查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList list, <span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-keyword">return</span> list.data[i - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 按值查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList list, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-comment">// 1.遍历全表，找到该元素为止</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++)&#123;<br><span class="hljs-keyword">if</span>(list.data[i] == e)<br><span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<span class="hljs-comment">// 返回的注意是位序哦！！！！</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 查找失败！</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考研笔试自用算法大题模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研笔试自用算法大题模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝SeeSaw甜橙子手冲咖啡</title>
      <link href="/posts/8635f45e7775/"/>
      <url>/posts/8635f45e7775/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>毕业季，最近比较忙，总算回家了。手冲器具都在家里，在学校搞不了手冲咖啡。</p><p>所以一回来，我就马上就买了两款咖啡豆，看咖啡评测似乎不错，但是自己不试试是不知道的。</p><p>这篇是<code>SeeSaw甜橙子</code>的评测，这篇只写主观评价，作为以后我是否会回购的依据。</p><p><img src="https://bu.dusays.com/2023/06/27/649a8529c469f.webp" alt="Screenshot_20230627_134637_com.taobao.taobao_edit"></p><p><img src="https://bu.dusays.com/2023/06/27/649a855845dd9.webp" alt="IMG_20230626_182450"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/06/27/649a8696b728d.webp" alt="IMG_20230627_135220"></p><p><img src="https://bu.dusays.com/2023/06/27/649a869c2ac12.webp" alt="IMG_20230627_135128"></p><p><img src="https://bu.dusays.com/2023/06/27/649a86a3a3585.webp" alt="IMG_20230627_135250"></p><p><img src="https://bu.dusays.com/2023/06/27/649a86e515e15.webp" alt="IMG_20230627_140635"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>香味十分浓郁，包装一打开我就猛一吸，我开心地笑了，因为很久没闻咖啡豆了（真该死，在学校带了豆子没带器具）。</p><p><code>SeeSaw甜橙子</code>它的酸味十分突出，有细微柑橘的苦味（至于包装说的乌龙茶我倒是没感觉到），在强烈的酸味刺激下，会有回甘。涩味不是很明显，全部喝完，还是能感觉到微微涩味，但还是在能够接受的范围内。</p><p><code>SeeSaw甜橙子</code>作为一款浅烘焙的咖啡豆，我个人觉得还是太有个性了，让我怀疑它真的不是极浅烘焙咖啡豆？这也太酸了吧，<code>甜橙子</code>的<code>甜</code>是极酸作用产生的甜味，这种<code>个性</code>是把双刃剑。</p><p><code>SeeSaw甜橙子</code>总体评价：极浅烘，过酸，性价比一般。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]34. 链表中环的入口结点</title>
      <link href="/posts/35d2359e9b06/"/>
      <url>/posts/35d2359e9b06/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-34-链表中环的入口结点"><a href="#AcWing-34-链表中环的入口结点" class="headerlink" title="[AcWing]34. 链表中环的入口结点"></a><a href="https://www.acwing.com/problem/content/86/">[AcWing]34. 链表中环的入口结点</a></h1><p>给定一个链表，若其中包含环，则输出环的入口节点。</p><p>若其中不包含环，则输出<code>null</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>节点 val 值取值范围 <code>[1,1000]</code>。<br>节点 val 值各不相同。<br>链表长度 <code>[0,500]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p><a href="https://www.acwing.com/media/article/image/2018/12/02/19_69ba6d14f5-QQ%E6%88%AA%E5%9B%BE20181202023846.png">!QQ截图20181202023846.png</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">给定如上所示的链表：<br>[1, 2, 3, 4, 5, 6]<br>2<br>注意，这里的2表示编号是2的节点，节点编号从0开始。所以编号是2的节点就是val等于3的节点。<br><br>则输出环的入口节点3.<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>y总讲这个题，听得我云里雾里，最终我放弃思考了，直接记住结论，开始写代码。</p><ol><li><code>慢指针一步一步走，快指针两步两步走</code></li><li><code>无环：快指针必定会先到达终点（NULL）</code></li><li><code>有环：俩指针会相遇，相遇之后，让慢指针回到起点，再让快慢指针同步速度，一步一步走</code></li><li><code>当再次相遇的时候，那个点就是环的入口</code></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">entryNodeOfLoop</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>       ListNode * slow = head, * fast = head;<br>       <br>       <span class="hljs-comment">// 死循环</span><br>       <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>           <span class="hljs-comment">// 判断fast -&gt; next是因为fast是连续走两步的</span><br>           <span class="hljs-comment">// 如果fast为空</span><br>           <span class="hljs-comment">// 1. 初始为空</span><br>           <span class="hljs-comment">// 2. 先走完</span><br>           <span class="hljs-keyword">if</span>(!fast || !fast -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>           slow = slow -&gt; next;<br>           fast = fast -&gt; next -&gt; next;<br>           <span class="hljs-comment">// 如果有环，那么这个是唯一的出口</span><br>           <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">break</span>;<br>       &#125;<br>       <br>       <span class="hljs-comment">// 跳出循环，必定相遇</span><br>       <span class="hljs-comment">// 快指针从头开始走</span><br>       fast = head;<br>       <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>           slow = slow -&gt; next;<br>           fast = fast -&gt; next;<br>       &#125;<br>       <br>       <span class="hljs-keyword">return</span> fast;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]29. 删除链表中重复的节点</title>
      <link href="/posts/448d550da686/"/>
      <url>/posts/448d550da686/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-29-删除链表中重复的节点"><a href="#AcWing-29-删除链表中重复的节点" class="headerlink" title="[AcWing]29. 删除链表中重复的节点"></a><a href="https://www.acwing.com/problem/content/27/">[AcWing]29. 删除链表中重复的节点</a></h1><p>在一个排序的链表中，存在重复的节点，请删除该链表中重复的节点，重复的节点不保留。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>链表中节点 val 值取值范围 <code>[0,100]</code>。<br>链表长度 <code>[0,100]</code>。</p><h4 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br><br>输出：1-&gt;2-&gt;5<br></code></pre></td></tr></table></figure><h4 id="样例2"><a href="#样例2" class="headerlink" title="样例2"></a>样例2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;1-&gt;1-&gt;2-&gt;3<br><br>输出：2-&gt;3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/12/645e40746c07e.png" alt="image-20230512213440430"></p><p><img src="https://bu.dusays.com/2023/05/12/645e412839dba.png" alt="image-20230512213751300"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy -&gt; next = head;<br>        <br>        ListNode * p = dummy;<br>        <br>        <span class="hljs-comment">// 保证节点都不为空</span><br>        <span class="hljs-keyword">while</span>(p -&gt; next)&#123;<br>            <span class="hljs-comment">// 被检查的节点</span><br>            ListNode * q = p -&gt; next;<br>            <span class="hljs-comment">// 由于这是一个已被排序的链表，因此可以通过while循环筛掉一连串的节点</span><br>            <span class="hljs-comment">// 循环跳出的时候 q -&gt; next 就是新的需要被检查的元素，与 q 的值不同</span><br>            <span class="hljs-keyword">while</span>(q -&gt; next &amp;&amp; q -&gt; val == q -&gt; next -&gt; val) q = q -&gt; next;<br>            <span class="hljs-comment">// 如果没有重复的元素，while循环体不会执行，会出现下面这种情况</span><br>            <span class="hljs-comment">// 那么 q 元素是没有重复元素的，就让 p 前进</span><br>            <span class="hljs-comment">// 否则，被筛选了，p 直接跳跃至 q -&gt; next 这个新的需要被筛选元素</span><br>            <span class="hljs-keyword">if</span>(p -&gt; next == q) p = p -&gt; next;<br>            <span class="hljs-keyword">else</span> p -&gt; next = q -&gt; next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dummy -&gt; next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]28. 在O(1)时间删除链表结点</title>
      <link href="/posts/766b1c104395/"/>
      <url>/posts/766b1c104395/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-28-在O-1-时间删除链表结点"><a href="#AcWing-28-在O-1-时间删除链表结点" class="headerlink" title="[AcWing]28. 在O(1)时间删除链表结点"></a><a href="https://www.acwing.com/problem/content/85/">[AcWing]28. 在O(1)时间删除链表结点</a></h1><p>给定单向链表的一个节点指针，定义一个函数在O(1)时间删除该结点。</p><p>假设链表一定存在，并且该节点一定不是尾节点。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>链表长度 <code>[1,500]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：链表 1-&gt;4-&gt;6-&gt;8<br>      删掉节点：第2个节点即6（头节点为第0个节点）<br><br>输出：新链表 1-&gt;4-&gt;8<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/11/645cf4ee045e4.png" alt="image-20230511213718985"></p><p><img src="https://bu.dusays.com/2023/05/11/645cf4f1ea571.png" alt="image-20230511214024756"></p><p><img src="https://bu.dusays.com/2023/05/11/645cf4e63b40d.png" alt="image-20230511214110079"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>        ListNode * q = node -&gt; next;<br>        ListNode * p = q -&gt; next;<br>        <br>        node -&gt; val = q -&gt; val;<br>        node -&gt; next = p;<br>        <span class="hljs-keyword">delete</span> q;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]17. 从尾到头打印链表</title>
      <link href="/posts/7cd2155b1ef6/"/>
      <url>/posts/7cd2155b1ef6/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-17-从尾到头打印链表"><a href="#AcWing-17-从尾到头打印链表" class="headerlink" title="[AcWing]17. 从尾到头打印链表"></a><a href="https://www.acwing.com/problem/content/18/">[AcWing]17. 从尾到头打印链表</a></h1><p>输入一个链表的头结点，按照 <strong>从尾到头</strong> 的顺序返回节点的值。</p><p>返回的结果用数组存储。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>0 ≤</code> 链表长度 <code>≤ 1000</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：[2, 3, 5]<br>返回：[5, 3, 2]<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>最简单的方法就是，直接遍历链表，然后存入<code>vector</code>，再利用库函数将其反转输出。<br>所以此处只写一下，递归函数法。<br>还是利用递归栈，出栈的时候将节点值塞入<code>vector</code>，这样就是逆序的了。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ListNode * head)</span></span>&#123;<br>        <span class="hljs-comment">// 出口</span><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 找到尾</span><br>        <span class="hljs-built_in">dfs</span>(head -&gt; next);<br>        <span class="hljs-comment">// 从尾到头放入res</span><br>        res.<span class="hljs-built_in">push_back</span>(head -&gt; val);<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printListReversingly</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(head);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printListReversingly</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果已经遍历到末尾，先创建一个空集合，为逆向存储元素做准备</span><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> &#123;&#125;; <br>        <span class="hljs-comment">// 压栈</span><br>        <span class="hljs-built_in">printListReversingly</span>(head -&gt; next);<br>        <span class="hljs-comment">// 出栈的时候</span><br>        ans.<span class="hljs-built_in">push_back</span>(head -&gt; val);<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>假设链表元素是：<code>[1, 2]</code>。</p><p>它的函数调用栈压栈顺序是：<code>printListReversingly(1)</code>、<code>printListReversingly(2)</code>、<code>printListReversingly(NULL)</code>。</p><p>它的出栈顺序是：<code>printListReversingly(NULL)</code>、<code>printListReversingly(2)</code>、<code>printListReversingly(1)</code></p><p>当执行到<code>printListReversingly(2)</code>的时候，<code>ans.push_back(2)</code>之后，接下来会执行<code>return ans</code>，那么为什么没有终止掉递归？</p><p><wavy>答：</wavy>因为<code>return ans</code>只是终止掉了属于<code>printListReversingly(2)</code>的这一层递归，还剩<code>printListReversingly(1)</code>的递归。最终<code>ans</code>里面的元素会是<code>[2, 1]</code>。</p><p>对于这道题来说，外部肯定有一个变量接收最后的<code>ans = [2, 1]</code>。</p><p>第二个问题来了同时也是最重要的一个问题：</p><p><code>为什么printListReversingly函数在递归过程中返回了多次，为什么第一次返回的时候没有将集合传给外部那个变量？</code></p><p><wavy>答：</wavy>因为当最初的调用者接收到返回值时，所有的递归调用都已经完成，并且<code>ans</code>已经包含了所有逆序的元素</p><p>类似于main函数中写：<code>auto a = printListReversingly(list);</code>，当a收到返回的ans的时候，函数递归早已经结束了。</p><p>有如下规律：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">第一次递归调用<br>第二次递归调用<br>第二次递归返回<br>第一次递归返回<br>主 printListReversingly 函数调用返回<br>auto a = [2, 1];<br>是一气呵成的！！！<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断子序列</title>
      <link href="/posts/8dc10c9dd9e8/"/>
      <url>/posts/8dc10c9dd9e8/</url>
      
        <content type="html"><![CDATA[<h1 id="2816-判断子序列"><a href="#2816-判断子序列" class="headerlink" title="2816. 判断子序列"></a><a href="https://www.acwing.com/problem/content/2818/">2816. 判断子序列</a></h1><p>给定一个长度为 <code>n</code> 的整数序列 <code>a1,a2,…,an</code> 以及一个长度为 <code>m</code> 的整数序列 <code>b1,b2,…,bm</code>。</p><p>请你判断 <code>a</code> 序列是否为 <code>b</code> 序列的子序列。</p><p>子序列指序列的一部分项按<strong>原有次序排列</strong>而得的序列，例如序列 <code>&#123;a1,a3,a5&#125;</code> 是序列 <code>&#123;a1,a2,a3,a4,a5&#125;</code> 的一个子序列。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <code>n,m</code>。</p><p>第二行包含 <code>n</code> 个整数，表示 <code>a1,a2,…,an</code>。</p><p>第三行包含 <code>m</code> 个整数，表示 <code>b1,b2,…,bm</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>如果 <code>a</code> 序列是 <code>b</code> 序列的子序列，输出一行 <code>Yes</code>。</p><p>否则，输出 <code>No</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ n ≤ m ≤ 10^5</code>,<br><code>-10^9 ≤ ai,bi ≤ 10^9</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 5<br>1 3 5<br>1 2 3 4 5<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Yes<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>a</code>序列和<code>b</code>序列同时进行遍历，直到某一个序列遍历完毕。</p><p>在这个过程中，如果<code>a</code>序列游标<code>i</code>和它长度相等，说明全部匹配，<code>a</code>序列是<code>b</code>的子序列</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[N], b[N], s[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) cin &gt;&gt; b[i];<br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; j &lt; m)&#123;<br>        <span class="hljs-keyword">if</span>(a[i] == b[j]) i++;<br>        <span class="hljs-comment">// 不管怎样，j都要往后走，保证</span><br>        j++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(i == n) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组元素的目标和</title>
      <link href="/posts/d268782dc5be/"/>
      <url>/posts/d268782dc5be/</url>
      
        <content type="html"><![CDATA[<h1 id="800-数组元素的目标和"><a href="#800-数组元素的目标和" class="headerlink" title="800. 数组元素的目标和"></a><a href="https://www.acwing.com/problem/content/802/">800. 数组元素的目标和</a></h1><p>给定两个升序排序的有序数组 <code>A</code> 和 <code>B</code>，以及一个目标值 <code>x</code>。</p><p>数组下标从 <code>0</code> 开始。</p><p>请你求出满足 <code>A[i] + B[j] = x</code> 的数对 <code>(i, j)</code>。</p><p>数据保证有唯一解。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 <code>n,m,x</code>，分别表示 <code>A</code> 的长度，<code>B</code> 的长度以及目标值 <code>x</code>。</p><p>第二行包含 <code>n</code> 个整数，表示数组 <code>A</code>。</p><p>第三行包含 <code>m</code> 个整数，表示数组 <code>B</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含两个整数 <code>i</code> 和 <code>j</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>数组长度不超过 <code>10^5</code>。<br>同一数组内元素各不相同。<br><code>1 ≤ 数组元素 ≤ 10^9</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">4 5 6<br>1 2 4 7<br>3 4 6 8 9<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1 1<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>双指针算法，首先应该先想出暴力解法，然后根据单调性求解。（本文暴力不分析）</p><p>由于题中给出，两个升序序列<code>A</code>和<code>B</code>，且存在唯一解。我们可以得到如下性质：</p><p><img src="https://bu.dusays.com/2023/05/05/6454ed463355d.png" alt="image-20230505194642740"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> A[N], B[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, m, x;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; A[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) cin &gt;&gt; B[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = m - <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; A[i] + B[j] &gt; x) j--;<br>        <span class="hljs-keyword">if</span>(A[i] + B[j] == x) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长连续不重复子序列</title>
      <link href="/posts/471596286a1c/"/>
      <url>/posts/471596286a1c/</url>
      
        <content type="html"><![CDATA[<h3 id="双指针算法核心思想"><a href="#双指针算法核心思想" class="headerlink" title="双指针算法核心思想"></a>双指针算法核心思想</h3><p>原本两个指针是有 n<sup>2</sup> 种组合，因此时间复杂度是 O(n<sup>2</sup>) 。<br>而双指针算法就是运用单调性使得指针只能单向移动，因此总的时间复杂度只有 O(2n) ，也就是O(n)。</p><p>之所以双指针可以实现 O(n) 的时间复杂度是因为指针只能单向移动，没有指针的回溯，而且每一步都会有指针移动。</p><p>而朴素的 O(n<sup>2</sup>) 算法的问题就在于指针经常<strong>回溯到之前的位置</strong>。</p><p>双指针算法的模板一般都可以写成下面的形式(模板)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>    <span class="hljs-comment">// check是满足某种性质</span><br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j++;<br><br>    <span class="hljs-comment">// 每道题目的具体逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="799-最长连续不重复子序列"><a href="#799-最长连续不重复子序列" class="headerlink" title="799. 最长连续不重复子序列"></a><a href="https://www.acwing.com/problem/content/801/">799. 最长连续不重复子序列</a></h1><p>给定一个长度为 <code>n</code> 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>n</code>。</p><p>第二行包含 <code>n</code> 个整数（均在 <code>0 ~ 10^5</code> 范围内），表示整数序列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ n ≤ 10^5</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5<br>1 2 2 3 5<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><ol><li>无脑暴力求解（不作解释）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> l , <span class="hljs-type">int</span> r )</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l ; i &lt;= r ; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = l ; j &lt; i ; j++)&#123;<br>            <span class="hljs-keyword">if</span>(q[i] == q[j]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; i ; j++)&#123;<br>            <span class="hljs-comment">// 判断区间 [j,i] 是否有重复元素,没有重复元素就返回结果 check代表成功</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(j,i) == <span class="hljs-number">1</span>) res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这种会TLE。</p><h3 id="双指针算法思想"><a href="#双指针算法思想" class="headerlink" title="双指针算法思想"></a>双指针算法思想</h3><p>可以考虑，使用<code>i</code>作为终点，<code>j</code>作为起点，让<code>j</code>去追赶<code>i</code>。</p><p><code>j</code>与<code>i</code>在这个过程，如果是不同序列，那么就让<code>i</code>一直走。</p><p>如果遇到了重复序列，就让<code>j</code>去追赶<code>i</code>，直到这个重复序列结束，然后计算<code>i - j + 1</code>就是<code>最长连续，但不重复的子序列长度</code>。</p><p><strong>代码实现提示：对每个整数进行桶计数。</strong></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> a[N], s[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br>    <span class="hljs-comment">// i和j下标最远距离</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> , j = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-comment">// 对 a[i] 进行桶计数</span><br>        s[a[i]]++;<br><br>        <span class="hljs-comment">// 跳过重复序列，s[a[i]]≥2的时候才可能触发，也就是进入了重复序列片段</span><br>        <span class="hljs-keyword">while</span>(s[a[i]] &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// a[j]如果等于a[i]自然也就是剔除重复序列</span><br>            s[a[j]]--;<br>            j++;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 只保留 i 和 j 相隔最远的距离。</span><br>        <span class="hljs-comment">// 即，最长连续，但不重复的子序列长度。</span><br>        res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[差分]差分矩阵</title>
      <link href="/posts/255d64b2bba3/"/>
      <url>/posts/255d64b2bba3/</url>
      
        <content type="html"><![CDATA[<h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的值加上<code>c</code>,是否也可以达到<code>O(1)</code>的时间复杂度。答案是可以的，考虑二维差分。<br><code>a[][]</code>数组是<code>b[][]</code>数组的前缀和数组，那么<code>b[][]</code>是<code>a[][]</code>的差分数组</p><p>原数组： <code>a[i][j]</code></p><p>我们去构造差分数组： <code>b[i][j]</code></p><p>使得<code>a</code>数组中<code>a[i][j]</code>是<code>b</code>数组左上角<code>(1,1)</code>到右下角<code>(i,j)</code>所包围矩形元素的和。</p><p><img src="https://bu.dusays.com/2023/05/03/64527be20518e.png" alt="image-20230503232104902"></p><h1 id="798-差分矩阵"><a href="#798-差分矩阵" class="headerlink" title="798. 差分矩阵"></a><a href="https://www.acwing.com/problem/content/description/800/">798. 差分矩阵</a></h1><p>输入一个 <code>n</code> 行 <code>m</code> 列的整数矩阵，再输入 <code>q</code> 个操作，每个操作包含五个整数 <code>x1, y1, x2, y2, c</code>，其中 <code>(x1, y1)</code> 和 <code>(x2, y2)</code> 表示一个子矩阵的左上角坐标和右下角坐标。</p><p>每个操作都要将选中的子矩阵中的每个元素的值加上 <code>c</code>。</p><p>请你将进行完所有操作后的矩阵输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>n,m,q</code>。</p><p>接下来 <code>n</code> 行，每行包含 <code>m</code> 个整数，表示整数矩阵。</p><p>接下来 <code>q</code> 行，每行包含 <code>5</code> 个整数 <code>x1, y1, x2, y2, c</code>，表示一个操作。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 <code>n</code> 行，每行 <code>m</code> 个整数，表示所有操作进行完毕后的最终矩阵。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ n,m ≤ 1000</code>,<br><code>1 ≤ q ≤ 100000</code>,<br><code>1 ≤ x1 ≤ x2 ≤ n</code>,<br><code>1 ≤ y1 ≤ y2 ≤ m</code>,<br><code>-1000 ≤ c ≤ 1000</code>,<br><code>-1000 ≤ 矩阵内元素的值 ≤ 1000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 4 3<br>1 2 2 1<br>3 2 2 1<br>1 1 1 1<br>1 1 2 2 1<br>1 3 2 3 2<br>3 1 3 4 1<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">2 3 4 1<br>4 3 4 1<br>2 2 2 2<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> a[N][N], b[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, m, q;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            cin &gt;&gt; a[i][j];<br>            <br>    <span class="hljs-comment">// 求差分数组，类比一维数组求差分</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            b[i][j] = a[i][j] - a[i - <span class="hljs-number">1</span>][j] - a[i][j - <span class="hljs-number">1</span>] + a[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <br>    <span class="hljs-keyword">while</span>(q --)&#123;<br>        <span class="hljs-type">int</span> x1, y1, x2, y2, c;<br>        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;<br>        b[x1][y1] += c;<br>        b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>        b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>        b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 求差分数组的前缀和，并且输出</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>            b[i][j] += b[i - <span class="hljs-number">1</span>][j] + b[i][j - <span class="hljs-number">1</span>] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], cout &lt;&lt; b[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p><a href="https://www.acwing.com/solution/content/27325/">林小鹿</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分</title>
      <link href="/posts/254738f560c0/"/>
      <url>/posts/254738f560c0/</url>
      
        <content type="html"><![CDATA[<h3 id="差分应用场景"><a href="#差分应用场景" class="headerlink" title="差分应用场景"></a>差分应用场景</h3><p>对区间内频繁地对数组中某个区间进行同一操作。例如将序列中[l, r]之间的每个数加上c这一操作，可能执行n次，每次的c不同，如果对原数组进行操作，每次操作都会花费O(n)的时间复杂度。如果使用该数组的差分数组进行操作，每次操作为O(1)。<br>然后求差分数组的前缀和即为所求结果。</p><h3 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h3><p>首先给定一个原数组<code>a[]</code>：a[1], a[2], a[3], … , a[n];</p><p>然后我们构造一个数组<code>b[]</code>： b[1] ,b[2] , b[3], … , b[i];</p><p>使得 <code>a[i] = b[1] + b[2 ]+ b[3] +,..., + b[i]</code></p><p>也就是说，<code>a</code>数组是<code>b</code>数组的前缀和数组，反过来我们把<code>b</code>数组叫做<code>a</code>数组的差分数组。换句话说，每一个<code>a[i]</code>都是<code>b</code>数组中从头开始的一段区间和。</p><p>考虑如何构造差分<code>b</code>数组？</p><p>最为直接的方法</p><p><code>a[0]= 0;</code></p><p><code>b[1] = a[1] - a[0];</code></p><p><code>b[2] = a[2] - a[1];</code></p><p><code>b[3] = a [3] - a[2];</code></p><p><code>........</code></p><p><code>b[n] = a[n] - a[n-1];</code></p><h3 id="差分数组的使用？"><a href="#差分数组的使用？" class="headerlink" title="差分数组的使用？"></a>差分数组的使用？</h3><p>给定区间<code>[l ,r ]</code>，让我们把<code>a</code>数组中的<code>[ l, r]</code>区间中的每一个数都加上<code>c</code>。</p><p>由于<code>a</code>数组是<code>b</code>数组的<code>前缀和</code>，所以有这样的一个性质：</p><p><img src="https://bu.dusays.com/2023/05/03/6452681e9318d.png" alt="image-20230503215308523"></p><p>抽象的来说：</p><p><img src="https://bu.dusays.com/2023/05/03/645268225b877.png" alt="image-20230503215648039"></p><h1 id="797-差分"><a href="#797-差分" class="headerlink" title="797. 差分"></a><a href="https://www.acwing.com/problem/content/799/">797. 差分</a></h1><p>输入一个长度为 <code>n</code> 的整数序列。</p><p>接下来输入 <code>m</code> 个操作，每个操作包含三个整数 <code>l, r, c</code>，表示将序列中 <code>[l, r]</code> 之间的每个数加上 <code>c</code>。</p><p>请你输出进行完所有操作后的序列。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <code>n</code> 和 <code>m</code>。</p><p>第二行包含 <code>n</code> 个整数，表示整数序列。</p><p>接下来 <code>m</code> 行，每行包含三个整数 <code>l，r，c</code>，表示一个操作。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 <code>n</code> 个整数，表示最终序列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ n,m ≤ 100000</code>,<br><code>1 ≤ l ≤ r ≤ n</code>,<br><code>-1000 ≤ c ≤ 1000</code>,<br><code>-1000 ≤ 整数序列中元素的值 ≤ 1000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">6 3<br>1 2 2 1 2 1<br>1 3 1<br>3 5 1<br>1 6 1<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 4 5 3 4 2<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-comment">// 求差分数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) b[i] = a[i] - a[i - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> l, r, c;<br>        cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;<br>        <span class="hljs-comment">// 在[l, r]区间的元素都 + c</span><br>        b[l] += c;<br>        b[r + <span class="hljs-number">1</span>] -= c;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 求一遍前缀和输出</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) b[i] += b[i - <span class="hljs-number">1</span>], cout &lt;&lt; b[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p><a href="https://www.acwing.com/solution/content/26588/">林小鹿</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[前缀和]子矩阵的和</title>
      <link href="/posts/0607b1e0bdb9/"/>
      <url>/posts/0607b1e0bdb9/</url>
      
        <content type="html"><![CDATA[<h1 id="796-子矩阵的和"><a href="#796-子矩阵的和" class="headerlink" title="796. 子矩阵的和"></a><a href="https://www.acwing.com/problem/content/798/">796. 子矩阵的和</a></h1><p>输入一个 <code>n</code> 行 <code>m</code> 列的整数矩阵，再输入 <code>q</code> 个询问，每个询问包含四个整数 <code>x1, y1, x2, y2</code>，表示一个子矩阵的左上角坐标和右下角坐标。</p><p>对于每个询问输出子矩阵中所有数的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 <code>n，m，q</code>。</p><p>接下来 <code>n</code> 行，每行包含 <code>m</code> 个整数，表示整数矩阵。</p><p>接下来 <code>q</code> 行，每行包含四个整数 <code>x1, y1, x2, y2</code>，表示一组询问。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 <code>q</code> 行，每行输出一个询问的结果。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ n,m ≤ 1000</code>,<br><code>1 ≤ q ≤ 200000</code>,<br><code>1 ≤ x1 ≤ x2 ≤ n</code>,<br><code>1 ≤ y1 ≤ y2 ≤ m</code>,<br><code>-1000 ≤ 矩阵内元素的值 ≤ 1000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 4 3<br>1 7 2 4<br>3 6 2 8<br>2 1 2 3<br>1 1 2 2<br>2 1 3 4<br>1 3 3 4<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">17<br>27<br>21<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/03/64526352163b6.png" alt="image-20230503211519377"></p><p><img src="https://bu.dusays.com/2023/05/03/645263574b964.png" alt="image-20230503213325665"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n , m , q , s[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j++)<br>            cin &gt;&gt; s[i][j];<br>    <span class="hljs-comment">// 计算前缀和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j++)<br>            s[i][j] += s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <br>    <span class="hljs-keyword">while</span>(q --)&#123;<br>        <span class="hljs-type">int</span> x1, y1 , x2 , y2;<br>        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;<br>        <span class="hljs-comment">// 输出区间和</span><br>        cout &lt;&lt; s[x2][y2] - s[x2][y1 - <span class="hljs-number">1</span>] - s[x1 - <span class="hljs-number">1</span>][y2] + s[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="/posts/4c155c76f2b7/"/>
      <url>/posts/4c155c76f2b7/</url>
      
        <content type="html"><![CDATA[<h3 id="前缀和有什么用？"><a href="#前缀和有什么用？" class="headerlink" title="前缀和有什么用？"></a>前缀和有什么用？</h3><p>前缀和是一种预处理，用于降低查询时的时间复杂度。 举个例子：给定 n 个整数，然后进行 m 次询问，每次询问求一个区间内值的和。</p><p>如果用暴力写法，那每次询问都需要从区间左端点循环到区间右端点求和，时间复杂度较大。</p><p>但是如果使用前缀和就可以将它降到<code>O(n + m)</code>。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/03/645257b375e96.png" alt="image-20230503115839749"></p><h1 id="795-前缀和"><a href="#795-前缀和" class="headerlink" title="795. 前缀和"></a><a href="https://www.acwing.com/problem/content/797/">795. 前缀和</a></h1><p>输入一个长度为 <code>n</code> 的整数序列。</p><p>接下来再输入 <code>m</code> 个询问，每个询问输入一对 <code>l, r</code>。</p><p>对于每个询问，输出原序列中从第 <code>l</code> 个数到第 <code>r</code> 个数的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <code>n</code> 和 <code>m</code>。</p><p>第二行包含 <code>n</code> 个整数，表示整数数列。</p><p>接下来 <code>m</code> 行，每行包含两个整数 <code>l</code> 和 <code>r</code>，表示一个询问的区间范围。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 <code>m</code> 行，每行输出一个询问的结果。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ l ≤ r ≤ n</code>,<br><code>1 ≤ n,m ≤ 100000</code>,<br><code>-1000 ≤ 数列中元素的值 ≤ 1000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 3<br>2 1 3 6 4<br>1 2<br>1 3<br>2 4<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br>6<br>10<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[N], s[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-comment">// 计算前缀和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br>    <br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> l , r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        cout &lt;&lt; s[r] - s[l - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度除法</title>
      <link href="/posts/ca4465c5974d/"/>
      <url>/posts/ca4465c5974d/</url>
      
        <content type="html"><![CDATA[<div class="note success simple"><p>再学完这个知识点，我再休息</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/01/644f6b6cb6fda.png" alt="image-20230428224911582"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp; r)</span></span>&#123;<br>    <span class="hljs-comment">// 默认A大于b</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 除法是从最高位开始 &lt;-</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 保存的时候是从高到低，需要反转一下</span><br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    <span class="hljs-type">int</span> r; <span class="hljs-comment">// 余数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">div</span>(A, b, r);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>    <br>    cout &lt;&lt; endl &lt;&lt; r;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 高精度算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度乘法</title>
      <link href="/posts/d222ff48c8bc/"/>
      <url>/posts/d222ff48c8bc/</url>
      
        <content type="html"><![CDATA[<div class="note success simple"><p>学累了就出去走走吧</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/01/644f6b65b32ba.png" alt="image-20230428221023505"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-comment">// 默认A 大于 b</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果t很大可能会留有剩余</span><br>    <span class="hljs-keyword">while</span>(t)&#123;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">mul</span>(A, b);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 高精度算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度减法</title>
      <link href="/posts/c87c248906c2/"/>
      <url>/posts/c87c248906c2/</url>
      
        <content type="html"><![CDATA[<div class="note success simple"><p>不要有强迫症，面对眼前的难题，可以跳过，回头再处理。</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/01/644f6b58d3634.png" alt="image-20230428213513607"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b5d16368.png" alt="image-20230428213521595"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 比较两个数谁大谁小，如果A大于B返回true，反之</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span>&#123;<br>    <span class="hljs-comment">// 如果两个数字位数不同</span><br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 如果两个数字位数相同，直接从最高位开始比较 方向提示：&lt;-</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span>(B[i] != A[i])<br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>            <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span>&#123;<br>    <span class="hljs-comment">// A一定是大于B的</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <br>    <span class="hljs-comment">// 进位</span><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 去除高位0，同时要保证结果长度大于1，不能1 - 1 = 0把答案0也给消了</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    string a, b;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-comment">// 如果A比B大</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A, B))&#123;<br>        C = <span class="hljs-built_in">sub</span>(A, B);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>        <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 如果A比B小</span><br>        C = <span class="hljs-built_in">sub</span>(B, A);<br>        <span class="hljs-comment">// 还需要输出减号</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 高精度算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度加法</title>
      <link href="/posts/759ae4655658/"/>
      <url>/posts/759ae4655658/</url>
      
        <content type="html"><![CDATA[<h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><div class="note success simple"><p>你有下大雨去网吧的勇气，却没有下小雨去图书馆的勇气吗</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用数组模拟平常我们的竖式计算。例如：</p><p><img src="https://bu.dusays.com/2023/05/01/644f6b0aa04aa.png" alt="image-20230427202700060"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b12b49a4.png" alt="image-20230428202609403"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b186bf4d.png" alt="image-20230428203007184"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b1e05ea1.png" alt="image-20230428203255775"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b2160933.png" alt="image-20230428203857482"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span>&#123;<br>    <span class="hljs-comment">// 为了方便计算，让A中保存较长的数字， B中保存较短的数字</span><br>    <span class="hljs-keyword">if</span>(B.<span class="hljs-built_in">size</span>() &gt; A.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br>    <br>    <span class="hljs-comment">// 保存最终的结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <br>    <span class="hljs-comment">// 以 A 为基准，开始按位计算</span><br>    <span class="hljs-comment">// 每位的进位</span><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        t += A[i];<br>        <span class="hljs-comment">// 如果B位置还没遍历完</span><br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        <span class="hljs-comment">// 9 + 9 = 18, 1 + 2 = 3。取余即可，进位交给 t /= 10 做</span><br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 如果是18, 那么下次t初始值会变成1</span><br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">// 最终，还需要判断进位上是否还有数</span><br>    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 字符串形式读取两个数</span><br>    string a, b;<br>    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-comment">// 用来保存两个数字</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>    <span class="hljs-comment">// 倒序保存，记得转数字</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">add</span>(A, B);<br>    <br>    <span class="hljs-comment">// 输出计算之后的结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 高精度算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]88. 树中两个结点的最低公共祖先</title>
      <link href="/posts/02073ceab06d/"/>
      <url>/posts/02073ceab06d/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-88-树中两个结点的最低公共祖先"><a href="#AcWing-88-树中两个结点的最低公共祖先" class="headerlink" title="[AcWing]88. 树中两个结点的最低公共祖先"></a><a href="https://www.acwing.com/problem/content/84/">[AcWing]88. 树中两个结点的最低公共祖先</a></h1><p>给出一个二叉树，输入两个树节点，求它们的最低公共祖先。</p><p>一个树节点的祖先节点包括它本身。</p><p><strong>注意：</strong></p><ul><li>输入的二叉树不为空；</li><li>输入的两个节点一定不为空，且是二叉树中的节点；</li></ul><!-- --><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[0,500]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]如下图所示：<br>    8<br>   / \<br>  12  2<br>     / \<br>    6   4<br><br>1. 如果输入的树节点为2和12，则输出的最低公共祖先为树节点8。<br><br>2. 如果输入的树节点为2和6，则输出的最低公共祖先为树节点2。<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/04/24/64468eb3c9247.png" alt="image-20230424221354590"></p><ol><li>如果<code>p</code>、<code>q</code>分别存在于这棵子树的左右两边，返回这棵子树的根，它就是最低公共祖先。</li><li>否则，<code>p</code>、<code>q</code>只可能全存在于这棵子树的左边、或者全存在于这棵子树的右边。</li><li>如果当前节点恰好是<code>p</code>或<code>q</code>中的一个，那么它就是最低公共祖先。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-comment">// 由于题目说了，输入的树不为空，并且p、q是树中的元素</span><br>        <span class="hljs-comment">// 就是说一定能够找到树中两个节点的最低公共祖先</span><br>        <span class="hljs-comment">// 遇到叶子节点</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// 左边找一下、右边找一下，遇到p、q节点就保存</span><br>        TreeNode * left = <span class="hljs-built_in">lowestCommonAncestor</span>(root -&gt; left, p, q);<br>        TreeNode * right = <span class="hljs-built_in">lowestCommonAncestor</span>(root -&gt; right, p, q);<br>        <br>        <span class="hljs-comment">// 如果p、q分别存在于这棵子树的左右两边，返回这棵子树的根，它就是p、q的最低公共祖先</span><br>        <span class="hljs-keyword">if</span>(left &amp;&amp; right) <span class="hljs-keyword">return</span> root;<br>        <br>        <span class="hljs-comment">// 那么p、q只可能全存在于这棵子树的左边、或者全存在于这棵子树的右边</span><br>        <span class="hljs-comment">// 如果当前节点恰好是p或q中的一个，那么它就是最低公共祖先</span><br>        <span class="hljs-keyword">if</span>(root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        <br>        <span class="hljs-comment">// 如果最低公共祖先在左边，返回左边的最低公共祖先</span><br>        <span class="hljs-comment">// 如果最低公共祖先在右边，返回右边的最低公共祖先</span><br>        <span class="hljs-keyword">if</span>(left) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>遍历整棵子树，时间复杂度<code>O(n)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]72. 平衡二叉树</title>
      <link href="/posts/4c34c5a2d3db/"/>
      <url>/posts/4c34c5a2d3db/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-72-平衡二叉树"><a href="#AcWing-72-平衡二叉树" class="headerlink" title="[AcWing]72. 平衡二叉树"></a><a href="https://www.acwing.com/problem/content/68/">[AcWing]72. 平衡二叉树</a></h1><p>输入一棵二叉树的根结点，判断该树是不是平衡二叉树。</p><p>如果某二叉树中任意结点的左右子树的深度相差不超过 <code>1</code>，那么它就是一棵平衡二叉树。</p><p><strong>注意：</strong></p><ul><li>规定空树也是一棵平衡二叉树。</li></ul><!-- --><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[0,500]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：二叉树[5,7,11,null,null,12,9,null,null,null,null]如下所示，<br>    5<br>   / \<br>  7  11<br>    /  \<br>   12   9<br><br>输出：true<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>在统计二叉树的深度的代码基础上，实时判断当前节点的左右子树的深度差是否大于1，如果是则不是平衡二叉树</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认是平衡二叉树，如果判断过程中当前节点的左右子树的深度差大于1，则改为false</span><br>    <span class="hljs-type">bool</span> res = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span></span>&#123;<br>        <span class="hljs-comment">// 空树深度为0</span><br>        <span class="hljs-comment">// DFS结束，那层空节点不算深度，返回0</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果不是空树,计算当前节点的左右子树深度</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>        <br>        <span class="hljs-comment">// 如果左右子树深度之差大于1，则不是平衡二叉树</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(left - right) &gt; <span class="hljs-number">1</span>) res = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 返回 包括当前节点的，二叉树的深度</span><br>        <span class="hljs-comment">// + 1 是因为当前节点也算1个深度，记得从下往上看</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(left - right) &gt; <span class="hljs-number">1</span>) flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 为什么这里直接return false是错的</span><br></code></pre></td></tr></table></figure><p>在判断二叉树是否平衡的过程中，如果在递归过程中遇到某个节点的左子树和右子树的高度差大于1，直接返回false确实可以立即表示该树不是平衡的。<br>但是，你<code>isBalanced</code>函数返回的是 <code>res</code> 啊。你<code>return false</code>只是中断了函数，并没有真的<code>res = false, return res</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]70. 二叉搜索树的第k个结点</title>
      <link href="/posts/58544f92f8ea/"/>
      <url>/posts/58544f92f8ea/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-70-二叉搜索树的第k个结点"><a href="#AcWing-70-二叉搜索树的第k个结点" class="headerlink" title="[AcWing]70. 二叉搜索树的第k个结点"></a><a href="https://www.acwing.com/problem/content/66/">[AcWing]70. 二叉搜索树的第k个结点</a></h1><p>给定一棵二叉搜索树，请找出其中的第 <code>k</code> 小的结点。</p><p>你可以假设树和 <code>k</code> 都存在，并且 <code>1≤k≤</code> 树的总结点数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[1,500]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [2, 1, 3, null, null, null, null] ，k = 3<br><br>    2<br>   / \<br>  1   3<br><br>输出：3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>中序遍历二叉搜索树，找到第k个节点。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    TreeNode * res;<br><br>    <span class="hljs-comment">// 注意这里的k是加了引用的</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> &amp; k)</span></span>&#123;<br>        <span class="hljs-comment">// 中序遍历</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-built_in">dfs</span>(root -&gt; left, k);<br>        <br>        k--;<br>        <span class="hljs-keyword">if</span>(!k) res = root;<br>        <span class="hljs-comment">// 剪枝（找到了答案，右子树显然不需要遍历了，否则它会执着地找到空结点才停止递归）</span><br>        <span class="hljs-keyword">if</span>(k &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(root -&gt; right, k);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">kthNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 中序遍历，找到第k个节点</span><br>        <span class="hljs-built_in">dfs</span>(root, k);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>每个节点最多被遍历一次，因此时间复杂度是<code>O(n)</code></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]71. 二叉树的深度</title>
      <link href="/posts/348ff2382b5d/"/>
      <url>/posts/348ff2382b5d/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-71-二叉树的深度"><a href="#AcWing-71-二叉树的深度" class="headerlink" title="[AcWing]71. 二叉树的深度"></a><a href="https://www.acwing.com/problem/content/67/">[AcWing]71. 二叉树的深度</a></h1><p>输入一棵二叉树的根结点，求该树的深度。</p><p>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[0,500]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]如下图所示：<br>    8<br>   / \<br>  12  2<br>     / \<br>    6   4<br><br>输出：3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>对二叉树进行DFS遍历，在这个过程中，进入下一子树，则<code>depth + 1</code>。<br>取左右子树<code>depth</code>的最大值。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>推荐第一个，因为在做平衡二叉树的时候直接改改就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span></span>&#123;<br>        <span class="hljs-comment">// 出口</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 左右子树的深度</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>        <span class="hljs-comment">// 取左右子树中较大的那个返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">treeDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>        <span class="hljs-comment">// 如果遍历到了树底，返回深度</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> depth;<br>        <span class="hljs-comment">// 有左子树就遍历左子树，有右子树就遍历右子树</span><br>        <span class="hljs-comment">// 取两个子树的最大深度</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(root -&gt; left, depth + <span class="hljs-number">1</span>), <span class="hljs-built_in">dfs</span>(root -&gt; right, depth + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">treeDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>        <span class="hljs-comment">// 到了最深处直接返回深度</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> depth;<br>        <br>        <span class="hljs-comment">// 左边子树深度，和右边子树深度</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root -&gt; left, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">dfs</span>(root -&gt; right, depth + <span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-comment">// 返回最大深度</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">treeDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>DFS遍历，每个节点只被遍历一次，时间复杂度是<code>O(n)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]49. 二叉搜索树与双向链表</title>
      <link href="/posts/154a15c68d1b/"/>
      <url>/posts/154a15c68d1b/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-49-二叉搜索树与双向链表"><a href="#AcWing-49-二叉搜索树与双向链表" class="headerlink" title="[AcWing]49. 二叉搜索树与双向链表"></a><a href="https://www.acwing.com/problem/content/87/">[AcWing]49. 二叉搜索树与双向链表</a></h1><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</p><p>要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p><strong>注意</strong>：</p><ul><li>需要返回双向链表最左侧的节点。</li></ul><p>例如，输入下图中左边的二叉搜索树，则输出右边的排序双向链表。</p><p><img src="https://www.acwing.com/media/article/image/2018/12/02/19_23bee494f5-QQ截图20181202052830.png" alt="QQ截图20181202052830.png"></p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[0,500]</code>。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>中序遍历的基本代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * cur)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!cur) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-built_in">dfs</span>(cur -&gt; left);<br><br>    cout &lt;&lt; cur -&gt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>    <span class="hljs-built_in">dfs</span>(cur -&gt; right);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据观察，考虑在二叉树的中序遍历的基础上，利用 <code>pre</code> 和 <code>cur</code> 来进行 <code>双链表</code>的构建。</p><ol><li>先找到<code>双链表</code>的第一个节点，它是中序遍历的第一个节点。</li><li>定义一个指针<code>cur</code>，指向当前处理的节点。</li><li>如果<code>cur</code>的左子树不为空，则递归处理左子树。</li><li>将<code>cur</code>与其前驱节点（即中序遍历中<code>cur</code>的前一个节点）连接起来。</li><li>更新前驱节点为<code>cur</code>。</li><li>处理<code>cur</code>的右子树，重复步骤2-4。</li></ol><p><img src="https://bu.dusays.com/2023/04/21/64429cd6d4474.png" alt="image-20230421222517569"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    TreeNode * head, * pre;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * cur)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!cur) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-built_in">dfs</span>(cur -&gt; left);<br>        <br>        <span class="hljs-comment">// 先找到中序遍历第一个节点作为双链表的head</span><br>        <span class="hljs-comment">// 只有当dfs(cur -&gt; left)压栈全部完毕才可能执行这行if，因此head一定是中序遍历的第一个元素</span><br>        <span class="hljs-keyword">if</span>(!pre) head = cur;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 将cur与其前驱节点连接起来</span><br>            pre -&gt; right = cur;<br>            <span class="hljs-comment">// 构成双向</span><br>            cur -&gt; left = pre;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 将当前的节点变成下一次回溯的前驱节点</span><br>        pre = cur;<br>        <br>        <span class="hljs-built_in">dfs</span>(cur -&gt; right);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convert</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 在中序遍历的基础上，做点改变 中序遍历：左根右</span><br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度<code>O(n)</code>：对于每个节点最多只会被访问两次，因此总的时间复杂度为<code>O(n)</code>。</li><li>空间复杂度<code>O(n)</code>：在最坏情况下，退化成单链表，空间复杂度为<code>O(n)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]46. 二叉搜索树的后序遍历序列</title>
      <link href="/posts/d46bd558c265/"/>
      <url>/posts/d46bd558c265/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-46-二叉搜索树的后序遍历序列"><a href="#AcWing-46-二叉搜索树的后序遍历序列" class="headerlink" title="[AcWing]46. 二叉搜索树的后序遍历序列"></a><a href="https://www.acwing.com/problem/content/44/">[AcWing]46. 二叉搜索树的后序遍历序列</a></h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。</p><p>如果是则返回true，否则返回false。</p><p>假设输入的数组的任意两个数字都互不相同。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>数组长度 <code>[0,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：[4, 8, 6, 12, 16, 14, 10]<br><br>输出：true<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/04/20/64415023411af.png" alt="image-20230420220541552"></p><p><wavy>初始划分阶段</wavy>：</p><ol><li>数组最后一个元素一定是根元素，然后<code>从左往右</code>找到<code>第一个比根元素大</code>的下标，记为<code>k</code>。</li><li>左区间就是<code>[0, k - 1]</code>，右区间是<code>[k, n - 1]</code>。（n为数组长度)</li><li>然后对子区间做同样的划分。</li></ol><p><wavy>注意事项<wavy>：</p><ol><li>区间长度为1，则后续遍历序列合法。</li><li>只有包含<code>k</code>的右区间可能会出现小于根节点的情况，因为左边已经在找<code>k</code>的过程中排除了非法情况（左区间中有比根节点大的元素）。</li></ol><p><img src="https://bu.dusays.com/2023/04/20/644150271b857.png" alt="image-20230420224540132"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;<span class="hljs-type">int</span>&gt; &amp; seq)</span></span>&#123;<br>        <span class="hljs-comment">// 如果区间长度小于等于1，说明一切合法</span><br>        <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 找到根节点</span><br>        <span class="hljs-type">int</span> root = seq[r];<br>        <br>        <span class="hljs-comment">// 从左往右找到第一个比根大的元素下标</span><br>        <span class="hljs-type">int</span> k = l;<br>        <span class="hljs-keyword">while</span>(k &lt; r &amp;&amp; seq[k] &lt; root) k++;<br>  <br>        <span class="hljs-comment">// 如果右区间有比根元素小的元素，一定不合法</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k; i &lt; r; i++)<br>            <span class="hljs-keyword">if</span>(seq[i] &lt; root)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-comment">// 左区间和右区间同时划分</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(l, k - <span class="hljs-number">1</span>, seq) &amp;&amp; <span class="hljs-built_in">dfs</span>(k, r - <span class="hljs-number">1</span>, seq);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verifySequenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; sequence)</span> </span>&#123;<br>        <span class="hljs-comment">// 整个区间长度[0, n - 1]。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, sequence.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, sequence);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度<code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code>：<code>dfs</code>中有一个while循环，最坏情况会循环O(n)次，一共执行O(n)次<code>dfs</code>，所以时间复杂度是<code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code>。其实也就是退化成单链表了。</li><li>空间复杂度<code>O(n)</code>：退化成单链表空间占用<code>O(n)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]47. 二叉树中和为某一值的路径</title>
      <link href="/posts/e407ed0acd1f/"/>
      <url>/posts/e407ed0acd1f/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-47-二叉树中和为某一值的路径"><a href="#AcWing-47-二叉树中和为某一值的路径" class="headerlink" title="[AcWing]47. 二叉树中和为某一值的路径"></a><a href="https://www.acwing.com/problem/content/45/">[AcWing]47. 二叉树中和为某一值的路径</a></h1><p>输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。</p><p>从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><p>保证树中结点值均不小于 <code>0</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中结点的数量 <code>[0,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">给出二叉树如下所示，并给出num=22。<br>      5<br>     / \<br>    4   6<br>   /   / \<br>  12  13  6<br> /  \    / \<br>9    1  5   1<br><br>输出：[[5,4,12,1],[5,6,6,5]]<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>DFS的过程中，在遇到叶子节点的时候进行累加求和，并且提交<code>path</code>作为<code>ans</code>之一。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <br>    <span class="hljs-comment">// 节点，当前累计的值，目标值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> target)</span></span>&#123;<br>        <span class="hljs-comment">// 遇到叶子节点下面的空节点，或者是棵空树，什么也不做，反正返回的是ans</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 将当前遇到节点加入路径集合</span><br>        path.<span class="hljs-built_in">push_back</span>(root -&gt; val);<br>        <span class="hljs-comment">// 进行累加计算</span><br>        sum += root -&gt; val;<br>        <br>        <span class="hljs-comment">// 有左子树就开始递归左子树</span><br>        <span class="hljs-keyword">if</span>(root -&gt; left) <span class="hljs-built_in">dfs</span>(root -&gt; left, sum, target);<br>        <span class="hljs-comment">// 有右子树就开始递归右子树</span><br>        <span class="hljs-keyword">if</span>(root -&gt; right) <span class="hljs-built_in">dfs</span>(root -&gt; right, sum, target);<br>        <span class="hljs-comment">// 剩下的情况就是，左子树和右子树都没有，说明是当前节点是叶子节点</span><br>        <span class="hljs-comment">// 订正：不一定是左子树和右子树都没有，或许它是只有一个子树，因此不能无脑开始计算并且提交答案</span><br>        <span class="hljs-comment">// 确定是叶子节点才能计算并且提交答案</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;<br>            <span class="hljs-keyword">if</span>(sum == target) ans.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 不成功也不管了，反正最终会提交一个ans</span><br>        <br>        <span class="hljs-comment">// 每次dfs都需要恢复现场</span><br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findPath</span>(TreeNode* root, <span class="hljs-type">int</span> sum) &#123;<br>        <span class="hljs-comment">// 从根节点找到每个分支的叶子节点</span><br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>, sum);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><wavy>注意事项</wavy>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">path.<span class="hljs-built_in">push_back</span>(root -&gt; val);<br><br>path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 恢复现场</span><br></code></pre></td></tr></table></figure><p>在DFS过程中，上面这两行到底怎么理解？</p><p>DFS的过程中，可以用函数调用栈来表示。如果调用四次DFS，则有四个DFS压入栈中，<code>path</code>也会有四个节点的值。在DFS出栈的过程中，如果不恢复现场，则会出现<code>函数调用栈空了，但path的里面值依旧没有减少</code>。</p><p>归根结底，四次DFS，<code>path</code>会加入四个节点的值，通过<code>path.pop_back()</code>会清除掉这四个节点的值。这样能够保证DFS在结束一个分支，再次开启新的分支的时候<code>path</code>是干净的。</p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul><li>最坏时间复杂度<code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code>：在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶子节点的路径都符合题目要求。路径的数目为<code>O(n)</code>，并且每一条路径的节点个数也为 O(n)。要想将n个路径的所有节点都统计起来，需要的时间复杂度是<code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code>。</li><li>平均时间复杂度<code>O(n)</code>：由于每个节点最多只会被访问一次，所以时间复杂度是<code>O(n)</code>。</li></ul><p>但是注意：在大多数情况下，二叉树不会退化成链表，因此大部分情况下的时间复杂度都是线性的。</p><p>我认为时间复杂度还是能看做<code>O(n)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> target)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>                <br>        path.<span class="hljs-built_in">push_back</span>(root -&gt; val);<br>        <br>        <span class="hljs-comment">// 只有到叶子结点的时候才开始全部计算</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;<br><br>            <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                total += path[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(total == target)&#123;<br>                <span class="hljs-comment">// 提交答案</span><br>                ans.<span class="hljs-built_in">push_back</span>(path);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(root -&gt; left) <span class="hljs-built_in">dfs</span>(root -&gt; left, target);<br>        <span class="hljs-keyword">if</span>(root -&gt; right) <span class="hljs-built_in">dfs</span>(root -&gt; right, target);<br>        <br>        <span class="hljs-comment">// 恢复现场</span><br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findPath</span>(TreeNode* root, <span class="hljs-type">int</span> sum) &#123;<br>        <span class="hljs-built_in">dfs</span>(root, sum);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我的算法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]45. 之字形打印二叉树</title>
      <link href="/posts/de0ff6a9d060/"/>
      <url>/posts/de0ff6a9d060/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-45-之字形打印二叉树"><a href="#AcWing-45-之字形打印二叉树" class="headerlink" title="[AcWing]45. 之字形打印二叉树"></a><a href="https://www.acwing.com/problem/content/description/43/">[AcWing]45. 之字形打印二叉树</a></h1><p>请实现一个函数按照之字形顺序从上向下打印二叉树。</p><p>即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点的数量 <code>[0,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入如下图所示二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]<br>    8<br>   / \<br>  12  2<br>     / \<br>    6   4<br>输出：[[8], [2, 12], [6, 4]]<br></code></pre></td></tr></table></figure><h3 id="算法思路1、2"><a href="#算法思路1、2" class="headerlink" title="算法思路1、2"></a>算法思路1、2</h3><p>在之前的题的基础上，添加了条件判断</p><p>详情参考<a href="/6929c8c24cea">分行从上往下打印二叉树</a></p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">printFromTopToBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 空树，返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        <br>        <span class="hljs-comment">// 基于BFS的分行操作</span><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 从根节点开始BFS</span><br>        <br>        <span class="hljs-comment">// 当前层是否需要逆置</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">// 下一层的节点数量</span><br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 保存每层的值</span><br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-comment">// 一口气将当前层的节点，全放入队列</span><br>            <span class="hljs-keyword">while</span>(len --)&#123;<br>                TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <br>                level.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>                <br>                <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>                <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>            &#125;<br>            <span class="hljs-comment">// 逆置判断</span><br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                <span class="hljs-built_in">reverse</span>(level.<span class="hljs-built_in">begin</span>(), level.<span class="hljs-built_in">end</span>());<br>            &#125;<br>                <br>            <span class="hljs-comment">// 下一层必定与当前层BFS的顺序相反</span><br>            flag = !flag;<br>            <span class="hljs-comment">// 提交当前层</span><br>            ans.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">printFromTopToBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 空树，返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        <br>        <span class="hljs-comment">// 基于BFS的分行操作</span><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 从根节点开始BFS</span><br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 代表这层结束</span><br>        <br>        <span class="hljs-comment">// 存储每层的节点值</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; level;<br>        <br>        <span class="hljs-comment">// 表示是否需要将 level 集合逆置(从右到左)</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <br>            <span class="hljs-comment">// 如果当前层结束了</span><br>            <span class="hljs-keyword">if</span>(!t)&#123;<br>                <span class="hljs-comment">// 如果下一层没有节点了</span><br>                <span class="hljs-comment">// 比如：4 NULL，while循环拿出4，放入level之后，取出NULL，进入这个if条件里面</span><br>                <span class="hljs-comment">// level不是空，因此提交 level 到 ans 里面</span><br>                <span class="hljs-comment">// 队列里面剩下的是 NULL，再拿出来，此时判断level，为空，break掉</span><br>                <span class="hljs-comment">// 这也就是下一层没有节点的情况</span><br>                <span class="hljs-keyword">if</span>(level.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 当前层结束了，下一行还有节点，根据类型提交level，再给下一层增加结束标识符</span><br>                <span class="hljs-comment">// 如果需要逆置</span><br>                <span class="hljs-keyword">if</span>(flag)&#123;<br>                    <span class="hljs-built_in">reverse</span>(level.<span class="hljs-built_in">begin</span>(), level.<span class="hljs-built_in">end</span>());<br>                &#125;<br>                ans.<span class="hljs-built_in">push_back</span>(level);<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>                <span class="hljs-comment">// 为了下一次，level容器是空的，还需要还原空状态</span><br>                level.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-comment">// 下一层必定与当前层BFS的顺序相反</span><br>                flag = !flag;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 当前层没结束,正常BFS</span><br>            level.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>            <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>            <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>由于树中每个节点仅会进队出队一次，所以时间复杂度是<code>O(n)</code></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]44. 分行从上往下打印二叉树</title>
      <link href="/posts/6929c8c24cea/"/>
      <url>/posts/6929c8c24cea/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-44-分行从上往下打印二叉树"><a href="#AcWing-44-分行从上往下打印二叉树" class="headerlink" title="[AcWing]44. 分行从上往下打印二叉树"></a><a href="https://www.acwing.com/problem/content/42/">[AcWing]44. 分行从上往下打印二叉树</a></h1><p>从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点的数量 <code>[0,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null]<br>    8<br>   / \<br>  12  2<br>     /<br>    6<br>   /<br>  4<br><br>输出：[[8], [12, 2], [6], [4]]<br></code></pre></td></tr></table></figure><h3 id="算法思想1"><a href="#算法思想1" class="headerlink" title="算法思想1"></a>算法思想1</h3><p>已知不分行的做法是使用<code>BFS</code>层序遍历这棵树。</p><p>在此基础上，做出一些改变，即可得到不分行的做法。</p><p>问：<wavy>在BFS的过程中，能否知道当前队列中有多少节点？</wavy></p><p>答：可以。<wavy>队列的容量就是当前层的节点数量</wavy></p><p>那么，在第1层，只有根节点，队列容量是1，当前层节点数量是1。</p><p>在第2层，有2个节点，队列容量是2，当前层节点数量是2。</p><p>原<code>BFS</code>每次只能弹出一个节点，如果我们一次性弹出<code>当前层数</code>的节点呢？然后将它放入小集合。</p><p>这样一轮结束，将小集合放入大集合。</p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">printFromTopToBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 如果是空树返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        <br>        <span class="hljs-comment">// BFS</span><br>        queue&lt;TreeNode *&gt; q;<br>        <span class="hljs-comment">// 从根节点开始扩展</span><br>        q.<span class="hljs-built_in">push</span>(root);<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">// 当前层的元素个数</span><br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <br>            <span class="hljs-comment">// 用来保存当前层的值的集合</span><br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <br>            <span class="hljs-comment">// 一次性将当前层的所有节点弹出</span><br>            <span class="hljs-keyword">while</span>(len --)&#123;<br>                <span class="hljs-comment">// 从队头开始弹出</span><br>                TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 记录这层值的元素</span><br>                level.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>                <br>                <span class="hljs-comment">// 为一次性弹出下层节点做准备</span><br>                <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>                <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>            &#125;<br>            <span class="hljs-comment">// 将小集合放入大集合</span><br>            ans.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="算法思想2"><a href="#算法思想2" class="headerlink" title="算法思想2"></a>算法思想2</h3><p><img src="https://bu.dusays.com/2023/04/19/643fb3cee443e.png" alt="image-20230419172627366"></p><p>代码实现2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">printFromTopToBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 空树，返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        <br>        <span class="hljs-comment">// 基于BFS的分行操作</span><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 从根节点开始BFS</span><br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 代表这层结束</span><br>        <br>        <span class="hljs-comment">// 存储每层的节点值</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; level;<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <br>            <span class="hljs-comment">// 如果当前层结束了</span><br>            <span class="hljs-keyword">if</span>(!t)&#123;<br>                <span class="hljs-comment">// 如果下一层没有节点了</span><br>                <span class="hljs-comment">// 比如：4 NULL，while循环拿出4，放入level之后，取出NULL，进入这个if条件里面</span><br>                <span class="hljs-comment">// level不是空，因此提交 level 到 ans 里面</span><br>                <span class="hljs-comment">// 队列里面剩下的是 NULL，再拿出来，此时判断level，为空，break掉</span><br>                <span class="hljs-comment">// 这也就是下一层没有节点的情况</span><br>                <span class="hljs-keyword">if</span>(level.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 当前层结束了，下一行还有节点，先提交level，再给下一层增加结束标识符</span><br>                ans.<span class="hljs-built_in">push_back</span>(level);<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>                <span class="hljs-comment">// 为了下一次，level容器是空的，还需要还原空状态</span><br>                level.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 当前层没结束,正常BFS</span><br>            level.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>            <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>            <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>由于树中每个节点仅会进队出队一次，所以时间复杂度是<code>O(n)</code></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]43. 不分行从上往下打印二叉树</title>
      <link href="/posts/b0ff145d2003/"/>
      <url>/posts/b0ff145d2003/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-43-不分行从上往下打印二叉树"><a href="#AcWing-43-不分行从上往下打印二叉树" class="headerlink" title="[AcWing]43. 不分行从上往下打印二叉树"></a><a href="https://www.acwing.com/problem/content/41/">[AcWing]43. 不分行从上往下打印二叉树</a></h1><p>从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点的数量 <code>[0,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null]<br>    8<br>   / \<br>  12  2<br>     /<br>    6<br>   /<br>  4<br><br>输出：[8, 12, 2, 6, 4]<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>显然，这是二叉树的层序遍历，使用 <code>BFS</code>就行。</p><p>我们从根节点开始按宽度优先的顺序遍历整棵树，每次先扩展左儿子，再扩展右儿子。</p><p>这样我们会：</p><ol><li>先扩展根节点；</li><li>再依次扩展根节点的左右儿子，也就是从左到右扩展第二层节点；</li><li>再依次从左到右扩展第三层节点；</li><li>依次类推</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <br>        <span class="hljs-comment">// 如果是空树，则返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>        <br>        <span class="hljs-comment">// 开始BFS</span><br>        queue&lt;TreeNode *&gt; q;<br>        <span class="hljs-comment">// 从根节点开始扩展</span><br>        q.<span class="hljs-built_in">push</span>(root);<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">// 取出队头元素</span><br>            TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <br>            <span class="hljs-comment">//题目要求输出序列，需要将它放入集合中</span><br>            res.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>            <br>            <span class="hljs-comment">// 拓展根节点的左右节点（如果存在的话）</span><br>            <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>            <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>BFS时每个节点仅被遍历一次，所以时间复杂度是 <code>O(n)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]39. 对称的二叉树</title>
      <link href="/posts/49a255ffe500/"/>
      <url>/posts/49a255ffe500/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-39-对称的二叉树"><a href="#AcWing-39-对称的二叉树" class="headerlink" title="[AcWing]39. 对称的二叉树"></a><a href="https://www.acwing.com/problem/content/38/">[AcWing]39. 对称的二叉树</a></h1><p>请实现一个函数，用来判断一棵二叉树是不是对称的。</p><p>如果一棵二叉树和它的镜像一样，那么它是对称的。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">如下图所示二叉树[1,2,2,3,4,4,3,null,null,null,null,null,null,null,null]为对称二叉树：<br>    1<br>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br><br>如下图所示二叉树[1,2,2,null,4,4,3,null,null,null,null,null,null]不是对称二叉树：<br>    1<br>   / \<br>  2   2<br>   \ / \<br>   4 4  3<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p><img src="https://bu.dusays.com/2023/04/14/6439692818a87.png" alt="image-20230414225426092"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* pA, TreeNode* pB)</span></span>&#123;<br>        <span class="hljs-comment">// 如果左根节点和右根节点有一个为空，那么只有它两都为空的时候才是true，否则是false</span><br>        <span class="hljs-keyword">if</span>(!pA || !pB) <span class="hljs-keyword">return</span> !pA &amp;&amp; !pB;<br>        <span class="hljs-comment">// 左右根节点都存在的情况</span><br>        <span class="hljs-comment">// 左右节点根节点值不同，则不对称</span><br>        <span class="hljs-keyword">if</span>(pA -&gt; val != pB -&gt; val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 左右根节点都存在，且值相同，比较他们的子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(pA -&gt; left, pB -&gt; right) &amp;&amp; <span class="hljs-built_in">dfs</span>(pA -&gt; right, pB -&gt; left);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果根节点是空的那么一定是对称的（规定如此）</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 判断左右子树是不是镜像的</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root -&gt; left, root -&gt; right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>从上到下每个节点仅被遍历一遍，所以时间复杂度是 <code>O(n)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]38. 二叉树的镜像</title>
      <link href="/posts/f218078c7891/"/>
      <url>/posts/f218078c7891/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-38-二叉树的镜像"><a href="#AcWing-38-二叉树的镜像" class="headerlink" title="[AcWing]38. 二叉树的镜像"></a><a href="https://www.acwing.com/problem/content/description/37/">[AcWing]38. 二叉树的镜像</a></h1><p>输入一个二叉树，将它变换为它的镜像。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入树：<br>      8<br>     / \<br>    6  10<br>   / \ / \<br>  5  7 9 11<br><br> [8,6,10,5,7,9,11,null,null,null,null,null,null,null,null] <br>输出树：<br>      8<br>     / \<br>    10  6<br>   / \ / \<br>  11 9 7  5<br><br> [8,10,6,11,9,7,5,null,null,null,null,null,null,null,null]<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>仔细观察发现，镜像就是：<wavy>交换左右子树，对于子树中的左右子节点也进行交换。</wavy><br>利用这个性质，抽象一下就是：递归遍历这个树，交换其<code>左右子树</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mirror</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归到空的节点，就跳出，什么也不做</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 交换左右子树</span><br>        <span class="hljs-built_in">mirror</span>(root -&gt; left);<br>        <span class="hljs-built_in">mirror</span>(root -&gt; right);<br>        <span class="hljs-built_in">swap</span>(root -&gt; left, root -&gt; right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的代码虽然简单，但还是可以分析一下。</p><ol><li>从宏观上来看：这是个交换左右子树的过程。</li><li>从微观上来看：这是个先找到叶子结点，从下面开始交换左右节点的过程。（函数递归调用栈）</li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>原树仅被遍历一次，所以时间复杂度是 <code>O(n)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]37. 树的子结构</title>
      <link href="/posts/e7ce670351d7/"/>
      <url>/posts/e7ce670351d7/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-37-树的子结构"><a href="#AcWing-37-树的子结构" class="headerlink" title="[AcWing]37. 树的子结构"></a><a href="https://www.acwing.com/problem/content/description/35/">[AcWing]37. 树的子结构</a></h1><p>输入两棵二叉树 <code>A，B</code>，判断 <code>B</code> 是不是 <code>A</code> 的子结构。</p><p>我们规定空树不是任何树的子结构。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>每棵树的节点数量 <code>[0,1000]</code>。</p><h4 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">    8<br>   / \<br>  8   7<br> / \<br>9   2<br>   / \<br>  4   7<br></code></pre></td></tr></table></figure><p>树 <code>B</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">  8<br> / \<br>9   2<br></code></pre></td></tr></table></figure><p>返回 <strong>true</strong>，因为 <code>B</code> 是 <code>A</code> 的子结构。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>代码分为两个部分：</p><ol><li>遍历树A中的所有非空节点R；</li><li>判断树A中以R为根节点的子树是不是包含和树B一样的结构，且我们从根节点开始匹配；</li></ol><p>对于第一部分，我们直接递归遍历树A即可，遇到非空节点后，就进行第二部分的判断。</p><p>对于第二部分，我们同时从根节点开始遍历两棵子树：</p><ul><li>如果树B中的节点为空，则表示当前分支是匹配的，返回true；</li><li>如果树A中的节点为空，但树B中的节点不为空，则说明不匹配，返回false；</li><li>如果两个节点都不为空，但数值不同，则说明不匹配，返回false；</li><li>否则说明当前这个点是匹配的，然后递归判断左子树和右子树是否分别匹配即可；</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPart</span><span class="hljs-params">(TreeNode* pA,TreeNode* pB)</span></span>&#123;<br>        <span class="hljs-comment">// 需要注意的是：必须先判断pB，否则遇到两棵一模一样的树，会返回false</span><br>        <span class="hljs-comment">// 我曾写成这样，然后报错了。</span><br>        <span class="hljs-comment">// if(!pA) return false;</span><br>        <span class="hljs-comment">// if(!pB) return true;</span><br>        <span class="hljs-comment">// 匹配成功的情况，B树已经遍历完了</span><br>        <span class="hljs-keyword">if</span>(!pB) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 匹配失败的情况(pB不为空)</span><br>        <span class="hljs-comment">// B树相比A树更枝繁叶茂，或者A树和B树比较的节点值不同，则子结构匹配失败</span><br>        <span class="hljs-keyword">if</span>(!pA || pA -&gt; val != pB -&gt; val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果A树和B树当前节点值相同，则继续匹配左右子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isPart</span>(pA -&gt; left, pB -&gt; left) &amp;&amp; <span class="hljs-built_in">isPart</span>(pA -&gt; right, pB -&gt; right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;<br>        <span class="hljs-comment">//空树不是任何树的子结构。任何树也不是空树的子结构。</span><br>        <span class="hljs-keyword">if</span>(!pRoot1 || !pRoot2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果是真的全匹配了，那么就是子结构</span><br>        <span class="hljs-comment">// 需要区别于 =&gt; return isPart(pRoot1,pRoot2);</span><br>        <span class="hljs-comment">// 上面这行是只要匹配错一个就直接错了，无容错空间。</span><br>        <span class="hljs-comment">// 下面这行是有容错空间的，还可以执行下下行代码</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isPart</span>(pRoot1,pRoot2)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 出现了一个节点不匹配，使得上面的出口未跳出</span><br>        <span class="hljs-comment">// 说明需要进入A树的左右子树，继续进行匹配</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasSubtree</span>(pRoot1 -&gt; left, pRoot2) || <span class="hljs-built_in">hasSubtree</span>(pRoot1 -&gt; right, pRoot2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><wavy>这里有个注意事项：代码注释已经写出，但这里抽出来再次解释</wavy><ol><li>if(isPart(pRoot1,pRoot2)) return true;这行代码需要区别于 =&gt; return isPart(pRoot1,pRoot2);</li><li><wavy>return isPart(pRoot1,pRoot2);这行是只要匹配错一个就直接错了，无容错空间。</wavy></li><li><wavy>if(isPart(pRoot1,pRoot2)) return true;这行是有容错空间的，还可以执行if后面的代码。</wavy></li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>最坏情况下，我们对于树A中的每个节点都要递归判断一遍，每次判断在最坏情况下需要遍历完树B中的所有节点。<br>所以时间复杂度是 <code>O(nm)</code>，其中 <code>n</code> 是树A中的节点数， <code>m</code> 是树B中的节点数。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]19. 二叉树的下一个节点</title>
      <link href="/posts/94e11a4b82e8/"/>
      <url>/posts/94e11a4b82e8/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-19-二叉树的下一个节点"><a href="#AcWing-19-二叉树的下一个节点" class="headerlink" title="[AcWing]19. 二叉树的下一个节点"></a><a href="https://www.acwing.com/problem/content/31/">[AcWing]19. 二叉树的下一个节点</a></h1><p>给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。</p><p><strong>注意：</strong></p><ul><li>如果给定的节点是中序遍历序列的最后一个，则返回空节点;</li><li>二叉树一定不为空，且给定的节点一定不是空节点；</li></ul><!-- --><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量<code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。<br><br>则应返回值等于3的节点。<br><br>解释：该二叉树的结构如下，2的后继节点是3。<br>  2<br> / \<br>1   3<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><wavy>中序遍历：左根右</wavy><p>情况1：有右子树</p><p>情况2：无右子树</p><p><img src="https://bu.dusays.com/2023/04/07/64301d778a9c8.png" alt="image-20230407214109154"></p><p><img src="https://bu.dusays.com/2023/04/07/6430218e1aa8c.png" alt="image-20230407215844606"></p><p><img src="https://bu.dusays.com/2023/04/07/643022e300731.png" alt="image-20230407220425944"></p><p><img src="https://bu.dusays.com/2023/04/07/64302521859e7.png" alt="image-20230407221400823"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode *father;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">inorderSuccessor</span><span class="hljs-params">(TreeNode* p)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果它有右子树，找到右子树下的最左边的节点</span><br>        <span class="hljs-keyword">if</span>(p -&gt; right)&#123;<br>            p = p -&gt; right;<br>            <span class="hljs-keyword">while</span>(p -&gt; left) p = p -&gt; left;<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果它没有右子树，则寻找它的父亲节点，直到满足条件p == p -&gt; father -&gt; left</span><br>        <span class="hljs-comment">// 那么 p -&gt; father 就是 它的中序遍历的下一个节点</span><br>        <span class="hljs-keyword">while</span>(p -&gt; father &amp;&amp; p != p -&gt; father -&gt; left) p = p -&gt; father;<br>        <span class="hljs-keyword">return</span> p -&gt; father;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><wavy>不论往上找还是往下找，总共遍历的节点数都不大于树的高度。所以时间复杂度是`O(h)`，其中 h 是树的高度。</wavy>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]18. 重建二叉树</title>
      <link href="/posts/c2f1d45bfc4f/"/>
      <url>/posts/c2f1d45bfc4f/</url>
      
        <content type="html"><![CDATA[<h1 id="18-重建二叉树-AcWing题库"><a href="#18-重建二叉树-AcWing题库" class="headerlink" title="18. 重建二叉树 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/23/">18. 重建二叉树 - AcWing题库</a></h1><p>输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。</p><p><strong>注意:</strong></p><p>二叉树中每个节点的值都互不相同；<br>输入的前序遍历和中序遍历一定合法；</p><p><strong>数据范围</strong><br>树中节点数量范围<code>[0,100]</code>。</p><p><strong>样例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">给定：<br>前序遍历是：[<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>]<br>中序遍历是：[<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7</span>]<br><br>返回：[<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]<br>返回的二叉树如下所示：<br>    <span class="hljs-number">3</span><br>   / \<br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  \<br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p><img src="https://bu.dusays.com/2023/04/04/642c0c5373b5f.png" alt="image-20230404193839718"></p><p><img src="https://bu.dusays.com/2023/04/04/642c1c1de0caf.png" alt="image-20230404204620577"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pos;<br>    <br>    <span class="hljs-function">TreeNode * <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-comment">// 如果区间为空（若 a == b ，比如 9 == 9，此时依旧要创建 根为9 的节点）</span><br>        <span class="hljs-keyword">if</span>(a &gt; b) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// 先构建根节点</span><br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[a]);<br>        <span class="hljs-comment">// 找到中序遍历中根节点的位置</span><br>        <span class="hljs-type">int</span> k = pos[root -&gt; val];<br>        <span class="hljs-comment">// 递归创建左子树和右子树</span><br>        root -&gt; left = <span class="hljs-built_in">build</span>(preorder, inorder, a + <span class="hljs-number">1</span>, k - x + a, x, k - <span class="hljs-number">1</span>);<br>        root -&gt; right = <span class="hljs-built_in">build</span>(preorder, inorder, b - y + k + <span class="hljs-number">1</span>, b, k + <span class="hljs-number">1</span>, y);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 提前记录中序遍历每个元素的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) pos[inorder[i]] = i;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder, inorder, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：O(n)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-质数</title>
      <link href="/posts/9c8937f58169/"/>
      <url>/posts/9c8937f58169/</url>
      
        <content type="html"><![CDATA[<h3 id="质数-素数-和合数的定义"><a href="#质数-素数-和合数的定义" class="headerlink" title="质数(素数)和合数的定义"></a>质数(素数)和合数的定义</h3><wavy>大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</wavy><wavy>合数是指在大于1的整数中除了能被1和本身整除外，还能被其他数（0除外）整除的数。</wavy><h3 id="质数的判定：试除法"><a href="#质数的判定：试除法" class="headerlink" title="质数的判定：试除法"></a>质数的判定：试除法</h3><p>此处，给出常规代码写法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">// 如果这个自然数比2小，则一定不是质数</span><br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 试除法</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        <span class="hljs-comment">// 能够被其它自然数整除，不是质数</span><br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>上述代码时间复杂度是O(n)。可是还能优化</p><p>例如：n = 12；i = 2; 那么 (n / i) 一定能整除 n。</p><p>12试除法试到2的时候同时可以知道6也是一个约数。</p><p>所以每次枚举的时候，只需要枚举较小的那个约数就行。</p><p>也就是说，只要 <code>i &lt;= (n / i)</code></p><p>下面给出优化过后的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">// 如果这个自然数比2小，则一定不是质数</span><br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 优化过后的试除法</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++)<br>        <span class="hljs-comment">// 能够被其它自然数整除，不是质数</span><br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码时间复杂度是O(n<sup>1/2</sup>)</p><p>主要修改了for循环里面的判断条件，没有使用<code>sqrt函数</code>，也没有使用<code>i * i &lt;= n</code>，而是使用了<code>i &lt;= n / i</code>。</p><wavy>因为使用sqrt函数慢，i * i 有爆 int 的可能</wavy><h3 id="分解质因数：试除法"><a href="#分解质因数：试除法" class="headerlink" title="分解质因数：试除法"></a>分解质因数：试除法</h3><wavy>合数可以分解质因数，质数不能分解质因数，因为质数只能等于1乘本身这种形式，而1不是质数。</wavy><p><code>算数基本定理</code> 也叫 <code>唯一分解定理</code>，主要的内容为：任何大于 <strong>1</strong> 的正整数都能 唯一 的分解为有限个质数的乘积。根据这一定理任何一个合数都可以被分解成几个质数相乘的形式。</p><p>质因数，给几个例子理解一下。</p><ul><li>1没有质因子。</li><li>5只有1个质因子，5本身。（5是质数）</li><li>6的质因子是2和3。(6 = 2 × 3)</li><li>2、4、8、16等只有1个质因子：2。（2是质数，4 =2²，8 = 2³，如此类推）</li><li>10有2个质因子：2和5。(10 = 2 × 5)</li></ul><h4 id="如何计算质因数：短除法"><a href="#如何计算质因数：短除法" class="headerlink" title="如何计算质因数：短除法"></a>如何计算质因数：短除法</h4><p><img src="https://bu.dusays.com/2023/03/31/6426f34ac5db5.png" alt="image-20230331225037221"></p><p>代码模拟如上操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">// 枚举质因子（i一定是质数，可证明）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++)&#123;<br>        <span class="hljs-comment">// 如果i是质因子</span><br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 进行计数</span><br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>)&#123;<br>                n /= i;<br>                s++;<br>            &#125;<br>            <span class="hljs-comment">// 输出底数和计数结果</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, s);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// n中最多只含有一个大于sqrt(n)的因子(可证明)</span><br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, n, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的点：</p><wavy>假如 i 是一个合数，那么它一定可以分解成多个质因子相乘的形式，这多个质因子同时也是 n 的质因子且比 i 要小，而比 i 小的数在之前的循环过程中一定是被条件除完了的，所以 i 不可能是合数，只可能是质数。</wavy><br /><wavy>n中最多只含有一个大于sqrt(n)的因子，证明通过反证法：如果有两个大于sqrt(n)的因子，那么相乘会大于n，矛盾。</wavy><h3 id="质数筛"><a href="#质数筛" class="headerlink" title="质数筛"></a>质数筛</h3><p>埃氏筛法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-comment">// 埃氏筛法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-comment">// 如果被筛过了</span><br>        <span class="hljs-keyword">if</span>(st[i]) <span class="hljs-keyword">continue</span>;<br>        <br>        <span class="hljs-comment">// 没有被筛过，当前数是质数</span><br>        primes[cnt ++] = i;<br>        <span class="hljs-comment">// 只标记质数的倍数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i)<br>            st[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-built_in">get_primes</span>(n);<br>    <br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><wavy>时间复杂度：O(nlog(logn))</wavy><p>线性筛法（欧拉筛）：</p><p>线性筛法是对朴素筛法的进一步优化，埃式筛法的缺陷在于，对于同一个合数，可能被筛选多次。为了确保每一个合数只被筛选一次，我们用<strong>每个合数的最小质因子</strong>来进行筛选</p><p>之所以被称为线性，是因为：1 ~ n 之内的任何一个合数一定会被筛掉,而且筛的时候只用最小质因子来筛,每一个数都只有一个最小质因子,所以<strong>每个数都只会被筛一次</strong>,因此线性筛法是线性的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-comment">// 欧拉筛</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )&#123;<br>        <span class="hljs-comment">// 如果没被筛过，它是质数</span><br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-comment">// 枚举质数表里面所有的质数(表里面的质数是从小到大存储的)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )&#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-built_in">get_primes</span>(n);<br>    <br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>时间复杂度：O(n)</wavy><br><br /><br>1、因为primes中质数是递增的，所以如果i%primes[j]!=0代表i的最小质因数还没有找到，<strong>即prime[j]小于i的最小质因数。但并不妨碍，primes[j]是primes[j] * i的最小质因数。</strong><br>2、如果当i%prime[j]==0时，代表<strong>i的最小质因数是prime[j]，primes[j]是primes[j] * i的最小质因数。</strong><br>3、综上所述达到了每个数仅筛一次的效果，时间复杂度O ( n ) .</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法-数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]788.逆序对的数量</title>
      <link href="/posts/da4ee60f29fd/"/>
      <url>/posts/da4ee60f29fd/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-788-逆序对的数量"><a href="#AcWing-788-逆序对的数量" class="headerlink" title="AcWing 788. 逆序对的数量"></a><a href="https://www.acwing.com/problem/content/790/">AcWing 788. 逆序对的数量</a></h1><p>给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。</p><p>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。</p><p><strong>输入格式</strong><br>第一行包含整数 n，表示数列的长度。</p><p>第二行包含 n 个整数，表示整个数列。</p><p><strong>输出格式</strong><br>输出一个整数，表示逆序对的个数。</p><p><strong>数据范围</strong><br>1 ≤ n ≤ 100000，<br>数列中的元素的取值范围 [1,109]。</p><p><strong>输入样例：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">6<br>2 3 4 5 6 1<br></code></pre></td></tr></table></figure><br><strong>输出样例：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5<br></code></pre></td></tr></table></figure></p><h3 id="暴力解法思想"><a href="#暴力解法思想" class="headerlink" title="暴力解法思想"></a>暴力解法思想</h3><p>模仿人类的肉眼观察法，从左往右进行两个for循环的迭代。</p><h3 id="暴力解法代码"><a href="#暴力解法代码" class="headerlink" title="暴力解法代码"></a>暴力解法代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-comment">// 暴力解法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n; cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; q[i];<br>    <br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)<br>            <span class="hljs-keyword">if</span>(q[i] &gt; q[j])<br>                cnt++;<br>                <br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用暴力解法，结果是TLE，因此暴力解法不可行。</p><h3 id="较优的方案：使用归并排序进行求解"><a href="#较优的方案：使用归并排序进行求解" class="headerlink" title="较优的方案：使用归并排序进行求解"></a>较优的方案：使用归并排序进行求解</h3><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><a href="/posts/e413468c3db1/">二路归并排序</a></p><p>在归并排序的过程中进行统计</p><p><strong>简单图示</strong></p><p><img src="https://bu.dusays.com/2023/02/16/63eda74378d04.png" alt="2023-02-16_114608"></p><h3 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h3><p>逆序对最多的情况：即倒序序列</p><p>此时有：</p><p><img src="https://bu.dusays.com/2023/02/16/63eda93ceccf5.png" alt="image-20230216115540983"></p><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> q[N], temp[N];<br><br><span class="hljs-function">LL <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <br>    LL res = <span class="hljs-built_in">merge_sort</span>(l, mid) + <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<span class="hljs-comment">// 核心代码1</span><br>    <br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j]) temp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span> &#123;<br>            temp[k++] = q[j++];<br>            res += mid - i + <span class="hljs-number">1</span>;<span class="hljs-comment">// 核心代码2</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= mid) temp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) temp[k++] = q[j++];<br>    <br>    <span class="hljs-keyword">for</span>(i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++,j++) q[i] = temp[j];<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n; cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; q[i];<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://blog.csdn.net/u014339447/article/details/109055298">C++ 基本数据类型中int、long等整数类型取值范围及原理看这一篇就够了_猿六凯的博客-CSDN博客_c++ int long</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二路归并排序</title>
      <link href="/posts/e413468c3db1/"/>
      <url>/posts/e413468c3db1/</url>
      
        <content type="html"><![CDATA[<h2 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h2><div class="note success simple"><p>本文将用图例介绍二路归并排序的过程，和经典的板子</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>归并排序和快速排序类似，是基于分治的算法，具有两个主要阶段「划分」和「合并」。</p><ol><li><wavy>划分阶段</wavy>：通过递归不断 <strong>将数组从中点位置划分开</strong>，将长数组的排序问题转化为短数组的排序问题；</li><li><wavy>合并阶段</wavy>：划分到子数组长度为 1 时，开始向上合并，不断将 <strong>左、右两个短有序数组</strong> 合并为 <strong>一个长有序数组</strong>，直至合并至原数组时完成排序；</li></ol><p>一个简单的例子：</p><p><img src="https://bu.dusays.com/2023/02/13/63ea3c2b1a3c7.png" alt="2023-02-13_213202"></p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><ul><li><p><wavy>时间复杂度</wavy>：「划分」阶段形成的递归树花费的时间为O(logn)，每层合并的总操作花费的时间为O(n)。因此总体时间复杂度为O(nlogn)</p></li><li><p><wavy>空间复杂度</wavy>：它需要临时存储原始数据的副本，因此使用了 O(n) 的额外空间，排序过程需要借助一个额外的辅助数组O(n)大小，因此空间复杂度为O(n)。</p></li><li><p><emp>提问：为什么归并排序的空间复杂度和递归深度无关？</emp><wavy>答：因为归并排序只需要复制原始数据的一份副本，而不需要将原始数据进行划分，这样就避免了递归深度的影响。</wavy></p></li><li><p><wavy>稳定性</wavy>：稳定</p></li></ul><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N] , w[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l , <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-comment">// 区间长度为1 则停止继续划分</span><br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 分割中点</span><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 递归划分</span><br>    <span class="hljs-built_in">merge_sort</span>(l , mid) ; <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span> , r);<br><span class="hljs-comment">// 排序合并</span><br>    <span class="hljs-type">int</span> i = l , j = mid + <span class="hljs-number">1</span> , k = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 在区间[l,mid]和[mid + 1, r]内</span><br>    <span class="hljs-comment">// 排序合并一部分</span><br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j]) w[k++] = q[i++];<br>        <span class="hljs-keyword">else</span> w[k++] = q[j++];<br>    &#125;<br>    <span class="hljs-comment">// 剩下的有序数组直接填入辅助数组内</span><br>    <span class="hljs-keyword">while</span>(i &lt;= mid) w[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) w[k++] = q[j++];<br><br>    <span class="hljs-comment">// 将辅助数组的值 覆盖原数组</span><br>    <span class="hljs-keyword">for</span>(i = l , j = <span class="hljs-number">0</span> ; j &lt; k ; i++ , j++)<br>        q[i] = w[j];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://www.hello-algo.com/chapter_sorting/merge_sort/">hello-algo</a></p><p><a href="https://www.bilibili.com/video/BV1Rt411H7UJ/">B站视频</a></p><p><a href="https://www.bilibili.com/video/BV16L411c7fn/">手写归并排序讲解视频</a></p><p><a href="https://www.acwing.com/activity/content/code/content/4550243/">我</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing]786.第K个数</title>
      <link href="/posts/1e599f9c3b25/"/>
      <url>/posts/1e599f9c3b25/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-786-第K个数"><a href="#AcWing-786-第K个数" class="headerlink" title="AcWing 786.第K个数"></a><a href="https://www.acwing.com/problem/content/788/">AcWing 786.第K个数</a></h1><p>给定一个长度为 n 的整数数列，以及一个整数 k，请求出数列从小到大排序后的第 k 个数。</p><p><strong>输入格式</strong></p><p>输入共两行，第一行包含整数 n 。</p><p>第二行包含 n 个整数（所有整数均在 1∼10<sup>9</sup> 范围内），表示整个数列。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示数列的第 k 小数。</p><p><strong>数据范围</strong></p><p>1 ≤ n ≤ 100000</p><p>1 ≤ k ≤ n</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 3<br>2 4 1 5 3<br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>由题可知，元素是基于数组存储的，于是考虑用快速排序，将元素有序化，输出对应位置的数即可。</p><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><a href="/posts/15ae1352a338">快速排序</a></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l , <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-comment">// 区间大小为1，跳出循环</span><br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 一开始 左边是 -1 右边是 length, pivot不取第一个元素是避免出现极端情况退化成单链表</span><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span> , j = r + <span class="hljs-number">1</span> , pivot = q[(l + r) &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; pivot);<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; pivot);<br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(q[i],q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(l,j);<br>    <span class="hljs-built_in">quick_sort</span>(j+<span class="hljs-number">1</span>,r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n , k;<br>    <br>    cin &gt;&gt; n &gt;&gt; k;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; q[i];<br>    <br>    <span class="hljs-built_in">quick_sort</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <br>    cout &lt;&lt; q[k - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="[AcWing 785. 快速排序 - AcWing](https://www.acwing.com/activity/content/code/content/4550243/">我</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的直接插入排序</title>
      <link href="/posts/f7271c1a5982/"/>
      <url>/posts/f7271c1a5982/</url>
      
        <content type="html"><![CDATA[<h2 id="单链表的直接插入排序"><a href="#单链表的直接插入排序" class="headerlink" title="单链表的直接插入排序"></a>单链表的直接插入排序</h2><div class="note success simple"><p>本文将图解LeetCode上面的一道基于单链表的直接插入排序的题</p></div><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><p><a href="/posts/a1dd46ab1c25/">基于数组的直接插入排序</a></p><h3 id="来自LeetCode的一道题对链表进行直接插入排序"><a href="#来自LeetCode的一道题对链表进行直接插入排序" class="headerlink" title="来自LeetCode的一道题对链表进行直接插入排序"></a>来自LeetCode的一道题<a href="https://leetcode.cn/problems/insertion-sort-list/">对链表进行直接插入排序</a></h3><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><ul><li>列表中的节点数在 <code>[1, 5000]</code>范围内</li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><h4 id="输入样例和输出结果"><a href="#输入样例和输出结果" class="headerlink" title="输入样例和输出结果"></a>输入样例和输出结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: head = [4,2,1,3]<br>输出: [1,2,3,4]<br></code></pre></td></tr></table></figure><p>以上面这个输入为例子，下面是表示图：<br><span style="color:green">绿色</span>：代表<strong>已经排序好的有序序列的元素</strong></p><p><span style="color:brown">褐色</span>：代表<code>base</code>即待插入的元素</p><p><span style="color:red">红色</span>：代表变量关系<br><img src="https://bu.dusays.com/2023/01/14/63c2a6500414f.png" alt="image-20230114205541206"></p><h4 id="算法思路图示-表述如下："><a href="#算法思路图示-表述如下：" class="headerlink" title="算法思路图示 + 表述如下："></a>算法思路图示 + 表述如下：</h4><p><img src="https://bu.dusays.com/2023/01/14/63c2a6c171e50.png" alt="image-20230114205746805"></p><wavy>顺序情况很容易理解，因为直接插入排序就是维护一个有序序列的过程。</wavy><p>我们来分析<wavy>逆序情况</wavy>：</p><p><img src="https://bu.dusays.com/2023/01/14/63c2a6f3ce4d3.png" alt="image-20230114205837275"></p><p>画五角星的这轮，实际上是最容易提取出 task 步骤的，请关注这一轮操作。</p><p>转换成<wavy>部分代码</wavy>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(sortedTail -&gt; val &lt;= base -&gt; val)&#123;<br>    <span class="hljs-comment">// 顺序</span><br>    sortedTail = sortedTail -&gt; next; <span class="hljs-comment">// sortedTail 后移一位    </span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// 逆序 （此处也是关注重点）</span><br>    <span class="hljs-comment">// pre处 是插入点（后插），需要循环找出来，因此 dummy 的重要性就体现出来了</span><br>    <span class="hljs-comment">// 毕竟在这个过程有一个极小的数，需要放在第一个位置，你怎么插？</span><br>    ListNode * pre = dummy;<br>    <span class="hljs-comment">// 过滤掉比base小的，使用 pre -&gt; next -&gt; val 的值来过滤，这样就能求出 插入点</span><br>    <span class="hljs-keyword">while</span>(pre -&gt; next -&gt; val &lt;= base -&gt; val) pre = pre -&gt; next;<br>    <span class="hljs-comment">// 现在 pre 处就是插入点了（后插）</span><br>    <span class="hljs-comment">// 插入三部曲，图示很清楚</span><br>    sortedTail -&gt; next = base -&gt; next;<br>    base -&gt; next = pre -&gt; next;<br>    pre -&gt; next = base;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们实现了<code>step 1</code> 和 <code>step 2</code> 了。</p><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果头结点为空或者只有一个结点，则直接返回头结点</span><br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">// 虚拟头结点，方便操作</span><br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <br>        <span class="hljs-comment">// 直接插入排序：① 默认第1个元素有序。② 第2个元素是 base</span><br>        <span class="hljs-comment">// sortedTail: 有序序列中的 最后一个结点, 在这也是元素中第1个结点</span><br>        <span class="hljs-comment">// base：第2个元素，也是待插入元素</span><br>        ListNode * sortedTail = head, * base = head -&gt; next;<br><br>        <span class="hljs-comment">// 当base不为空，则一直是排序状态</span><br>        <span class="hljs-keyword">while</span>(base)&#123;<br>            <span class="hljs-comment">// base 与 sortedTail比较</span><br>            <span class="hljs-comment">// 产生两种情况 (1. 顺序 2. 逆序)</span><br><br>            <br>            <span class="hljs-keyword">if</span>(sortedTail -&gt; val &lt;= base -&gt; val)&#123;<br>                <span class="hljs-comment">// 顺序</span><br>                sortedTail = sortedTail -&gt; next; <span class="hljs-comment">// sortedTail 后移一位    </span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 逆序，执行 task 步骤</span><br>                ListNode * pre = dummy;<br>                <span class="hljs-comment">// 过滤掉比 base 小的值，pre就是插入的位置</span><br>                <span class="hljs-keyword">while</span>(pre -&gt; next -&gt; val &lt;= base -&gt; val) pre = pre -&gt; next;<br><br>                <span class="hljs-comment">// 插入三部曲</span><br>                sortedTail -&gt; next = base -&gt; next;<br>                base -&gt; next = pre -&gt; next;<br>                pre -&gt; next = base;<br>            &#125;<br>            <span class="hljs-comment">// 注意：base总是 sortedTail的next，不能写成 base = base -&gt; next</span><br>            base = sortedTail -&gt; next;<br>        &#125;<br>        <span class="hljs-comment">// 去掉dummy，返回排序后的链表</span><br>        <span class="hljs-keyword">return</span> dummy -&gt; next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ol><li><p>时间复杂度：<br>对于链表而言，插入元素时只要更新相邻节点的指针即可，不需要像数组一样将插入位置后面的元素往后移动，因此插入操作的<strong>时间复杂度</strong>是<strong>O(1)</strong>，但是找到插入位置需要遍历链表中的节点，<strong>时间复杂度是O(n)</strong>，因此链表直接插入排序的总<strong>时间复杂度</strong>仍然是<strong>O(n<sup>2</sup>)</strong>。</p></li><li><p>空间复杂度：<br>整个排序过程中需要的额外辅助空间为 <code>dummy</code>，<code>sortedTail</code>，<code>base</code>，<code>pre</code>。<br>使用常数大小的额外空间，<strong>空间复杂度为O（1）</strong></p></li></ol><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://leetcode.cn/problems/insertion-sort-list/solution/dui-lian-biao-jin-xing-cha-ru-pai-xu-by-leetcode-s/">LeetCode官方解答</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/posts/9ec0dc442f72/"/>
      <url>/posts/9ec0dc442f72/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><div class="note success simple"><p>本文将介绍数据结构堆，以及堆排序</p></div><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一种<wavy>完全二叉树</wavy>，分为<wavy>小根堆</wavy>和<wavy>大根堆</wavy>；以大根堆为例：根≥儿子。<br>通常堆是通过<strong>一维数组</strong>来实现的。</p><p><wavy>堆的存储方式</wavy>：顺序存储（因为要支持随机索引）</p><p><emp>在数组起始下标为0的情况下</emp>：</p><p>如果根节点的编号是 x 的话，它的左儿子编号是 2x + 1，右儿子编号是 2x + 2。</p><p>一个子节点是 p 的话，它的父节点是 ⌊ (p - 1) / 2 ⌋。</p><p><emp>在数组起始下标为1的情况下</emp>：</p><p>如果根节点的编号是 x 的话，它的左儿子编号是 2x，右儿子编号是 2x + 1。</p><p>一个子节点是 p 的话，它的父节点是 ⌊ p / 2 ⌋。</p><div class="tip blue"><p>在数组起始下标为1的情况下</p></div><p><wavy>大根堆的创建</wavy>：</p><p><img src="https://bu.dusays.com/2023/02/01/63da191470816.png" alt="image-20230201135015855"></p><p><img src="https://bu.dusays.com/2023/02/01/63da1cc17a06d.png" alt="image-20230201160315416"></p><p><wavy>大根堆的删除（堆顶）</wavy>：</p><p>将堆的最后一个元素覆盖堆顶元素，堆的大小减1。（最后一个元素很好删）</p><p>然后，从堆顶开始 down 一遍。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用大根堆，基于大根堆的操作基础；堆顶元素总是最大值，每次将堆顶元素与堆中最后一个元素互换，将堆的大小减1，然后 <code>down(1)</code>维护大根堆。反复如此，直到 n 个元素，执行 n - 1 次这样的操作，排序完成。</p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p><wavy>时间复杂度</wavy>：初始化建堆时间是O(n)，更改堆元素后重建堆时间是O(nlogn)，但一般认为全部情况都是O(nlogn)</p><p><wavy>空间复杂度</wavy>：O(1)</p><p><wavy>稳定性</wavy>：不稳定</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><p>需要注意的是，需要维护一个变量 <code>sz</code>，它代表堆的容量</p><p><emp>在数组起始下标为1的情况下</emp>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 维护以 u 为根的堆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> &lt;= sz &amp;&amp; q[u * <span class="hljs-number">2</span>] &gt; q[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= sz &amp;&amp; q[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &gt; q[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 如果 t 和 u 不相等，说明有 儿子比父亲大，应该进行交换，然后进行维护之前儿子在的位置</span><br>    <span class="hljs-keyword">if</span>(u != t)&#123;<br>        <span class="hljs-built_in">swap</span>(q[t],q[u]);<br>        <span class="hljs-comment">// 如果是上层发生改变，可能会牵涉到下层，因此需要递归down下去</span><br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">()</span></span>&#123;<br>    sz = n;<br>    <span class="hljs-comment">// 从有分支的结点开始down</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> ; i ; i--) <span class="hljs-built_in">down</span>(i);<br><br>    <span class="hljs-comment">// down完之后堆顶是最大的元素, 利用大根堆性质，进行n - 1次与数组最后一个元素交换可以进行排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n - <span class="hljs-number">1</span> ; i++)&#123;<br>        <span class="hljs-built_in">swap</span>(q[<span class="hljs-number">1</span>],q[sz]);<br>        sz--;<br>        <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://oi-wiki.org/basic/heap-sort/">Wiki</a><br><a href="https://www.acwing.com/activity/content/code/content/4550243/">我</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/posts/15ae1352a338/"/>
      <url>/posts/15ae1352a338/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><div class="note success simple"><p>本文将介绍王道书上的快排模板和一种不同于老教材的快排模板，图示是根据考研书上画的</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>快速排序的核心操作为「哨兵划分」，其目标为：<wavy>选取数组某个元素为基准数，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边</wavy>。「哨兵划分」执行完毕后，原数组被划分成两个部分，即 <wavy>左子数组</wavy> 和 <wavy>右子数组</wavy>，且满足 <wavy>左子数组任意元素 ＜ 基准数 ＜ 右子数组任意元素</wavy>。因此，接下来我们只需要排序两个子数组即可，再将两个子数组执行「哨兵划分」……；直至子数组长度为1时<wavy>终止递归</wavy>。</p><p>一个简单的例子：</p><p><img src="https://bu.dusays.com/2023/01/24/63cf7ee962723.png" alt="image-20230124144637959"></p><p>以上是快速排序第一轮的模拟。</p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p><wavy>时间复杂度</wavy>：</p><ul><li>快速排序的<wavy>平均情况下的运行时间与其最佳情况下的运行时间很接近都是O(nlogn)</wavy></li><li>快速排序的运行时间与划分是否对称有关，<wavy>快速排序的最坏情况发生在两个区域分别包含 n - 1 个元素和 0 个元素时</wavy>，这种最大限度的不对称若发生在每层递归上，本应是二叉树的递归树退化成一叉树（单链表），<wavy>即对应于初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度O(n<sup>2</sup>)</wavy>。</li></ul><wavy>空间复杂度</wavy>：由于快速排序是递归的，<wavy>需要借助一个递归工作栈</wavy><ul><li>最好情况：O(logn) （二叉树）</li><li>平均情况：O(logn) （二叉树）</li><li>最坏情况：由于要进行 n - 1 次递归调用，所以栈的深度为O(n)</li></ul><wavy>稳定性</wavy>：不稳定<br><br><div class="tip "><p>在快速排序算法中，每趟排序后会将枢轴（基准）元素放到其最终位置上。（考研写法） </p></div><h3 id="快速排序为什么快？"><a href="#快速排序为什么快？" class="headerlink" title="快速排序为什么快？"></a>快速排序为什么快？</h3><p>从命名能够看出，快速排序在效率方面一定“有两把刷子”。快速排序的平均时间复杂度虽然与「归并排序」和「堆排序」一致，但实际 <strong>效率更高</strong>，这是因为：</p><ul><li><strong>出现最差情况的概率很低</strong>：虽然快速排序的最差时间复杂度为 O(n<sup>2</sup>) ，不如归并排序，但绝大部分情况下，快速排序可以达到 O(nlogn) 的复杂度。</li><li><strong>缓存使用效率高</strong>：哨兵划分操作时，将整个子数组加载入缓存中，访问元素效率很高。而诸如「堆排序」需要跳跃式访问元素，因此不具有此特性。</li><li><strong>复杂度的常数系数低</strong>：在提及的三种算法中，快速排序的 <strong>比较</strong>、<strong>赋值</strong>、<strong>交换</strong> 三种操作的总体数量最少（类似于「插入排序」快于「冒泡排序」的原因）。</li></ul><h3 id="算法模板1（背诵适合面试）"><a href="#算法模板1（背诵适合面试）" class="headerlink" title="算法模板1（背诵适合面试）"></a>算法模板1（背诵适合面试）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l , <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-comment">// 区间大小为1，跳出循环</span><br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 一开始 左边是 -1 右边是 length, pivot不取第一个元素是避免出现极端情况退化成单链表</span><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span> , j = r + <span class="hljs-number">1</span> , pivot = q[(l + r) &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; pivot);<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; pivot);<br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(q[i],q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(l,j);<br>    <span class="hljs-built_in">quick_sort</span>(j+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法模板2（考研版本）"><a href="#算法模板2（考研版本）" class="headerlink" title="算法模板2（考研版本）"></a>算法模板2（考研版本）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-type">int</span> pivot = q[i];<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; q[j] &gt;= pivot) --j;<br>        q[i] = q[j];<br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; q[i] &lt;= pivot) ++i;<br>        q[j] = q[i];<br>    &#125;<br>    q[i] = pivot;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt; r)&#123;<br>        <span class="hljs-type">int</span> pivot_pos = <span class="hljs-built_in">partition</span>(l,r);<br>        <span class="hljs-built_in">quick_sort</span>(l, pivot_pos - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quick_sort</span>(pivot_pos + <span class="hljs-number">1</span>, r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上两种模板，各有缺点：</p><ul><li><wavy>第一种模板的pivot最终不一定是在分界点上，而教材上的pivot最终一定是在分界点上的</wavy>    </li><li><wavy>第二种模板的分界点取每个区间的第一个元素作为pivot，若被卡数据，比如：顺序或逆序，让二叉树退化成一叉链表。这样就会TLE(Time Limit Exceeded)</wavy></li></ul><p>第一种适合算法模板（短），第二种适合考研写法。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><a href="/posts/1e599f9c3b25">第k个数</a></p><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://www.hello-algo.com/chapter_sorting/quick_sort/">hello-algo</a></p><p><a href="https://www.acwing.com/activity/content/code/content/4550243/">我</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/posts/0f47dab8531e/"/>
      <url>/posts/0f47dab8531e/</url>
      
        <content type="html"><![CDATA[<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><div class="note success simple"><p>本文将用图例介绍希尔排序的过程，和经典的优化板子</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>对 n 个序列进行分组，每组内的下标是等差数列，其公差就是增量，每一组的等差数列的公差相等，然后对每组序列进行<wavy>直接插入排序</wavy>，然后将增量缩小（例如：n/2、n/4、n/8,…）<wavy>直至每组元素只有1个</wavy>，然后再进行一次直接插入排序。</p><div class="tip "><p>直接插入排序对于部分有序的序列效率很高</p></div><p>一个简单的例子：</p><p><img src="https://bu.dusays.com/2023/01/24/63cf49a9cd35d.png" alt="image-20230124105921140"></p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p><wavy>时间复杂度</wavy>：希尔排序的平均时间复杂度和最坏时间复杂度与间距序列的选取（就是间距如何减小到 1）有关，比如「间距每次除以 3」的希尔排序的时间复杂度是O(n<sup>3/2</sup>)</p><p><wavy>空间复杂度</wavy>：O（1）</p><p><wavy>稳定性</wavy>：不稳定</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 分组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d = n / <span class="hljs-number">3</span> ; d ; d = d == <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : d / <span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-comment">// start是每组的第一个元素的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> start = <span class="hljs-number">0</span> ; start &lt; d ; start++)&#123;<br>            <span class="hljs-comment">// 直接插入排序(找到组内第二个元素)</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start + d ; i &lt; n ; i += d)&#123;<br>                <span class="hljs-type">int</span> base = q[i] , j = i;<br><br>                <span class="hljs-keyword">while</span>(j &gt; start &amp;&amp; q[j - d] &gt; base)&#123;<br>                    q[j] = q[j - d];<br>                    j -= d;<br>                &#125;<br>                q[j] = base;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://www.acwing.com/activity/content/code/content/4550243/">我</a></p><p><a href="https://oi-wiki.org/basic/shell-sort/">Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单选择排序</title>
      <link href="/posts/1421240f22ac/"/>
      <url>/posts/1421240f22ac/</url>
      
        <content type="html"><![CDATA[<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><div class="note success simple"><p>本文将用图例介绍冒泡排序的过程，和经典的优化板子</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>每一趟（如第 i 趟）在后面 n - i + 1（i从1开始）个待排序元素中选取最小的元素，作为有序子序列的第 i 个元素，直到 n - 1 趟做完，只剩最后一个元素时，就不需要再选了。</p><p>一个简单的例子：</p><p><img src="https://bu.dusays.com/2023/01/22/63cd4bd4ee6e5.png" alt="image-20230122222342741"></p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p><wavy>时间复杂度</wavy>：雷打不动O(n<sup>2</sup>)，堪称经典内排序里面最弱的</p><p><wavy>空间复杂度</wavy>：O(1)</p><p><wavy>稳定性</wavy>：不稳定</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">select_sort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// n个元素，比 n - 1 趟</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n - <span class="hljs-number">1</span> ; i++)&#123;<br>        <span class="hljs-type">int</span> k = i; <span class="hljs-comment">// 记录最小的那个元素下标，一开始默认第一个</span><br>        <br>        <span class="hljs-comment">// 从第二个开始找，找到最后，与记录的最小值一一比较</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span> ; j &lt; n ; j++)&#123;<br>            <span class="hljs-comment">// 如果出现更小的就替换给 k</span><br>            <span class="hljs-keyword">if</span>(q[j] &lt; q[k])<br>                k = j;<br>        &#125;<br>        <span class="hljs-comment">// 最小的元素和下标为i的元素交换</span><br>        <span class="hljs-built_in">swap</span>(q[i],q[k]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://www.acwing.com/activity/content/code/content/4550243/">我</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/posts/085c695cb1f5/"/>
      <url>/posts/085c695cb1f5/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><div class="note success simple"><p>本文将用图例介绍冒泡排序的过程，和经典的优化板子</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><strong>从后往前</strong>（或从前往后），两两比较相邻元素的值，<strong>若为逆序</strong>（q[i - 1] &gt; q[i]），<strong>则交换它们</strong>，直到序列比较完。</p><p>一个简单的例子：</p><p><img src="https://bu.dusays.com/2023/01/22/63ccdf3d64573.png" alt="image-20230122144353880"></p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p><wavy>时间复杂度</wavy>：</p><ul><li>最好情况：O(n)</li><li>平均情况：O(n<sup>2</sup>)</li><li>最坏情况：O(n<sup>2</sup>)</li></ul><p><wavy>空间复杂度</wavy>：O(1)</p><p><wavy>稳定性</wavy>：稳定</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// n个元素，比 n - 1 趟</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n - <span class="hljs-number">1</span> ; i++)&#123;<br>        <span class="hljs-comment">// 优化，这样可以当元素有序时，一趟就退出</span><br>        <span class="hljs-comment">// 有没有交换过</span><br>        <span class="hljs-type">bool</span> has_swap = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 从后往前枚举，由于比较的是相邻元素，j到 i + 1 就行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span> ; j &gt; i ; j--)&#123;<br>            <span class="hljs-comment">// 逆序</span><br>            <span class="hljs-keyword">if</span>(q[j - <span class="hljs-number">1</span>] &gt; q[j])&#123;<br>                <span class="hljs-built_in">swap</span>(q[j - <span class="hljs-number">1</span>], q[j]);<br>                has_swap = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果没有交换过，代表整个序列在第一趟检测出有序，直接退出排序</span><br>        <span class="hljs-keyword">if</span>(!has_swap) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://www.acwing.com/activity/content/code/content/4550243/">我</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>折半查找插入排序</title>
      <link href="/posts/122fd3617f53/"/>
      <url>/posts/122fd3617f53/</url>
      
        <content type="html"><![CDATA[<h2 id="折半查找插入排序"><a href="#折半查找插入排序" class="headerlink" title="折半查找插入排序"></a>折半查找插入排序</h2><div class="note success simple"><p>本文将结合 <code>二分查找</code> 和 <code>直接插入排序</code> 的知识点，介绍折半查找插入排序</p></div><emp>你可以通过点击以往文章回顾知识点:</emp><h3 id="点击-gt-二分查找"><a href="#点击-gt-二分查找" class="headerlink" title="点击 -&gt; 二分查找"></a>点击 -&gt; <a href="/posts/1893f995f535/">二分查找</a></h3><h3 id="点击-gt-直接插入排序"><a href="#点击-gt-直接插入排序" class="headerlink" title="点击 -&gt; 直接插入排序"></a>点击 -&gt; <a href="/posts/15cc1348375f/">直接插入排序</a></h3><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>在维护一个有序序列的过程中，从左往右看，使用二分查找出第一个比 <code>base</code> 大的数的位置 <code>l</code>，然后将元素后移，在 <code>l</code> 处腾出空间，将 <code>base</code> 插入。</p><p>一个简单的例子：</p><p><img src="https://bu.dusays.com/2023/01/22/63cd56119d7f3.png" alt="image-20230122232426185"></p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">binary_insert_sort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 维护一个有序序列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i++)&#123;<br>        <span class="hljs-comment">// 相邻元素顺序情况</span><br>        <span class="hljs-keyword">if</span>(q[i - <span class="hljs-number">1</span>] &lt;= q[i]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 相邻元素逆序情况</span><br>        <span class="hljs-comment">// 二分，从左往右找到第一个大于 base 的数</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = i, base = q[i];<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(q[mid] &gt; base) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将 l 空出来</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span> ; j &gt;= l ; j--)<br>            q[j + <span class="hljs-number">1</span>] = q[j]; <span class="hljs-comment">// 元素后移，空出 l 这个位置</span><br>        <span class="hljs-comment">// 插入</span><br>        q[l] = base;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="折半查找插入排序-VS-直接插入排序"><a href="#折半查找插入排序-VS-直接插入排序" class="headerlink" title="折半查找插入排序  VS  直接插入排序"></a>折半查找插入排序  VS  直接插入排序</h3><p><wavy>时间复杂度</wavy>：</p><ul><li>最好情况：O(n)</li><li>平均情况：理论上来说，折半查找插入排序是比直接插入排序要快的，毕竟是直接插入排序的优化版本。折半查找插入排序通过二分来优化比较次数，时间复杂度是O(nlogn)，但是移动次数并没有优化，因此时间复杂度还是O(n<sup>2</sup>)与直接插入排序一样。</li><li>最坏情况：O(n<sup>2</sup>)</li></ul><p><wavy>空间复杂度</wavy>：O(1)(都是常数额外辅助空间)</p><p><wavy>稳定性</wavy>：稳定（相同大小元素不改变相对位置）</p><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://www.acwing.com/problem/content/787/">我自己</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/posts/1893f995f535/"/>
      <url>/posts/1893f995f535/</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><div class="note success simple"><p>本文将使用画图来理解二分，并且介绍了经典的二分查找板子，例题。</p></div><p>能够使用二分查找的两个前提：</p><ul><li><wavy>二分查找仅使用于数组</wavy>，这样才能通过判断大小关系来排除一半的搜索区间；</li><li><wavy>要求输入数据是有序的</wavy>，而在链表中使用效率很低，因为其在循环中需要跳跃式（非连续地）访问元素。</li></ul><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p>根据上面两个前提，很多人认为二分的本质是<emp>单调性</emp>，但实际上并不是的，二分的本质是<emp>边界</emp>。</p><p>假设给定一个区间，在这个区间上给定了某种性质，使得在右半区间满足这个性质，左半区间不满足这个性质，那么二分既能够查找左半区间的边界，也可以寻找右半区间的边界。</p><p><img src="https://bu.dusays.com/2023/01/18/63c806098d17f.png" alt="image-20230118203344229"></p><p>现在我们来看一下 <span style="color:red">左半区间二分查找：</span></p><p><img src="https://bu.dusays.com/2023/01/18/63c8060ee4081.png" alt="image-20230118213519331"></p><p>再看一下<span style="color:green">右半区间二分查找：</span></p><p><img src="https://bu.dusays.com/2023/01/18/63c8061474bb0.png" alt="image-20230118214805016"></p><p>那么这里有一个问题，<div class="tip "><p>为什么两种二分，mid的写法有一个 + 1有一个并没有（对应向上取整和向下取整）</p></div></p><p>下面举一个例子：</p><p>看一下为什么要加上1</p><p><img src="https://bu.dusays.com/2023/01/18/63c8061bdaa0f.png" alt="image-20230118221434740"></p><h3 id="整数二分实战思想"><a href="#整数二分实战思想" class="headerlink" title="整数二分实战思想"></a>整数二分实战思想</h3><p>如果你想让<wavy>答案在右边区间</wavy>，<wavy>那么你得让mid满足左区间的性质</wavy>，反之,可求左区间</p><h3 id="整数二分实战模板"><a href="#整数二分实战模板" class="headerlink" title="整数二分实战模板"></a>整数二分实战模板</h3><p>二分模板一共有两个，分别适用于不同情况。</p><h4 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h4><p>其更新操作是r = mid，计算mid时不需要加1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/01/18/63c8061f58820.png" alt="image-20230118224520428"></p><h4 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h4><p>其更新操作是l = mid，此时为了防止死循环，计算mid时需要加1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/01/18/63c8062229fdc.png" alt="image-20230118224158712"></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><emp>时间复杂度：O(logn)</emp>（折半查找树）</p><p><emp>空间复杂度：O(1)</emp>（使用常数大小空间 l, r, mid)</p><div class="tip warning"><p>大数越界处理</p></div><p>当数组长度很大时，加法 (l + r) 的结果可能超出 <code>int</code> 类型的取值范围。可换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 换成</span><br><span class="hljs-type">int</span> mid = l + (r - l) &gt;&gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="整数二分经典例题"><a href="#整数二分经典例题" class="headerlink" title="整数二分经典例题"></a>整数二分经典例题</h3><h4 id="AcWing789-数的范围"><a href="#AcWing789-数的范围" class="headerlink" title="AcWing789.数的范围"></a><a href="https://www.acwing.com/problem/content/791/">AcWing789.数的范围</a></h4><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</p><p>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 q，表示数组长度和询问个数。</p><p>第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。</p><p>接下来 q 行，每行包含一个整数 k，表示一个询问元素。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n ≤ 100000<br>1 ≤ q ≤ 10000<br>1 ≤ k ≤ 10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">6 3<br>1 2 2 3 3 4<br>3<br>4<br>5<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 4<br>5 5<br>-1 -1<br></code></pre></td></tr></table></figure><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n, Q; <span class="hljs-comment">// 整数个数、询问个数</span><br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; Q;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];<br>    <br>    <span class="hljs-keyword">while</span>(Q --)&#123;<br>        <span class="hljs-comment">// 需要查找的数</span><br>        <span class="hljs-type">int</span> x; cin &gt;&gt; x;<br>        <br>        <span class="hljs-comment">// 第一次二分</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span> , r = n - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">// 先找左边开始，第一个出现的 x，那么满足右边性质即可</span><br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(q[mid] &gt;= x) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果没找到</span><br>        <span class="hljs-keyword">if</span>(q[l] != x) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1 -1&quot;</span>);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 如果找到了</span><br>            cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-comment">// 开始找右边开始，第一个出现的x，那么满足左边的性质即可</span><br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span> , r = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(q[mid] &lt;= x) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">//if(q[l] != x) puts(&quot;-1&quot;); </span><br>            <span class="hljs-comment">// else cout &lt;&lt; l &lt;&lt; endl;</span><br>            <span class="hljs-comment">// 就算从右边也一定会找到一个值，它可以是左边开始找，找到的那个x</span><br>            cout &lt;&lt; l &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浮点数二分经典例题"><a href="#浮点数二分经典例题" class="headerlink" title="浮点数二分经典例题"></a>浮点数二分经典例题</h3><h4 id="AcWing-790-数的三次方根"><a href="#AcWing-790-数的三次方根" class="headerlink" title="AcWing 790. 数的三次方根"></a><a href="https://www.acwing.com/problem/content/792/">AcWing 790. 数的三次方根</a></h4><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个浮点数 n，求它的三次方根。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个浮点数 n 。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个浮点数，表示问题的解。</p><p>注意，结果保留 6 位小数。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>−10000 ≤ n ≤ 10000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1000.00<br></code></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">10.000000<br></code></pre></td></tr></table></figure><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-type">double</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-comment">// 依据数据范围取[min, max]</span><br>    <span class="hljs-type">double</span> l = <span class="hljs-number">-10000</span> , r = <span class="hljs-number">10000</span>;<br>    <span class="hljs-comment">// 调整精度</span><br>    <span class="hljs-keyword">while</span>(r - l &gt; <span class="hljs-number">1e-8</span>)&#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid * mid * mid &gt;= n) r = mid; <span class="hljs-comment">// 重点</span><br>        <span class="hljs-keyword">else</span> l = mid; <span class="hljs-comment">// 重点</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span> , l);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h2><p><a href="https://www.hello-algo.com/chapter_searching/binary_search/">hello-algo</a><br><a href="https://www.acwing.com/activity/content/code/content/4690436/">AcWing789.数的范围</a><br><a href="https://www.acwing.com/activity/content/code/content/4690546/">AcWing 790. 数的三次方根</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 查找算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直接插入排序</title>
      <link href="/posts/a1dd46ab1c25/"/>
      <url>/posts/a1dd46ab1c25/</url>
      
        <content type="html"><![CDATA[<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><div class="note success simple"><p>本文将介绍<strong>基于数组</strong>的直接插入排序</p></div><p><strong>算法的思想</strong>：<strong>维护一个有序序列</strong>，初始时<strong>有序序列只有一个元素</strong>即为<strong>第1个元素</strong>，随后选定数组的<strong>第2个元素</strong>为<strong>待插入元素</strong> <code>base</code> ，将 <code>base</code> 与其左边的元素依次对比大小，并“插入”到正确位置。每次将一个新的元素插入到有序序列中，将有序序列的长度增加 1，直到全部元素都加入到有序序列中。</p><p><strong>一个简单的例子：</strong><br><img src="https://bu.dusays.com/2023/01/14/63c24f0730913.png" alt="image-20230114144248474"></p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol><li>第1轮先选取排序元素中的<strong>第2个元素</strong>为<code>base</code>，<code>base</code>与它之前的所有元素一一比较，然后执行<span class='p red'>插入</span>操作，至此<strong>元素中前2个元素已完成排序</strong>。</li><li>第2轮先选取排序元素中的<strong>第3个元素</strong>为<code>base</code>，<code>base</code>与它之前的所有元素一一比较，然后执行<span class='p red'>插入</span>操作，至此<strong>元素中前3个元素已完成排序</strong>。</li></ol><p>这样排序就完成了，有序序列长度从1变成了3，这个过程进行了<strong>2轮</strong></p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p><strong>时间复杂度O(n<sup>2</sup>)</strong>：</p><ul><li>最好情况：<strong>O(n)</strong>，比如：[1,2,3,4,5] 有序情况，整个过程<strong>未进行任何插入操作</strong>，<strong>仅进行比较操作</strong></li><li>平均情况：O(n<sup>2</sup>)</li><li>最差情况：各轮插入操作循环n-1，n-2，…，2，1次，求和为 ((n - 1) x n ) / 2，使用<strong>O(n<sup>2</sup>)</strong>时间。</li></ul><p><strong>空间复杂度O(1)</strong>：变量 i , j 使用常数大小的额外空间。</p><p><strong>稳定性</strong>：<strong>稳定</strong>（不交换相等元素）</p><h3 id="直接插入排序-vs-冒泡排序"><a href="#直接插入排序-vs-冒泡排序" class="headerlink" title="直接插入排序 vs 冒泡排序"></a>直接插入排序 vs 冒泡排序</h3><p style="color:red">虽然「直接插入排序」和「冒泡排序」的时间复杂度皆为O(n<sup>2</sup>) ，但实际运行速度却有很大差别，这是为什么呢？</p><p>回顾复杂度分析，两个方法的循环次数都是((n - 1) x n )/2。但不同的是，「冒泡操作」是在做<emp>元素交换</emp>，需要借助一个临时变量实现，共 3 个单元操作；而「插入操作」是在做<emp>赋值</emp>，只需 1 个单元操作；因此，可以粗略估计出冒泡排序的计算开销约为直接插入排序的 3 倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 冒泡排序的 元素交换</span><br><span class="hljs-built_in">swap</span>(q[j], q[j + <span class="hljs-number">1</span>]); <span class="hljs-comment">// 这个函数实现一下就知道了 共3个单元操作</span><br><span class="hljs-comment">// 直接插入排序的 赋值</span><br>q[j + <span class="hljs-number">1</span>] = q[j];<br></code></pre></td></tr></table></figure><p>直接插入排序运行速度快，并且具有原地（指针变量仅使用常数大小额外空间）、稳定（不交换相等元素）、自适应（最佳情况下，时间复杂度为O(n<sup>2</sup>)的优点，因此很受欢迎。实际上，包括 Java 在内的许多编程语言的排序库函数的实现都用到了直接插入排序。库函数的大致思路：</p><ul><li>对于<strong>长数组</strong>，采用基于分治的排序算法，例如<strong>快速排序</strong>，时间复杂度为O(nlogn)</li><li>对于<strong>短数组</strong>，直接使用<strong>直接插入排序</strong>，时间复杂度为O(n<sup>2</sup>)</li></ul><p>在数组较短时，复杂度中的常数项（即每轮中的单元操作数量）占主导作用，此时插入排序运行地更快。</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_sort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 外层循环保证 n - 1 趟的同时</span><br>    <span class="hljs-comment">// 还保证了选取 第2个 元素作为base</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i++)&#123;<br>        <span class="hljs-type">int</span> base = q[i] , j = i;<br>        <span class="hljs-comment">// 如果 j 大于 0 并且 base 比 q[j - 1] 小</span><br>        <span class="hljs-keyword">while</span>(j &amp;&amp; base &lt; q[j - <span class="hljs-number">1</span>])&#123;<br>            q[j] = q[j - <span class="hljs-number">1</span>];<br>            j--;<br>        &#125;<br>        q[j] = base;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><a href="/posts/f7271c1a5982">单链表的直接插入排序</a></p><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://www.hello-algo.com/chapter_sorting/insertion_sort/">Hello 算法</a><br><a href="https://www.acwing.com/activity/content/code/content/4550243/">我自己</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 算法模板 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
