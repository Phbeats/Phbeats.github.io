<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试文章</title>
      <link href="/posts/475f6642ad39/"/>
      <url>/posts/475f6642ad39/</url>
      
        <content type="html"><![CDATA[<h3 id="这是我的第一篇测试文章"><a href="#这是我的第一篇测试文章" class="headerlink" title="这是我的第一篇测试文章"></a>这是我的第一篇测试文章</h3>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直接插入排序</title>
      <link href="/posts/15cc1348375f/"/>
      <url>/posts/15cc1348375f/</url>
      
        <content type="html"><![CDATA[<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><div class="note success simple"><p>本文将介绍<strong>基于数组</strong>的插入排序和<strong>基于单链表</strong>的插入排序。</p></div><p><strong>插入排序的思想</strong>：<strong>维护一个有序序列</strong>，初始时<strong>有序序列只有一个元素</strong>即为<strong>第1个元素</strong>，随后选定数组的<strong>第2个元素</strong>为<strong>待插入元素</strong> <code>base</code> ，将 <code>base</code> 与其左边的元素依次对比大小，并“插入”到正确位置。每次将一个新的元素插入到有序序列中，将有序序列的长度增加 1，直到全部元素都加入到有序序列中。</p><p><strong>一个简单的例子：</strong><br><img src="https://bu.dusays.com/2023/01/14/63c24f0730913.png" alt="image-20230114144248474"></p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol><li>第1轮先选取排序元素中的<strong>第2个元素</strong>为<code>base</code>，<code>base</code>与它之前的所有元素一一比较，然后执行<span class='p red'>插入</span>操作，至此<strong>元素中前2个元素已完成排序</strong>。</li><li>第2轮先选取排序元素中的<strong>第3个元素</strong>为<code>base</code>，<code>base</code>与它之前的所有元素一一比较，然后执行<span class='p red'>插入</span>操作，至此<strong>元素中前3个元素已完成排序</strong>。</li></ol><p>这样排序就完成了，有序序列长度从1变成了3，这个过程进行了<strong>2轮</strong></p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p><strong>时间复杂度O(n<sup>2</sup>)</strong>：</p><ul><li>最差情况下，各轮插入操作循环n-1，n-2，…，2，1次，求和为 ((n - 1) x n ) / 2，使用<strong>O(n<sup>2</sup>)</strong>时间。</li><li>最好情况：<strong>O(n)</strong>，比如：[1,2,3,4,5] 有序情况，整个过程<strong>未进行任何插入操作</strong>，<strong>仅进行比较操作</strong></li></ul><p><strong>空间复杂度O(1)</strong>：变量 i , j 使用常数大小的额外空间。</p><p><strong>稳定性</strong>：<strong>稳定</strong>（不交换相等元素）</p><h3 id="插入排序-vs-冒泡排序"><a href="#插入排序-vs-冒泡排序" class="headerlink" title="插入排序 vs 冒泡排序"></a>插入排序 vs 冒泡排序</h3><p style="color:red">虽然「插入排序」和「冒泡排序」的时间复杂度皆为O(n<sup>2</sup>) ，但实际运行速度却有很大差别，这是为什么呢？</p><p>回顾复杂度分析，两个方法的循环次数都是((n - 1) x n )/2。但不同的是，「冒泡操作」是在做<emp>元素交换</emp>，需要借助一个临时变量实现，共 3 个单元操作；而「插入操作」是在做<emp>赋值</emp>，只需 1 个单元操作；因此，可以粗略估计出冒泡排序的计算开销约为插入排序的 3 倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序的 元素交换</span></span><br><span class="line"><span class="built_in">swap</span>(q[j], q[j + <span class="number">1</span>]); <span class="comment">// 这个函数实现一下就知道了 共3个单元操作</span></span><br><span class="line"><span class="comment">// 插入排序的 赋值</span></span><br><span class="line">q[j + <span class="number">1</span>] = q[j];</span><br></pre></td></tr></table></figure><p>插入排序运行速度快，并且具有原地（指针变量仅使用常数大小额外空间）、稳定（不交换相等元素）、自适应（最佳情况下，时间复杂度为O(n<sup>2</sup>)的优点，因此很受欢迎。实际上，包括 Java 在内的许多编程语言的排序库函数的实现都用到了插入排序。库函数的大致思路：</p><ul><li>对于<strong>长数组</strong>，采用基于分治的排序算法，例如<strong>快速排序</strong>，时间复杂度为O(nlogn)</li><li>对于<strong>短数组</strong>，直接使用<strong>插入排序</strong>，时间复杂度为O(n<sup>2</sup>)</li></ul><p>在数组较短时，复杂度中的常数项（即每轮中的单元操作数量）占主导作用，此时插入排序运行地更快。</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 外层循环保证 n - 1 趟的同时</span></span><br><span class="line">    <span class="comment">// 还保证了选取 第2个 元素作为base</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="type">int</span> base = q[i] , j = i;</span><br><span class="line">        <span class="comment">// 如果 j 大于 0 并且 base 比 q[j - 1] 小</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; base &lt; q[j - <span class="number">1</span>])&#123;</span><br><span class="line">            q[j] = q[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        q[j] = base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="来自LeetCode的一道题对链表进行插入排序"><a href="#来自LeetCode的一道题对链表进行插入排序" class="headerlink" title="来自LeetCode的一道题对链表进行插入排序"></a>来自LeetCode的一道题<a href="https://leetcode.cn/problems/insertion-sort-list/">对链表进行插入排序</a></h4><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><ul><li>列表中的节点数在 <code>[1, 5000]</code>范围内</li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><h4 id="输入样例和输出结果"><a href="#输入样例和输出结果" class="headerlink" title="输入样例和输出结果"></a>输入样例和输出结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,2,1,3]</span><br><span class="line">输出: [1,2,3,4]</span><br></pre></td></tr></table></figure><p>以上面这个输入为例子，下面是表示图：<br><span style="color:green">绿色</span>：代表<strong>已经排序好的有序序列的元素</strong></p><p><span style="color:brown">褐色</span>：代表<code>base</code>即待插入的元素</p><p><span style="color:red">红色</span>：代表变量关系<br><img src="https://bu.dusays.com/2023/01/14/63c2a6500414f.png" alt="image-20230114205541206"></p><h4 id="算法思路图示-表述如下："><a href="#算法思路图示-表述如下：" class="headerlink" title="算法思路图示 + 表述如下："></a>算法思路图示 + 表述如下：</h4><p><img src="https://bu.dusays.com/2023/01/14/63c2a6c171e50.png" alt="image-20230114205746805"></p><wavy>顺序情况很容易理解，因为插入排序就是维护一个有序序列的过程。</wavy><p>我们来分析<wavy>逆序情况</wavy>：</p><p><img src="https://bu.dusays.com/2023/01/14/63c2a6f3ce4d3.png" alt="image-20230114205837275"></p><p>画五角星的这轮，实际上是最容易提取出 task 步骤的，请关注这一轮操作。</p><p>转换成<wavy>部分代码</wavy>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sortedTail -&gt; val &lt;= base -&gt; val)&#123;</span><br><span class="line">    <span class="comment">// 顺序</span></span><br><span class="line">    sortedTail = sortedTail -&gt; next; <span class="comment">// sortedTail 后移一位    </span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 逆序 （此处也是关注重点）</span></span><br><span class="line">    <span class="comment">// pre处 是插入点（后插），需要循环找出来，因此 dummy 的重要性就体现出来了</span></span><br><span class="line">    <span class="comment">// 毕竟在这个过程有一个极小的数，需要放在第一个位置，你怎么插？</span></span><br><span class="line">    ListNode * pre = dummy;</span><br><span class="line">    <span class="comment">// 过滤掉比base小的，使用 pre -&gt; next -&gt; val 的值来过滤，这样就能求出 插入点</span></span><br><span class="line">    <span class="keyword">while</span>(pre -&gt; next -&gt; val &lt;= base -&gt; val) pre = pre -&gt; next;</span><br><span class="line">    <span class="comment">// 现在 pre 处就是插入点了（后插）</span></span><br><span class="line">    <span class="comment">// 插入三部曲，图示很清楚</span></span><br><span class="line">    sortedTail -&gt; next = base -&gt; next;</span><br><span class="line">    base -&gt; next = pre -&gt; next;</span><br><span class="line">    pre -&gt; next = base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们实现了<code>step 1</code> 和 <code>step 2</code> 了。</p><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果头结点为空或者只有一个结点，则直接返回头结点</span></span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 虚拟头结点，方便操作</span></span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入排序：① 默认第1个元素有序。② 第2个元素是 base</span></span><br><span class="line">        <span class="comment">// sortedTail: 有序序列中的 最后一个结点, 在这也是元素中第1个结点</span></span><br><span class="line">        <span class="comment">// base：第2个元素，也是待插入元素</span></span><br><span class="line">        ListNode * sortedTail = head, * base = head -&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当base不为空，则一直是排序状态</span></span><br><span class="line">        <span class="keyword">while</span>(base)&#123;</span><br><span class="line">            <span class="comment">// base 与 sortedTail比较</span></span><br><span class="line">            <span class="comment">// 产生两种情况 (1. 顺序 2. 逆序)</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(sortedTail -&gt; val &lt;= base -&gt; val)&#123;</span><br><span class="line">                <span class="comment">// 顺序</span></span><br><span class="line">                sortedTail = sortedTail -&gt; next; <span class="comment">// sortedTail 后移一位    </span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 逆序，执行 task 步骤</span></span><br><span class="line">                ListNode * pre = dummy;</span><br><span class="line">                <span class="comment">// 过滤掉比 base 小的值，pre就是插入的位置</span></span><br><span class="line">                <span class="keyword">while</span>(pre -&gt; next -&gt; val &lt;= base -&gt; val) pre = pre -&gt; next;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 插入三部曲</span></span><br><span class="line">                sortedTail -&gt; next = base -&gt; next;</span><br><span class="line">                base -&gt; next = pre -&gt; next;</span><br><span class="line">                pre -&gt; next = base;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意：base总是 sortedTail的next，不能写成 base = base -&gt; next</span></span><br><span class="line">            base = sortedTail -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉dummy，返回排序后的链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ol><li><p>时间复杂度：<br>对于链表而言，插入元素时只要更新相邻节点的指针即可，不需要像数组一样将插入位置后面的元素往后移动，因此插入操作的<strong>时间复杂度</strong>是<strong>O(1)</strong>，但是找到插入位置需要遍历链表中的节点，<strong>时间复杂度是O(n)</strong>，因此链表插入排序的总<strong>时间复杂度</strong>仍然是<strong>O(n<sup>2</sup>)</strong>。</p></li><li><p>空间复杂度：<br>整个排序过程中需要的额外辅助空间为 <code>dummy</code>，<code>sortedTail</code>，<code>base</code>，<code>pre</code>。<br>使用常数大小的额外空间，<strong>空间复杂度为O（1）</strong></p></li></ol><h3 id="借鉴文章"><a href="#借鉴文章" class="headerlink" title="借鉴文章"></a>借鉴文章</h3><p><a href="https://leetcode.cn/problems/insertion-sort-list/solution/dui-lian-biao-jin-xing-cha-ru-pai-xu-by-leetcode-s/">LeetCode官方解答</a><br><a href="https://www.hello-algo.com/chapter_sorting/insertion_sort/">Hello 算法</a><br><a href="https://www.acwing.com/activity/content/code/content/4550243/">我自己</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加密文章测试</title>
      <link href="/posts/a9fe598e654c/"/>
      <url>/posts/a9fe598e654c/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9b945f47a85f319860038cd6862648a9668611b8e04c910a270cc50a7d59ad03">40006f26432b51246312fba1b7437ee209fde60e0fcf5d58d590a820a18fc4ba792587e80495c836cdb13cdc873d50343cfdc1bca88a0f14e2ea61212af9e61093cb790572e83a216f2fa0a9dc7fd9a912a94964dbcb0967673f5f5b50103735732d19aa84675422c1d09b817fd323d617f01c072ff6852744db6ba0cde5d09b898843fe188cfd5546703ad6b70a7765d096a14bce4c91312e54b96eb82decb2ff2fc3dbbee174d684b0d7b3af5010db</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 私密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密的文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外挂标签测试</title>
      <link href="/posts/0cb988991ca8/"/>
      <url>/posts/0cb988991ca8/</url>
      
        <content type="html"><![CDATA[<h3 id="外挂标签小测试"><a href="#外挂标签小测试" class="headerlink" title="外挂标签小测试"></a>外挂标签小测试</h3><p class='p red'>我是红色的！</p><p class='p green'>我是绿色的！</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试文章</title>
      <link href="/posts/b52ef19cbecf/"/>
      <url>/posts/b52ef19cbecf/</url>
      
        <content type="html"><![CDATA[<h3 id="这是测试文章"><a href="#这是测试文章" class="headerlink" title="这是测试文章"></a>这是测试文章</h3>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试文章 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
