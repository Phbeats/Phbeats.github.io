<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phbeats-Blog</title>
  
  <subtitle>记录学习历程和生活感悟</subtitle>
  <link href="https://blog.phbeats.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.phbeats.cn/"/>
  <updated>2024-05-16T12:50:00.297Z</updated>
  <id>https://blog.phbeats.cn/</id>
  
  <author>
    <name>Phbeats</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[AcWing]3757. 重排链表</title>
    <link href="https://blog.phbeats.cn/posts/15cb5950f25b/"/>
    <id>https://blog.phbeats.cn/posts/15cb5950f25b/</id>
    <published>2024-05-14T13:17:44.000Z</published>
    <updated>2024-05-16T12:50:00.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3757-重排链表"><a href="#AcWing-3757-重排链表" class="headerlink" title="[AcWing]3757. 重排链表"></a><a href="https://www.acwing.com/problem/content/3760/">[AcWing]3757. 重排链表</a></h1><p>一个包含 <code>n</code> 个元素的线性链表 <code>L = (a_1,a_2,…,a_&#123;n-2&#125;,a_&#123;n-1&#125;,a_n)</code>。</p><p>现在要对其中的结点进行重新排序，得到一个新链表 <code>L’ = (a_1,a_n,a_2,a_&#123;n-1&#125;,a_3,a_&#123;n-2&#125;…)</code></p><h4 id="样例1："><a href="#样例1：" class="headerlink" title="样例1："></a>样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;2-&gt;3-&gt;4<br><br>输出：1-&gt;4-&gt;2-&gt;3<br></code></pre></td></tr></table></figure><h4 id="样例2："><a href="#样例2：" class="headerlink" title="样例2："></a>样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;2-&gt;3-&gt;4-&gt;5<br><br>输出：1-&gt;5-&gt;2-&gt;4-&gt;3<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 1000</code>,<br><code>1 &lt; a_i &lt; 10000</code></p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2024/05/14/66435bd78bd41.png" alt="image-20240514204050974"></p><p><code>将链表分成左右两部分，右边那一部分进行逆置，然后将两个链表合并</code>。</p><p>前半段是较长的，切断点应该是向上取整，尽可能让前半段长。</p><p><img src="https://bu.dusays.com/2024/05/14/66435c81b8b12.png" alt="image-20240514204345071"></p><p>选其中一种情况讨论。</p><p><img src="https://bu.dusays.com/2024/05/14/6643611cc4cc8.png" alt="image-20240514210325505"></p><p><code>step1是合并链表的过程</code>。</p><p><code>s</code>节点是需要提前保存的，用来维护<code>q</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rearrangedList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 题目说链表节点满足：1≤n≤1000，只有一个节点，则什么也不做</span><br>        <span class="hljs-keyword">if</span>(!head -&gt; next) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 先计算分割点</span><br>        <br>        <span class="hljs-comment">// 求长度</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(ListNode * p = head; p ; p = p -&gt; next) len++;<br>        <br>        <span class="hljs-comment">// 向上取整</span><br>        <span class="hljs-type">int</span> left = (len + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// 找到分割点处的尾节点</span><br>        ListNode * a = head;<br>        <span class="hljs-comment">// 移动 left - 1 次</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) a = a -&gt; next;<br>        <br>        <span class="hljs-comment">// 右边的链表，由于要进行翻转因此有两个指针</span><br>        ListNode * b = a -&gt; next, * c = b -&gt; next;<br>        <br>        <span class="hljs-comment">// 先置空</span><br>        a -&gt; next = <span class="hljs-literal">NULL</span>; b -&gt; next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// 进行反转</span><br>        <span class="hljs-keyword">while</span>(c)&#123;<br>            <span class="hljs-comment">// 记录排头兵的next，方便维护b</span><br>            ListNode * p = c -&gt; next;<br>            <span class="hljs-comment">// 反转</span><br>            c -&gt; next = b;<br>            b = c; c = p;<br>        &#125;<span class="hljs-comment">// 跳出循环, b就是反转后第一个节点</span><br>        <br>        <span class="hljs-comment">// 合并链表</span><br>        ListNode * p = head, * q = b;<br>        <span class="hljs-comment">// 选 q，是因为 q 比较短</span><br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            <span class="hljs-comment">// 提前备份，维护q</span><br>            ListNode * s = q -&gt; next;<br>            <span class="hljs-comment">// 合并</span><br>            q -&gt; next = p -&gt; next;<br>            p -&gt; next = q;<br>            <span class="hljs-comment">// 新的开始</span><br>            p = q -&gt; next;<br>            q = s;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3757. 重排链表</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>第七周总结(5/13 - 5/19)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/18dce1045e76/"/>
    <id>https://blog.phbeats.cn/posts/18dce1045e76/</id>
    <published>2024-05-12T12:50:07.000Z</published>
    <updated>2024-05-16T12:50:00.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第七周总结-5-13-5-19-与下周规划"><a href="#第七周总结-5-13-5-19-与下周规划" class="headerlink" title="第七周总结(5/13 - 5/19)与下周规划"></a>第七周总结(5/13 - 5/19)与下周规划</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h4><p>写完算法之后，应该还要预留时间来写周志。<br>英语每日任务150个新单词，改为2个番茄钟。</p><h4 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h4><p>奖励机制没有完善。</p><h4 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h4><p>算法<code>第三周</code>的还不是很熟练，估计后面的也是。<br>感觉算法分配的时间如果是半小时根本不够，也许需要增长时间。<br>周末复习完算法需要调整时间安排表。</p><h3 id="下周规划"><a href="#下周规划" class="headerlink" title="下周规划"></a>下周规划</h3><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><h4 id="第一天-1"><a href="#第一天-1" class="headerlink" title="第一天"></a>第一天</h4><p>复习了多元函数微分学，完成了二重积分概念性质</p><h4 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h4><p>上午复习了昨天的错题，还有昨天学习的二重积分的概念性质。<br>由于研究了一下gpt4o，导致上午只完成了两个番茄钟，所以决定牺牲中午时间来补任务。<br>今天完成了二重积分的课，还剩习题没做，打算明天上午开始就一举拿下。<br>算法前几周的好像很久没有复习了，周六的学习课程安排应该优先为算法考试。<br>今天调整了时间安排表。</p><h4 id="第三天-1"><a href="#第三天-1" class="headerlink" title="第三天"></a>第三天</h4><p>二重积分习题做完了，真的是做的我易怒啊。<br>今天数学时长远远没有达到，这是因为紧凑的计划只要被打断就会开始破罐子破摔？<br>买了<code>杭菊</code>。</p><h4 id="第四天-1"><a href="#第四天-1" class="headerlink" title="第四天"></a>第四天</h4><p>中午忘记设闹钟，迟到了，今天的数学任务应该也是完不成了。<br>1000题A组高数部分做到了111/200题。<br>好消息是下午吃完饭马上补，被我补回来了。<br>突然发现定积分以后的知识我并不熟练，我打算快点过完高数，然后利用APP再重刷一遍例题，<br>对于不会的知识点直接进行截图处理了。</p><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><h4 id="第一天-2"><a href="#第一天-2" class="headerlink" title="第一天"></a>第一天</h4><p>做了2011年的text04.</p><h4 id="第二天-1"><a href="#第二天-1" class="headerlink" title="第二天"></a>第二天</h4><p>做了2011年的text04，翻译了2012年的text1、text2.</p><h4 id="第三天-2"><a href="#第三天-2" class="headerlink" title="第三天"></a>第三天</h4><p>复习了2012年的text1、text2。翻译了text3一部分。</p><h4 id="第四天-2"><a href="#第四天-2" class="headerlink" title="第四天"></a>第四天</h4>]]></content>
    
    
    <summary type="html">第七周总结(5/13 - 5/19)与下周规划 - 加密</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>[AcWing] 66. 两个链表的第一个公共节点</title>
    <link href="https://blog.phbeats.cn/posts/0a6333a85e34/"/>
    <id>https://blog.phbeats.cn/posts/0a6333a85e34/</id>
    <published>2024-05-10T11:34:56.000Z</published>
    <updated>2024-05-16T12:50:00.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-66-两个链表的第一个公共节点"><a href="#AcWing-66-两个链表的第一个公共节点" class="headerlink" title="[AcWing] 66. 两个链表的第一个公共节点"></a><a href="https://www.acwing.com/problem/content/62/">[AcWing] 66. 两个链表的第一个公共节点</a></h1><p>输入两个链表，找出它们的第一个公共结点。</p><p>当不存在公共节点时，返回空节点。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>链表长度 <code>[1,2000]</code>。<br>保证两个链表不完全相同，即两链表的头结点不相同。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">给出两个链表如下所示：<br>A：        a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗            <br>B:     b1 → b2 → b3<br><br>输出第一个公共节点c1<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>两个链表，两种情况，<code>相交</code>和<code>不相交</code>。</p><h4 id="相交"><a href="#相交" class="headerlink" title="相交"></a>相交</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32ff3099be.png" alt="两个链表的第一个公共节点"></p><p><code>a + c + b</code> = <code>b + c + a</code>，它们相遇的时候一定是两个链表的第一个公共节点。</p><h3 id="不相交"><a href="#不相交" class="headerlink" title="不相交"></a>不相交</h3><p><img src="https://bu.dusays.com/2023/08/09/64d330de84da4.png" alt="两个链表的第一个公共节点2"></p><p><code>a + b</code> = <code>b + a</code>，下一步它们都会走向<code>NULL</code>，而<code>NULL === NULL</code>。看作相遇。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">findFirstCommonNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode * p = headA, * q = headB;<br>        <br>        <span class="hljs-comment">// p从headA开始走，走完从headB开始走</span><br>        <span class="hljs-comment">// q从headB开始走，走完从headA开始走</span><br>        <br>        <span class="hljs-comment">// 不管两个链表相交还是不相交. 根据 a + c + b = b + c + a 原理</span><br>        <span class="hljs-comment">// 它们一定相交</span><br>        <span class="hljs-keyword">while</span>(p != q)&#123;<br>            <span class="hljs-comment">// 如果p走到末尾</span><br>            <span class="hljs-keyword">if</span>(!p) p = headB;<br>            <span class="hljs-keyword">else</span> p = p -&gt; next;<br>            <br>            <span class="hljs-comment">// 如果q走到末尾</span><br>            <span class="hljs-keyword">if</span>(!q) q = headA;<br>            <span class="hljs-keyword">else</span> q = q -&gt; next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing] 66. 两个链表的第一个公共节点</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]3756. 筛选链表</title>
    <link href="https://blog.phbeats.cn/posts/5a709920de81/"/>
    <id>https://blog.phbeats.cn/posts/5a709920de81/</id>
    <published>2024-05-08T12:11:58.000Z</published>
    <updated>2024-05-16T12:50:00.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3756-筛选链表"><a href="#AcWing-3756-筛选链表" class="headerlink" title="[AcWing]3756. 筛选链表"></a><a href="https://www.acwing.com/problem/content/3759/">[AcWing]3756. 筛选链表</a></h1><p>一个单链表中有 <code>m</code> 个结点，每个结点上的元素的绝对值不超过 <code>n</code>。</p><p>现在，对于链表中元素的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。</p><p>请输出筛选后的新链表。</p><p>例如，单链表 <code>21 -&gt; -15 -&gt; -15 -&gt; -7 -&gt; 15</code>，在进行筛选和删除后，变为 <code>21 -&gt; -15 -&gt; -7</code>。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：21-&gt;-15-&gt;-15-&gt;-7-&gt;15<br><br>输出：21-&gt;-15-&gt;-7<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; m &lt; 1000</code>,<br><code>1 &lt; n &lt; 10000</code></p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>如果要筛选掉重复的元素，那么必须要有记录每个数字是否出现过的<code>bool st[N]</code>。</p><p>而且链表中的第1个元素一定是没出现过的，可以直接标记<code>st</code>为<code>true</code>。</p><p><img src="https://bu.dusays.com/2024/05/08/663b74242dace.png" alt="image-20240508204615900"></p><p>对于<code>p</code>和<code>q</code>，删除点有讲究，如果是删除<code>q</code>，那么成本小得多。</p><p>所以<code>q</code>就作为被检查节点</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">filterList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 标记该数字是否已经出现过了</span><br>        <span class="hljs-type">bool</span> st[<span class="hljs-number">10010</span>] = &#123;&#125;;<br>        <br>        <span class="hljs-comment">// 第1个元素一定没有出现过</span><br>        st[ <span class="hljs-built_in">abs</span>(head -&gt; val) ] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 当前没重复元素的最后一个节点的地址</span><br>        ListNode * p = head;<br>        <span class="hljs-comment">// 当前被检查的节点存在</span><br>        <span class="hljs-keyword">while</span>(p -&gt; next)&#123;<br>            <span class="hljs-comment">// 当前正在被检查的节点</span><br>            ListNode * q = p -&gt; next;<br>            <br>            <span class="hljs-keyword">if</span>(st[<span class="hljs-built_in">abs</span>(q -&gt; val)])&#123;<br>                <span class="hljs-comment">// 如果出现过了，删除</span><br>                p -&gt; next = q -&gt; next;<br>                <span class="hljs-keyword">delete</span> q;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 如果没有出现过</span><br>                st[<span class="hljs-built_in">abs</span>(q -&gt; val)] = <span class="hljs-literal">true</span>;<br>                p = p -&gt; next;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3756. 筛选链表</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>第六周总结(5/06 - 5/12)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/a395edc2fc97/"/>
    <id>https://blog.phbeats.cn/posts/a395edc2fc97/</id>
    <published>2024-05-05T12:09:48.000Z</published>
    <updated>2024-05-16T12:50:00.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第六周总结-5-06-5-12-与下周规划"><a href="#第六周总结-5-06-5-12-与下周规划" class="headerlink" title="第六周总结(5/06 - 5/12)与下周规划"></a>第六周总结(5/06 - 5/12)与下周规划</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>本周摆烂周，上周数学和英语计划都没有完成。</li><li>7小时睡眠能保证效率。</li><li>时间表进行了较大更新，使用番茄工作法学习，配合<code>Todo清单</code>。</li><li>以后的复习都能依赖<code>Todo清单艾宾浩斯提醒</code>这个功能了。</li><li>下周开始，只要复习，遇见有问题的直接使用<code>APP设置艾宾浩斯提醒</code>。</li></ol><h3 id="下周规划"><a href="#下周规划" class="headerlink" title="下周规划"></a>下周规划</h3><ol><li>下周彻底拿捏二重积分，微分方程能学多少学多少。 </li><li>利用好<code>Todo清单</code>，做一个听劝的人。</li></ol><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><ol><li>1000题A组定积分以前完成</li><li>二重积分开了个头，1/3</li></ol><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><ol><li>刷了2011年的text01、text02、text03。</li><li>翻译了text04</li></ol>]]></content>
    
    
    <summary type="html">第六周总结(5/06 - 5/12)与下周规划 - 加密</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>[AcWing]35. 反转链表</title>
    <link href="https://blog.phbeats.cn/posts/2097c5abe775/"/>
    <id>https://blog.phbeats.cn/posts/2097c5abe775/</id>
    <published>2024-05-03T12:50:44.000Z</published>
    <updated>2024-05-16T12:50:00.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-35-反转链表"><a href="#AcWing-35-反转链表" class="headerlink" title="[AcWing]35. 反转链表"></a><a href="https://www.acwing.com/problem/content/33/">[AcWing]35. 反转链表</a></h1><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p><p><strong>思考题：</strong></p><ul><li>请同时实现迭代版本和递归版本。</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>链表长度 <code>[0,30]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入:<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-literal">NULL</span><br><br>输出:<span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>先分析理想情况</p><p><img src="https://bu.dusays.com/2024/05/03/6634df9defdf9.png" alt="image-20240503205906942"></p><p>分析较为苛刻的情况</p><p><img src="https://bu.dusays.com/2024/05/03/6634e0232c079.png" alt="image-20240503210127943"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 只有当链表一个元素都没有才返回空</span><br><span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 只有当链表一个元素都没有才返回空</span><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 迭代版本</span><br>        ListNode * p = head;<br>        ListNode * q = head -&gt; next;<br>    <br>        <span class="hljs-comment">// 当q不为空，则可以一直反转</span><br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            ListNode * t = q -&gt; next;<br>            q -&gt; next = p;<br>            p = q;<br>            q = t;<br>        &#125;<br>        <br>        head -&gt; next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// q为空，p是原来链表中的最后一个元素</span><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]35. 反转链表</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>第五周总结(4/29 - 5/05)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/85a455bed5d5/"/>
    <id>https://blog.phbeats.cn/posts/85a455bed5d5/</id>
    <published>2024-04-29T11:26:06.000Z</published>
    <updated>2024-05-16T12:50:00.293Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="119c3e33974b5bc638c4883c92d80c7812602266195769950c12ea008c792151">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08149440b265571a5a7ec46d02fbd8532beeb82a238ea588828539567ce9a75dc174b49773c4aa6b00588a520d0915ca8e3f54793cfd93f33c0a4eee66004549ad97e4fa2e967f3318874369148cbed3863b3ce275b16fc419fcc5f542e74b188a2309b8323a25e7315092778008831571e8c9ba3ecdad9ffd3127c25c7099abacd7385ee48de3dc0ce644425469d8bd051c1ac810d9d17999878d51068493b0bcc96eaa7eebb38e1c5cc50bf5791ae3b8f56fccd3417213f17917ba9dd6cd5357d9f9b5a2e5b61fdf48db4ed61341dd00b2ac501b236fcf12f501c67763163144195544f38824f72631b598eac4fea9539885015414a9a3d66d4fbd1cf16e956c75ab17359945cdb4e99252fe0be9d3e610c712b1b5f5e5c7e93f9075579b2e38533b3bd8583199f4059da85afb7766142198e3ada491d3368b94d2d58147aae3a1ff4f73e48619f49a7363bc3120cb328c4e690b97d042c52a8557311bffd94bf2a7d3df59b3d4c5615d8f766b85a7dd5dc38fbf4e6c41c9fdd0d64ebe448be031d54ee5b4958666771ac029a2c8ebf7118a8b86aa6ad37843c9874be6e05eee76902469e8c5079a57439f12bb7c893bd5c82da30282668aae8616799fab66ae2932e815b04ec3f44dda059df3d80f851b472e9b8d33ad59aea3f80323262f39f05e27a135e7613beff1299469c0c6bfb13e98d2edb7722bcbd52c033ee18336b146755711f70b9a732384fabcbe8de8ef9379b1c5c241c5450d92e52a0373258bb3c9cca18a67bd8658441c7a623420bd921fd7624d99745e5fb71f68a15336182ae565d9fe8f621b21ce3e794ef6ac19dae5c2a159d2db412d90ff044beb0f4441ae36d1ba74ae7e2a6cabedaf958f0ad52576f520f7e91d819ff12757760a233d57c40714d51b4ef9ee999fe15d4a0502eb8196a40af473512b3593ee37f9c5b4fe4f27df88b4407ee0f7ccf9a61f91b3ecca896152499c758b1b1185d75fb248581b229f6443bd334e0e9693ff57455654883a72a3877542acb2a09442050c3133fa3058facfcefcfd7848eef9a2d93d685e19c6a6d7041e7d7c369c0636d8b968c60b12c03c29be35b2fbd05ffe286284d332e30f3038f96d20e61a836c5883bb82fdc95dde28e4e385857e8c8084ef53eca9b90dd720aedf1aced6a8ba232450dc541b80d912f68d3b9e9eae39c805d2b5b9bbfd07c8c4ea43dcb7e50a39e8b64ba3d11c1dab5658ab0179820fb94a8ce1aa699957d52460fdf3c908994fe8af89c9be86c9b1756243cd2bfca2716dc7a1b6c4320ed0cec7d122ca8bd88814e246baf8eb02014b81dd36af7cc393944e6cf8b57b243f9cddf1f0f49fbaaa16c723969b22ac5b29a6e54483370b09cbcf9f8082fba2dffe6496e430e7248ad750f61f941aa13f841c65c3dc4918ac3c5843ab0b1dad217942f3590fe33c09aaba8705293346ea1141fa6a5325e24edc6e6c5f9cf9146cb31c4d4e5722a61bf17ae97ddfd51425462151119133a97f123db796b779dffc8bd30ab89d034ca62c98ffb4d1ee8e4e699dfaf2b43eaeb06d65d050bdf3ef18ad2920c43a6463a1f802dee7c3d542eb602fa9efaf19d988bb5933a0a0c65b8463c4f9fe80a95b9657d837b904a08ddc6f20f1d88edea8a8d93101c79bd3a51351d55c3b30cf9b4d0fae3580a2384af788eea296f4f00a893ea9f3afa91da0474bd867ddc79b91289a73e13f1459d17e170324e471ddacc6316486ca2365c213a15d3ab90a6c11d36e6322694fc3b7597847b0fdd17ef540d106d4c6c8fa0575b2567b7a15b1eaf2ba4c9fa12fd8aa934cb12fcc09436f3a4fde3058626b8b0a87ac00aca66f8fb2e084632ff4f3f75bf3ed454f4e1cdce53a7d64e3ebc524cd835c6a313c55114ffded1226c2532297c7a5b19caf102dcc60243fcfa530cf4568df2e0409402f6ea61e6397e65fd1a9b16e50440481e4beeacd9c0bc0c84e64743ef093f51d965883f2c0a82c11621a462e4c2c122e9a38aed7511c3a9bd68743233795a2e55d5de4a886b6b5213525137f42f3fda1d947df7b2fc8648ea6ea86bb75785ef6eb9e4b4a587a270e53f27cf9abc7a06d3260e0cb366287993d522ae504e7329a8d6f3070d2ab0bb5568fbcc1cddea74228a19f75f5b529b23c406d81acb21fa42550a527621d60a9e23cf5e3aebe897be285d096d977262d494d1efc316c44acc332bd67c715572e83bd68619bf63e7703125829aae7f89dd64153fb6cfb55bb7f4bad7ac1402d7d534505632654d3fa434c14e0b3e7b977f9b726aec97978a4960c7041a6e87d9ddcebe732e832ea72ce9c5bd5e745b5c01fea7c485f7b81584e324f1d9b8b70480903ee30e34f4125084bad79f7d3f8cc6c09bcb80345f9dc00bdbfe4c736944713fc519f9e336ddbc6b631b615062ec427b27b2da802ced0bd8d3ec48a79853c222ec266a35c9b2d0f23019f002ded200a5fdaa56d74c7ead97d3a6d593201af450ab5bde47c884e5e599eb07bcdec913af970b2226434ef3112ac51ded3e94af1d7997742eb874cd9de90cb9ad323d54c7ab44310d3d3211b33760a622d97516a36a5cbebdb8a6046751d992c8935d36cb80fa3adc015fd3199c107d340d6e9eb8a7089c38f1a4cd2bcf36d1866db0b4fa6ad99baf40b4af93979884b5197b83664fc98cfc4085c6d4f804a06c8861b5a21efccb4a72d50d28ca6be86078422d00db550896f69c28d4e44d667aa513906c3f539d38f95de329b16f91caf0e18def03dde40ecfbad095874b1a91761a6bda7473784175a0361778f7ae706c844cc924a23580bb6eada715d37973197b80eebafcb80748faaeec545b8c2c5ee9541511a16d8a3a0d2a8fec30f64cdfdd8675464c434f9320e55d0372c1569cc75c7e468e21656c7e108722b006b8dff6342494ac4b7e26bc5514ab65c29d70efe6b41b0185d6a80c8d032459f60e1dce2dcab1d035d85ef7c7a72a2d8bd6edf4eaf2203ea2af684ebaa9b60f528f7b5ff937225ed9195bcaec6fd446e2ad92b8092b2d33801dd8d56ae79024dbba2c4e18a62347d1b4dbcb23f6d874f4dbd74c798480b36d108772c6302</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第五周总结(4/29 - 5/05)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>第四周总结(4/22 - 4/28)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/e67d1afdd8f3/"/>
    <id>https://blog.phbeats.cn/posts/e67d1afdd8f3/</id>
    <published>2024-04-21T11:59:19.000Z</published>
    <updated>2024-05-16T12:50:00.293Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="028ffd2e0fc6afe4ebf9836bd1666d5a32b0eb0fcdae0f066a826f662322d5b8">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814dd28c6c18edca31e1555a8485cd273625e25395c9f1c3aea939741d0bfa2f12a0aeb4c1d8cc993704f2a677a3202850096330a427b75265891b1a548643f6866a2af112c9c35c420c639b21c412b0a309a6c516de92c941c8b5f75a220e6dc3c472b304eae7cdefa406c0769129f0eabf84ac5ce473a55fefb13320b8b35a288ba2ce2409078c405a791a52b8c6208996435723bb5a8702b9e928a187ceb98d5e3bdd7cd8483f34496f283cb4a10f3e45dbb744c8b968194b575695a51d47c4f2e28e534556c5f5df69844c3eb61f0b0b17ac7fe3b67a5c1c83bcf626c57954584e4b49e0c2e66d95148ed7ac80a4327ca27c4aab8246a73ef3a41c645939fe58d430d7c7c75f8408b0e53bfc632de8ffa343607066a76b2238da758611feb2bab70c2c9f85732c132affb395bd427ba38b3f658cc5e2ffcbe86ae3132bfd99697b1dba1b87f0f0097eba194fc7ffef7015b34700485afea89ba7ba7d04e8585ce8fb1cd9e48b69fd72f0f01bfe3781d01c74086401dfc9818435f1d979831c0f276414304e4c22418ecb28dd5722219c73d435b4b1fc6adcc43f9bcbe58e9db1c490f841ab3a9686c7fda8fdc13860ada1286184bdf0e71c630c5763cf988d2673a209eee41eb9d11120e6d0e61e052498e574ee87c16021b41729634752cc2bc5abf028b00682d0431ed977b41442730e6198c131a225a2e2de0072da2ab48edf003cd808ac10868d837f3e6eb7854cbd2d3dc7b772b13d2dcbf8ce740b870f9aa5241e68d6e3a4409a571bd71f58a36fa8a1e8011401419d5fc569c8e8de99aeeb5e570efa0fde28fc0c3db9da3946c3536fc9d92e9cb123659994df584ef38a38d4a6287744fa562e78cfaa29bec80c1b4866cac6f7ec7a880b52381996915395a5b3b0e176a56531db74e4d620f3e1042ac52cbeeeb4f5e5abba6a6b6870d68ef16a7349b897bc35918035d06a858dd1732a60df2d2b2dbaadd719e0eee2ddec5897a30cef5452f6c68791861f8ec8833466cd8ebec43347e62fab76258e2b0bd133d4aa1a3394b53580342a741a6a5a54c64b9c503aca650797685ffa4769a7844ddef7ea5f62ff0a9422b4978f2daf4da1c50129188a78c29855b16960eb1609ae398ebd78691cb6f3affe227f114be5e0037fa44394597cd9aa53b6444c5d9151b938a3e1f503672fa3f8a934442b218dbf4c5eba56dad9339fb4011ab43d5ced978fd446c9987a7f9fb419fb31679914f0d536e09813879613a26dfa42ffc7c8ba8875ed4759bba5ae221360459fc5a2cb959525abc35295e77e8a213fa5e3272b5ac1800faf3e96a8f561eaa6b776a30ff151d4a42830c99f8936ba9770a6f554d1b9a96e38977f7e7d9d550cc6d59a83589b49fb8571a7f4aef86c17ee8484c12357d3207afa1af7ea57d4519202fa670baacd417ba8a3a6f828dba4ea2a98260a4c96a423c42b8aa44119f00f5b5dc04991a835850874a0813e935ffc51414447e8c0a73db49b7b086333573f1d14c5a40e6824b86a52974b3eedde0d8529648b526925d6c6463f4a299af9a86c55c8faea01bd51ed7589cb39a2f2a1ed941bdcf8699251158b969a9ec7a65d5e1714d10eb425cd90f8817608b55d64d9bcf34dbf718c4aab804866b4ed2e79c4bc3bebd5e8a233e3900f8c86b353332a08f60827a5c9df2ea84a91e39afb4a64818c012855aabb334b4d292f1e477512af03a8902c5a233c58062f532f631315da35486bef7695c65251649ff9a1a680051c7239eab223441c9e7fc20aab541ccf84be64fd050d5aa48af6eb096ba4b927809bea632b86af5762836872361a95a16c2774ecd0bffba5f1d7d29669bfe9a504b36d2f4cfb98f737182e73e8248272a6db51632ab3bcff68095badfd988d1597fef34ce6a3e8d31cf1bafc74e9f89a64c75b20695dd23ce95e6781d8477df4c6271fb65e673b292be9c5c4d325c54b9a9474432fc73757118ab541c2aa9cf27876826812b81db5c8ad218718ea89a98eaea93dd73aeb963d934e9d069a392230d55044356713872c3f5c3e1f1feac2e664025033657e630d788bff791873bb082326885716377f6ad6d960661cfbb6fe801f960b901e2eb923d0100cc82860588e356cb0e030aa75905f58cb6a7b1c87507b3446f2c6c0e042759b6a8748e35bf11b0a67ad96ef8ad97b109be497be9d17a5cc2f5cc5d4f2264fc1a527b30fa81e5186baef53dcdbdcc65271165efd58a7c228dfe95c30b6c93db966849c5a2d9aa3e2c2e7dbe7b47adc70ab8b6f7a3d887d5dff2dde55b1ebe5766e62fcd61bb8c4b7119e25cf4f0d4bf1733d527a14c066290a2c20cf11dd99af20b95b9e531e11119491a9ab41f1a902daed890d27ce51141b2fd91131156f2c84fbe02fa4b3ceeaa4c7fb80d44e4d63e0870636af64aa0a9abbc5ff0771ffabbe90c38a76ae9bc6fe21c6fb49f7273167ec551f5d57779d0c68c35eb245f9dba863df082c4cfb3b3c4477ff855ea6fb7382952982cdf390a3c3f92c0d2b5c0fb3d30637b9bd35b41588287d267dec3d53ea319c13aecdc24b8e694976a2d6449e68068d222d9cd08e3a055ddc42c5767968161e62e5ebc3449d73bb525833b2eebbb60fa8be7a7217ff8cdaf1746a1f122185abb6a6bb9e06e753456db872c0f99cc4ad9b79f2e0446214b9fe10645c6fbc9ce10edb58d0869d6d359acfb103a34cd08d7ce997bddb44ebeb6923b9becda5e85ec509e6d3eb2c04a21940b5395de8755c03cfb920b84e8b20074cf96b87265900c11f50cf86f1af154aea48a55f057397c1bed1c0705096346ef798a446d7d2789c6686bb3ba458bd600a803b547c32a48bfc2a6dd6f2cfc0acab3f873e7d794cd355f16ceff04c1661b7e6084fe1a406675daa8a268e925f85a77d968e4a8467abae314b06bc5e354ae4cdb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第四周总结(4/22 - 4/28)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]842. 全排列数字</title>
    <link href="https://blog.phbeats.cn/posts/2eede509a240/"/>
    <id>https://blog.phbeats.cn/posts/2eede509a240/</id>
    <published>2024-04-19T11:55:28.000Z</published>
    <updated>2024-05-16T12:50:00.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-842-全排列数字"><a href="#AcWing-842-全排列数字" class="headerlink" title="[AcWing]842. 全排列数字"></a><a href="https://www.acwing.com/problem/content/844/">[AcWing]842. 全排列数字</a></h1><p>给定一个整数 <code>n</code>，将数字 <code>1 ~ n</code> 排成一排，将会有很多种排列方法。</p><p>现在，请你按照字典序将所有的排列方法输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个整数 <code>n</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>按字典序输出所有排列方案，每个方案占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 7</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>此题，适合用来理解<code>DFS</code>。<code>DFS</code>可以用<code>树</code>模型来理解。</p><p><img src="https://bu.dusays.com/2024/04/19/6622634b9d95a.png" alt="image-20240419202755100"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 从1开始全排列的数字长度</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-comment">// 数字是否被用过了</span><br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-comment">// 值</span><br><span class="hljs-type">int</span> path[N];<br><br><span class="hljs-comment">// 关于数字1的全排列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-comment">// 数字u 为 n + 1说明 1~n 已经进行全排列了，此时直接输出</span><br>    <span class="hljs-keyword">if</span>(u &gt; n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            cout &lt;&lt; path[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 进行全排列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-comment">// 如果这个数字还没用过</span><br>            <span class="hljs-keyword">if</span>(!st[i])&#123;<br>                <span class="hljs-comment">// 就用一下这个数字</span><br>                st[i] = <span class="hljs-literal">true</span>;<br>                path[u] = i;<br>                <span class="hljs-comment">// u + 1 数字的全排列</span><br>                <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 恢复现场</span><br>                st[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-comment">// 使用的path空间下标1开始，同时也是从1开始全排列</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]842. 全排列数字</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="DFS" scheme="https://blog.phbeats.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]3766. 二叉树的带权路径长度</title>
    <link href="https://blog.phbeats.cn/posts/6049e4bb40ad/"/>
    <id>https://blog.phbeats.cn/posts/6049e4bb40ad/</id>
    <published>2024-04-17T12:17:11.000Z</published>
    <updated>2024-05-16T12:50:00.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3766-二叉树的带权路径长度"><a href="#AcWing-3766-二叉树的带权路径长度" class="headerlink" title="[AcWing]3766. 二叉树的带权路径长度"></a><a href="https://www.acwing.com/problem/content/3769/">[AcWing]3766. 二叉树的带权路径长度</a></h1><p>二叉树的带权路径长度(WPL)是二叉树中所有叶结点的带权路径长度之和，也就是每个叶结点的深度与权值之积的总和。</p><p>给定一棵二叉树 <code>T</code>，请你计算并输出它的 WPL。</p><p>注意，根节点的深度为 <code>0</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">输入：二叉树[<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]如下图所示：<br>    <span class="hljs-number">8</span><br>   / \<br>  <span class="hljs-number">12</span>  <span class="hljs-number">2</span><br>     / \<br>    <span class="hljs-number">6</span>   <span class="hljs-number">4</span><br><br>输出：<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>二叉树结点数量不超过 <code>1000</code>。<br>每个结点的权值均为不超过 <code>100</code> 的非负整数。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>从根结点到各叶结点的路径长度</code> * <code>相应叶节点权值</code> 之和。</p><p><img src="https://bu.dusays.com/2024/04/17/661fc561aba08.png" alt="image-20240417204932311"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 只结算叶子结点的</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right) <span class="hljs-keyword">return</span> depth * root -&gt; val;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root -&gt; left, depth + <span class="hljs-number">1</span>) + <span class="hljs-built_in">dfs</span>(root -&gt; right, depth + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3766. 二叉树的带权路径长度</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>第三周总结(4/15 - 4/21)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/e3b1009c0e89/"/>
    <id>https://blog.phbeats.cn/posts/e3b1009c0e89/</id>
    <published>2024-04-14T13:45:42.000Z</published>
    <updated>2024-05-16T12:50:00.293Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="889028f094df5c939f4119464b37a90c4f3c744f2967972bdf73dcb2153d99e6">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814d2b442d5d57a8a1951978d9635e2a48b4ded424e00212e73fc5a3d8aba0ecae59698a3711542c20c3ddcab60165cfc56be82b5c60b0812e64082439dc1fdd18fe5db88e3baba417f4a1537df105e8702028de40e40817343b03654b548d7079c96160c52d602c9e2bdafeeb15e69919d159096053356a84a17c8833b394fa79d06932aa0d4979f14e1a11ce96fe9f29d398054b676644f7b3105e64a9ef1153818f9eb19cad9deabad3579d8cf2cda24525d34fbf4132c2195bdfa591a786f06cd4883b750a10e1e75b3107d92ebe01cccce7b36e2f6d7de0b2d6fef14b49b4a352373cea646ec8b7c5bcf94228a261f24fb036e4c25db5758d72924878ce91e1930a454ee0ef97c926dbf965e1ded2bffd86de66984127894ca8ebc7576fbf6fc1a13af54d3bd1fbcff9e4dbb51be0a6ccc189b08f6566e7ada89682b2006e300f7fc661e9a2cdae977c0ce163f8832c52405b82aa98bad124ad852b619364c5af4d34a1da58caf436ab5156a60e46518ef07e49f265f7fe822326d692d3c4e1b3b9cf3bbfaf912ab50eaa5b422f163bb3cad0192f44122dd37246a8b5326f0fa6a682a875fb461e72809b8777f2a5c76c75957f032338edeb590626dd02e63128536f6cc847e62cb7356c92ff3c9b74a6ae26d8f7dd6d2905a325c7afab5a9f2aa412f81d88dcbbe350129360f101c76ad4192453224987161f718151a0a4f77dd4b7a6331966b45707daec6f243aced6c6acd7ea5e15823b3b7ad56ec90dd5cafae95be2e4515956ff180775c5f347aa38ace25fd8139b8b034d26d1e953fe2c18bfd22321f6eda1ea552608564745cd925f3bdf1c7dc11f909e5bfec206519383f2733b81ba9e73a8723a5eda47ffca8b28e80af63e71c5fb4514a05cab3af59c5d0bb09ded30c8880b8920968f6e88c5d95c255ebefce94c004b45cf26db2e25a839b86e5f03921aecd17eeb67d5474fb05b10390556734ad897d27d68b1471f43c57fb5a34b839e87ff9b015fb8dd0c788c3d47db0a12d537c3f74f3e946ecceed521d74679cca5c187a8f0cbec116f7d025e51422ff859e50dd13ef5936d354345c042b732f651a58a9f2634777408db0d526908d65596306f3ab2fa11a253b1bb62a77bedb02d642b657ebe178dfa0b1a66b5384d7c7b6e10a0c11ed938b37a817b1768c83d8468542795d98b55cd60cbb9cd8ac0ef5675a3b50125efeb023a76b14fa4ba1f4b42c8d4e029e822529bc5c5f8b99412e981368225d222f305d63b32b51920e4cfe018e6dd73d48b060bc321688df2d97b949c3c5760655a46aec1fa32da01cd3f1526d70273734d4ebf18bb15b53febe57f0b45775bc1f20b9f185a5cf99e98829de089e4fb24cd425d0912d94512f4c6937846bb0c9772b02d26ebae11ef5d84afb85cdaeefef71cb3212997875755cf6fe552d17940a1c1c0d454067e1983daa2aabcb20b855ef0ecbe21fa26f34e970e22c060c04f329053c299e3ad28617f36abc235604a4691ca7a33d6db0a94432530d2d2e0d11d7655f2d30fc5967e8fefd513a4b706c12c93c7bc2144af605a5edcc9e5a8951ba90e2cfbd5d076ea9cb9218d78ed15ab1e837f1750dd626292f67267d57a6cd1bf2ca28eeaaa6e48523f0c8bf4b17b972495730418bec6821710075cf2910fa8772cae7d9550da9cdab124c1876ba6caeb1840b70e1f80ab56731f4bd82a694fc1567cebc73bae0d37dfba3f78e29d1767cfe6a9b3eca0d8928e6e2ed30a905f33e47ea97c9c9fb47fc982ed4695d39f2039daa1815f6e2398ce8c551ee29bd805dfdc24ef5de8fe0eb38f52da5ec942af292be0867aa6c919ff3579d4c0243ce3fe50e5630455399638226c74b824a443e194cf097bf1b5e103ed573061ec03affbcd43b2ee54e3b83ffd52880f7de3af0f935fa1862951adfaab2150033b5371ab52d4ba7b623bf018af295eba0d4401d28724ada9435662568af085deedaa1c1ecf3782a5c0ecd667069d08faefd08df091c00a1466f64692eb321b0cb13fd8df1d41ab4b5551336bdcbbfd9cde398d02620c20b94ad68999d5518456509f63c165e6260d5c402dbbb5a6452e429cf24df0cd6bc2b1187d8a49ea96e6a734ad03e53edf161516f4b51af0861b582c32af60134762c53f64d14ce5173b21ec110b737e6ffa3bf21fcc19943b2ba81683d15669849b06ef6873a3a128427b09e9b26d7a14f13ec48a6ee637c1de932461a817f5fe84964bf122c970832ae70e0a927fa0af3f4a5730059c9a127776133e4d3a37e4c42f2978435fbbfabe1deb617c27e3172f44b5c9c0c56507f8231ef60da3cbfad4db2da21286a85095ce4f3d1479eb0e4aeef427026dff40c7f5746a42557d19358a15eebed1ce59f3e8ca6a01a42c79b078711a00eca2fcc4d9c76398182b70b5ed3a946f073652e5b2a91acc3a0af094f9d45a3e60afc899112d175bbf5e1caaccb53828322e7df22600ef5e743a714e084eeb87adc1ef006f55471409c5e988515215f714ff36f54b16be8abc92f871cf9047b296cf19f866f8efee0f98b43fc38ba82a54c63940fcd97a802f34ffdbf96ed2260c0b18551fa40f0f844d58ea12f720436014e0da9655632da6283557207dfd54f79b86ee4e83985a33abef998e95a4f6704d6a7939d8d2b1a37e40c820993ff7bbb90f0b6465ffe8e0bc75b7eb84fdc386011d70f6abe93cef24d38e5fa0226b548fd73f9ead572b517209743c4afb0297142bf6763e971d2e3e13f8012d7457cc1c552d41f1e6d95f9a5e1034e248288e764d9a59586f20bd555dbe371297d3c43888d25</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第三周总结(4/15 - 4/21)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>第二周总结(4/8 - 4/14)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/132dfe66ee9d/"/>
    <id>https://blog.phbeats.cn/posts/132dfe66ee9d/</id>
    <published>2024-04-07T23:27:47.000Z</published>
    <updated>2024-05-16T12:50:00.293Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="54fe2eb614a4591dc0cd6fe3205b343a0602da356c2f286c39f766fb72e3c01d">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b081440615059111ca942f2f251783284cea21ced08223624de214a5926aa8247bbc65092b6fa39ead19508aadcef5c3ee7a74d96a50ab26d770064aaf5ad89e02666fd3875200aac86754786dc68c87fd99773d3ed6484b498670cf5bab6d4ca163cc26468b034a4cbf9a4075d9008f2a1be4e9bebec9471a0ba8f5c7019651ee02b12603bbad4d408b406e6192cd007e1df7ecca6b62378ea269660b3068680d556b08d2ea294f6a5cf704345237f062cfbf0d3bb5e12ef0e47483a84aca890060f153846ab2f8a2d8a3358bed91fd2d70b1241960386a35b583260aa91fa52afa1af665824335ed939705d8960ea0a1f2fc21ec127c74686bf1979993b38d73f52457fe101003e6337aefea82aec510888f2eeb4a6c64cb48584c10e4ca84f7975e7718d2bb6602075350dac64ef0d41b22c4453d794b235d72d73ffb98cab0e6d1c8622900282a552f4604ca8c55927ae18111e59a94af7758324519ac76f91d15072b8d1b1a485845dbf258d5c705a01f77a7b26bfb3852637fa8ee0568f4fea2578678cc7b707381a6ba27929616dcb0fb95abbd1e5216db5406c3fe0a24c85cba8f849138361e4fd4ffb02802936fdfacfbeb34357e12479a176b0888dd600577468b45198139b891c74ec7897ba18c866518c0af7f0c13e7e8bb9ddac70d064e569ac7c6005f531f9c0c5902a6a23b803d82585662fbd9e7007f1cd07461ac1cb0e4963afe83ec972e91d09a436de834061fafeecd29614325152dc873ff173a0045797dcf08cec55c074ba7c2e48e364c5311700af4e267a7042f04444e8070556b0ff5c9c5b3d62fe55b6fc12f1bc7aa47ec066203f5b9be0b563c29edd4c6ed120c2e63ed274a0945416d412f69dd888dfe48e1301b704268702837b5d80ba7fb30000b0468c00fec10cf527d8fb9ae5747bb6d3c51325ea3b80427f381a06b5dbb8c190fe265cde516e6aa8f6a371d39f80783c1c97070f9a1eea37378ad83e1c7b18ff07b6ee1623ab7b397072fd5777a5154d18bd52277eca8917ddea946f592743fc9f0557a9ce95519c69f062e541cf274783a83db2855f4efc5d73b240ee9f4661a9dc1a01c3a5169af7548bbf94c86ff4c7b8b56c0b954a5fc037e762a74a803d8f3cb96389cdb5e58a67dc952310e8298eee4af7537001d8e98fa3ba51ce71e6b79703922f44e8942e2760d2635d39ecf87d2b449fee0969aa14a9a7526bd258326b7cdee8820331f9d37553b660aa77885d9e5d8bbae44656834d8345771d085568fdaca22028219602963d2c599cea4939c4ada03b623c94a7186d1d04fc25d0916f45ccf1204c7e5b96b4ea44eec17eafc64ba79d02bb1861486f0298878891775f43808d0499467c7c007daa13a08ab54f53206d233c9bb4e7efe52f1f6a907c80f55bab2608dfb075ef06ae600119e9b5050f2c18d143e84ad399cdfe5be3ca1d6e36263c633a1184af2d0b4e0c461d20d345e25a32b55508724f1ad2a72be4988d3ee4abb24aaf10e2652de0849a846b1cede2c62ff7a597100260f672b6842858ccdb15043f493c3bb80985e4e177413e11ea6f27a3e638bbd0f66e4ad8c97750da1544f9ff299e41cb6c24e34ac1501c39b64063d966112e48ff1e7219feeb0ab993e54503090296a2ff964423e1efe583a0d207916e24268849d92418011169a4d575aecbec61fdf1258dc5c86ef6025e471e645d76d47fa099ab51ddec424af319ee9e9511642c3123a1bba417e13f332256e592f43de9fa4be10a13e8e7f8269957a75a9f80212f7c82605770862ac9984f56a5c1e86797d6748f998ab8834c784fe49669d2a9e04bf102f855ff62bbd0a3bb32cdc331e3c3c04c9d097933d5cd3e2a38a04519ae0f70b381ef9332c95ae89d6a2f28834c5fd2f5883d3faa55e03bb7d7149da6a926a915962eeca8052de806383d32b7e7c2f422c7717d3116cf43c347c4f0440f202431c07fb2ab9019dcaf8357008940df91f5d0c3d6039a1271edbbf0988a7dae9fee20838e712884bfa3f9089b75ea4c6dda9565f5c1801e4deabe393699132ef06f5bab8c5f92165a9abbd1627140647656be6965df2779cd967aeed81d3f3001b206cc458363488e0e0ce420bd3d6f08736187d90d35ed0e69cbcaa5847a3ec508adc18d5993329801150c66198b764c1a2bacb01a08234c916733bcec55d03f0ad872d39852fa08c6956696f536d160c3b747d070d875f4529cc35b4bd9f12befd915fb245dc3aedfea68ce449a74f15b88dca186bb014581461b6a4242b0ae2273645388b138cf7e4de58e70c0da7440b36457d699de671f073f3ca3c4b6d045f9acbe1cbfa343efb61c9333e8099d56176a8c04d201cfffa7c5120871a7ca3e04b9184a928a9d6c80b1ffc1538c638cbfa6fb20233a30ab1fbc8a1e1b9e4ef6657aee2aa8727415f0ca0d3aff4533bc47a938519c513bdbf0b347713457dc0d8a3da2fb3c2643e37dab70a5896221ffbaac1d7d1c7db0d0a679eae65d600bfafa3bcdd83fd11b1cf689d3550b458acf78d19b6d06b672b05201cad5553e8135d259bc311a31ca9c08779d6aa8a2ae18f94b82b3f5788fe3a7133332905d9af2ae3ee409277e3e6e6384c96dc52a10660460f04c5cca986c6c734064643276bb165567df21301186d2cb9424d8af44c80421a1d0245840841d06803a3ccf08a1c15b6e9795994f73ae5e9f108ec753f7e62a8e8bbe67e12e0e6d1f88607e7554b1729389e7b5bb1e772e52e6659a64c3746f59bfb474de41a2990e00da0f4b4e7279df56b84cec0aa101a409009ca6a738f97751ed1e57db5a3983a94072514dafc4f6c946fe82f5113bccdef304e9e9a8826ec785bd9cc7a091278dbbba6634d3a5d977d11178677a28641ebb24a2ec196ef256a2ec1f41865b28ed56962e270a0de0e077a12b9be6bce7ed33b41e166b8a69774e331680a456dfbbc5ae781ec09e0acd1df726f482b322de99c4734cfdccd384329cdf5f4d620040d8bd8226871538aa805f3e82a75f7ae508d0db8f236f110076a5ae35b6c4c2bbb2a51478de6338554ccf5983bbb8b2e01ca733f737a87773389c7363337a6ae75eb2c074f2b963e418a8f52cb108dd8cf3cd4016e6651b3883b034e2ce966afbeeb3738bf4820a4f8bbe640e4a817e676f925b6c7967530b3c8eddc5b6976c85a65f58936a895243fe8fe5d010f1679988a7d371a2bb5482332529466e3f3b767479fc0f18ffee2c109214c9e701d2114dd8a50802af2ca42e00a081007eec36cd229604002ad85e617b4013ad3bcc47d96020fa7a109379c7db93bf0e43367dd333c779472b2634e8eab0663364d1c36189f55a8ef8c28fd2bea3eaad11da958373f0c4ceac6de422f90666c203604ff386f79d6b43aa0623656bfa1910ec823a0c21b1bcd2356a11950435f6a9f69e733eaab9ce12fb5c09b31ba859072c8127107a820f0246d67ed962eebc7aaf9ada4683730012d6e28c99f918ba4df68d5a1d43ec1c91f841ae0a7f53e6ecb1406bb0cb6882831d03519be1bbd3c59eed93b6f252774683e75d448d5e39246465d942931eebd3d04c845c3807a33282b7e8fe6847dda7e591421ef46258fb18c5254883608c9d08f4618bdff30929178c68521858d35b13a4a8c6e91e888dfccdc7b964d1df1b80d3a6a345660382ef4b99628a858e98495c87be8d3f300e0fa466a61c9e999d278dc7f98fb316ef4220393b917b153d43f51fd78462c8d1f74bc9e1092bcbc972f72fdaffafe675709ba29866e6736aeed1b0f1045f16deeb8df7937f76ba739fd07d36bf42bb3cc52c073d4092e90254140f989ff7ab5a9ec438e1eea29a0f4b0577ef6f975d6dd306119d2a52f346464dac4d10f915ce70a3cf174a7a40d709ebf56f26e0f3bb1771b65bb887664be161cf07322ea171279ecc45d813dcbc09360f8c4728fcaa435ceb8d74c936730bd8f3bd10960879e91a3b49b9f5dcabe369555ac4d1fc23108fec294da25dbc9cd4218d001068e74af077f57c20d23ca4fd500a776a9eea66e7231c05f473b781c9dcbf3bd6a876ac78a043932eeea47f4170e7b7d873a5ff4a487e9a072155871d586607f2a0de5dba4e2e876c0ead06c46c111e2c10cab8ec3c9c05ba6905c13861149285a0447c97e221d0123e99a5ac0c6262c4d7168cce0dc058601744258155f29ea66517b421f114d4553f99992fa2e72af5ac384f71631a61cfe2cdc50e1f7143cedcea599f59772342780c60e6fc5e4ee9267cce6440a1a81e6b4a10e05b1ecc0f9573ef12f36b7e5247cd54d9b2b15734ea95d014d7baa76e4f2d53b8dcddf07013175371b748da7f3ba8607b63bae07a41835b99c393d0a40947af1d28e34079dd8a987c64259c214eff4e940b502a8cc45283299ae3753af178e3c13291790742269b927c752ae91fdac1ae5c3fbc03a70d7716da5da65c8b4fe5f7b803b587e694c49b2d0c1c2ddd7cdd51d5a160c3f6eaa08201af37abf31f09426644f917c5b2c71379d947eca8edd94f72e0342e89b687859843c8b5e2c4aa223e42da03948907eeba994bd808606e7f4408e1282855283df579f6ad695a1f19e88f173ab8e33098da2415d813f570064d60e3c79a0cf537eb0901de1cbd8443b4b956d09919cbbf90c52fc732879c15b36c8b44421f600ab45f46204f38a3064d10e56b6516ad3feccee903004c1917f33c4b1521c94d83e26ac2f79a221ecfb06cda65ca67951296d024f799c0ca63be49df268265351735a2a3a16b8add3685cd9a0dc623d539f2db894588f8e74ffb4fc0cc382f91616c1d6b5e3a223e7f13ef1b748c7cc841e02447eb0092adb0f3c5689b9852b1d6644955124507a314558d36d8db50e54381c829136a49152c1642031648d58981afac98fdd68b263db1a79faf5d0662f5c3b0f81f798153ab03286d302978accb33428e20b3c4b01d1e56f59c72ab3ac985fdf4c7148f7b8f70cfb1e7fdbba9f3a5bc0e6f53f008b5194791f6aa5afefbc8b0a0310bc5b51c5bf9b648e2588aa604c583a960cdcae4214283a1397df8a7b901f413dcce91811d72d47c6b8afdb6315b78be3dc3e8a7183ec87630fe054d52b0f6ac0a9d1d4080a0caaa36e2256dd254850eb4d285fefc2cf2abc029d2ef5ee0fdaab1336b1aa413ae3fafec79ef08497ef26b0ce7234cdc0e77bc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第二周总结(4/8 - 4/14)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]3765. 表达式树</title>
    <link href="https://blog.phbeats.cn/posts/4d1178f3e0bb/"/>
    <id>https://blog.phbeats.cn/posts/4d1178f3e0bb/</id>
    <published>2024-04-04T11:41:18.000Z</published>
    <updated>2024-05-16T12:50:00.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3765-表达式树"><a href="#AcWing-3765-表达式树" class="headerlink" title="[AcWing]3765. 表达式树"></a><a href="https://www.acwing.com/problem/content/3768/">[AcWing]3765. 表达式树</a></h1><p>请设计一个算法，将给定的表达式树(二叉树)转换为等价的中缀表达式(通过括号反映操作符的计算次序)并输出。</p><p>例如，当下列两棵表达式树作为算法的输入时：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c3f2bab7.png" alt="QQ截图20210708095213.png"></p><p>输出的等价中缀表达式分别为 <code>(a+b)*(c*(-d))</code> 和 <code>(a*b)+(-(c-d))</code>。</p><p><strong>注意</strong>：</p><ul><li>树中至少包含一个运算符。</li><li>当运算符是负号时，左儿子为空，右儿子为需要取反的表达式。</li><li>树中所有叶节点的值均为非负整数。</li></ul><h4 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">输入：二叉树[+, <span class="hljs-number">12</span>, *, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]如下图所示：<br>    +<br>   / \<br>  <span class="hljs-number">12</span>  *<br>     / \<br>    <span class="hljs-number">6</span>   <span class="hljs-number">4</span><br><br>输出：<span class="hljs-number">12</span>+(<span class="hljs-number">6</span>*<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>给定二叉树的非空结点数量保证不超过 <code>1000</code>。</p><p>给定二叉树保证能够转化为合法的中缀表达式。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>很容易想到这是基于树的<code>中序遍历</code>的算法，难点在于加括号的时机。</p><p>通过观察发现，除了根节点，每棵子树都一直在重复做的事情：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c45e6e6b.png" alt="image-20240404195438756"></p><p>那么就会有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">ans += <span class="hljs-string">&quot;(&quot;</span>;<br><span class="hljs-built_in">dfs</span>(root -&gt; left);<br>ans += root -&gt; val;<br><span class="hljs-built_in">dfs</span>(root -&gt; right);<br>ans += <span class="hljs-string">&quot;)&quot;</span>;<br></code></pre></td></tr></table></figure><p>在中序遍历之前需要加上括号。</p><p>可是，有特殊情况：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c5cd7fef.png" alt="image-20240404201019068"></p><p>那么就需要特殊处理。</p><p>当碰到叶子结点的时候就不需要加括号了，直接输出结点值就行。<br>也就是说：<code>只有叶子结点两边不加括号</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     string val；</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string ans;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 遇到叶子结点</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;<br>            ans += root -&gt; val;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 非叶子结点</span><br>            ans += <span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>            ans += root -&gt; val;<br>            <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>            ans += <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">expressionTree</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理根节点的特殊情况，直接处理左右子树</span><br>        <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>        ans += root -&gt; val;<br>        <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3765. 表达式树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>第一周总结(4/1 - 4/7)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/216a02683518/"/>
    <id>https://blog.phbeats.cn/posts/216a02683518/</id>
    <published>2024-04-01T13:19:14.000Z</published>
    <updated>2024-05-16T12:50:00.293Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0e0c679d7feafcc9d0c2aa66f93997a13d827a30477d5d0f72ff0812234a3cb6">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814870b88c966fecb0cc2e967028af3411eee7300cb80bbf274f423dd19658f7505c530642711d548c2dc40e28f93eae2df7482b8d7f287346b0700bc0a6340105e6ea3aede3f037af485f18b8b3bed1367387e302de213c7661d9311e5de8feb9732ca67c4573b20edc8ef5bc3525464e85c21b047d751374412e1463cf3a1916e8dc86e753f6a76827c450ce814391ede13b13708368897ddf751d3ad12d75ab7133e419f45a4daba29d4481590da59f287b85f357d28fca03170453ea227274644608fd462f2583ae33283f8743e5b57ebae9650ba1c2c522a73c49277e7f818b4431fbe5ff793fea52c249e7afcef85a308419edb0fefad03f15809f45519fe8c7a8708c35d74100c7086b7ad28972b1e75ca4016ebebf8ddae22c333e262e490409525fb7934949c1986f5bf59394f88d55a073260d2e9b32bad061280a3c3f7547da3daf47cc63cb300bee14abb49bcd0f7bd1f45058ce82fd0046ac77c135f286d65eaf6d5ed12ed7924e83ad033f13b2385c6fb254d67f5bb56f986d6920740ed912071ee156e64bdc2b418fe3a02f1d35744e03b1643bac3e1f27329e2b2c087e123e026353bf929e9e6606b5f7dbf9dac23db4275a990b4f63f422a32d1c82c115b6f038cf05bdb7d0b63e1af02405c17e5b5afcbdcbe549229ee0dfd451cf3a4da25d9f9b857eab388167c95d0396598c5e8da793e6889421792e10ee2a97328e78910dc679a18fd4ee0caca158b028754a4a0eae729875bffa3313f6f74dc7f3ac84d2dd6a1dddeadd6254eff498178e35afc40bbb0ed400aba75744d10837c389dfbb2313239650c73edaa70eb81b48c2929d57e7cb58888ee62da4a49d54745011b231d6913f20f4b4aad9755bc5ffe1322783604e37930b4125a7b12d0a397946f687a57cbee171764684ea69c1d0f7f1ac89d2929449466af2c2a90ee603de2c8547af4249ce635ce40ab3f9a509e5ca2cdfbabfb6f486f17f5033203745892373a04bb569a30b14e2d4bd5d5cbe2d53bd24edd801a51b06bbd28189e8c41ef9b2ec399a8fab257c23bbe98ec4d70f688b1d59c40eb229ac8aaeabdd02733ae8e083a1ff7b1dc9e58dbb4d9dcca755c95b39d01e057f06e24faabcb8fed7ab3758adc9013dfb9c1c8b9a4f28fae3dca392cfd84f7eb96a2d5849295e77c2d2f5b0a042d88dbb9db9e1d9d6376f8fe4775e1feb304dc9cd17672d9b90660b3936554039277744e40d248b436296ee908fecc9a2399d97e31d0318488deb60437a0ac1f1cf87d716c2df7fb79138188ea830dc4190da8139ef770a591f99bb8c4101872f9cb49de48b7470d64e17509d117a02420badf97e2a6785abb3433ebe1516912c02bc897956f2bf9a582534892ff7ad14bc4b8a936f36a60bd0f3cbf29118f4354127c00d1a1e9112f1e062551e3adcea9cb59e17349194e2f6a5467260be116b37a19ff20fddd3488f3231ef37859c69eddef5444225941eca15cce22dfd117a18d4cfa0d916584169a7602ce347edda5a803d76c2cb9ff7ff9b407a6c89d04227d896dd0694e676540ffc43d99606c194bc843c3283205f188834040d1b8f67f118fc7a53fbd1a92d62af6de5725cf3cca1942a2233e595be09e68d43afe709f1ac6c4c782c27f1c338f8cb1d91e354986a867def22dbd2cb6cf362609fabc464e6210a579abeccad63874985184b19ef62703957ab2eb0f20957c6bf1d489b0d2e0b2704bd958c46606e0beb0279cb9c571225a46bd7c1504e878f1822224e394362546d8fdd8ee76f68bd7e75c37ec7e488e25919244030f7cdf67f7bbcb40c6f2828e1967bf9b125d403619a3887af06751dcb3f1860425db9eaad334b330d2cf3674cb7e0e791d50f2e019a7484321be621f9add7aea8c74a90d81405771b067764f85cf874647a419b4957e3411ba824fe80be6fac4591b2ff31d6089edcc32c16d9d682255cf8026a5c3b4d97668b2411ea145e1ba346e8bc442895fb218a970da23c87fed093c33131d21600aca663bdf2f5e95620b857aa13d9d110bd76ed824f3b74d96a495568ff6fbd97d9938656f7b1b99ca3e1f764d228cb603b1ddb83de65353a13b51a118e0cdfbabcba5845577af9d7ff5919b4677afcc898aede7d585f616688a671b594af7afad2918e3b08df08ff2add06b3a23bcd6a7460a49d591905f3ac6dc609c749293025a2aeb20b06757667e2abfc8146cde114763f43c4287c495a4246f48a50c0853ab049bece83cdaed9e536ebb76ae18afb400ab539ad95a81f89f56092e19e9bc77a0bb9fdabf2ec2e949d40d6774deab16cd1ba93293993d4b73e8d4d53ffa347040ba62af15621da3b26f0949e5630e8f7eb58983e681f8774bea20f17e85e6870dd1a16227babe00ae8dc9a6fa4e03ebb07d4affd666b1eae87c79707445102ce2a5f631be9a634ebd95d8fda953feb569fbac61dc05e0fbf54a3624a390170fca78a148a9d01ad3fc3a743e2f4ea1173a9f28b3db4752690517f78e99bf2ac444d10ae0e71f9ec54bf9bce0a5654d0770dcf81f7175e9a7f1d8e9fdf5ba9fefe32f83aa8eaebf056061011b26b59a0e5d6437cae171f8c9febcd1ab79ebcb77329f0689ece6f4c87aba14548466c1f44b6afffa34e94bb1c30fdb7121937840b23ac0e42c2d1ee867821e1a5de98875b60e16b28aad7912e5e088b12ebf6e6c4c3a9d074dc4f3bf96ac79979051a514bd266b7fe07d050380d82d7d0c4355254dbd2569144e8629ac7fe6913db449d28af15846ebfad03b923edb4ec6adcd925f333cbb5a1a42f258e19e0f1f9c0377d75b469daaef5e7e368698aaa0bf5f27711a78684a8b51be1485fb48fbc5bae67682562d43f85dfc56d19e3dd96c926f19a7ab4c5d963b37f1af5bc0d4bce17c09125c6fd6d1336aaed5f02acd1c4b6b5d5dde44f3d01bf806b473661368664fb054cfae7b1552194c3c2335209b5857ff0fe4e8c77e0b655e4fad1b15b0234ddf4a11907af50dd17d7ef9a02e0607bf3c033ca34cc28be0eb849cfb64342ac0728c61562194506803a3082371253e304f4f00da52fb8d1105b13092e9261108446f9ec1f35fa43b49fa138ddc7ad8a3280aa499c9f61c572f8826392061bbc4372174fb6d6f2f6f77adf947fe27634bfa5f16562b78b0bb958f145ef012131f41bba37c1fecda639ccabaf074e890c8c1e6263fae5ae453783fecc511a4f170887fb48ca0eaf3e75205d868a3c788629b8b6000740d98f67a7aa0b550826c06430afbbd6f35877367d3e74ce95397ff6ddf1ed65cee771d9b22a2fe17f97e00fb9d4279657d01cc33cc1331c6c001777cc7892b855d3b14003e1e9df3c65d491ea8c4b58956b2d3b0f4cb6315a3c0cef2a83cbf81c3eb3e5c1ed8a02addbb74d337d9fa40387cdd215e342591eee13c8689e265c38d73c9039bd6267a06fcf8867f038780eb53a04ff743e8433c47f3e4178d2baa5f884e32d0475643e311c08056e820169305c52304db20ee34a1f41d8a8e1edead8eddceef5bf8fc1fb6f850c62605749c32d428925839cbd398b183cf22cf0bea285b8bcc524b2aee6c5c9daca2e82fc306accdbb8bd41c2c9e3841a99b7fda56ca282cb7863df41153c95d55e19dcc9397681945bf44d34809b8a10ad5f4a956758847b26453558ba1503e180be88c70adc465690d3fc9268db6f324cceef38a4e4de46fadcd687680956171035015b5283adfbc70563eb42fc38317ed2f588c56f39ee21bc2c54b3188cbd4cdb12e3cc59995d2677353ff823b1f3319f232e740c3de89f0cafc44e62b48865154188c7143a952d83f858408506600d648c9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第一周总结(4/1 - 4/7)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>美好的每一天～不连续存在～</title>
    <link href="https://blog.phbeats.cn/posts/ca2f7778875d/"/>
    <id>https://blog.phbeats.cn/posts/ca2f7778875d/</id>
    <published>2024-03-19T14:53:45.000Z</published>
    <updated>2024-05-16T12:50:00.293Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="cab7a019e98abf1e13ac9485d6f41fd87fea4fc8313acc1f6fc92ab8ba99128b">e673c8ca06aefc9fd566f76e908c7073bf122394db4047bcd924ce9ea37328240a38cdea58412a376dfb2c4084c8672e19e7fec2a499cc6cfafe0f544c575fc22968d157ace4fc995bc36c6fc521fa9124d0e79762ed71cfa3cbcfcd4f2370559b60818db7bb6248fa9ec9043fefa6ddd9daae6953ba901f3b971678481dcee1f13ad850e842de09a7c3163f96bfe109ca867b2dc83bcc21ac84d0a70d21b8084f6fc776f65dda5936baf3f89ed826708fa0111450ebbd723630f4858f9b52d4dd1aa605d1fe5ea68f715459a4654df40881da453aa694a3fb0de34b8a3ec0c8dce4495c591ac913f37de8ba201526361352d7c161af77bb1058e56adc7ce2a7bffbfce3dcde47bf495993af096840be3bc84addc5ff934878ba7ded3174baa97d74a6c200dbd8350fcdd0563c0fb71f0779028acf0b6987c59f5be9d8b40d78e1f83910af085d290f461c002d47cb650291f0b0838af5457877960f94bbb7d37e684d9a957cf73ff2a8131baf0860e594c83df1e20b554be188ad14e685bca8f18fc7a5ea63c98c078873d9ff1996cc9f6b694313d4d34a3936c46b8e987cf350381c26d5bba90e8f188819843872c38321f463a0af6c26f162228b995481d97218ab7c70c1802e49d9ffb2fc3a99a0f4d94412cfae73501e3036a9de2d19512724defc1c5be6fc89a489dd340453362a4e734d7c4ae050b7f3af45009146e67fc807bddb5742e1a15f4aff8c8c866aa4f6b0aaf2de85faa9fc4c0704bb125b768fb1688758ad898db8c2244459186ca8c8a7a6a620738a5eda2e3f46c642a4fb7d5215a2577d00d4d72d33cbbdb0c8b30e9887cc7a7af67655c510c5ad6d1bb94af0d9df7bb6ec27afd8280256786afddd48ac242bc24d5412b874251fa2c25ec61e705b506a9063e60f8d7a71c160d55a6ac8c896facf3c97b991bcb3cb16491e68eccc48cc52908ae6da136d3ab140c5061e1649b453c59ed4bde8bbfd50632dcd00bf40283cf1500720caa7c4b9417cc4e01e0547423488339da47078070d3778982e5735f2cba06162c4b2159e5f80d58fb3ce96a376d6067470d78d57e65c51bfb19181f47f986835d5e45652c5b857cc827fe618ab9f1bd5998cd72e385da19cf843e6d796ee9fd367aff5114274410201ef541c4dc7850f8a7da0de4ab4219363df32678c46af521b8f93d80c94588ff3784ab415bfb5a312408f71b7d483f676ee0c8b470d736ca4cfa6ba8fafac55396ec4e824a97c3529ac14c61dc04a36e7348b10c025e553b8f3141e08134fbde88758f4d1e88227a4975be294c050cf6dc8ae96e71a3dc6aaa96ad32cc0b63489d113081aacb3e17090689c128e9c528d76782f635f63157f863eebae765a361f0880e49acd751d1481d5616d1e98e42a6f18571b5f104e592fc87763a14c1887b20e7c625b7ff5eca7fce2f51318a6133d7f475c10f9cd34ad550f64a8c927edb5bec5a21bd455c206b47a3e1e4805925b50474ede78e119e8b11b23418732cfad56eae00d101a4475383c3238f7a3d7d5bcd43517a761c20249ba7db09c9a238f3d1ee001a46ecec2e2f410cf2cb531ac679d4ac223c59231fa025b9a2472db731ed0c05f692cfd0234001b3012c804b329f7201ec3f09646de65ac195bec59651ca544a61c59f810606107d91df62bb5a9ef0c970bb17659b32f6729bf6abd86ea112729ecf1ef56f4899332c20cc9246e86778992ed07f000e43f21fed98260b5b6cb9a6c92d3e226fd75ce05ea7bae79813922326cf6885cce72897b4b204a1216a658d5c985ff219edec3a1a7f80357d168dd8cc4e00b55c613fbb532d1370f1672bdb30b4d0984e5a25c8c7a7351b88237a66539f3094512621490c6c13f10a33a2a6cac4683ca58f0ea13c0e16a17aae6fdca46035555faf04cc565fd6634772a9452fe9c019866b94e24a8ae21aff2f6d8388ea91b89b2bb8fb5084c391b0382d4692e3cd3686d415b01bdcbf1f10d6291f26605efaabbd0202578621497fb46e17d0d668ef344fdd3a02115e6b9017bf21d7e3996bb260a8c443107e449c6c259127611147a5fc70fe97392a65e96cff4c5a1f13d4bf54adf7c34a3213a8ea3b06f5cc28692d4534d2d6ebd2a7a8d7fb760e882fc1abf18b9bc8e0b098d34e4c8ea24acc13077993b2c3eed318837ad1d13557d85aa81ec11cac925e9d31a3023468b61890c08bf3310288a3f4ffd2418949fe8639a325189bbb66f2ed65a4d348c07dd9d17f06cd6d48af1db54a7b1c06a314342bd07e754a3ded1a4e80603eebd801fd01335813cf598be2ce5cc0f4a27be6e1358111212df0f229599311cdece7dc1f9f636a35f1f98bd1e05067f0487ccfb822f8b7032da17ac787b9a4d336622e242f75270c81016b2677b7d40afa990715cf42c7fdb9019e8a76f93e170eb33451e9ebc9d1afb1422356374bf758ecb9f512e6d014b8d5e6438a94dd9ff77afc58a74e77b7f9cee9d36ec3d73b7242f2706f29fbc0fc4dc3dd098f9789916b46c8c2d38e7675299462d922749246df8e34b51bf57de8804286f30a2ce1f19d2ff7c03c8e6ddaf6efabe5ffdce32bff4accf431c240fd635ac986395af3133432ee6c9075494e4fb780fbb1e2debb6d5dc411326403dbf7cca8c92a7c6abbae69c8cc9e9ef51a8478a7d374f1321691e3986769fc005b234aa856fee6866b1d90e324c459c65d692081b5b501f59a5bb4f12ceb1904a09c0601864fe5912b134a16a1331cb66a512f1a6224d9388fa06832723b2291d7e468b62c217086767a0fa79aa087a9ef28aa88c321eb92c6b494e777e4a322326dbc458f5b9fd25ebce88502960e27ebab081f9f3f203c19808bc09d31390a9918630be2fd4122ba935337fc14e6cbf30a8c93638fbb391bd3661f583e894c2cab38718191769d7b942abc7c71f317b40682d42f9833939feeea5b60190d381b11660e9c041783091627521827e458634e5d08801e99353423479976d4e6bc15ab9562bdea8f1088b4d995b63c90e5e520de93b27e8df3f58c1b049221c92a347fa614c36acc0a6ac8806ee07c9e836b5db639d7525748539e685c4075fc510524271c2a9b15064768ec43cbf33607414cc0196117e85d1602b232ee49616bcddcf039c3aefe43528eb9efc7c35740c406ca0409a844f4b9899d33c6ed59463fd8fb871c44616d7194fb809ce8ff1dd1a4ddf1566229602d6720abcc94e2c3057f06bc5e06cb417c513ddc06ae0021f47f13911fa281c38c2affc1a1a3f473ac107367742aea53d023fc491690f3c60bb8f90a28ef406bf92e10619ddf1be2f7d61831be18c36c3d740cdfca3d5d61e6151c0f8b1938fe2613bb040f9fb3a0cce889f37f330bef708dfe56ef234ce34eb2eb9aba63261ff49bdfb6bdac26d2147bdc2ad94b2f03bbea6a8b295c6f1125051877a73dacb233d713fbd189326d8c8ac07712af03c0183b0abccb2006cf973a35a710bf81a16fe4c4714b07d3ed6fb788e5674e77bedb350df25bd02906bababc612bccc18c9116a3bb91e263b41d06e11f323a494f1c03f855f1040138fe9ed03e9d0f07775355a2461fe6e0ba714dc61b7137dd9d90c41d181d5bcdd1106886bda317d5dd8e18c71c078ec476971d5c4222e924dded72417b2fad49dad87cb59c4c9c93d6fff33ff626d1a893b95b00f037a960b99d36f16948714c7315d29e025c3998f28143f34ad9010a69955b166bd4d836770a13d096d9f0d5c1ba35901456b69dbe84991a12fdfe19442025fb95ff4b9a1956c329e24ab35d6dafe189892f95f7950fbfdd9687824313363804792f4e02fbc01f03e96e6279a305acea417900344ee68151e20d2e1d43ac4826f5eb92dcbff94399ce113756d17cc3b271137c282efba3745553a7fb3d11c093b120b756dcee73ebfb560301d26a4cb7bb039416b913804ea93958abdaddbf6eb031c6e498e14c5b488538e3b8056b36530dfd6ffb9af43f6b64d694985e16e87446b36ea4bd377e6aa361a73edb46d257a9cba9edfa16d7b503da97d97dfcac87ef63a1f99aff8bf78044b99364fecdf7f41876e7ed9c2dbcc87e65fd95b7ab614e42282181f33edd639153226dbe2a6cc9b6b77578ef509d817bd5b0c08362ce5a20ee4b74fa32efd79ec9b05059eca2091500095a880f25a0d8b74c54b74c45aa5f1e0a48412ebd12a2df05235ae687a8aaf8a00611092b0c859f8dde0ec280f36437cd99b803d8dd69e6e5a377dc7de76f1b4b4121a922f8856b663e9c52a4a2c37c48ab6a5e717be2526cc31cde09d74a9e71fc27392bea1f8a9bd79a8e5efc7b602633e737442ef27f9539b43b5e4755f64a6f5fa9cbb82ade03a3471190b7b350bd2443d0652e63e5d39cc0cc2a91391fbc5323dc607eaf5561bcfa126aabf7db39a44e43bf081d577b31cf2c03f27452f80540f1e43395cef639f6f95555c9a1b77b53a8c7ab75ced3314339b3ad5b0eacedc75285823ea1a07adb9cee15c38af634e1ba0fda1c6315f2ce27eb121dc977784cd2c9b9686dfef9cf5edc178eadf9b6108aeb722b23bdc1d5472337858a52ccceb708fdb74b455be1509441b33dd434ee05e8c65142a7ad02a8ecd0189abbbff6f470827b176c75031aa380a4c01c5784a2b437d2d2d3605d8d7bbe38a9164e78c7452dd52086bb8a51903da0bbc711cccbb886c229dfd7bd6e5ff5fd36bffbefb737e86d1ae655d173f6c050ff567c239b804b2c0a5b732e4f84aa607b5ce2acceea532796209e5b1c4c514e04e29c88862beea978385cc53e02ec27f9cfee9a2e63e20f000baf22a710dedeafb012ce30a5acbc39836106ef0fb9114e653510d866fd8ab9f516a611bc7bc6ed6bcd5cb05833aeccd9a7fd2daf07ffb47637044f3ba56731933521a46678e1dbf0084a82e28aa23b21aa11628cf7df22b460b90b094ff8b843c5c227833886a2dea7666b9351756b87ecd9bef409507bca41d5d1b6e365a04d812009d9c7da13ee0537a9f002f41cae7a12f02d9b31d02fae7cdf0271b804540da5cea432641a01d933c6f71918112fb35abeb91b1220ccf302ada010177de1eade37a6a8748cf31d90ac08bd10e06e9ce4930d5ebc3741425d78face46b9f1b9aecf5226d4a31a37ea922d8e23b8180031b2fadd550a19d37d4af964967341000bd5716c9ce9caf947c3d861d73777482d3e82da0b7cac6d543dd42a25a173ac3eb626c7ed79900ed6746a22d311e1a774c20150a592ac11fa8ba1cfee1e5329dd7d2227fd77a5a96cd50cc19bc79e544b4e58562b3dc6335b46ce5818645fb12acf697b699ff68549a6ceab0a84673968e0f0ff882704c2757f596d2950ee1d09fbd14188256f768e6308464aa005d350e3a982a08e73f65971c1885661c77d35f0d0dc97a5bb2affbda665439cc4ab2f7770833b9b82802ca6e39fdf708cc09cd567c04fc181a5f459488ed696e5c24ac9de838792fa3f3f8be0b94fa5c8a46c55be8df89e52c8d4e8857177f50e978f1e1d8daef1b820d095cb638c12e2d0f47bdb0d9b0f9168e1668e53af5eb73469cd6d09688cf9d99ee12f0945da0cde44f6b75592cf5ddd12dc005a9f56278dd2f6c6e829b5792a319b34a39bd13fa744421bd11f137483ad8f9e210f553a3f589c98519f8eceb99ed8c0c7ff4ed71d4eafe177c9d3ad49337a47d66ce0c27c13c765c1e40f10a153c5ec20b9517d76d7f4fe7e6a1405ccf5110259b88f20628c02be68d48b0a36b3e50478694f6a0d874b13397f326274c7622968260b95fa8aada7122f3f70a57b1d622392a43b0a2750e9ea2452e7998c180ff0ce33c43acd4a0f699a739f9140c0b82854c367dfeed995dac83ee0683c73644fd56938ed78dc3134978bb87ec08e8f753de8cc1ff5558ae2f5f7647be27287c8491aa2e59594c26c5a980c94c493207a3e0b6676be372f3f2ee06f31e0aa2e4b2c581907e583faeb3d7d417d26638d1f25882cc7b79b69bcbf019562e00d91558bb9b3e1a25d45f342b303e6c6eb113bc49d4bb33c52653a4f0c5c5d1a4736eb742f14b32cbe5b55dfd22205df852d265d0eb6cb40c4b99fc9d7644e51da5a3b0d1740b60d1625cbc9462fe024d99382bfb936395ceb402c03eb0e1c050aafe4614454e6f90697abb0faac384559df800481c68aee4664dd6ba8189b15042bdc4f7f630822f58407f139f1fcab729a75555009a2931692e0bb97a169a6488fd33bd8e03393e69c78d15999a99cfaf8efcb0e58a30086644ed885e79653b2223b8e1236fd67ec0611f2b23ae02ad9309bbce14e02cdc17e03bbbc4768e6c8c0c7143d90520b432119324c7545024cc0bba11d5d76851cfa834101fc182e6b4ed486f92ba36f97ba33c440e0f8a64a5514bc957663fa0b25c0627ad4690bd5ad185dc114f20829db58d615d3eb09786da0b58cb07b04cbdcdf54431e04debbda2befdb9618b0a276b154fa7d22eb7fffd6fea874ff0e82fad6df675f0771d2f7852d682e806de59b9b520ec359c3537e494466d03fcbdaca0107a2c8fa26e3b3d8bb7fb3a25da1b85a1dc2f6061842927d64973c6a4de2f0f5153688d1403c8af123e3fd0c326b24ef162a42708564880290d80cf51e5ec6753ed4b3818456959524e67140b39112a3aa21bf9a45761a07f0c648fcd6b6b843f7445030358f181700216b86210c9bff1b79891d7505b89c3385058d1866030254c4b01d4ccb8869f9b4ebf72ea6a09b57360299a2cc81de8bb05c0d3ca80205bf63f4df19c7f365c828f740e293600fccb432bec6d882756ac303bd304c63e2f5347bbb45640e29cd1c13eb8d1ba1f5d4c2c43f3ba4bc775f1274876a8ffdcb24a05d3d62707623d9d161348ad3100b61b50acf2f25cda13e7c4f6f3a69e7e2b196941bcf550c5a973c37716ef377269bcd7a1db169fbffac748680c866e5528942bdbc8f46c5a2599a9b091d6609c049687e51ea23225b9409cde2e9f23c0bb52c4e4e442f638e8c90e907b089cbb7871d35923b16e1db5ae59988e0ab8735202040cf687439af016c989e4d2d494dca1c26186cb2bfaf4d75ae9f980a317e5ec51b4a62e9c093da7717fb0c2ab486c18e5bcdfce8f3f6082e5bef42f811d6112d68597bb48ed2f50dedbfbbfe0167a7cbffc8f422b1eba06ba86e6ac5d1f69c3ac314189b098ab4251b9f6ac157c306c338384b0a0a95ce5579a41799250a11297a1ae349185c03bf850dfcf140937dadbda6844516a456fc9d2e56f51a907458f4f55863c24a3a877af022f975012b05daec62ffb9b75a3e4d66004aeeb0224097b17cd10369c48d3e960b48cfe10371ecb83cc8d99bd870c615c6072e8d1707711748aa4128887fa1a504e0f1380df57803b13813cc5f458cf62d45e419b3c344ac2d6bd1e1bbaae58c426f1fd59c90a87390b05a98f986f5d4c17c93863bb65865a1e76640cd149d314c1dcfb92ad3b24fa3e43471ce29a12a869326e9a107f020eb17cc59c66fd2f041ab52907d0f387950198be8866ffb29f04d99303428973d02d6dfe3a7e6a4fdf0305261176e8e8726e0f9b95993df6e813b872cfc410bd93ff205fd1b82873be8e110c799d285b890c5239f299160a7ddbdd978cc97de07d7d4295e9306063137a1155cb6e8e34c4436faf111668dcac32190b28c311a46291223e816fe7134d0791b9906ed61f881bf290a37345e50d87edc42e4937450cff9226e4f8a6a59a86fb1f0b95f8dde737b4aae149f9b1068174a228d3213100c8ed3302e342d400392549ef638766fa3e753dfd00e01bb78d6e416ae2776a57a8eee1ae2a700629ddee292b603d7d529b5865cdc7e4c46a077f321839e17bbc9a6edd139d788621acba8461f8fb3f4793d2a11214c1ae47f16c0f0c36ddea0076a490a8b89bf0eb1cbb38847ee90492c9eb31e3d06a3964ac0bca239fb3dc08c643c6e81f9a653d44e7829dba01ff428d2a7090a697e1a65170877d8ed11a656a8424b76fd8678eecb4cb33400acebb1d401d3494c39757f928e8a772eaa0d0920cff193b41a49118e26c3e9c70eeac92054b853c1d33ca8b874ae62675101fb1e8cf334d24cfb188a8f101db01dbef55a43aaf2a5bc436d9c2bbfbb6153f8663cb6aa6e72b201b38448a85c7941c9d1035f5834a728234acb1bd47a92d9f5c45913b163f1b025127f111d5d98471174022a6e490bedc0997f9ff2c72e97df369866778560e538d7ed7dec2b42c650f1eb5608db0204bd7f7b17ed06e6bdd0fa53102d99f70e078bbc815774b7fc872ef4646d22b59ebfcc72b2029c9fe54b62b97edc2984ae24b723f40a8552a2bb993c58bf483367b445ac78d2826043b947ec8b0c4707b78f183330140dfa5a4384620ef80899aa0d1f5c61a01edbd8a076d695a200f5937c1c97273fc92df2ca96f65a39eae0300a4e49e3544c4fa087a2545304a6164f8627a92dfbaf0c4a03fe952cc869235962928f48df5108e47abd66202c6927b3a1e5b8248dcd6290201d79913c39d5e89c67d8eecd507508e102d62d0da5a33c2a6103ecc3402e6178bd8e916e85aac85eb398d52b844fc9e4161c13cc170cbef3eceff997d3c4191359761db0e953b79ca8b34d8757b9fafeb86492f2bda8a962473e63e75af5c98e5d382bd5d967bda5daa980de5865479bd5559f9795d719802869e146ae8b8b195b5281c684a32d53973cf70b13a12a5c5b81b3d103d220074a3480dca06ef062b0b1c32088331629e1fdddda6431a7f9368a753312fc4d1b85a5c69067479fd117c78a1bd4d7341c473d03807f2dc67a523c6a21d2964f5f1cd8e25b295b912f8b6338f5d12ddcfb993b86a4ad060506c6a675132d569288f7fef8c2b0b508849cf144988596dcdb0ae9e464cb1bc8f9236dc9eba311b0dc138c2958c332ba0cfa1ce7821e3c1efa405640da7e72ca2289ad2ce773e95f66c2e236aefe15366fdb9e284616150c49e947d0965a8339a1916b74e1a4a9095b97c502f688adf57a5bafaba45c3b17513462f910fad50b3fcde6f119bf59b71cda19074ab94ec7cf91f1f7c05f4714ed5383235d7320f241ba24d928c484d1e112151fe520bbe177d5040e10a7c273b65ee78c3737c88407d667bf39763fd25b4881f626fe2956e463d4220d1877a3bfe2d0dd310a5728fc0bf330f8af9bb6ed2341067ec3b9c23b7a0e6ee07d5276d23968e85af76c970ba8146f1a33ea86b189972e70ea1480de68ecf867621fedcf75de16d4ef058ec7d4a531425ac9c223f52065b4c40881ade1f20b713cec885560cb8ffd57f136bff886ad63c92b9812e33bc1b5d925dc22f0c2bddba6b0d7d5de4ffa302c2915afecb51bf2c274cb429f6f56ec4f7a7616d54b48346b9b74e64784af6354a16737c455ebe248721a1aaac371f76c526e88c21ce9229cbcfaede13d7a22b922a0e5d10ddb1434eee406e514fa17b54ebf85c3ab9da7ada0f2b05f7c87426f17b686d89f5faf476bdd7d2174134ac74528daf0531f661baea242c9175d15cb4099c94fc58739df441c74dc9c0dbda4992755959ed2c8a1dfb63bed2d3d4cfe37c84bc70c842785c461f0721d752487cb1e8ad7be130dd454366e53f06bd54a91829e9177ade5dba630bd2d5f8c062c7b3622a7e667bf89aae64a214503270460db06f2e3257f5c7cdb3eafb7c7af772303cf8c9c224b26ff4250f56138c4580f26caf26e2065e10856e1eb7272ab201d9e1a10de3ec4f2457119afcf446aa312ec27b9e5d6e9cde68decf533f15fa665d4f7ade1b9090ab6c2c6245db2c3a3553702bb5723d607152483260b5db04f4b233227f969a744d639736deca82b8d1acff1846b35f515ed1d44d1d33402b92734c2b958d47182a2334e4f99a05d618f7e6f2aab584612d5180713a0363383b4ab14de9e489ebc0c21332c30ae68861a1a076bdda837307f6471587b37aac4a5c59226baead88a1a51767177499bff76678c776530dbd569702e6231ce20f6ff6ff8fd6e97a3460fa0877c0489c08bc5fc85fe0c672c08addab57c47efc8f396ae16ebd8c80bcc4770b906dbc43204f227829e0ff8278fce668d44293667a6095212de6e2707e821217611a7ae65fa9099f66e0a170b6eaaa2bdc0268ffc3fd2a5266aa015b1efddb07fa3abf9d56e230993ef3cebf56f51b7e25296af17e782f5c0bb134aadb18d4c15766bffbbc923bef3cb5959efaf23643655d9d925f5cf62b0e76029df9dde8ed02d00203fba396ff6b8c8b6e83c24094cfe92097930839aa5da34e4df7420efb814890616a9bbae3c25bac20bbcc460b4e2c582040d1502d1dc9de5d6b2c58ac70be71d35d002b1ee37c13b006aafd072843d5e0a9b77f8367c15183d5f2235d3c8e0611f90940532b583eca25efe8752677d28a0d64360bc6c80ba1f7d885d8cfa0163f767293cb1ef8f9fbb809a83b79789ba7dd175fbc9bbc4f859746fd5e466494224d1fadf37693d06ece97f6aab667c924947c546482dbb8c6eb19da431c43ecd0b4dea93b7f22da58fc848286fdf972981418bbfcacca1a51cc66a870d0fc4c3565b6aa771ba56c9fe30f91b9fa2465bdcb1d41e3fc43afc586cf5dac0ffc1217043723a3c6cf7b3490399952cb6f72d14792de166acfe531290f1d3caba9d3453ac02adaefba970640e6791ba1be83468387173d265c30a04520b3637a97cbb03a6e88edd522fea0a921c32504d94b819a057073de69a270ec00b1a08cb5aa978d33d970b497ad5b764e8096ce6ee2e0abe136feb9cae2013624af93ecc658a3443b933d79ed43c28eafd7e017f238eaa1552124d23bb6697ec6ce24dc722699ddb9d021ac1fa0d905427abb99b3f75c5ff98372f81665b15f8407a99ef7e782857878f5fd46fb197ab896e04d6aabcaefe19496d22f0d945dee8fd344664f53651709b2d9a9b321bcba686abc01424f5964b8a2d4939027b675892df6030d37bbdf1cb1421b29023ceac7cd585db6f4e43e618da2bc2cf0f1c1b283278cccc7655a6de09487ff8c7926bef3fc1c2b97bc7327ab7501e35ff54b66d8eb38396fd03be0829afaf939abe02ebbc02e03b2a91e93f72e682a0fb6f9ac337d0d850124c9f595a375bc8afcccd132de02178a490a8b1ba4682da03069aa2f43d78eaf60d42ea1525b6e1f44c4728de59688e0c4e07b2c4d4ea76d2426bff08fe6d768b390c2bec12bd4503c3ecfdb7d4844b3827a48bdcdccf09fd4d482ae514728ef2a43465e4bf5c1fc223ebc13e78b7d3f10a57e8ba7926bef29d6ed6a9f93a7b30821f53ae77cf8c59b2729e579bc4eeef30fac434704adee280567cb8ab5ada1ce41791af3551a53c36e9b911dfa7bf44d902a19ae853d8546b97104d55a14d4c1d90b5d2479168e41dab449f56eadf2ee1c34a69f4178c71492e5fcbd5c6b4afb8bf536d5e35ac199c13cf0dc18ab4cdfc7a60867ee2dd683622f27dd74acdf8d77cf7869dbb34eaa472b437f4dada0b9e048a1ba97dfe39492118be20424dcc6c22378a7e809756230472e5b38d51655401db25610b384903c0026d75544af59bf3bfdcf3d7ab7f310c35d8d05f6f25bd3e21ac55a28242f88784288023a71cd20e384cf40e2a428e01743175ebea7ab2e586f66a471499e44f39e72210bfd2ccd1a96755639abdb1f2d6254e85ad7e1bf2c628d2846f80fe7846af5be38a460028432b12216c6c079a1315d2df34e496bdc11aefd8ba30b945ae5e4c4295d620a5637d81dcb89e38b0f5d79d85c6aaa6c9dfb98ce5b8b9c42c80fb9aae45826caf3e016e905ae664740b9adbe945f7fa214bcc547bc77417113c22608f8d72ebc218644ed48e5f89b28f651366e1a3084a31fd64aab1d9edaef0e8c4a3b322fa1dd7bc51785c740fd317c4c699688f8339b524aba84565931ed1940c413008cf662d32ed207d58ddb6efecea7d73608e94399ce0ee8bca8f50c8b565505c1f4ae7a5dc5bd0d12cf5c20d685a63a89b2ba143133f5e4e7be4185b07292fc4fca8f2a1b56d2b98e5e9bfd3a800697662ea7cba2836367ee884604183de9a79ecf38d891f6d1c2d8721eb3a106aa87f6e7e29b07a1c588e3fc435462f4274dcd6ede2c70de33720aec0e8a100b402219d74dc0ab99d652bb6f91686602b95d0a7ba4aefa835e0a1d6bdf7ca23d173725757a78d67545bce62303100edda6613bc9679b4a317264a089a62df1501e4104dd3e7a80683215bc666c155231738ee67c84afaec587e36b510e65974692fd2b49ca7f3881cab527b47a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">美好的每一天～不连续存在～</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>周志汇总</title>
    <link href="https://blog.phbeats.cn/posts/acdb8d5c9b7b/"/>
    <id>https://blog.phbeats.cn/posts/acdb8d5c9b7b/</id>
    <published>2024-03-19T14:37:12.000Z</published>
    <updated>2024-05-16T12:50:00.297Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="885e60e2d6a5ed0fb38db62a527ed1e1d7c376653dd08149fdf9727fe0936f04">e673c8ca06aefc9fd566f76e908c7073bf122394db4047bcd924ce9ea3732824180a4f1db344e311487ba241f1b16c4587f75b861f83fe634c4c300b5ce9c13f6ab2dc51be3173e872c5b9303aab66b98f2d10c9186f542c60bdf6e9e018902100efec3c9b0d9e25eb662a6738083cac0144094eaf56dff4f3d0dac07a1d8fde55b12b81cafe45e830d294450db7709fb63d8646cd7dbfc68602c1aa7bd817e8f76fdfc74c1277e320a30180efe06403a97e6f934d084e4d24a4b565f7c367414397784ed156c305a7ffd132f0e9754e52f1377dc9ab7b8c82e80eb332a9499cad7e6433e805342202368e93c755a7afccbd65b77c0be4e4d18f65b7b251eb790731125c3f694c853c1f69b5e5df409f5bfd03d0949ba954eb996b0623e80bb1ba55a0fcbf1124aba367eca4d5273a2853ae153eb861f18cccc9de081e15f3fdee3195620f6f7f415a7c86f033937b748de82d7f0c9fae37b4882190a3b6dca92202b2d28d07a2a4fa623336ffc9483be1b7b60644593122b61456f3296175f8acac9ddfdfefa420c67c3f063702dbc614d95d49c95d548e1e77d39fdf6eee41b2dc2c79e17a12a021f5166cc9270ec4b3afbeb3e46ae99b1f558961228e7ab7c26f1f33dfec514a525ffa53da17b920e7d71c4ab55378b8d4ffab137706da1bb7b837ec5c15398b66fc0c47b930e8587cea57746eaf2f238ef15f31f03838ffcd40b210347625623f90bd7f4388cf801756e759ba337bab9712a18ba91a92198ce53d51f4d6226f4b3910e0c29a04d2cf04fbd3fc503394d6260482eb681a0b6725bc19b1d3ab3f9588029494893ef2a0bbeeae8df0c09a9ab4cec0196b7456784f64c8949d3445e1b66b2498c1e41a18e005d0a736420a9bcc099520e0a708cc80cc435302ad2dbb09605ea947005199136277c4a5669834488d0742cb6c7b111dbdec1ee66d7fde127e69716789c913d4d0bdf77244e89fd7c5afe3c4403fc2ac7b2e201be680aab46d455ec3ec6a6b087ea4c89475b065ae1273f9ff80b3f371a9b6a126d4c8a2dae839fcf58585516e8d85f671d01b5ce847165bdef1873ff3c3ac6bd684ce142aa520cbfae06b46b99ed28b4c76bc3309cfda46ac8beda582e77c746cfc03f60ac0ca3c3aac831e1719ee6db6c0d81c133592fb517205cd0b8318aaa16972b29e6cfdf5d9bad937491bb334436190329f9cbc9cdcc5cd68209ebfdc0b5bdb1b33a4e013c57adede375b20313fd6a16f0ad58e526e51d5612198b3a975f4e67d28e21e7fd90cee4b8bcfe9a08d1af07f30351bd6b0fbf09d1bb68940b172c2d926e8f6c83dd62f50828231c6d7069906f35252b2ae2d5ac6dc625caa50b69808c8c6e35563f6413356df81fa87a943249397a31dff4ae97332db591ed65eb68a2bae3c66fde4c968257063b3c85895ed22a788c6c19be43555e388199d6f7eba58f0913a05665af896587f4e58e4f3dc2376b9046ded71d9a3ce9c265d7bab2a0b2e0eea0aeaec9c56a3213e8c3cf2cce25b9f0204bf3af25ee8f38f723b99fc415af712814a3265ed1c3d872aded82171d42d19798bab450cd92ce63db531e241b01410724cbfadf43e64e6b22be58aa514979ea62dd0cb25a22f7d0d7ed7f217e018d2d539182b454147b09af38b73160ea81bce613d003a11f00d563e0ef3a3e40888d27b6696c7204b121dc26b710a3207664f53ac9f05e5c29680670dede2a7da3659fecd7300ceebeb211fdff9bc9689e2a0cd1d50eb4a3b667ad4d830932849b001e7af0ecf1a97cfb6da2bc748e6bc078f4f6eb741acee3dae970f77fdb86ab45974b6c140bbf6d681d7c1442717f7bce3b064be525ffba6746ecddd830bf9b9b5d93e1741863cc8a87a4ec32073d24e54d4f7605dd5d37d49d1b801fda8d1504cec7aa0b303f05ccbb17fabc254eea9713034c72aaa0476a26323057ae821953aabc96f6b69b20286b05b9081a92b82073d5888424db879e52cc27eae14d1a8962d1744c5fb6bf003c56b0a6a38e7b32a5e3f64c72496748186487feb4693fed7e6684e037fbeb93940b033e0efd33d0ea7471a1f729e9013c94ade9fb954bcfaf3a0106e7e3418f9c8045860b5bb3545445d97ad0d2635df9faea389bcac4e5abdd525df7b8a9cc41117a7d9e0a1ad5a378bc8aa4df2a5e814a8f90e06e1cdc2399bdfc57062bd1796e69c00a475d78e4d4f531adcff8a5fd3509173a649ae371ad2a8b2791c17d6be6ffc07701ae8d36e322c0c0208d2207af5b44bf029b896b18344ef276a75b867e90fe5b414291208795e5ded1867d2358e4252d5a3d96cce76e31a866d05c2ee5c91b8ed895e0647902128512095d3c2235720300547e563b90eae6e4a3ae04aa0f290bad0ad1271ab8c390ddbea95f97be366c44c0b3212920372926bc65ee4e79137da976a8c40c8f206b063e3d8e52209fc93c4aa8f1e66a481bcfcded89da77e2c4ac6bdec99f1b15006f3ad363e69f08fb17a2ed14c5c27a79a05cd8b87548475a33903f7df4c24643c41aaa79446908f1e3ce1b6d46422f16fa9064a930d4d082cc391676e6e4ddd8c9b29681daa33f913eeafceb4ad7240d82eb412716e062ea6a88223a23573a1abf61ce52a2726cfd14051cfbb797eb8ccd98c058495b1110501a791c8bb8ef25d2020f0183208ff92e51aa34886ee07bdf94cc9806fef13cb51e28b64b0d64f948de8b6ef68eb28c2349f926ca02cdc5698dbcddfcddc95c02e4c73214451e59263d116db31b29c81eca7fea17be2a429ed101da9adfebdc4646cc0d392f35b7a6d4a2e2c4a668d42377f4932f05de600691a8450552d3ee577ce6093626c7179a7d7ad35f4b23407ecd7883ee3d0462f59490b321e468ebc392f599bca7f06224606e8324528804092da8d71b7bbafffcf8165a3b092fcf84d0f25e03bd61edcc24550b7e18c48a521307cc0aa051fcc96735b3cfd523b1694a585975ee6aa1bb009d67cfb601c4cf8ce67a73a59f648c8ac7f72b56c02fac07d97b886c5ec8affac459546c1336223f083639a2216ff4cd438ed7c2589ff6eb797ab39e8cc350a578e3351159195f2b6b9b596b6ff4e8b1b52a49a00391b9b3f5210195abba80503ed615f2099186c4b942b164c0fd36cd54eb6be156dfdbe116aed3151dd17fc275b3d1f66adb504621170f192c1b3aae0a281e1115aaa6343c82ea5e8df07a2286efe403904c728e1b637b2d9458935470cf3bb22067885fe7d8d3c3eec5086f7a8ad0cc99a2f908455e24ec9ec69d4a770ed6cb5bc7469aff598b0de11bb5d5729cdf074b5b983bc673bc5f7c0ff844cc0492d9dbd5d31ebe6ae85aeae99c6d28a24ebcca9fdf47c0717b42415802e1b2177e55f31123c39bfb171a5660841e721b3e0540a1b13717731e66df2a2f0df9d39e7a9d45677cf996538ca4ae72616ca5bde8cefe421f6f59a0ccaea594b121f0a69e2a0f61d526add5ea04e1200b2f902526c2a62455310772d588d93481725ac0e75a10db3b0b8b65a2bc196fbbb81a0ae754ea31b9c648081ee11a3be1c8e0778a21cfa8ff32688415d45b6a3a9151c5ae4b204c68f9499e5c8b965ec967ae6b61d6a2ec1ef482b3288b6159f2c224a0d300b3309fd62fa0fe6a837f9aefda85acce25d64e05f1ad00b09109c3dc1f6837407546218637cb2716266584bbfc1504949b765f067fe54c43759eef383defc13050c84d6e5cc9c572bc3232c910b0fbcee2eb3f502d50870bd2fc6f4fbfb08251796ee66955b856691eb8e084bcff9461d957984547600eb94cb3daef76db215042472cd5bce998088d0373fd3ab6d542d4e29e6a1a1ebaaaa8b31306d065b3c139151f0947436734288925c5e88a0662fe6e1496a865bd6d9ae3ee8243447b2899814b2356aa52dedc666f65a03c496de530e9fc7b9feafc89406bdc717976f495c5f6c3e94ad78d1cf2d138ffe99487f7c6024ac71d7ead1ea13855826af1e368aa023db406447c4d3a2918e6ca33bc638459a86d1bcc70a59aa2e9694965d03c0323948e5fe707797228836fb59733e436c045ae48c4577f67aacc282d2d9ae40c612025fa84df0903886a13a12b9519c87b79b946f0b4eddb9f76300ce724a405261d0499ab0549142cb636621c510d57dab33d86493060330d3fea9dd92ec89c48213d996c754a84e11a6957f5a48c8db02366a1d788d9eba3b6a30b325a8544e1d6e8c84f5d8a7f5e71544125381ac85859414c5eea3de9ded2fc224a04cbcaec46e1663152f7caee2f395f5d235607232cc36f2a14193a943614ea16a300a964e016085796bdc6f8b24bcd0ea1cc718c4478e1c211c7fb6747074b91abfc5f397d6b7a9d9755ee5d1cca5eb3f8feec145174be74cbf39805060b83307611681a76829a8b50e2f647f79ea24b09437ae15acf567807e195c0f1578aa37faf4811e860275b07c87d558c4eb2341792c01c7ccf4064ba7af7c86595709ca97fa48f53b133cef1a06393b72b774ab0c42a33b8c81a7aea5b656392ee6b5367a94b8379d22af8e539aa81f2b2fa8c5ec271dbef34571535084acf449fa06e7646f41f01dc899263f6a8a4ea584ad161fc38b59873a75091b841869c1f6f05f5f4cddde0fd0e030d2cc9b2b0538ab76c9cac31fba605fdc062a5f66e956b6db01796258e0a3cc44223968ac8ddb87933844efcc6c94fae908e5ac25efdf1606d064105bd867a12e559bf77d74131c2b84b1b12720639e33a344f2ced6c092211abbcf4e9bc4613a5b77d268e93980ce2700f783b70ecd3d1f3e39c4ab1f3016972baa439fdde93b61a10fe2684765cc65263e69b9ebb2f0fbd95a999b646876d974b71056b86f6e272a5e83a3a07a0995efe73d02c6d46e8818f3bdd99a6173f04aad3e798077eed1a56b4057b2235ddcf8d1161830e38a1c72564ba58625335055ba9ef28f2fe15e8eda28539f8a418b58e9d13e2302d592a261363cea8d3a6dd268fed2cfb3dd3428aeed5b50c2ad3109b731e00614e174869dcd5241298c5c9c8e8ffe28d9f3d5a7536d796236bd2c9552be6bd49eac7f31c9db24f07cdc515c3e04321663d2d7533dfee9177db5f35da97d4b621cd072ed150765fd28d1504044153142bbb0036bbe5aa03ca9c4b595da64d86d93f85e951e79bc821e91cdee23deb598ee69eb3a80c53857dba99c24233bcd8caeb418a30316ec935aea721b1f074d2046be1569c9fa763d0cba4b36dbd20d685b2a8d29f13d602533c9025d305b38dd4584d8210eeefba021875fb823c28f2fb6e17d113db958e99a3a8b20cb14b1d070e24ffc354ad120fbeaa3e329360ddd76840bdc229bcb4ab0d44388067b024b5151d9d4f47122d25db69ce022af53d81ddfda9b21663b2e7bf6ea33fc2fafcf766fb1b7645200758c30483dfd0a92156d87765260024f4875c1b7471d45073c43413768c1e73f85dd0e64e012b83ae1512ee17592930b7464920f8f517cb33d16cced6110e282c190dc53c03aa62faab5b7882fbbf2f84c5857fa7924d1cf731f0b03eecfe06edbdc973bdeee5d78d7683453624593dc82c1e05e4fb8bff70cfe9259aacccc777b371a68557ffb4bb9ea761d63dbb952d069460498f4f18de01b19ba6348b87c01a177373dc2cb9dc4d294d2941d373575ce84f45f4cf534e37d050eaded75adc07f4a6d52967ed68b867841a2fca89fc7cddc666a1a9f33d519f1ea1e89b8aae6cf19260d12e97299e59e66bdd4faa1cd42092220c824dacb676c7105cc4bcd3925ab8d35a0769a83433eccc8f3be235c0ebdf023775a94b2d1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">周志汇总</summary>
    
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/tags/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>图-基于邻接表实现</title>
    <link href="https://blog.phbeats.cn/posts/de48a254d011/"/>
    <id>https://blog.phbeats.cn/posts/de48a254d011/</id>
    <published>2023-10-28T06:30:33.000Z</published>
    <updated>2024-05-16T12:50:00.297Z</updated>
    
    <content type="html"><![CDATA[<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>使用<code>邻接表</code>作为我的<code>图论算法</code>的基本模板。</p><p><code>图论算法</code>可以使用<code>邻接表</code>和<code>邻接矩阵</code>来作为地基。<br>我选择王道书上的邻接表作为我的模板原因有：</p><ol><li>若要使用<code>邻接矩阵</code>，我有 y 总 的模板。并且也契合，因为可以使用一个<code>二维数组</code>来简化类似邻接矩阵</li><li>我如果是出题人，要指定数据类型，我会选择邻接表，因为考生肯定会优先选择二维数组。</li></ol><h3 id="邻接表的类型描述"><a href="#邻接表的类型描述" class="headerlink" title="邻接表的类型描述"></a>邻接表的类型描述</h3><wavy>我似乎理解错《数据结构》这门考试科目的含义了。它应该重视的是理论，而不是代码的实现，我花费了大量的时间在代码上，这是错误的！因此我打算停更...</wavy>]]></content>
    
    
    <summary type="html">图-基于邻接表实现</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://blog.phbeats.cn/posts/00977ebe8687/"/>
    <id>https://blog.phbeats.cn/posts/00977ebe8687/</id>
    <published>2023-10-27T09:10:02.000Z</published>
    <updated>2024-05-16T12:50:00.297Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>使用<code>链式存储</code>。</p><p>因为书上的大题使用的都是<code>链式存储</code>。所以我也采取这样的方式，作为我的算法模板。</p><h3 id="二叉树的类型描述"><a href="#二叉树的类型描述" class="headerlink" title="二叉树的类型描述"></a>二叉树的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br><span class="hljs-type">int</span> data; <span class="hljs-comment">// 数据域</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> * lchild, * rchild; <span class="hljs-comment">// 左、右孩子指针</span><br>&#125;BiTNode, * BiTree;<br></code></pre></td></tr></table></figure><h3 id="先序递归建树"><a href="#先序递归建树" class="headerlink" title="先序递归建树"></a>先序递归建树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序递归建树</span><br><span class="hljs-function">BiTree <span class="hljs-title">CreateBiTree</span><span class="hljs-params">()</span></span>&#123;<br>BiTNode * root = (BiTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br><span class="hljs-type">int</span> ch;<br>cin &gt;&gt; ch;<br><br><span class="hljs-keyword">if</span>(ch == <span class="hljs-number">-1</span>)&#123;<br>root = <span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>root -&gt; data = ch;<br>root -&gt; lchild = <span class="hljs-built_in">CreateBiTree</span>();<br>root -&gt; rchild = <span class="hljs-built_in">CreateBiTree</span>();<br>&#125;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">PreOrder</span>(root -&gt; lchild);<br><span class="hljs-built_in">PreOrder</span>(root -&gt; rchild);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br><span class="hljs-built_in">InOrder</span>(root -&gt; lchild);<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">InOrder</span>(root -&gt; rchild);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br><span class="hljs-built_in">PostOrder</span>(root -&gt; lchild);<br><span class="hljs-built_in">PostOrder</span>(root -&gt; rchild);<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先序遍历的非递归算法"><a href="#先序遍历的非递归算法" class="headerlink" title="先序遍历的非递归算法"></a>先序遍历的非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">// 一路向左</span><br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 出栈，并转向出栈结点的右子树</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>p = p -&gt; rchild;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于先序遍历的非递归算法：<wavy></p><ol><li><code>根左右</code>，先根的性质，决定了在<code>一路向左</code>的过程，是可以<code>边输出边入栈</code>的。</li><li>模拟递归回溯，也就是<code>else</code>部分，此时已经完成了<code>根左</code>。现就只要出栈，并转向出栈结点的右子树。</li></ol><h3 id="中序遍历的非递归算法"><a href="#中序遍历的非递归算法" class="headerlink" title="中序遍历的非递归算法"></a>中序遍历的非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 中序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">// 一路向左</span><br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 出栈，并转向出栈结点的右子树</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br>p = p -&gt; rchild;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于中序遍历的非递归算法：<wavy></p><ol><li>与<code>先序遍历的非递归算法</code>类似，不同的是<code>什么时候访问结点</code>。</li><li><code>左根右</code>，决定了必须要找到最左边的结点再回溯。</li><li><code>else</code>部分，也就是模拟递归回溯过程，必须要先<code>出栈</code>再拿着那个结点的值访问。</li></ol><h3 id="后序遍历非递归算法"><a href="#后序遍历非递归算法" class="headerlink" title="后序遍历非递归算法"></a>后序遍历非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 后序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><span class="hljs-comment">// 还需要借助一个指针r，记录最近访问过的结点</span><br><span class="hljs-comment">// 因为回溯的过程中，可能是从左边回溯，也可能是从右边回溯</span><br><span class="hljs-comment">// 从左边回溯，那么根结点就没被访问过。</span><br><span class="hljs-comment">// 从右边回溯，那么根结点被访问过。</span><br>BiTNode * r = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123; <span class="hljs-comment">// 一路向左</span><br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 转右</span><br><span class="hljs-built_in">GetTop</span>(s, p);<br><span class="hljs-comment">// 右子树存在，且右子树还没被访问过</span><br><span class="hljs-keyword">if</span>(p -&gt; rchild &amp;&amp; p -&gt; rchild != r)&#123;<br>p = p -&gt; rchild;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 否则出栈</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br>r = p; <span class="hljs-comment">// 标记为最近访问过的结点</span><br>p = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 重置p，这样下次循环会直接弹出栈顶元素。</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于后序遍历的非递归算法：<wavy></p><ol><li>指针<code>r</code>：回溯的过程中，可能是从左边回溯，也可能是从右边回溯。<code>∴</code> 从左边回溯，那么根结点就没被访问过。从右边回溯，那么根结点被访问过。根结点被访问过，说明该直接从栈顶弹出一个元素。</li></ol><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 层序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 辅助队列</span><br>SqQueue q; <span class="hljs-built_in">InitQueue</span>(q);<br><br><span class="hljs-built_in">EnQueue</span>(q, root);<br><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">EmptyQueue</span>(q))&#123;<br>BiTNode * t; <span class="hljs-built_in">DeQueue</span>(q, t);<br>cout &lt;&lt; t -&gt; data &lt;&lt; endl;<br><br><span class="hljs-keyword">if</span>(t -&gt; lchild) <span class="hljs-built_in">EnQueue</span>(q, t -&gt; lchild);<br><span class="hljs-keyword">if</span>(t -&gt; rchild) <span class="hljs-built_in">EnQueue</span>(q, t -&gt; rchild);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">二叉树</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>顺序队列</title>
    <link href="https://blog.phbeats.cn/posts/54e3f3a21b91/"/>
    <id>https://blog.phbeats.cn/posts/54e3f3a21b91/</id>
    <published>2023-10-27T08:33:53.000Z</published>
    <updated>2024-05-16T12:50:00.297Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>顺序队列，以<code>循环队列</code>为主。</p><p>因为好写，所以采取它作为我的模板。</p><h3 id="顺序队列的类型描述"><a href="#顺序队列的类型描述" class="headerlink" title="顺序队列的类型描述"></a>顺序队列的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>ElemType data[MaxSize]; <span class="hljs-comment">// 存放队列元素</span><br><span class="hljs-type">int</span> front, rear; <span class="hljs-comment">// 队头、队尾指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化队列 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp; q)</span></span>&#123;<br>q.front = q.rear = <span class="hljs-number">0</span>; <span class="hljs-comment">//初始化队头、队尾指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EmptyQueue</span><span class="hljs-params">(SqQueue q)</span></span>&#123;<br><span class="hljs-keyword">if</span>(q.front == q.rear) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 入队</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp; q, ElemType x)</span></span>&#123;<br><span class="hljs-comment">// 队满,报错</span><br><span class="hljs-keyword">if</span>((q.rear + <span class="hljs-number">1</span>) % MaxSize == q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 入队</span><br>q.data[q.rear] = x;<br>q.rear = (q.rear + <span class="hljs-number">1</span>) % MaxSize;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 出队</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp; q, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 队空, 报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">EmptyQueue</span>(q)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 出队</span><br>x = q.data[q.front];<br>q.front = (q.front + <span class="hljs-number">1</span>) % MaxSize;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获得队头元素"><a href="#获得队头元素" class="headerlink" title="获得队头元素"></a>获得队头元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获得队头元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue q, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 队空，报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">EmptyQueue</span>(q)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 获得队头元素</span><br>x = q.data[q.front];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">静态分配的顺序队列</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>顺序栈</title>
    <link href="https://blog.phbeats.cn/posts/15d79a1a4b3e/"/>
    <id>https://blog.phbeats.cn/posts/15d79a1a4b3e/</id>
    <published>2023-10-27T08:04:26.000Z</published>
    <updated>2024-05-16T12:50:00.297Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><wavy>顺序栈比较好写,因此我使用它作为我的算法模板</wavy><h3 id="顺序栈的类型描述"><a href="#顺序栈的类型描述" class="headerlink" title="顺序栈的类型描述"></a>顺序栈的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>ElemType data[MaxSize]; <span class="hljs-comment">// 存放栈中元素</span><br><span class="hljs-type">int</span> top; <span class="hljs-comment">// 栈顶指针</span><br>&#125; SqStack;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp; s)</span></span>&#123;<br>s.top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化栈顶指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断栈空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack s)</span></span>&#123; <br><span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 入栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp; s, ElemType x)</span></span>&#123;<br><span class="hljs-comment">// 看栈是否已满,报错</span><br><span class="hljs-keyword">if</span>(s.top == MaxSize - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 入栈</span><br>s.data[++s.top] = x;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 成功</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 出栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp; s, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">StackEmpty</span>(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 先出栈，再减</span><br>x = s.data[s.top--];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获得栈顶元素"><a href="#获得栈顶元素" class="headerlink" title="获得栈顶元素"></a>获得栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获得栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack s, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 空栈，报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">StackEmpty</span>(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 获取栈顶元素</span><br>x = s.data[s.top];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">静态分配的顺序栈</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
</feed>
