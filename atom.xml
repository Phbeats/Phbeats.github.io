<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phbeats-Blog</title>
  
  <subtitle>记录学习历程和生活感悟</subtitle>
  <link href="https://blog.phbeats.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.phbeats.cn/"/>
  <updated>2024-09-23T02:49:29.918Z</updated>
  <id>https://blog.phbeats.cn/</id>
  
  <author>
    <name>麦高芬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谁是你的潜在朋友</title>
    <link href="https://blog.phbeats.cn/posts/34326bde9f48/"/>
    <id>https://blog.phbeats.cn/posts/34326bde9f48/</id>
    <published>2024-08-01T05:13:44.000Z</published>
    <updated>2024-09-23T02:49:29.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing3404-谁是你的潜在朋友"><a href="#AcWing3404-谁是你的潜在朋友" class="headerlink" title="AcWing3404. 谁是你的潜在朋友"></a><a href="https://www.acwing.com/problem/content/3407/">AcWing3404. 谁是你的潜在朋友</a></h1><p>“臭味相投”——这是我们描述朋友时喜欢用的词汇。</p><p>两个人是朋友通常意味着他们存在着许多共同的兴趣。</p><p>然而作为一个宅男，你发现自己与他人相互了解的机会并不太多。</p><p>幸运的是，你意外得到了一份北大图书馆的图书借阅记录，于是你挑灯熬夜地编程，想从中发现潜在的朋友。</p><p>首先你对借阅记录进行了一番整理，把 <code>N</code> 个读者依次编号为 <code>1,2,…,N</code>，把 <code>M</code> 本书依次编号为 <code>1,2,…,M</code>。</p><p>同时，按照“臭味相投”的原则，和你喜欢读同一本书的人，就是你的潜在朋友。</p><p>你现在的任务是从这份借阅记录中计算出每个人有几个潜在朋友。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <code>N</code> 和 <code>M</code>。</p><p>接下来 <code>N</code> 行，每行包含一个整数 <code>P</code>，表示一个读者最喜欢的书籍编号。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 <code>N</code> 行，每行输出一个整数，其中第 <code>i</code> 行的整数表示第 <code>i</code> 名读者的潜在朋友数量，如果没有潜在朋友则输出 <code>BeiJu</code>（即悲剧，^ ^）。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>2 &lt; N,M &lt; 200</code>,<br><code>1 &lt; P &lt; M</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">4 5<br>2<br>3<br>2<br>1<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1<br>BeiJu<br>1<br>BeiJu<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>看代码，十分好理解</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-comment">// 每个读者爱读的书籍编号、每本书有多少读者喜欢</span><br><span class="hljs-type">int</span> reader_love[N], books[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-comment">// 每个读者爱读的书籍编号，同时更新每本书有多少读者喜欢</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; reader_love[i], books[reader_love[i]]++;<br><br>    <span class="hljs-comment">// 输出答案</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-comment">// 读者 i 喜欢的书，书有多少读者喜欢是可以知道的</span><br>        <span class="hljs-comment">// 比如：书籍编号：1</span><br>        <span class="hljs-comment">//       喜欢此书的读者：读者1、读者2</span><br>        <span class="hljs-comment">// 对于读者1有1个同好，读者2也一样。规律是：喜欢此书的读者数 - 1</span><br><br>        <span class="hljs-comment">// 一本书如果只有一个读者喜欢，那么那个读者是没有同好的，输出 BeiJu</span><br>        <span class="hljs-keyword">if</span>(books[reader_love[i]] == <span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;BeiJu&quot;</span>);<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; books[reader_love[i]] - <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">谁是你的潜在朋友</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="数组" scheme="https://blog.phbeats.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>图中点的层次</title>
    <link href="https://blog.phbeats.cn/posts/56731801551e/"/>
    <id>https://blog.phbeats.cn/posts/56731801551e/</id>
    <published>2024-08-01T04:05:52.000Z</published>
    <updated>2024-09-23T02:49:29.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing847-图中点的层次"><a href="#AcWing847-图中点的层次" class="headerlink" title="AcWing847. 图中点的层次"></a><a href="https://www.acwing.com/problem/content/849/">AcWing847. 图中点的层次</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的有向图，图中可能存在重边和自环。</p><p>所有边的长度都是 <code>1</code>，点的编号为 <code>1 ~ n</code>。</p><p>请你求出 <code>1</code> 号点到 <code>n</code> 号点的最短距离，如果从 <code>1</code> 号点无法走到 <code>n</code> 号点，输出 <code>-1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <code>n</code> 和 <code>m</code>。</p><p>接下来 <code>m</code> 行，每行包含两个整数 <code>a</code> 和 <code>b</code>，表示存在一条从 <code>a</code> 走到 <code>b</code> 的长度为 <code>1</code> 的边。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 <code>1</code> 号点到 <code>n</code> 号点的最短距离。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n,m &lt; 10^5</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">4 5<br>1 2<br>2 3<br>3 4<br>1 3<br>1 4<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>边权为1</code>的最短路径，考虑使用BFS.</p><p>很简单，看代码即可。<br>需要关注的是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 从起点到节点 k 的当前最短距离 dist[k] 是否大于从起点到节点 t 的距离加上 1</span><br><span class="hljs-comment">// 如果条件成立，说明通过节点 t 到达节点 k 的路径更短，因此需要更新 dist[k]。</span><br><span class="hljs-keyword">if</span> (dist[k] &gt; dist[t] + <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 更新距离</span><br>    dist[k] = dist[t] + <span class="hljs-number">1</span>;<br>    q[++tt] = k;  <span class="hljs-comment">// 将未访问的点加入队列</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = N * <span class="hljs-number">2</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);  <span class="hljs-comment">// 初始化距离数组</span><br><br>    dist[start] = <span class="hljs-number">0</span>;<br>    q[++tt] = start;  <span class="hljs-comment">// 将起点加入队列</span><br><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt) &#123;<br>        <span class="hljs-type">int</span> t = q[hh++];  <span class="hljs-comment">// 取出队头</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = h[t]; ~j; j = ne[j]) &#123;  <span class="hljs-comment">// 遍历所有相邻点</span><br>            <span class="hljs-type">int</span> k = e[j];<br>            <span class="hljs-comment">// 从起点到节点 k 的当前最短距离 dist[k] 是否大于从起点到节点 t 的距离加上 1</span><br>            <span class="hljs-comment">// 如果条件成立，说明通过节点 t 到达节点 k 的路径更短，因此需要更新 dist[k]。</span><br>            <span class="hljs-keyword">if</span> (dist[k] &gt; dist[t] + <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 更新距离</span><br>                dist[k] = dist[t] + <span class="hljs-number">1</span>;<br>                q[++tt] = k;  <span class="hljs-comment">// 将未访问的点加入队列</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dist[n] == INF ? <span class="hljs-number">-1</span> : dist[n];  <span class="hljs-comment">// 返回终点距离或-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);  <span class="hljs-comment">// 初始化邻接表</span><br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>) &lt;&lt; endl;  <span class="hljs-comment">// 输出结果</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">图中点的层次</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>我想回家</title>
    <link href="https://blog.phbeats.cn/posts/f8b1a9df93e6/"/>
    <id>https://blog.phbeats.cn/posts/f8b1a9df93e6/</id>
    <published>2024-07-25T09:10:19.000Z</published>
    <updated>2024-09-23T02:49:29.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing3403-我想回家"><a href="#AcWing3403-我想回家" class="headerlink" title="AcWing3403. 我想回家"></a><a href="https://www.acwing.com/problem/content/3406/">AcWing3403. 我想回家</a></h1><p>某国正处于激烈的内战之中，该国的各个城市按照支持领导人的不同分属两个阵营。</p><p>作为一个商人，<code>M</code> 先生并不关心政治，但他能够感受到目前事态的严峻。</p><p>你需要帮助他尽快回家。</p><p>出于安全的考虑，你所提供的回家线路中，最多只能包含一条连接两个不同阵营城市的道路。</p><p>请你计算，<code>M</code> 先生回家所需花费的最短时间。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含多组测试数据。</p><p>每组数据第一行包含整数 <code>N</code>，表示该国家的城市数量。</p><p>第二行包含整数 <code>M</code>，表示该国家的道路数量。</p><p>接下来 <code>M</code> 行，每行包含三个整数 <code>A,B,T</code>，表示城市 <code>A</code> 和城市 <code>B</code> 之间存在一条道路，通过它的时间为 <code>T</code>。</p><p>最后一行包含 <code>N</code> 个整数 <code>1</code> 或 <code>2</code>，其中的第 <code>i</code> 个整数是 <code>1</code>，则表示城市 <code>i</code> 位于阵营 <code>1</code>，否则，表示城市 <code>i</code> 位于阵营 <code>2</code>。</p><p>所有城市编号 <code>1 ~ N</code>。</p><p>为了简化问题，我们假设 <code>M</code> 先生是从城市 <code>1</code> 出发，目的地是城市 <code>2</code>，并且城市 <code>1</code> 一定位于阵营 <code>1</code>，城市 <code>2</code> 一定位于阵营 <code>2</code>。</p><p>注意，所有道路都是双向的，且两个城市之间最多只有一条道路。</p><p>输入 <code>N=0</code> 时，表示输入结束。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每组数据输出一行一个结果，表示最短时间。如果无法到达目的地，则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>每个输入最多包含 <code>10</code> 组数据。<br><code>2 &lt; N &lt; 600</code>,<br><code>0 &lt; M &lt; 10000</code>,<br><code>1 &lt; A,B &lt; N</code>,<br><code>1 &lt; T &lt; 500</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">2<br>1<br>1 2 100<br>1 2<br>3<br>3<br>1 2 100<br>1 3 40<br>2 3 50<br>1 2 1<br>5<br>5<br>3 1 200<br>5 3 150<br>2 5 160<br>4 3 170<br>4 2 170<br>1 2 2 2 1<br>0<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">100<br>90<br>540<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>分析输入：</p><ol><li>第一行：点数<code>n</code></li><li>第二行：边数<code>m</code></li><li>第三行：边<code>add(a,b,c)</code></li><li>最后一行：每个点的阵营<code>team[N]</code></li></ol><p>核心思想：<br><code>A国最短路径 + 连接两国的唯一一条路 + B国最短路径 = 答案</code></p><p><img src="https://bu.dusays.com/2024/07/25/66a21626eaf76.png" alt="QQ_1721898317357"></p><p>难点：</p><ol><li>查表<br>0、1、2、3、4、5、6、7、8、9、……<br>看成：[0, 1]、[1, 2]、[3, 4]、[5, 6]、[7, 8]、[9, 10]、……<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = e[i ^ <span class="hljs-number">1</span>], b = e[i];<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">对于： 0 -&gt; 1<br>a = 0, b= 1; <br><span class="hljs-code">`0 ^ 1 = 1`</span><br><span class="hljs-code">`1 ^ 1 = 0`</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">对于： 2 -&gt; 3<br>a = 2, b= 3; <br><span class="hljs-code">`2 ^ 1 = 3`</span><br><span class="hljs-code">`3 ^ 1 = 2`</span><br></code></pre></td></tr></table></figure></li></ol><p><code>idx</code>一定是这样增长的，所以<code>任取终边一定能找到其反向边</code></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 题目给的边范围[0, 10000]</span><br><span class="hljs-comment">// 由于是无向边，每条边建两次，所以M至少要超过20000</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">610</span>, M = <span class="hljs-number">20010</span>, INF = <span class="hljs-number">0X3F3F3F3F</span>;<br><br><span class="hljs-type">int</span> h[N], e[M], ne[M], w[M], idx;<br><span class="hljs-type">int</span> distA[N], distB[N], team[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 复用型 dijkstra</span><br><span class="hljs-comment">// 起点、起点所属阵营、起点阵营的dist表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> camp, <span class="hljs-type">int</span> dist[])</span></span>&#123;<br>    <span class="hljs-comment">// 因为是复用，所以还要 重置dist和st</span><br>    <span class="hljs-comment">// 细节是 sizeof distA，但是memset执行对象是 dist</span><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> distA);<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <span class="hljs-comment">// 起点距离为0</span><br>    dist[start] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))<br>                t = j;<br>        &#125;<br>        <br>        st[t] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 更新邻接表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = h[t]; ~j; j = ne[j])&#123;<br>            <span class="hljs-comment">// 邻接点</span><br>            <span class="hljs-type">int</span> k = e[j];<br>            <span class="hljs-comment">// 如果不是同一个阵营，则什么也不做</span><br>            <span class="hljs-keyword">if</span>(team[k] != camp) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 是同一个阵营就更新</span><br>            dist[k] = <span class="hljs-built_in">min</span>(dist[k], dist[t] + w[j]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n, n)&#123;<br>        <span class="hljs-comment">// 复用就需要重置图</span><br>        <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>        idx = <span class="hljs-number">0</span>;<br>        <br>        cin &gt;&gt; m;<br>        <span class="hljs-keyword">while</span>(m --)&#123;<br>            <span class="hljs-type">int</span> a, b, c;<br>            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>            <span class="hljs-built_in">add</span>(a, b, c);<br>            <span class="hljs-built_in">add</span>(b, a, c);<br>        &#125;<br>        <span class="hljs-comment">// 阵营输入</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; team[i];<br>        <br>        <span class="hljs-comment">// A国最短路径 + 连接两国的唯一一条路 + B国最短路径 = 答案</span><br>        <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, distA);<br>        <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, distB);<br>        <br>        <span class="hljs-comment">// 查表</span><br>        <span class="hljs-type">int</span> res = INF; <span class="hljs-comment">// 没有答案的话，res还是 INF</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i++)&#123;<br>            <span class="hljs-comment">// [0,1]、[2,3]、...:规律</span><br>            <span class="hljs-comment">// 0^1 = 1</span><br>            <span class="hljs-comment">// 1^1 = 0</span><br>            <span class="hljs-comment">// 建图的时候，add(a,b,c),add(b,a,c)</span><br>            <span class="hljs-comment">// 正向边和反向边，一对一对建的</span><br>            <span class="hljs-comment">// 此时 a 是反向边，b 是正向边</span><br>            <span class="hljs-type">int</span> a = e[i ^ <span class="hljs-number">1</span>], b = e[i];<br>            <span class="hljs-keyword">if</span>(team[a] == <span class="hljs-number">1</span> &amp;&amp; team[b] == <span class="hljs-number">2</span>)&#123;<br>                res = <span class="hljs-built_in">min</span>(res, distA[a] + w[i] + distB[b]);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 无解输出-1，否则输出值</span><br>        <span class="hljs-keyword">if</span>(res == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">我想回家</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>朴素邻接表版Dijkstra求最短路</title>
    <link href="https://blog.phbeats.cn/posts/026d6c6391c3/"/>
    <id>https://blog.phbeats.cn/posts/026d6c6391c3/</id>
    <published>2024-07-25T07:18:13.000Z</published>
    <updated>2024-09-23T02:49:29.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-849-Dijkstra求最短路-I"><a href="#AcWing-849-Dijkstra求最短路-I" class="headerlink" title="[AcWing.849. Dijkstra求最短路 I]"></a><a href="https://www.acwing.com/problem/content/851/">[AcWing.849. Dijkstra求最短路 I]</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 <code>1</code> 号点到 <code>n</code> 号点的最短距离，如果无法从 <code>1</code> 号点走到 <code>n</code> 号点，则输出 <code>-1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>n</code> 和 <code>m</code>。</p><p>接下来 <code>m</code> 行每行包含三个整数 <code>x,y,z</code>，表示存在一条从点 <code>x</code> 到点 <code>y</code> 的有向边，边长为 <code>z</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 <code>1</code> 号点到 <code>n</code> 号点的最短距离。</p><p>如果路径不存在，则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 500</code>,<br><code>1 &lt; m &lt; 10^5</code>,<br>图中涉及边长均不超过10000。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 3<br>1 2 2<br>2 3 1<br>1 3 4<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>两个难点：</p><ol><li>邻接表建图</li><li>dijkstra算法 （参考<a href="/posts/6d0f7c8cf39d/">邻接矩阵版本</a>的）</li></ol><p>给出变量名粗略解释：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N];   <span class="hljs-comment">// 顶点 i 的邻接表的首边索引</span><br><span class="hljs-type">int</span> e[M];   <span class="hljs-comment">// 第 i 条边的终点</span><br><span class="hljs-type">int</span> ne[M];  <span class="hljs-comment">// 第 i 条边的下一条边索引</span><br><span class="hljs-type">int</span> w[M];   <span class="hljs-comment">// 第 i 条边的权重</span><br><span class="hljs-type">int</span> idx;    <span class="hljs-comment">// 当前边的索引</span><br></code></pre></td></tr></table></figure></p><p>给出变量名详细解释：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N];   <span class="hljs-comment">// h 数组，存储每个顶点的第一条边的索引。h[i] 表示顶点 i 的第一条边在 e 数组中的索引。</span><br><span class="hljs-type">int</span> e[M];   <span class="hljs-comment">// e 数组，存储每条边的终点。e[i] 表示第 i 条边的终点。</span><br><span class="hljs-type">int</span> ne[M];  <span class="hljs-comment">// ne 数组，存储每条边的下一条边的索引。ne[i] 表示第 i 条边的下一条边在 e 数组中的索引。</span><br><span class="hljs-type">int</span> w[M];   <span class="hljs-comment">// w 数组，存储每条边的权重。w[i] 表示第 i 条边的权重。</span><br><span class="hljs-type">int</span> idx;    <span class="hljs-comment">// idx 变量，记录当前边的数量，同时作为边的索引。</span><br></code></pre></td></tr></table></figure></p><p>容易混淆的点：</p><ol><li><code>e[M]</code>：如果你有一条边从顶点 u 到顶点 v，那么 e 数组的对应位置（例如 e[idx]）就是顶点 v</li><li><code>ne[M]</code>：ne[i] 表示第 i 条边在邻接表中指向的下一条边的索引。这使得我们可以在遍历某个顶点的邻接边时，依次访问所有与该顶点相邻的边。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;      <span class="hljs-comment">// 顶点数量上限</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">100010</span>;   <span class="hljs-comment">// 边数量上限</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3F3F3F3F</span>; <span class="hljs-comment">// 无穷大</span><br><br><span class="hljs-type">int</span> h[N];    <span class="hljs-comment">// 每个顶点的邻接表首条边的索引</span><br><span class="hljs-type">int</span> ne[M];   <span class="hljs-comment">// 每条边的下一条边的索引</span><br><span class="hljs-type">int</span> e[M];    <span class="hljs-comment">// 每条边的终点</span><br><span class="hljs-type">int</span> w[M];    <span class="hljs-comment">// 每条边的权重</span><br><span class="hljs-type">int</span> idx;     <span class="hljs-comment">// 当前边的索引</span><br><br><span class="hljs-comment">// 添加一条边 a -&gt; b，边权为 c</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b;       <span class="hljs-comment">// 设置边的终点为 b</span><br>    w[idx] = c;       <span class="hljs-comment">// 设置边的权重为 c</span><br>    ne[idx] = h[a];   <span class="hljs-comment">// 当前边的下一条边索引</span><br>    h[a] = idx++;     <span class="hljs-comment">// 更新顶点 a 的邻接表首条边为当前边</span><br>&#125;<br><br><span class="hljs-type">int</span> n, m, dist[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-comment">// 使用 Dijkstra 算法计算最短路径</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist); <span class="hljs-comment">// 初始化距离为无穷大</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起点到自身的距离为 0</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 找到未标记顶点中距离起点最小的顶点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t])) &#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <br>        st[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记顶点 t 为已访问</span><br>        <br>        <span class="hljs-comment">// 更新顶点 t 的所有邻接边的最短路径</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = h[t]; ~j; j = ne[j]) &#123;<br>            <span class="hljs-type">int</span> k = e[j]; <span class="hljs-comment">// 邻接点</span><br>            dist[k] = <span class="hljs-built_in">min</span>(dist[k], dist[t] + w[j]); <span class="hljs-comment">// 更新最短距离</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dist[n]; <span class="hljs-comment">// 返回到终点 n 的最短距离</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h); <span class="hljs-comment">// 初始化邻接表，表示每个顶点没有边</span><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-comment">// 读入边的信息并添加到邻接表</span><br>    <span class="hljs-keyword">while</span> (m --) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c); <span class="hljs-comment">// 添加边 a -&gt; b，权重为 c</span><br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">dijkstra</span>(); <span class="hljs-comment">// 执行 Dijkstra 算法</span><br>    <span class="hljs-keyword">if</span> (res == INF) cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 如果无法到达终点，输出 -1</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl; <span class="hljs-comment">// 输出最短距离</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">朴素邻接表版Dijkstra求最短路</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数组中出现次数超过一半的数字</title>
    <link href="https://blog.phbeats.cn/posts/4a6913efcb5c/"/>
    <id>https://blog.phbeats.cn/posts/4a6913efcb5c/</id>
    <published>2024-07-25T05:59:09.000Z</published>
    <updated>2024-09-23T02:49:29.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing52-数组中出现次数超过一半的数字"><a href="#AcWing52-数组中出现次数超过一半的数字" class="headerlink" title="AcWing52. 数组中出现次数超过一半的数字"></a><a href="https://www.acwing.com/problem/content/48/">AcWing52. 数组中出现次数超过一半的数字</a></h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>假设数组非空，并且一定存在满足条件的数字。</p><p><strong>思考题</strong>：</p><ul><li>假设要求只能使用 <code>O(n)</code> 的时间和额外 <code>O(1)</code> 的空间，该怎么做呢？</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>数组长度 <code>[1,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,2,1,1,3]</span><br><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>计数器（最受欢迎的选举人票数）：<code>cnt</code></li><li>主元（最受欢迎的选举人）：<code>val</code></li><li>核心思想：<code>新的选举人可以消耗最受欢迎的选举人的票</code></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">moreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, val;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(!cnt) val = nums[i], cnt++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == val) cnt++;<br>            <span class="hljs-keyword">else</span> cnt--;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数组中出现次数超过一半的数字</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="摩尔投票法" scheme="https://blog.phbeats.cn/tags/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]3786. 二叉排序树</title>
    <link href="https://blog.phbeats.cn/posts/1e9e0dd97bd8/"/>
    <id>https://blog.phbeats.cn/posts/1e9e0dd97bd8/</id>
    <published>2024-07-20T10:02:22.000Z</published>
    <updated>2024-09-23T02:49:29.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3786-二叉排序树"><a href="#AcWing-3786-二叉排序树" class="headerlink" title="[AcWing]3786. 二叉排序树"></a><a href="https://www.acwing.com/problem/content/3789/">[AcWing]3786. 二叉排序树</a></h1><p>你需要写一种数据结构，来维护一些数，其中需要提供以下操作：</p><ol><li>插入数值 <code>x</code>。</li><li>删除数值 <code>x</code>。</li><li>输出数值 <code>x</code> 的前驱(前驱定义为现有所有数中小于 <code>x</code> 的最大的数)。</li><li>输出数值 <code>x</code> 的后继(后继定义为现有所有数中大于 <code>x</code> 的最小的数)。</li></ol><p>题目保证：</p><ul><li>操作 <code>1</code> 插入的数值各不相同。</li><li>操作 <code>2</code> 删除的数值一定存在。</li><li>操作 <code>3</code> 和 <code>4</code> 的结果一定存在。</li></ul><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>n</code>，表示共有 <code>n</code> 个操作命令。</p><p>接下来 <code>n</code> 行，每行包含两个整数 <code>opt</code> 和 <code>x</code>，表示操作序号和操作数值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于操作 <code>3,4</code>，每行输出一个操作结果。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 2000</code>，<br><code>-10000 &lt; x &lt; 10000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">6<br>1 1<br>1 3<br>1 5<br>3 4<br>2 3<br>4 2<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br>5<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>略. 详细看代码注释</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode * left, * right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> _val) : <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 要用引用，需要将改变的结果带回去</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(TreeNode *&amp; root, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">// 此题没有重复的元素插入</span><br>    <span class="hljs-comment">// 遇到空节点直接创建</span><br>    <span class="hljs-keyword">if</span>(!root) root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(x);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; root -&gt; val) <span class="hljs-built_in">insertNode</span>(root -&gt; left, x); <span class="hljs-comment">// 如果插入的值比当前节点的值小，就去左子树找</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">insertNode</span>(root -&gt; right, x); <span class="hljs-comment">// 否则去右子树</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode *&amp; root, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">// 都找遍了都没找到这个结点，那么干脆什么都不做了</span><br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 如果要删除的节点比当前节点小，去左子树找，否则去右子树找</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; root -&gt; val) <span class="hljs-built_in">deleteNode</span>(root -&gt; left, x);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; root -&gt; val) <span class="hljs-built_in">deleteNode</span>(root -&gt; right, x);<br>    <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 找到了</span><br>        <span class="hljs-comment">// 1. 刚好是叶子节点，直接删除</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right) <span class="hljs-keyword">delete</span> root, root = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 2. 只有左子树，只有右子树。让子树接替</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!root -&gt; right) root = root -&gt; left;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!root -&gt; left) root = root -&gt; right;<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 3. 左右子树都存在</span><br>            <span class="hljs-comment">// root的前驱节点顶替root</span><br>            TreeNode * p = root -&gt; left;<br>            <span class="hljs-keyword">while</span>(p -&gt; right) p = p -&gt; right;<br>            root -&gt; val = p -&gt; val;<br>            <span class="hljs-comment">// 去左子树当中删掉它的前驱</span><br>            <span class="hljs-comment">// 在你找到 p 后，简单地删除 p 会破坏树的结构，因为它可能还有子节点。</span><br>            <span class="hljs-built_in">deleteNode</span>(root -&gt; left, p -&gt; val);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 找前驱（小于x的最大数）</span><br><span class="hljs-comment">// 当前值，比x大，应该往左递归，继续找</span><br><span class="hljs-comment">// 当前值，比x小，当前值可能作为答案，当前节点的右子树中也可能存在答案，两者取max即可</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPre</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">// INF是不可能取的值，代表没有找到前驱</span><br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> -INF;<br>    <span class="hljs-keyword">if</span>(root -&gt; val &gt;= x) <span class="hljs-keyword">return</span> <span class="hljs-built_in">findPre</span>(root -&gt; left, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(root -&gt; val, <span class="hljs-built_in">findPre</span>(root -&gt; right, x));<br>&#125;<br><br><span class="hljs-comment">// 找后继（大于x的最小数）</span><br><span class="hljs-comment">// 当前值，比x小，应该往右递归，继续找</span><br><span class="hljs-comment">// 当前值，比x大，当前值可能作为答案，当前节点的左子树中也可能存在答案，两者取min即可</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findSuc</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">// INF是不可能取的值，代表没有找到后继</span><br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">if</span>(root -&gt; val &lt;= x) <span class="hljs-keyword">return</span> <span class="hljs-built_in">findSuc</span>(root -&gt; right, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(root -&gt; val, <span class="hljs-built_in">findSuc</span>(root -&gt; left, x));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    TreeNode * root;  <br>    <br>    <span class="hljs-keyword">while</span>(n --)&#123;<br>        <span class="hljs-type">int</span> op, x; <br>        cin &gt;&gt; op &gt;&gt; x;<br>        <br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 插入</span><br>            <span class="hljs-built_in">insertNode</span>(root, x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-comment">// 删除</span><br>            <span class="hljs-built_in">deleteNode</span>(root, x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-comment">// 前驱</span><br>            cout &lt;&lt; <span class="hljs-built_in">findPre</span>(root, x) &lt;&lt; endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">4</span>)&#123;<br>            <span class="hljs-comment">// 后继</span><br>            cout &lt;&lt; <span class="hljs-built_in">findSuc</span>(root, x) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3786. 二叉排序树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Floyd求多源最短路径</title>
    <link href="https://blog.phbeats.cn/posts/8ec7c1c49651/"/>
    <id>https://blog.phbeats.cn/posts/8ec7c1c49651/</id>
    <published>2024-07-10T13:33:50.000Z</published>
    <updated>2024-09-23T02:49:29.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Acwing-854-Floyd求最短路"><a href="#Acwing-854-Floyd求最短路" class="headerlink" title="[Acwing.854. Floyd求最短路]"></a><a href="https://www.acwing.com/problem/content/856/">[Acwing.854. Floyd求最短路]</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的有向图，图中可能存在重边和自环，边权可能为负数。</p><p>再给定 <code>k</code> 个询问，每个询问包含两个整数 <code>x</code> 和 <code>y</code>，表示查询从点 <code>x</code> 到点 <code>y</code> 的最短距离，如果路径不存在，则输出 <code>impossible</code>。</p><p>数据保证图中不存在负权回路。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 <code>n,m,k</code>。</p><p>接下来 <code>m</code> 行，每行包含三个整数 <code>x,y,z</code>，表示存在一条从点 <code>x</code> 到点 <code>y</code> 的有向边，边长为 <code>z</code>。</p><p>接下来 <code>k</code> 行，每行包含两个整数 <code>x,y</code>，表示询问点 <code>x</code> 到点 <code>y</code> 的最短距离。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 <code>k</code> 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 <code>impossible</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 200</code>,<br><code>1 &lt; k &lt; n^2</code><br><code>1 &lt; m &lt; 20000</code>,<br>图中涉及边长绝对值均不超过 <code>10000</code>。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 3 2<br>1 2 1<br>2 3 2<br>1 3 1<br>2 1<br>1 3<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">impossible</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>Floyd算法</code>可以实现求任意两点的最短距离。有动态规划的思想，纯模板背就行。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span> , INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> n , m , q;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(g , <span class="hljs-number">0x3f</span> , <span class="hljs-keyword">sizeof</span> g);<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br><br>    <span class="hljs-keyword">while</span> (m --)&#123;<br>        <span class="hljs-type">int</span> a , b , c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt;c;<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],c);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 主对角线先置为0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) g[i][i] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 三层for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )&#123;<br>                <span class="hljs-comment">// i -&gt; k -&gt; j</span><br>                g[i][j] = <span class="hljs-built_in">min</span>(g[i][j] , g[i][k] + g[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(q --)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-type">int</span> c = g[a][b];<br>        <br>        <span class="hljs-comment">// 比如只有三个点：1 -&gt; 2 权值是-2</span><br>        <span class="hljs-comment">// 3是孤立点，那么 1 -&gt; 3 的距离是 INF - 2 不是INF但也是无穷大</span><br>        <span class="hljs-comment">// 不妨用 c &gt; INF / 2 表示这种情况</span><br>        <span class="hljs-keyword">if</span>(c &gt; INF / <span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; c &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Floyd求多源最短路径</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Prim求最小生成树</title>
    <link href="https://blog.phbeats.cn/posts/ca375a506a38/"/>
    <id>https://blog.phbeats.cn/posts/ca375a506a38/</id>
    <published>2024-07-08T02:41:45.000Z</published>
    <updated>2024-09-23T02:49:29.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-858-Prim算法求最小生成树"><a href="#AcWing-858-Prim算法求最小生成树" class="headerlink" title="[AcWing.858. Prim算法求最小生成树]"></a><a href="https://www.acwing.com/problem/content/860/">[AcWing.858. Prim算法求最小生成树]</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的无向图，图中可能存在重边和自环，边权可能为负数。</p><p>求最小生成树的树边权重之和，如果最小生成树不存在则输出 <code>impossible</code>。</p><p>给定一张边带权的无向图 <code>G=(V, E)</code>，其中 <code>V</code> 表示图中点的集合，<code>E</code> 表示图中边的集合，<code>n=|V|</code>，<code>m=|E|</code>。</p><p>由 <code>V</code> 中的全部 <code>n</code> 个顶点和 <code>E</code> 中 <code>n-1</code> 条边构成的无向连通子图被称为 <code>G</code> 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 <code>G</code> 的最小生成树。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <code>n</code> 和 <code>m</code>。</p><p>接下来 <code>m</code> 行，每行包含三个整数 <code>u,v,w</code>，表示点 <code>u</code> 和点 <code>v</code> 之间存在一条权值为 <code>w</code> 的边。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 <code>impossible</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 500</code>,<br><code>1 &lt; m &lt; 10^5</code>,<br>图中涉及边的边权的绝对值均不超过 <code>10000</code>。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">4 5<br>1 2 1<br>1 3 2<br>1 4 3<br>2 3 2<br>3 4 4<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">6<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>Prim求最小生成树的核心思想：</code></p><ol><li>从源点开始，将源点纳入最小生成树集合中，求出其余点哪个点离它更近，将更近的点纳入最小生成树集合之中（如果最佳点都不连通，意味着其余点距离都是<code>INF</code>，直接返回<code>INF</code>，因为最小生成树要求每个点都连通）</li><li>在这个过程中，始终是<code>最小生成树集合</code>与<code>非最小生成树集合中其余点</code>进行判断。</li><li>Prim算法是一种用于<code>求解加权连通无向图的最小生成树的贪心算法</code>。</li></ol><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-comment">// 使用邻接矩阵建图，dist是最小生成树集合与点的距离</span><br><span class="hljs-type">int</span> g[N][N], dist[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    <span class="hljs-comment">// 集合中初始包含点1，距离是0</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 计算最小生成树的权值（很重要）</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))<br>                t = j;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 与 dijkstra不同的是，这里需要判断集合与当前最佳点是否连通</span><br>        <span class="hljs-comment">// 如果不连通，那么没有最小生成树</span><br>        <span class="hljs-keyword">if</span>(dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br>        <span class="hljs-comment">// 这个点加入最小生成树集合中</span><br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 权值累加</span><br>        res += dist[t];<br>        <br>        <span class="hljs-comment">// 更新最小生成树集合，权值最小的点加入进来，可能会改变其它点的dist值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 返回最小生成树的权值</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-comment">// 双向图 + 重边过滤</span><br>        g[a][b] = g[b][a] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">prim</span>();<br>    <br>    <span class="hljs-keyword">if</span>(res == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">200010</span>, INF = <span class="hljs-number">0X3F3F3F3F</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], w[M], idx;<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx] = b;<br>    w[idx] = c;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))<br>                t = j;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br>        st[t] = <span class="hljs-literal">true</span>;<br>        res += dist[t];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = h[t]; ~j; j = ne[j])&#123;<br>            <span class="hljs-type">int</span> k = e[j];<br>            dist[k] = <span class="hljs-built_in">min</span>(dist[k], w[j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>        <span class="hljs-built_in">add</span>(b, a, c);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">prim</span>();<br>    <br>    <span class="hljs-keyword">if</span>(res &gt; INF / <span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Prim求最小生成树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>有向图的拓扑序列</title>
    <link href="https://blog.phbeats.cn/posts/ef6a4cd7f55c/"/>
    <id>https://blog.phbeats.cn/posts/ef6a4cd7f55c/</id>
    <published>2024-07-04T03:16:47.000Z</published>
    <updated>2024-09-23T02:49:29.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-848-有向图的拓扑序列"><a href="#AcWing-848-有向图的拓扑序列" class="headerlink" title="[AcWing.848. 有向图的拓扑序列]"></a><a href="https://www.acwing.com/problem/content/850/">[AcWing.848. 有向图的拓扑序列]</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的有向图，点的编号是 <code>1</code> 到 <code>n</code>，图中可能存在重边和自环。</p><p>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 <code>-1</code>。</p><p>若一个由图中所有点构成的序列 <code>A</code> 满足：对于图中的每条边 <code>(x, y)</code>，<code>x</code> 在 <code>A</code> 中都出现在 <code>y</code> 之前，则称 <code>A</code> 是该图的一个拓扑序列。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <code>n</code> 和 <code>m</code>。</p><p>接下来 <code>m</code> 行，每行包含两个整数 <code>x</code> 和 <code>y</code>，表示存在一条从点 <code>x</code> 到点 <code>y</code> 的有向边 <code>(x, y)</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</p><p>否则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n,m &lt; 10^5</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 3<br>1 2<br>2 3<br>1 3<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1 2 3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>首先，存在拓扑序列，必定是<code>有向无环图</code>，如果是<code>有向有环图一定没有拓扑序列</code>，无向图更别说了。</p><p><code>核心思想</code>：</p><ol><li>n个节点，将入度为0的节点全部入队</li><li>删除掉所有入度为0的节点，在这个过程中，被删掉的节点不妨设为<code>t</code></li><li>遍历<code>t</code>节点的邻边节点，让<code>t</code>节点的所有邻边节点<code>入度减1</code>，如果<code>邻边节点入度被减之后恰好为0</code>，则入队</li></ol><p>此题，n的数量达到了10^5。所以需要使用邻接表，当然邻接矩阵算法也写下来，用于借鉴。<br>时间复杂度分别为<code>o(n + m)</code>和<code>o(n^2)</code>。</p><p><code>需要注意的是</code>：<br>邻接矩阵的重边造成的影响需要在加边的时候进行判断，维护入度，不让重边的出现导致入度混乱。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!g[a][b])&#123;<br>    <span class="hljs-comment">// 加边</span><br>&#125;<br></code></pre></td></tr></table></figure><br>或者，在topsort的时候将重边一起删掉，也意味着重边入度也要减少<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(g[t][j]) --g[t][j],--d[j];<br></code></pre></td></tr></table></figure><br><code>使用邻接表</code>就不需要加判断了，因为邻接表在加边的时候，重边不仅加进去了，在<code>topsort</code>的时候<br>它会处理重边，所以入度一直是正确的。</p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 最大节点的数量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-comment">// 节点数，边数</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> id;<br>    Node * next;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _id): <span class="hljs-built_in">id</span>(_id), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<br>&#125; * head[N]; <span class="hljs-comment">// 邻接表</span><br><br><span class="hljs-comment">// 入度，队列</span><br><span class="hljs-type">int</span> d[N], q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 有向图头插法加边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-comment">// 创建b节点</span><br>    Node * p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(b);<br>    <span class="hljs-comment">// b节点的next指向原来节点a指向的next</span><br>    p -&gt; next = head[a];<br>    <span class="hljs-comment">// 节点a指向节点b</span><br>    head[a] = p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 将所有入度为0的节点加入队列之中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span>(!d[i])<br>            q[++tt] = i;<br>            <br>    <span class="hljs-comment">// 删除掉所有入度为0的节点</span><br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh++];<br>        <br>        <span class="hljs-comment">// 遍历t节点的邻边节点</span><br>        <span class="hljs-keyword">for</span>(Node * p = head[t]; p; p = p -&gt; next)&#123;<br>            <span class="hljs-comment">// 周边节点入度-1，如果入度为0，则加入队列</span><br>            <span class="hljs-keyword">if</span>(--d[p -&gt; id] == <span class="hljs-number">0</span>)&#123;<br>                q[++tt] = p -&gt; id;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// n个节点都应该被删掉一次，那么tt达到 n - 1</span><br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-comment">// a -&gt; b</span><br>        <span class="hljs-built_in">add</span>(a, b);<br>        d[b]++; <span class="hljs-comment">// b的入度+1</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果图有环</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">topsort</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 合法拓扑序列恰好是 0 ~ tt，这里写成 &lt; n也无妨，输出那n个节点(0 ~ n - 1)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>; <span class="hljs-comment">// 假设最多有1000个顶点</span><br><br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">// 邻接矩阵表示图</span><br><span class="hljs-type">int</span> d[N]; <span class="hljs-comment">// 入度数组</span><br><span class="hljs-type">int</span> q[N], tt = <span class="hljs-number">-1</span>, hh = <span class="hljs-number">0</span>; <span class="hljs-comment">// 队列及其指针</span><br><span class="hljs-comment">// 节点数、边数</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 遍历所有节点，入度为0的点全部入队</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!d[i]) &#123;<br>            q[++tt] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 装填完毕，删除当前节点，周边节点的入度-1，看是否为0，如果满足它们也入队</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt) &#123;<br>        <span class="hljs-type">int</span> t = q[hh++];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (g[t][j]) &#123; <span class="hljs-comment">// 如果存在边t-&gt;j</span><br>                <span class="hljs-comment">// 由于重边的影响，比如两次 2 -&gt; 3</span><br>                <span class="hljs-comment">// 需要一口气将3的入度-2</span><br>                <span class="hljs-keyword">while</span>(g[t][j]) --g[t][j],--d[j];<br>                <br>                <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">0</span>) &#123;<br>                    q[++tt] = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        g[a][b]++; <span class="hljs-comment">// 边数+1</span><br>        d[b]++; <span class="hljs-comment">// b的入度+1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">topsort</span>()) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n ; i++) &#123;<br>            cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码实现3"><a href="#代码实现3" class="headerlink" title="代码实现3"></a>代码实现3</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = N * <span class="hljs-number">2</span>, INF = <span class="hljs-number">0X3F3F3F3F</span>;<br><br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!d[i])<br>            q[++tt] = i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh++];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])&#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <br>            <span class="hljs-keyword">if</span>(--d[j] == <span class="hljs-number">0</span>)&#123;<br>                q[++tt] = j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>        d[b]++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">topsort</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">有向图的拓扑序列</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>朴素邻接矩阵版Dijkstra求最短路</title>
    <link href="https://blog.phbeats.cn/posts/6d0f7c8cf39d/"/>
    <id>https://blog.phbeats.cn/posts/6d0f7c8cf39d/</id>
    <published>2024-07-01T02:49:03.000Z</published>
    <updated>2024-09-23T02:49:29.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-849-Dijkstra求最短路-I"><a href="#AcWing-849-Dijkstra求最短路-I" class="headerlink" title="[AcWing.849. Dijkstra求最短路 I]"></a><a href="https://www.acwing.com/problem/content/851/">[AcWing.849. Dijkstra求最短路 I]</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 <code>1</code> 号点到 <code>n</code> 号点的最短距离，如果无法从 <code>1</code> 号点走到 <code>n</code> 号点，则输出 <code>-1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>n</code> 和 <code>m</code>。</p><p>接下来 <code>m</code> 行每行包含三个整数 <code>x,y,z</code>，表示存在一条从点 <code>x</code> 到点 <code>y</code> 的有向边，边长为 <code>z</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 <code>1</code> 号点到 <code>n</code> 号点的最短距离。</p><p>如果路径不存在，则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 500</code>,<br><code>1 &lt; m &lt; 10^5</code>,<br>图中涉及边长均不超过10000。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 3<br>1 2 2<br>2 3 1<br>1 3 4<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>朴素Dijkstra</code>可以用来求<code>有向图</code>的<code>单源最短路</code>(一个点到其余点的最短距离，一般默认是求起点1到其余点的距离)，<code>无向图</code>可以看作特殊的<code>有向图</code>，只需要建图的时候<code>建两条边</code>即可。</p><p><code>邻接矩阵</code>版，主要变量名解释:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 最大点、边的数组容量、正无穷</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">100010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-comment">// 点、边</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-comment">// 使用邻接矩阵表示图</span><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-comment">// 源点距离其它点的距离</span><br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-comment">// 该点是否已经属于最短路集合中</span><br><span class="hljs-type">bool</span> st[N];<br></code></pre></td></tr></table></figure></p><p><code>易错点：</code></p><ol><li>main函数一开始<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 很重要的一点！一开始就将邻接矩阵的距离都初始化为无穷大</span><br><span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br></code></pre></td></tr></table></figure></li><li>dijkstra函数内一开始<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化源点距离数组为无穷大</span><br><span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br></code></pre></td></tr></table></figure></li><li>dijkstra逻辑细节别都嵌套到for循环里面去了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 枚举所有点（这层循环要求点的编号也能对应上，从1开始）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>    <span class="hljs-comment">// 如果这个点还没有被纳入最短路集合里面</span><br>    <span class="hljs-comment">// t是-1，或者 有点j存在使得 有更短的路径</span><br>    <span class="hljs-comment">// 更新 t</span><br>    <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))&#123;<br>        t = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 确定这个t点是最短路集合里面的点</span><br>st[t] = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 由于t这个点加入，需要更新一下距离</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>    <span class="hljs-comment">// g[t][j]是边权</span><br>    dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 最大点、边的数组容量、正无穷</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">100010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-comment">// 点、边</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-comment">// 使用邻接矩阵表示图</span><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-comment">// 源点距离其它点的距离</span><br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-comment">// 该点是否已经属于最短路集合中</span><br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 初始化源点距离数组为无穷大</span><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    <span class="hljs-comment">// 源点距离源点它自己的距离为0，源点默认为1</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 枚举所有点（n次），虽然dist[1] = 0，但实际上它还没加入最短路集合中。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-comment">// 保存当前循环，距离最短的点</span><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-comment">// 枚举所有点（这层循环要求点的编号也能对应上，从1开始）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-comment">// 如果这个点还没有被纳入最短路集合里面</span><br>            <span class="hljs-comment">// t是-1，或者 有点j存在使得 有更短的路径</span><br>            <span class="hljs-comment">// 更新 t</span><br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))&#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 确定这个t点是最短路集合里面的点</span><br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 由于t这个点加入，需要更新一下距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-comment">// g[t][j]是边权</span><br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 从源点到终点的距离</span><br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-comment">// 很重要的一点！一开始就将邻接矩阵的距离都初始化为无穷大</span><br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <br>    <span class="hljs-comment">// 建图</span><br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-comment">// 保证没有重边，如果有重边，保留一个最小的边就行</span><br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 求最短路</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">dijkstra</span>();<br>    <br>    <span class="hljs-comment">// 如果结果是正无穷，输出-1，否则输出结果</span><br>    <span class="hljs-keyword">if</span>(res == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">朴素邻接矩阵版Dijkstra求最短路</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>游戏（约瑟夫）</title>
    <link href="https://blog.phbeats.cn/posts/08d4ec6ea429/"/>
    <id>https://blog.phbeats.cn/posts/08d4ec6ea429/</id>
    <published>2024-06-27T14:27:25.000Z</published>
    <updated>2024-09-23T02:49:29.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing3253-游戏"><a href="#AcWing3253-游戏" class="headerlink" title="[AcWing3253. 游戏]"></a><a href="https://www.acwing.com/problem/content/3256/">[AcWing3253. 游戏]</a></h1><p>有 <code>n</code> 个小朋友围成一圈玩游戏，小朋友从 <code>1</code> 至 <code>n</code> 编号，<code>2</code> 号小朋友坐在 <code>1</code> 号小朋友的顺时针方向，<code>3</code> 号小朋友坐在 <code>2</code> 号小朋友的顺时针方向，……，<code>1</code> 号小朋友坐在 <code>n</code> 号小朋友的顺时针方向。</p><p>游戏开始，从 <code>1</code> 号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加 <code>1</code>。</p><p>若一个小朋友报的数为 <code>k</code> 的倍数或其末位数（即数的个位）为 <code>k</code>，则该小朋友被淘汰出局，不再参加以后的报数。</p><p>当游戏中只剩下一个小朋友时，该小朋友获胜。</p><p>例如，当 <code>n=5, k=2</code> 时：</p><ul><li><code>1</code> 号小朋友报数 <code>1</code>；</li><li><code>2</code> 号小朋友报数 <code>2</code> 淘汰；</li><li><code>3</code> 号小朋友报数 <code>3</code>；</li><li><code>4</code> 号小朋友报数 <code>4</code> 淘汰；</li><li><code>5</code> 号小朋友报数 <code>5</code>；</li><li><code>1</code> 号小朋友报数 <code>6</code> 淘汰；</li><li><code>3</code> 号小朋友报数 <code>7</code>；</li><li><code>5</code> 号小朋友报数 <code>8</code> 淘汰；</li><li><code>3</code> 号小朋友获胜。</li></ul><p>给定 <code>n</code> 和 <code>k</code>，请问最后获胜的小朋友编号为多少？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一行，包括两个整数 <code>n</code> 和 <code>k</code>，意义如题目所述。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行，包含一个整数，表示获胜的小朋友编号。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于所有评测用例，<code>1 ≤ n ≤ 1000</code>，<code>1 ≤ k ≤ 9</code>。</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 2<br></code></pre></td></tr></table></figure><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">7 3<br></code></pre></td></tr></table></figure><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">4<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>这是经典的<code>约瑟夫问题</code>。采用数组模拟，但要注意：没有环，但是怎么实现环的效果呢？<br><code>采用重新入队的方式</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, k;<br>    <br>    <span class="hljs-comment">// n个小朋友，幸运数字k</span><br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-comment">// 小朋友排队等待枪毙</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) q[++tt] = i;<br>    <br>    <span class="hljs-comment">// 编号</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// n个小朋友枪毙 n - 1 个,枪毙的号码是幸运数字的k的倍数或末尾数为k，剩下一个</span><br>    <span class="hljs-comment">// 已知 hh &lt;= tt，循环条件为：队列不为空则一直...</span><br>    <span class="hljs-comment">// 那么: hh &lt; tt，循环条件为：队列不为1个则一直...</span><br>    <span class="hljs-keyword">while</span>(hh &lt; tt)&#123;<br>        <span class="hljs-comment">// 如果当前编号的小朋友不该枪毙</span><br>        <span class="hljs-keyword">if</span>(j % k &amp;&amp; j % <span class="hljs-number">10</span> != k)&#123;<br>            <span class="hljs-comment">// 重新排队</span><br>            q[++tt] = q[hh];<br>            ++hh;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ++hh; <span class="hljs-comment">// 该枪毙就枪毙</span><br>        &#125;<br>        j++;<br>    &#125;<br>    <span class="hljs-comment">// 输出剩下的唯一一个在队首的小朋友</span><br>    cout &lt;&lt; q[hh] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">游戏（约瑟夫）</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="队列" scheme="https://blog.phbeats.cn/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口内求最大值和最小值</title>
    <link href="https://blog.phbeats.cn/posts/37333600838e/"/>
    <id>https://blog.phbeats.cn/posts/37333600838e/</id>
    <published>2024-06-17T03:13:21.000Z</published>
    <updated>2024-09-23T02:49:29.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-154-滑动窗口内求最大值和最小值"><a href="#AcWing-154-滑动窗口内求最大值和最小值" class="headerlink" title="[AcWing. 154. 滑动窗口内求最大值和最小值]"></a><a href="https://www.acwing.com/problem/content/156/">[AcWing. 154. 滑动窗口内求最大值和最小值]</a></h1><p>给定一个大小为 <code>n &lt; 10^6</code> 的数组。</p><p>有一个大小为 <code>k</code> 的滑动窗口，它从数组的最左边移动到最右边。</p><p>你只能在窗口中看到 <code>k</code> 个数字。</p><p>每次滑动窗口向右移动一个位置。</p><p>以下是一个例子：</p><p>该数组为 <code>[1 3 -1 -3 5 3 6 7]</code>，<code>k</code> 为 <code>3</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">窗口位置</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th></tr></thead><tbody><tr><td style="text-align:center">[1 3 -1] -3 5 3 6 7</td><td style="text-align:center">-1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1 [3 -1 -3] 5 3 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1 3 [-1 -3 5] 3 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">1 3 -1 [-3 5 3] 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">1 3 -1 -3 [5 3 6] 7</td><td style="text-align:center">3</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">1 3 -1 -3 5 [3 6 7]</td><td style="text-align:center">3</td><td style="text-align:center">7</td></tr></tbody></table></div><p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含两行。</p><p>第一行包含两个整数 <code>n</code> 和 <code>k</code>，分别代表数组长度和滑动窗口的长度。</p><p>第二行有 <code>n</code> 个整数，代表数组的具体数值。</p><p>同行数据之间用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出包含两个。</p><p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p><p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">8 3<br>1 3 -1 -3 5 3 6 7<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1 -3 -3 -3 3 3</span><br>3 3 5 5 6 7<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>滑动窗口，每次滑动一个单位，<code>窗口内求最大最小值</code>。</p><p>借图：</p><p><img src="https://cdn.acwing.com/media/article/image/2022/03/05/55289_0923cf569c-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.PNG" alt="滑动窗口"></p><p><code>题外话</code>：在一个从小到大排列的数列中，若左边的数比右边的数大，就称作逆序数啊，如：1，3，5，4，6 中，5就是逆序数啊，看看5在题目中有没有用，若是没有用，那该题就有单调性。</p><ol><li><p>使用双端单调队列：利用双端单调队列来高效维护滑动窗口的最小值和最大值。</p></li><li><p>维护窗口边界：在每次滑动时，检查队列头部的元素是否已经滑出窗口范围，如果是则移除。</p></li><li><p>保持单调性：<br>对于最小值，保持队列单调递增，移除队列中比当前元素大的元素。<br>对于最大值，保持队列单调递减，移除队列中比当前元素小的元素。<br>插入新元素：将当前元素的索引插入队列。</p></li><li><p>输出结果：当窗口大小达到要求时，队首元素即为当前窗口的最小值或最大值。</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-comment">// 数组和双端单调队列</span><br><span class="hljs-type">int</span> a[N], q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 数组元素个数和滑动窗口的长度</span><br><span class="hljs-type">int</span> n, k;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br><br>    <span class="hljs-comment">// 输入元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br><br>    <span class="hljs-comment">// 求滑动窗口的最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 维护窗口，i - k + 1 是窗口的左边界</span><br>        <span class="hljs-comment">// 如果队首元素的索引已经小于当前窗口的左边界</span><br>        <span class="hljs-comment">// 说明该元素已经滑出窗口，需要将队首指针 hh 向后移动以排除这个元素</span><br>        <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) ++hh;<br>        <br>        <span class="hljs-comment">// 保持队列单调递增，排除不可能的最小值</span><br>        <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) --tt;<br>        <br>        <span class="hljs-comment">// 当前元素入队</span><br>        q[++tt] = i;<br><br>        <span class="hljs-comment">// 输出当前窗口的最小值</span><br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= k) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 重置队列指针</span><br>    hh = <span class="hljs-number">0</span>;<br>    tt = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">// 求滑动窗口的最大值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 维护窗口，i - k + 1 是窗口的左边界</span><br>        <span class="hljs-comment">// 如果队首元素的索引已经小于当前窗口的左边界</span><br>        <span class="hljs-comment">// 说明该元素已经滑出窗口，需要将队首指针 hh 向后移动以排除这个元素</span><br>        <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) ++hh;<br><br>        <span class="hljs-comment">// 保持队列单调递减，排除不可能的最大值</span><br>        <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) --tt;<br><br>        <span class="hljs-comment">// 当前元素入队</span><br>        q[++tt] = i;<br><br>        <span class="hljs-comment">// 输出当前窗口的最大值</span><br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= k) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">滑动窗口内求最大值和最小值</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="单调队列" scheme="https://blog.phbeats.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://blog.phbeats.cn/posts/3be02f72e427/"/>
    <id>https://blog.phbeats.cn/posts/3be02f72e427/</id>
    <published>2024-06-11T12:19:11.000Z</published>
    <updated>2024-09-23T02:49:29.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-20-用两个栈实现队列"><a href="#AcWing-20-用两个栈实现队列" class="headerlink" title="[AcWing. 20. 用两个栈实现队列]"></a><a href="https://www.acwing.com/problem/content/36/">[AcWing. 20. 用两个栈实现队列]</a></h1><p>请用栈实现一个队列，支持如下四种操作：</p><ul><li>push(x) – 将元素x插到队尾；</li><li>pop() – 将队首的元素弹出，并返回该元素；</li><li>peek() – 返回队首元素；</li><li>empty() – 返回队列是否为空；</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用栈的标准操作：<code>push to top</code>，<code>peek/pop from top</code>, <code>size</code> 和 <code>is empty</code>；</li><li>如果你选择的编程语言没有栈的标准库，你可以使用list或者deque等模拟栈的操作；</li><li>输入数据保证合法，例如，在队列为空时，不会进行<code>pop</code>或者<code>peek</code>等操作；</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>每组数据操作命令数量 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyQueue queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyQueue</span>();<br><br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>queue.<span class="hljs-built_in">peek</span>();  <span class="hljs-comment">// returns 1</span><br>queue.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// returns 1</span><br>queue.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// returns false</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2024/06/11/66684222ae1fc.png" alt="image-20240611202459520"></p><p><img src="https://bu.dusays.com/2024/06/11/666842358a6bf.png" alt="image-20240611202525947"></p><p>借助辅助栈，可以让<code>主栈只剩下一个元素</code>，然后拿一个变量保存它后执行<code>pop</code>或者<code>peek</code>逻辑返回它。</p><p>过程中，拿变量保存它之后，需要<code>将辅助栈中的元素们回到主栈中</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> stk[<span class="hljs-number">100010</span>];<br>    <span class="hljs-type">int</span> tmp_stk[<span class="hljs-number">100010</span>];<br>    <span class="hljs-type">int</span> tt;<br>    <span class="hljs-type">int</span> tmp_tt;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br>        tt = <span class="hljs-number">0</span>;<br>        tmp_tt = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 0不用，直接用1</span><br>        stk[++ tt] = x;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// stk只留下1个，其它全部移到辅助栈tmp_stk里去</span><br>        <span class="hljs-keyword">while</span>(tt &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// tmp_stk入栈，stk出栈</span><br>            tmp_stk[++ tmp_tt] = stk[tt --];<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> k = stk[tt --];<br>        <br>        <span class="hljs-comment">// 移回去</span><br>        <span class="hljs-keyword">while</span>(tmp_tt)&#123;<br>            stk[++ tt] = tmp_stk[tmp_tt --];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// stk只留下1个，其它全部移到辅助栈tmp_stk里去</span><br>        <span class="hljs-keyword">while</span>(tt &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// tmp_stk入栈，stk出栈</span><br>            tmp_stk[++ tmp_tt] = stk[tt --];<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> k = stk[tt];<br>        <br>        <span class="hljs-comment">// 移回去</span><br>        <span class="hljs-keyword">while</span>(tmp_tt)&#123;<br>            stk[++ tt] = tmp_stk[tmp_tt --];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !tt;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * bool param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">用两个栈实现队列</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="栈" scheme="https://blog.phbeats.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>直方图中最大矩形</title>
    <link href="https://blog.phbeats.cn/posts/410b68f36e34/"/>
    <id>https://blog.phbeats.cn/posts/410b68f36e34/</id>
    <published>2024-06-09T09:27:51.000Z</published>
    <updated>2024-09-23T02:49:29.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-131-直方图中最大的矩形"><a href="#AcWing-131-直方图中最大的矩形" class="headerlink" title="[AcWing]131. 直方图中最大的矩形"></a><a href="https://www.acwing.com/problem/content/description/133/">[AcWing]131. 直方图中最大的矩形</a></h1><p>直方图是由在公共基线处对齐的一系列矩形组成的多边形。</p><p>矩形具有相等的宽度，但可以具有不同的高度。</p><p>例如，图例左侧显示了由高度为 <code>2,1,4,5,1,3,3</code> 的矩形组成的直方图，矩形的宽度都为 <code>1</code>：</p><p><img src="https://cdn.acwing.com/media/article/image/2019/01/14/19_eac6c46017-2559_1.jpg" alt="2559_1.jpg"></p><p>通常，直方图用于表示离散分布，例如，文本中字符的频率。</p><p>现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。</p><p>图例右图显示了所描绘直方图的最大对齐矩形。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含几个测试用例。</p><p>每个测试用例占据一行，用以描述一个直方图，并以整数 <code>n</code> 开始，表示组成直方图的矩形数目。</p><p>然后跟随 <code>n</code> 个整数 <code>h_1，…，h_n</code>。</p><p>这些数字以从左到右的顺序表示直方图的各个矩形的高度。</p><p>每个矩形的宽度为 <code>1</code>。</p><p>同行数字用空格隔开。</p><p>当输入用例为 <code>n=0</code> 时，结束输入，且该用例不用考虑。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。</p><p>每个数据占一行。</p><p>请注意，此矩形必须在公共基线处对齐。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 100000</code>,<br><code>0 &lt; h_i &lt; 1000000000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">7 2 1 4 5 1 3 3<br>4 1000 1000 1000 1000<br>0<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">8<br>4000<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>对于每个矩阵，基于单调栈的算法，<code>从左往右，从右往左，可以算出各自矩阵的最近且最小的矩阵位置是多少</code>。</p><p><img src="https://bu.dusays.com/2024/06/09/6665b6961d895.png" alt="image-20240609203648376"></p><p><img src="https://bu.dusays.com/2024/06/10/666703e9110d9.png" alt="image-20240610214630320"></p><p>边界预处理在这里的作用主要是为了避免在处理第一个和最后一个矩形时出现特殊情况。具体来说，当你从左到右遍历矩形并尝试找到它们的左边界时，对于第一个矩形（i=1），如果没有额外的预处理，你就没有办法找到一个左侧比它矮的矩形来确定其左边界，因为 h[0] 不存在。同样地，当你从右到左遍历矩形并尝试找到它们的右边界时，对于最后一个矩形（i=n），如果没有额外的预处理，你也没有办法找到一个右侧比它矮的矩形来确定其右边界，因为 h[n+1] 不存在。</p><p>具体来说：</p><p>当从左到右遍历时，对于第一个柱子 h[1]，如果没有 h[0] 作为哨兵，并且 h[1] 是所有柱子中最高的，那么 l[1] 将不会被正确设置（因为没有比它矮的柱子在左侧）。但是，由于我们设置了 h[0] = -1（一个比所有实际柱子都小的值），l[1] 就会被正确地设置为 0（或者说，没有柱子在 h[1] 的左侧）。<br>当从右到左遍历时，对于最后一个柱子 h[n]，如果没有 h[n+1] 作为哨兵，并且 h[n] 是所有柱子中最高的，那么 r[n] 将不会被正确设置（因为没有比它矮的柱子在右侧）。但是，由于我们设置了 h[n+1] = -1，r[n] 就会被正确地设置为 n+1（或者说，没有柱子在 h[n] 的右侧）。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 爆int</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-comment">// h装每个矩形的高，l装每个矩形的左边界，r装每个矩形的右边界</span><br><span class="hljs-comment">// q是双端单调队列</span><br><span class="hljs-type">int</span> h[N], l[N], r[N], q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    <br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n, n)&#123;<br>        <span class="hljs-comment">// 输入每个矩形的高</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; h[i];<br>        <br>        <span class="hljs-comment">// 让h[0]和h[n + 1]值为 -1，这样就不用处理边界问题了（什么边界问题？）</span><br>        h[<span class="hljs-number">0</span>] = h[n + <span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br>        q[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 开始维护单调队列，从左往右</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-comment">// 维护</span><br>            <span class="hljs-keyword">while</span>(tt &amp;&amp; h[i] &lt;= h[q[tt]]) tt--;<br>            <span class="hljs-comment">// 左边界</span><br>            l[i] = q[tt];<br>            q[++tt] = i;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 准备维护单调队列，从右往左</span><br>        tt = <span class="hljs-number">0</span>;<br>        q[<span class="hljs-number">0</span>] = n + <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i ; i--)&#123;<br>            <span class="hljs-comment">// 维护</span><br>            <span class="hljs-keyword">while</span>(tt &amp;&amp; h[i] &lt;= h[q[tt]]) tt--;<br>            <span class="hljs-comment">// 右边界</span><br>            r[i] = q[tt];<br>            q[++tt] = i;<br>        &#125;<br>        <br>        ll res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, (ll)h[i] * (r[i] - l[i] - <span class="hljs-number">1</span>));<br>        &#125;<br>        <br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">直方图中最大矩形</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="单调队列" scheme="https://blog.phbeats.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="单调栈" scheme="https://blog.phbeats.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://blog.phbeats.cn/posts/c2dbcb3c40df/"/>
    <id>https://blog.phbeats.cn/posts/c2dbcb3c40df/</id>
    <published>2024-06-05T13:28:05.000Z</published>
    <updated>2024-09-23T02:49:29.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-830-单调栈"><a href="#AcWing-830-单调栈" class="headerlink" title="[AcWing]830. 单调栈"></a><a href="https://www.acwing.com/problem/content/832/">[AcWing]830. 单调栈</a></h1><p>给定一个长度为 <code>N</code> 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 <code>-1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>N</code>，表示数列长度。</p><p>第二行包含 <code>N</code> 个整数，表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 <code>N</code> 个整数，其中第 <code>i</code> 个数表示第 <code>i</code> 个数的左边第一个比它小的数，如果不存在则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; N &lt; 10^5</code><br><code>1 &lt; 数列中元素 &lt; 10^9</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5<br>3 4 2 7 5<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1 3 -1 2 2</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>给定一个序列，求每一个数的左边离它最近的<code>小于等于</code>或<code>大于等于</code>它的数是什么。<br><code>单调栈需要维护一个单调的栈</code>。</p><p>注意：插入元素时需要与栈顶元素比较，<code>以单调增为例子</code>。<br><code>更小则取而代之全部</code>，否则，<code>正常入栈</code>。</p><ol><li><code>筛选操作</code>：先保证栈顶元素就是新插入元素离得最近且最小的元素</li><li><code>输出操作</code>：输出离x最近且最小的元素，如果没有就输出-1</li><li><code>入栈操作</code>：x入栈，栈从数组下标1开始使用</li></ol><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(n --)&#123;<br>        <span class="hljs-type">int</span> x; cin &gt;&gt; x;<br>        <br>        <span class="hljs-comment">// 维护栈，单调递增</span><br>        <span class="hljs-comment">// 单调栈不为空且压栈元素x比栈顶元素小，则删除它们</span><br>        <span class="hljs-keyword">while</span>(tt &amp;&amp; x &lt;= stk[tt]) tt--;<br>        <br>        <span class="hljs-comment">// 单调栈顶剩下的总是离x最近的，比x小的数</span><br>        <span class="hljs-comment">// 单调栈里面还有元素</span><br>        <span class="hljs-keyword">if</span>(tt) cout &lt;&lt; stk[tt] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <br>        stk[++tt] = x;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码实现2（单调队列）"><a href="#代码实现2（单调队列）" class="headerlink" title="代码实现2（单调队列）"></a>代码实现2（单调队列）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> a[N], q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n; cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-comment">// 维护单调队列</span><br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) --tt;<br>        <br>        <span class="hljs-comment">// 如果单调队列不为空，队尾是最近的，比当前更小的元素</span><br>        <span class="hljs-keyword">if</span>(hh &lt;= tt) cout &lt;&lt; a[q[tt]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;-1 &quot;</span>;<br>        <br>        q[++tt] = i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">单调栈</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="单调队列" scheme="https://blog.phbeats.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="单调栈" scheme="https://blog.phbeats.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>包含min函数的栈</title>
    <link href="https://blog.phbeats.cn/posts/9c0080b038b9/"/>
    <id>https://blog.phbeats.cn/posts/9c0080b038b9/</id>
    <published>2024-06-04T12:46:59.000Z</published>
    <updated>2024-09-23T02:49:29.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-41-包含min函数的栈"><a href="#AcWing-41-包含min函数的栈" class="headerlink" title="[AcWing 41. 包含min函数的栈]"></a><a href="https://www.acwing.com/problem/content/90/">[AcWing 41. 包含min函数的栈]</a></h1><p>设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。</p><ul><li>push(x)–将元素x插入栈中</li><li>pop()–移除栈顶元素</li><li>top()–得到栈顶元素</li><li>getMin()–得到栈中最小元素</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>操作命令总数 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">MinStack minStack = new MinStack();<br>minStack.push(-1);<br>minStack.push(3);<br>minStack.push(-4);<br>minStack.getMin();   --&gt; Returns -4.<br>minStack.pop();<br>minStack.top();      --&gt; Returns 3.<br>minStack.getMin();   --&gt; Returns -1.<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>普通栈：<code>来者不拒</code><br>这种情况的单调栈：<code>只接受不大于栈顶的元素</code></p><p>单调栈的栈顶永远是最新的最小值。</p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">/** initialize your data structure here. */</span>  <br>    <span class="hljs-type">int</span> stk[<span class="hljs-number">100010</span>];  <br>    <span class="hljs-type">int</span> stk_min[<span class="hljs-number">100010</span>];  <br>    <span class="hljs-type">int</span> tt;  <span class="hljs-comment">// 用于 stk 数组的栈顶指针  </span><br>    <span class="hljs-type">int</span> tt_min;  <span class="hljs-comment">// 用于 stk_min 数组的栈顶指针，它总是指向当前最小值  </span><br>      <br>    <span class="hljs-built_in">MinStack</span>() &#123;  <br>        tt = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化栈为空  </span><br>        tt_min = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化最小栈也为空  </span><br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;  <br>        stk[++tt] = x; <br>        <span class="hljs-comment">// 单调栈为空或者压栈的元素不大于栈顶元素</span><br>        <span class="hljs-keyword">if</span>(!tt_min || x &lt;= stk_min[tt_min]) &#123;  <br>            stk_min[++tt_min] = x;  <br>        &#125;  <br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">if</span>(stk[tt] == stk_min[tt_min]) &#123;  <br>            tt_min--;  <br>        &#125;  <br>        tt--;  <br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> stk[tt];  <br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> stk_min[tt_min];  <br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-comment">// 普通栈</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; stackValue;<br>    <span class="hljs-comment">// 单调栈，只放入不大于栈顶的元素</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; stackMin;<br>    <br>    <span class="hljs-built_in">MinStack</span>() &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 普通栈来者不拒</span><br>        stackValue.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-comment">// 单调栈只接受不大于栈顶的元素，除非一个都没有</span><br>        <span class="hljs-keyword">if</span> (stackMin.<span class="hljs-built_in">empty</span>() || x &lt;= stackMin.<span class="hljs-built_in">top</span>())<br>            stackMin.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 要弹出的元素和单调栈的栈顶元素相同，那么同时弹出，否则只弹出普通栈的</span><br>        <span class="hljs-keyword">if</span> (stackMin.<span class="hljs-built_in">top</span>() == stackValue.<span class="hljs-built_in">top</span>()) stackMin.<span class="hljs-built_in">pop</span>();<br>        stackValue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackValue.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackMin.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">包含min函数的栈</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="栈" scheme="https://blog.phbeats.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]3757. 重排链表</title>
    <link href="https://blog.phbeats.cn/posts/15cb5950f25b/"/>
    <id>https://blog.phbeats.cn/posts/15cb5950f25b/</id>
    <published>2024-05-14T13:17:44.000Z</published>
    <updated>2024-09-23T02:49:29.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3757-重排链表"><a href="#AcWing-3757-重排链表" class="headerlink" title="[AcWing]3757. 重排链表"></a><a href="https://www.acwing.com/problem/content/3760/">[AcWing]3757. 重排链表</a></h1><p>一个包含 <code>n</code> 个元素的线性链表 <code>L = (a_1,a_2,…,a_&#123;n-2&#125;,a_&#123;n-1&#125;,a_n)</code>。</p><p>现在要对其中的结点进行重新排序，得到一个新链表 <code>L’ = (a_1,a_n,a_2,a_&#123;n-1&#125;,a_3,a_&#123;n-2&#125;…)</code></p><h4 id="样例1："><a href="#样例1：" class="headerlink" title="样例1："></a>样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;2-&gt;3-&gt;4<br><br>输出：1-&gt;4-&gt;2-&gt;3<br></code></pre></td></tr></table></figure><h4 id="样例2："><a href="#样例2：" class="headerlink" title="样例2："></a>样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;2-&gt;3-&gt;4-&gt;5<br><br>输出：1-&gt;5-&gt;2-&gt;4-&gt;3<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 1000</code>,<br><code>1 &lt; a_i &lt; 10000</code></p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2024/05/14/66435bd78bd41.png" alt="image-20240514204050974"></p><p><code>将链表分成左右两部分，右边那一部分进行逆置，然后将两个链表合并</code>。</p><p>前半段是较长的，切断点应该是向上取整，尽可能让前半段长。</p><p><img src="https://bu.dusays.com/2024/05/14/66435c81b8b12.png" alt="image-20240514204345071"></p><p>选其中一种情况讨论。</p><p><img src="https://bu.dusays.com/2024/05/14/6643611cc4cc8.png" alt="image-20240514210325505"></p><p><code>step1是合并链表的过程</code>。</p><p><code>s</code>节点是需要提前保存的，用来维护<code>q</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rearrangedList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 题目说链表节点满足：1≤n≤1000，只有一个节点，则什么也不做</span><br>        <span class="hljs-keyword">if</span>(!head -&gt; next) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 先计算分割点</span><br>        <br>        <span class="hljs-comment">// 求长度</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(ListNode * p = head; p ; p = p -&gt; next) len++;<br>        <br>        <span class="hljs-comment">// 向上取整</span><br>        <span class="hljs-type">int</span> left = (len + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// 找到分割点处的尾节点</span><br>        ListNode * a = head;<br>        <span class="hljs-comment">// 移动 left - 1 次</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) a = a -&gt; next;<br>        <br>        <span class="hljs-comment">// 右边的链表，由于要进行翻转因此有两个指针</span><br>        ListNode * b = a -&gt; next, * c = b -&gt; next;<br>        <br>        <span class="hljs-comment">// 先置空</span><br>        a -&gt; next = <span class="hljs-literal">NULL</span>; b -&gt; next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// 进行反转</span><br>        <span class="hljs-keyword">while</span>(c)&#123;<br>            <span class="hljs-comment">// 记录排头兵的next，方便维护b</span><br>            ListNode * p = c -&gt; next;<br>            <span class="hljs-comment">// 反转</span><br>            c -&gt; next = b;<br>            b = c; c = p;<br>        &#125;<span class="hljs-comment">// 跳出循环, b就是反转后第一个节点</span><br>        <br>        <span class="hljs-comment">// 合并链表</span><br>        ListNode * p = head, * q = b;<br>        <span class="hljs-comment">// 选 q，是因为 q 比较短</span><br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            <span class="hljs-comment">// 提前备份，维护q</span><br>            ListNode * s = q -&gt; next;<br>            <span class="hljs-comment">// 合并</span><br>            q -&gt; next = p -&gt; next;<br>            p -&gt; next = q;<br>            <span class="hljs-comment">// 新的开始</span><br>            p = q -&gt; next;<br>            q = s;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3757. 重排链表</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing] 66. 两个链表的第一个公共节点</title>
    <link href="https://blog.phbeats.cn/posts/0a6333a85e34/"/>
    <id>https://blog.phbeats.cn/posts/0a6333a85e34/</id>
    <published>2024-05-10T11:34:56.000Z</published>
    <updated>2024-09-23T02:49:29.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-66-两个链表的第一个公共节点"><a href="#AcWing-66-两个链表的第一个公共节点" class="headerlink" title="[AcWing] 66. 两个链表的第一个公共节点"></a><a href="https://www.acwing.com/problem/content/62/">[AcWing] 66. 两个链表的第一个公共节点</a></h1><p>输入两个链表，找出它们的第一个公共结点。</p><p>当不存在公共节点时，返回空节点。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>链表长度 <code>[1,2000]</code>。<br>保证两个链表不完全相同，即两链表的头结点不相同。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">给出两个链表如下所示：<br>A：        a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗            <br>B:     b1 → b2 → b3<br><br>输出第一个公共节点c1<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>两个链表，两种情况，<code>相交</code>和<code>不相交</code>。</p><h4 id="相交"><a href="#相交" class="headerlink" title="相交"></a>相交</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32ff3099be.png" alt="两个链表的第一个公共节点"></p><p><code>a + c + b</code> = <code>b + c + a</code>，它们相遇的时候一定是两个链表的第一个公共节点。</p><h3 id="不相交"><a href="#不相交" class="headerlink" title="不相交"></a>不相交</h3><p><img src="https://bu.dusays.com/2023/08/09/64d330de84da4.png" alt="两个链表的第一个公共节点2"></p><p><code>a + b</code> = <code>b + a</code>，下一步它们都会走向<code>NULL</code>，而<code>NULL === NULL</code>。看作相遇。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">findFirstCommonNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode * p = headA, * q = headB;<br>        <br>        <span class="hljs-comment">// p从headA开始走，走完从headB开始走</span><br>        <span class="hljs-comment">// q从headB开始走，走完从headA开始走</span><br>        <br>        <span class="hljs-comment">// 不管两个链表相交还是不相交. 根据 a + c + b = b + c + a 原理</span><br>        <span class="hljs-comment">// 它们一定相交</span><br>        <span class="hljs-keyword">while</span>(p != q)&#123;<br>            <span class="hljs-comment">// 如果p走到末尾</span><br>            <span class="hljs-keyword">if</span>(!p) p = headB;<br>            <span class="hljs-keyword">else</span> p = p -&gt; next;<br>            <br>            <span class="hljs-comment">// 如果q走到末尾</span><br>            <span class="hljs-keyword">if</span>(!q) q = headA;<br>            <span class="hljs-keyword">else</span> q = q -&gt; next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing] 66. 两个链表的第一个公共节点</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]3756. 筛选链表</title>
    <link href="https://blog.phbeats.cn/posts/5a709920de81/"/>
    <id>https://blog.phbeats.cn/posts/5a709920de81/</id>
    <published>2024-05-08T12:11:58.000Z</published>
    <updated>2024-09-23T02:49:29.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3756-筛选链表"><a href="#AcWing-3756-筛选链表" class="headerlink" title="[AcWing]3756. 筛选链表"></a><a href="https://www.acwing.com/problem/content/3759/">[AcWing]3756. 筛选链表</a></h1><p>一个单链表中有 <code>m</code> 个结点，每个结点上的元素的绝对值不超过 <code>n</code>。</p><p>现在，对于链表中元素的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。</p><p>请输出筛选后的新链表。</p><p>例如，单链表 <code>21 -&gt; -15 -&gt; -15 -&gt; -7 -&gt; 15</code>，在进行筛选和删除后，变为 <code>21 -&gt; -15 -&gt; -7</code>。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：21-&gt;-15-&gt;-15-&gt;-7-&gt;15<br><br>输出：21-&gt;-15-&gt;-7<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; m &lt; 1000</code>,<br><code>1 &lt; n &lt; 10000</code></p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>如果要筛选掉重复的元素，那么必须要有记录每个数字是否出现过的<code>bool st[N]</code>。</p><p>而且链表中的第1个元素一定是没出现过的，可以直接标记<code>st</code>为<code>true</code>。</p><p><img src="https://bu.dusays.com/2024/05/08/663b74242dace.png" alt="image-20240508204615900"></p><p>对于<code>p</code>和<code>q</code>，删除点有讲究，如果是删除<code>q</code>，那么成本小得多。</p><p>所以<code>q</code>就作为被检查节点</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">filterList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 标记该数字是否已经出现过了</span><br>        <span class="hljs-type">bool</span> st[<span class="hljs-number">10010</span>] = &#123;&#125;;<br>        <br>        <span class="hljs-comment">// 第1个元素一定没有出现过</span><br>        st[ <span class="hljs-built_in">abs</span>(head -&gt; val) ] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 当前没重复元素的最后一个节点的地址</span><br>        ListNode * p = head;<br>        <span class="hljs-comment">// 当前被检查的节点存在</span><br>        <span class="hljs-keyword">while</span>(p -&gt; next)&#123;<br>            <span class="hljs-comment">// 当前正在被检查的节点</span><br>            ListNode * q = p -&gt; next;<br>            <br>            <span class="hljs-keyword">if</span>(st[<span class="hljs-built_in">abs</span>(q -&gt; val)])&#123;<br>                <span class="hljs-comment">// 如果出现过了，删除</span><br>                p -&gt; next = q -&gt; next;<br>                <span class="hljs-keyword">delete</span> q;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 如果没有出现过</span><br>                st[<span class="hljs-built_in">abs</span>(q -&gt; val)] = <span class="hljs-literal">true</span>;<br>                p = p -&gt; next;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3756. 筛选链表</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]35. 反转链表</title>
    <link href="https://blog.phbeats.cn/posts/2097c5abe775/"/>
    <id>https://blog.phbeats.cn/posts/2097c5abe775/</id>
    <published>2024-05-03T12:50:44.000Z</published>
    <updated>2024-09-23T02:49:29.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-35-反转链表"><a href="#AcWing-35-反转链表" class="headerlink" title="[AcWing]35. 反转链表"></a><a href="https://www.acwing.com/problem/content/33/">[AcWing]35. 反转链表</a></h1><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p><p><strong>思考题：</strong></p><ul><li>请同时实现迭代版本和递归版本。</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>链表长度 <code>[0,30]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入:<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-literal">NULL</span><br><br>输出:<span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>先分析理想情况</p><p><img src="https://bu.dusays.com/2024/05/03/6634df9defdf9.png" alt="image-20240503205906942"></p><p>分析较为苛刻的情况</p><p><img src="https://bu.dusays.com/2024/05/03/6634e0232c079.png" alt="image-20240503210127943"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 只有当链表一个元素都没有才返回空</span><br><span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 只有当链表一个元素都没有才返回空</span><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 迭代版本</span><br>        ListNode * p = head;<br>        ListNode * q = head -&gt; next;<br>    <br>        <span class="hljs-comment">// 当q不为空，则可以一直反转</span><br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            ListNode * t = q -&gt; next;<br>            q -&gt; next = p;<br>            p = q;<br>            q = t;<br>        &#125;<br>        <br>        head -&gt; next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// q为空，p是原来链表中的最后一个元素</span><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]35. 反转链表</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
