<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phbeats-Blog</title>
  
  <subtitle>记录学习历程和生活感悟</subtitle>
  <link href="https://blog.phbeats.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.phbeats.cn/"/>
  <updated>2024-04-04T12:30:12.820Z</updated>
  <id>https://blog.phbeats.cn/</id>
  
  <author>
    <name>Phbeats</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[AcWing]3765. 表达式树</title>
    <link href="https://blog.phbeats.cn/posts/4d1178f3e0bb/"/>
    <id>https://blog.phbeats.cn/posts/4d1178f3e0bb/</id>
    <published>2024-04-04T11:41:18.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3765-表达式树"><a href="#AcWing-3765-表达式树" class="headerlink" title="[AcWing]3765. 表达式树"></a><a href="https://www.acwing.com/problem/content/3768/">[AcWing]3765. 表达式树</a></h1><p>请设计一个算法，将给定的表达式树(二叉树)转换为等价的中缀表达式(通过括号反映操作符的计算次序)并输出。</p><p>例如，当下列两棵表达式树作为算法的输入时：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c3f2bab7.png" alt="QQ截图20210708095213.png"></p><p>输出的等价中缀表达式分别为 <code>(a+b)*(c*(-d))</code> 和 <code>(a*b)+(-(c-d))</code>。</p><p><strong>注意</strong>：</p><ul><li>树中至少包含一个运算符。</li><li>当运算符是负号时，左儿子为空，右儿子为需要取反的表达式。</li><li>树中所有叶节点的值均为非负整数。</li></ul><h4 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">输入：二叉树[+, <span class="hljs-number">12</span>, *, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]如下图所示：<br>    +<br>   / \<br>  <span class="hljs-number">12</span>  *<br>     / \<br>    <span class="hljs-number">6</span>   <span class="hljs-number">4</span><br><br>输出：<span class="hljs-number">12</span>+(<span class="hljs-number">6</span>*<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>给定二叉树的非空结点数量保证不超过 <code>1000</code>。</p><p>给定二叉树保证能够转化为合法的中缀表达式。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>很容易想到这是基于树的<code>中序遍历</code>的算法，难点在于加括号的时机。</p><p>通过观察发现，除了根节点，每棵子树都一直在重复做的事情：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c45e6e6b.png" alt="image-20240404195438756"></p><p>那么就会有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">ans += <span class="hljs-string">&quot;(&quot;</span>;<br><span class="hljs-built_in">dfs</span>(root -&gt; left);<br>ans += root -&gt; val;<br><span class="hljs-built_in">dfs</span>(root -&gt; right);<br>ans += <span class="hljs-string">&quot;)&quot;</span>;<br></code></pre></td></tr></table></figure><p>在中序遍历之前需要加上括号。</p><p>可是，有特殊情况：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c5cd7fef.png" alt="image-20240404201019068"></p><p>那么就需要特殊处理。</p><p>当碰到叶子结点的时候就不需要加括号了，直接输出结点值就行。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     string val；</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string ans;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 遇到叶子结点</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;<br>            ans += root -&gt; val;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 非叶子结点</span><br>            ans += <span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>            ans += root -&gt; val;<br>            <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>            ans += <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">expressionTree</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理根节点的特殊情况，直接处理左右子树</span><br>        <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>        ans += root -&gt; val;<br>        <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3765. 表达式树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>第一周总结(4/1 - 4/7)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/216a02683518/"/>
    <id>https://blog.phbeats.cn/posts/216a02683518/</id>
    <published>2024-04-01T13:19:14.000Z</published>
    <updated>2024-04-04T12:30:12.816Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="155b908430483e3a7d92817191e6d944f0c17a83863fcaf84aaf0c7ce1241330">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814870b88c966fecb0cc2e967028af3411eee7300cb80bbf274f423dd19658f7505c530642711d548c2dc40e28f93eae2df7482b8d7f287346b0700bc0a6340105e6ea3aede3f037af485f18b8b3bed1367387e302de213c7661d9311e5de8feb9732ca67c4573b20edc8ef5bc3525464e85c21b047d751374412e1463cf3a1916e8dc86e753f6a76827c450ce814391ede13b13708368897ddf751d3ad12d75ab7133e419f45a4daba29d4481590da59f287b85f357d28fca03170453ea227274644608fd462f2583ae33283f8743e5b57dc1edbf3c0076f1b8184bd4968c0ab993703cd2589cabed699c4e5a9b87fea5922b77110099f0fdd810c4dabfa50eb8f1521ec5a9277c52c43ee5ca78ca687be315cc97dad3c7afd467062c1fc5e8378680786a8646fc00c54503d2db5ff5db5f85b423fb1bb772ff2775d6e7df37c082c89fb315be103547ba44cac2d8ef99bb15fa4afb16e7b902d819ea662a24347a6a41fc24a701d9846f9ee927db1b4dc76142cf0dce52e74140a3bac0d3af7d46c72451af4546d77a7041d0133bf2e1b234d1ee68b5e93d789bd10882fe5fe2356ed0fa4cebd01247eb15efd8922e19063541c24be6201e6b2b5f768a2f098a3c475b936436bae438a2a0ddda25abfcb7093289e1b564b21056956db47739e047042a3fbc176d0255d3a4e6ede8c6d53d87f2266ffd6c2f825cf954a742976b5e6f35b56d8823caa43b06608ae5e268e65a66f0e609f3ad86bd7adba3cb9bc4b6072236b558cdc7f3352096add69fb4ca045e8dded9514a7c645646711e3d1f7c0c1562ba23810ca4164815b5436be1912c4e6f34d17c03a72aacf09a87a8f9bb546a80676aefa24e9cfeaba0c8ffd4aeda135fac122116c9f2fe0f435e78ba313811e05aa5edc544a7addc8c0dc8bff6b780c56f50b7e25fc1d9aa11861db19a4fe803526de01a0d86cc3f76ee02b629f2793b56f11a6efa22304c32c7dc071da5ea4bbdfec720740b8fe7587f39e2b4bd0efa80b55862c4afe0b4f889153182c6e1e5af71458024bda63146b8771d8fa916544eea28fe0886c4f118f366862b82f1f117d1a42fb50cd22efb55b314bbbbac58151294a44fad05f5e0984fe5f568f2d2a6c16abc26256f0fe0bdc8ab861f606d570c2e375e7df2891d0235fc8ede81250af149f12b25f0149e1014cb292bf052b52e3ef5d42a346b2c1a673c752430a6480c59dd9f1291264a5f8b95868d59df2008b4dd38961c1b72148d3c65669058c8fcbe07b6f65c479e68d40894878e515f86f270a2a48ecae10d81b0546100a0261f11bece6cc96847c03ce2bfb362a13a00a55f619c5976ebb1a2e5430248ddc4ca625811d647b57f644d952288cfab47f58325bfd66fd8ac1dca209dddbd7d196dc06aaa0ec5d0406f334dd6a25aa5f5b6947840350b8885d7e572b7b7dacca1fd5067e41cf07df59f96258cc9006c96bf2991bcf3f8e592e40b10087598fac37b8f62b45c480901eb4b6c20b03e2630563a0c4eff18e531d995f4e41999fd026212db192916cbfa2c9cb01d4f3e48a7807e578d9536fe639bf76ff6d31e56d8f423ea3b8f297f103d1c93617101b21a4bf2428451bada4148a6ef63ec8dc65ebecc97811ed4042c5ce275c58a1040eddc3a68f2c3d7779918629fac0e65c84f914d5424c7830f7c44bfd29445e018213e223bb2469e12def711c76275469ace878a7d4062c21b99978d8bca53f49ed77d814816857324be4dbd4121063a3bfa3b164e7bc2dd19af44f676072cc5d869e76c8fed539c5969cc105ecf1f2ed9e57f89d586681a8a0fd48c010e91d345a1bc1904945c67d5486293286c5b1a9d74cc0b018d3bba1e69ba6edb2b6ea76213b48959ba69e19359ee28fe7366f4a211f9cdadc0512286399f312f8d93a6338a061d95099c60d0056cb7c859f2de627cd9e0d568314b2bd34a0ae20ffc8bea87a085afb630d6ea039c9ec30fe335a64e9418144e2989c739cb19661059531cf9506d98cb78721c3aae40f29b097a5675dcab31ee348f3b8b6b17292790da23a4c8797bc0c9169513e53093061b7cb3017030aa7069d0e1c00908de904d98179dc9ee35e8da0bf85ab2f4b151b05d9b44b8f18dd47f54a21b285c0779f9d607ee22bef6d82506d8e84839616bba5c121cf5c65a9ae5c47b98fa12d85cd04559e919e1f4154febd99be65575f5d33e54238f50618a9f6fbf3d573057c1e5fc08c621e5bc2ffc1ca72e831912a5c633235a59225848d6c907860b6701929655eddf3320ffd559631b563f26a6b674088952493196844942439dfa0be656f4900c3afea3a472083229d1d6a384f8aab7ca5a6ea00be48b3d3acde11e32f4d10cbeb96ce108eece953af8a7782373762e4125c2b1c56948642cfe4206a12110cf5ee98afc3643052056f1579f36c270490e3ab97677a96fb11d00ef97cc1d446dc989391a48e5e71dc000f2d0f9585654b06b357274a35b7e2da3203d20fdb3ed48516e8fe555faae226df9a99352d693a27d1e91a5c3ae49bf9c46c5ab46069104d881671c41c54c5d0ae76ea7a013f5d17817340e9dfbe37da11918631bf714fc952e94f56bf479f26a0391fd74648fe258433b74017fa2bbfee8527cd79a6958c6ff580eec7a2c72e3136e5c9f18a202f76163e8b529860b1ec446b201fde32a888f40779277acb1076a7cbe348215084bcfd915682fbb0eec582459cc11cec029918b0cd45d80f07960280e232925c1cab343167192c204718bf7a33019ffe10b6e48d988bf12d8590409fe33e7ef2e6462df91100e1ea753c063ed4e9d864a3948b35afa47944891aeab94efcf693aec8c60ca0b63f8094db21de96ca4268c7aa354c8f99c69af35c3be6bcc621c7e3925b0cb879cd520e5cde08f632235bb2bee655ef7f44d505253ac0ad327e12601720b86f4d69e8868e01c020d52c6dd3cb5a92b92c6c6006193e17293c125eaa4a5f8c156154197cc132575cde64ec440bbbdc3a2e2ef65e5964ce442f122378d743cb3ff206ce36c0a2a75c991a5bb5a10679b8fdb957957c2e609ad4739cbe7ba948304ee8805a431348ed08aa0e6bcbbb0b6c841a3c19ee81c8f3e61d48071603856998ce9d45dd1e9f65d150f4f917e39df3c03abb4466bc9c4470ee07366cf7d8636255b31d2a0e53c3bebf3429e36d2d4367b54a040a4864b65e7b97ecdb599cb00a54fc77664e06f22b43dc6086758afd0f9c2861cd964ffe7bfb8881da17f4970ed154be91c61f11d26559cd8fa36934e63f53e28c39973dac2e3830af20c3d4e36ce8cec7f44102239dbabe9dc2708db330b6705495c562f7e4d268aa7b3f23ba30e724834e1d1a31804d40b256bc02f9afd383eb2a9f312f0224c3d84e9db518999aceb782005e8049ac381e734705f3729cefa0e6b1d244afe1d8b59d2e46f85ff1986e86b27c91576d65040ee04dc4a673db3cba9eb84dbf48e4d33db334632a179003508e1dfd67175109ad8d5bdadce91c97192ef7f66e937df81307c21ecc0d160ca5d9c220e3c3bb3f190c77d22f6097889973a7f205a42be15a35b64cd3d237d35cba7cf6c165ee3ac952f07bdfc7d80678cf81f9a678f035f079ad61b5a7e10719cda7281372993c45d96e67ae55a69a947ae72a572f78b48fea5a8f749c58f4edcf0c2520b77901cc831ec95e33cf325ef0980acec029c0f6e461e0ad0ea7aeb32164c3aa3be0ba512a5392c0f6ea83c35a925f824437d8ce6b5bcc00263d2e98600f83c5e5fddb54af0cc8ea0e7bdde7296f0dec1dd90ec606a3558ec9e756b28abd65afbc7db6b08785453583ef9f2b588e6e1d8aca3bae201a27015a1758192a52a849b6851e0398dc24f80253d7d9d220728567207c61f4a09d4531f5dc3c42dba1c0a4bb0e4f3d988388e5bebb1e27c3577123b2c159bb6479baad859252c63c1d59f9e77315fba394290e445f6f7520ebdc4bfacb3e88058eb452b5d79aaa6e8aa10252b08684168c0da944176af01c123eb849339ea092e1e00c99bbd929022c9a3502929efbd0e374c73fddba2c0b12b78862cae0484823296f76c5cbef631dc986f727c03d86ee50e5c73fe956ec594945f8683f339b9ae2567924980607dfbe23f9bd5d4b30ed2e682101c0ac6b77c948a7b26c81c2530caedc07611fe2a456d3e9edf9f57c0fefab7426b46922e5a59217764cf53b7b30ba7a34d5d3c66e95c0141a5e897cd328215e58f941092c173614d461f9c5a1a4c6ca7cd63e28e383216f25e3cbe9fa1fa7312bcc0f7e18338cf8eae66eae790fe8844dc90edf07389fe075e04793cbeee4a639059be0b5fbbfde77aa1e0d3ff042b9157391ebfde1228edc6b098e267285d31f006c83ba46fcf72c7beb6b6f77bd4ef328bfacd509654274d0d0f725bf9b902a76139db9a790250a93837066ad109e8ed52692b0225c77589d39bfcf0a82d34e9a12b0c821b9b74f5e4df17a1edb9d06659e0ae1c95845ef01b07ec327e0a7b43fe7c6d9a4f17fec1fb1b1719685010491bb050da49ff9a2515778551995f6029015e4afe65d99048734de1f05d134e9cd9ec2c8235c8904fd81e475e70b5fec6d41113fb17c969e2cfd60cb69f770a2d13172f17241de395a9210c745773de6ca394d899d036fab1492601aa9278bb1a4512fd67eb7b860181b19ab53f079b3ba2960e5b1fa89d7fb2953d3d7efa529d3a3fc0cf6d43fb443f8f11db611fe91505768bf02e28094cdb5487450fbcfcc81d5728d702f8c9a8e6313c8c57a0dab1c1fb4f0785bbccf5a83b3b76193ec81f6e9db4381c9fa9000c0fddd67b2e6b4e92aa6cbb9e8de7fe7b7b30e478567ae682bfc6f7a3116ed6cb93e545587586d8d89ef3c2e0d01026e72a7f2af692e116037dc6f3aedba50df0684380c6bfb828e2da22de4a9c5a2bd0835b143400bc756a2b6139db3769e1f2fb4501366772df6a80771107d52e52d284e0423c337d1bed94501fb0d3017f11d2b9b55fcfcf6e4442275215254054147402b72c731b3fec0337933ecc3260ecda279ffd9fa88c11d227d1a765dc82826ee042b5ef8efe1b4687dd66ea7e777f5b3bd8f5baeb68a6def059fb04c60e2642cda961f1c94ca5e28742e43c9435281520b196e5bdeebcc8c86f8d12cbb19f306bff52ac9d6886dad56d07cab8e047ce0ee7517db8872f24a7eb03dde1c8ac6ec0298b7a85fdb344402387571b2eaca325c132c71bacb0d84caaa598088843e9550b132a478cc6aefd6118742bf9f1a99847a7bd1bb3037dc6ea395d40ea311593402b38ff7a00536b2253c386702a0cbcbd5af0a54785159f2f772c5bb222cd78fdfe99ca257f3523be8d410461def54f347b9b3e40059e041cfe349a87c8c35e95174be0c0885dd61d9096ea6839d695d4c6b3e4370b95c124d90f4a5ba71ccb79b3dcac61dedbc0279b68ef023f5b1c77f46798dcd1893e2e03739e1c1f346224f90ef7cf2f2daba0daecb4b8a1e09be7385a033fa15c259b03ee2d3b5dc0c301d89067aeda29529366994297216a3d33b6bc5edcdbb73c2de28051ff72e74e0c2e3952da267771dfb8f3ae91e490a25b3f54517ee5e4910b0a6d0925037603b682e7ce42be873a4bf690de09c59dde580819bd65a02a9ca81e020868438c5cd9c4b4246859bc58b94594ff5093dd58ae4cb8c0ca05f0f5932306fe3afe9c158da25e883659e6f9c3b3d06935c5abbfb038b1f82052dfa8fc277124812acd4de331a972f285b9d597718105e711ec15105fcf7bf44266e55ec67b3f68dca66535d3d12946d54c912cf2be535d4f22618be07e8ecea2d31f0bf6ebd89ee35d17409d40d741d21e639a77c99787734b34a1f8ba07be7237125e58a9a3eaa703ad7c58c0e99f09551d7d666dd57110f191eb7b2aec6ee7cf1162797c6d41da65f7cfcb455a23051ea7d2e272b98813c58665e07a4b26adc48564cba187df932379a2a952ac6a99080cfaba2846f1bbf3a508c59319c02ffda4a1ef9c70874087481e776825a920f1614a287972d1e4a7d5302d617b373a104c032e2aa339de2ab72f75799691d58dfccaeb8a20710879a18e9dd413684d89ceb6ac1f568023ee74d819e97a3293109bf5ac09bb98e387b173d7460602d31db40380b46a83c6fa2530e27dae63c309c391373b894833e3e406d687957e817e314ad988f2756c1628e825b661df591ec05bf9ae1f10f95ee48006232aa62fd78f407a90494326412396ff6686f249898d431d9a8b012dadab23eedfe7991920a6e55b3612694a85bb25bf647696dcda45db08099c5978a995494d0506011078097f585ed0513f5ff67da558688d4bcda739c2ae0a84022a89753dbc7e6724b192a2ec461ceb763370002c6ead7b8de6e74195422bf66fb7d950467313c4f230ff8536c206f1d68e79f93ec59810c1733d4b2fa5cee7a5ac6aa243431af85e90acc03f22ba52800d1a2081809cdb1292908f196291cb26fa84c8bdd90dbe8193e80bc7cdf2c47e14fec19103a76d849dc9a204f973cb06185de6c359ba226b35f23e7c3eac25ebef866986c45175b62227b914c32b5b45c9a7a2b8830bb8223253ebae557b5e8f21e3a50ff27441f432d4e829d44df6103c9a841430c0913ef1db78ee6a7b98bd16b8955a3373c834d4135e47ecdcc4a949b8c295e5eaa480447d00514e5fb0160cca37858d49e10fd531866b4c3a3f10ba9e90815a127d6cb202374ff8802ce4b0d8bb38b16dbc3287c3033a2878f7f45d647ee230d478d9e9b07c617b63b663d261f40413d9ba1b972d1835fea54fd837d55bc8f7af0230a8334b0306705091c4746a87994c56a26dca7702d4e5872d9f3e6ca2cbe7a8c94fbe6303a1fa6d566c2f82f05c4f8b36a269f78d7b95759e26a2d36f64cc9fc869926f5ca8140609ccdf25aadfcde43586f318f6f5e31d6fd62e171f6de511362d355dee3aea2556ce10b6c8acb6d73798a3b01940da72e9573e5d41f4b6823a5e03f37c7ec9aac7029e7aa86488c70f3ae62a1a18fcc13ef2c399203693051eba236357fc68b9c92cbbd0c7c7b47d31c3360187a8659c1aa60bae707159e0bc4d0520b3e6182ec96dfa05036f285763c03b80ae09b4c1a3e01c82110f0c4711e81584cc3e9e02cc456371ab1d1ef733ee80aebec73d4955332a031135573a0d9ae75aedf8a2c91f03409717a2caa45822687b39e8b422b9ba6a8d62d2cb5aff26ce50b1ee260e287a490c352aef0cbb5db8e03ce264b940baa07a191b096775746d39412a252e4198456c20b4674611e8cfdd30b19ca2b632a94a583b00f2aba94956ce515cfa8268194278ec221b9f522e1305d53fdd000d08482c1c98336e10b055b21827f97aeb61f10689929568c969af33cbe8a6295c26b36206f72651749e5a0ce0034d219333c6a3c80d5b828a55ca613a4fa4b775ce2da36a022bdcacea17451dcb26d4b8ea5963241c1f789e35c5e850672905ebf9c2dd00167166f528b5c05aa65ecc64112ee94fab536bd30d7ab0b53cd43bd527e9abb2e966558ddf8b0e3b5c730038b082dfafc198bd4a55692a0531f6a6ccb173dbc1a057cac152c0d3d664ca71a3ce6a52d49ef58a6810ab6279bc87f54cfca19d1a6f4611513bc8db7c6bf67d17a663d7eb47e75627de621f821d16bc2a79631ce4ed4381a846ff50e4b8aa05915aa736cc98be7f98763d6588cb39c6b3bee82c909c47bf7a04861881e1c4ade58383f6fe529146fb86ce02daeba20f5aeb4132bd81eff16f06d6138654b196f2956818e4d529c899a15ab3464c68a65580143b86b143ce880e757f058bc234d8e74d5b08d77f2ca43e0a2c946f99dff5f42febf23bfda22ff53440256779f5ff0fb9be37148aaed63cb618ae4abb731ce15dcd013190d6c13a32c468f2891d8c4615d51ce034042bfebd6b156ea7e478aa5f81610343465919efb002782098ba6f2f779185b71a0ff34f1e69655f4ecc1dcaba4cee59ffd07514c1b143a4f8dd30e46168eac932fcba7257d3de1df24afad15f5d45d148d67fbc91f2ec92eb60ae837d34dc6c6eb720f54c2470f9dfd27a779b6b9517580196adef3a09c18b5f1b1c63a5774ae60f3eb1570718e1e1ecb12483ecf27b4f167a2ef14ddae466dc158ae1e79182e1758ed0e91285653b8610e36ac24c459b309c6201e01e071a0026c1a26674e49fdd9ae4fd8e7bae9cc8282363488e653d4b506b6b34603c4a65f23c498ee8eba71a911a67fc34cc366ed341b0c6ca86f6f7880e269c3f58b691bed3d40302a410015694c9845ef43863b7c06d8cf8c76e8f414fe94d30932dd2aab0d6cef67408f9c8b7e85bcb24b92fadb3c70badf002b7614dd3b7e83207693e7ab6b9aea0349a5fcdb4008f0abaaa37f837c50eeddd46406d007b0d7f158dac25ba1c481e7414eac10981c3452d696dd53d61d4bf92fe76855414292cc837128cef6c4af0986be41f7e3fcc44c64b814836bb4f45bc5749c2fc1818713235888bfe57cfbd47e16c6dcd17471ccd46d27734321a054341da2ad7e12bab562babed214272224d6b095affdfec267ef6543c985df90c4bfd4099e48c7602b64f73496b86846578cd56eba8c49b570f324c4e054338c34fe54</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第一周总结(4/1 - 4/7)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>美好的每一天～不连续存在～</title>
    <link href="https://blog.phbeats.cn/posts/ca2f7778875d/"/>
    <id>https://blog.phbeats.cn/posts/ca2f7778875d/</id>
    <published>2024-03-19T14:53:45.000Z</published>
    <updated>2024-04-04T12:30:12.816Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="82919a83c5e260c5301ac0dbaa429e9b337b2682e62afa85a33275e9a0ac9a73">e673c8ca06aefc9fd566f76e908c7073bf122394db4047bcd924ce9ea37328240a38cdea58412a376dfb2c4084c8672e19e7fec2a499cc6cfafe0f544c575fc22968d157ace4fc995bc36c6fc521fa9124d0e79762ed71cfa3cbcfcd4f2370559b60818db7bb6248fa9ec9043fefa6dd542fad9625b40ee414f98f8b4d4229f43045d6de6524382334aa4bed97a16c7bc05e200ebf0b391e85dd57d31d13a06bce177e062841c4bb1b41ab134bc77b3f70b96877878da8e45570bc5c4ee08c33ad15d85aee225e68d757cf0aac34fe97b285f3215fbf412a760af5f6f3691597d84ad90fda5219954d39ea8b1e3644a3240473aaf12cd8cf5aed44a9fe285f0c4207a2772aa01f08ef95291a83d3b0eabe0f6ad0e1ae7a23e6ef964e46f8eb8ed46a8e5c2ae3a3c780cc8ab09d94cf1cb6195cbc0489e14bd2f9ee4863ff555244fda4fe3a65be8fd19f23892a7fe1c8ecb04b6348ba842687d71ddd21456506718cb68994c50b19946737e56a1d0489649d5b15fe3f02639a4bfdb432b111bc7cf3593ac49ab49886c252d62d4d2f54a19cb18bd9a0b28fb89a9891b679cdd2693f8e8c129a53eb5ec1b9f2d33f2c8824f4e9cd870abe7ca2aac942d1118ee7ce0c27f79c5b3629cf0ab9219a52fa209b52ba4aad6af95aac24d6f56fd33ed14b04453498d782395ff5b2b93ba5f45a1e32398aeffeeffbd03fbabd58b079fe1d1ccb6be2dd3cb2590438d42256c6e4fb4a558a72582cc0f05253116d6b494b98bc165fe6dbae9212bc1401d0229d4e9d0ca4610c2fd6acaad1de300846d215bfc72ce50c8228081235ba8b3a3bc70bda5b380c0bdd728c3e1e9325c6699354524eeca4bf58819b11f200d98f183411dc236030cbc2404ae0d1dc99eb3d559cb6f10818f7b5939cb0ca8984afc5cfa8c0d76b10ba53898ca567f69d6ae36ff666d0ef2e4f0712c4f35f212e5169804774a618d6d703150f7fe46dce77b67aa6fbc7d211ca34476e8417e2f475dc04d18af0c4e956522b8e1d3849ae0f61c2fd586d6de11cdba44563f40ac8f5d672f4eaddc3f5852991b5d3a54c1e727df3db4f25eedcb03621f51de166e847e681e41c2ab685c0dbfa76b133f01468cac27fe2635ba79b7d49d4df7f779cb3459c0ecf77890eda5d4c69c77c512c8c2f9c2c7e14e20d42934da46c84b9b3d14c744250033c2e35c69baf9aa405236e0820fb638236801acee70e03b25dde41230ed4233b248493c533b5e2f1fe6df0e03fe93d12a15c3a50d1df7f4400722d8714d784490412041358d6cf06b3effeef828443453d7af54a201f85fff313ee68f133238d3c1c26546c1061639867c5c93b62b1b99cebd2e4d6476c7a6cb558ea8fea080acc9086458757c8bc39aa93d1a10948729202a91fa2b038cb753f5a41333d6087a563284bd219559be98027c31574a7c6093ede4d70b2c9b8cded26fc3504d9bfc9122a583a0c0f01e37a96aee0a9a6f4abdb2b3590a9d7fa4cd89d67e4983f5e4fdc7e62d23a88bc93a9facb6829e094be9ec57a1ed942523e6d8a60ccd19690e41cf61fe7f3f4150fcac532ce156313d29d85d53c0f9297616a8f073c931e79be84d44be5012c7d6acfd645b972c3568268e0c1cf415d2b2a340e5cb0512165ccca9416593839fa6a41ca8de4feb311fca1b27f163c81d2f067bc0b199f5e12ea16f55251fab78b86d9e93e26e958e9c9d9abf6a4e3745c96b5eeaf888a873970f3e65bbf81f117a42789e11c27f9f754f6bf982622ada8f184536ed23e9fae83a1341d26606a2ff4b440b56adca4bc38137da068e0eadee4ab5a8d8aecc37bace0236e62a963b4feb56e379ef042c6500a427b3e5cf810a5e5ed2ce01118e7685e0fb7215d57a08d4e9b91ee392a38441b7bf4d56e1bed8f3c0e3c1cf91ad4713bbaf995e292cf87dc2c3033dc42b45c37a616d002d47326d6ef8f3328e6c70ccc119cf7ff94c63248661a22d7a0659c9ebbdeaa20d1cb6e0a07a1ac46d9eb0b971139b08373d1f6a157adc187c00bfec8bad155152f6edb461073d8ab668731916ce75ab0c691fdb1fd93f63dfa9b5e69d304e482302200c23cb13c85e6198322f9f9036d64db30bef3dc3b91c9faac0033fbd13039ff757af30dcb1d6ce4b8902d4e4db875340e2175792efd493307f8759cfec0d1e61c8986065dddce1f689c82f24ec9cc183ad64effb9569a3078e7ffa95c6d391028b1faf8be5183b8293502f216a855690a52efcd02383f2e8a7441e91907cc50ce68f65b264f05ecf5f9ea1ab9e8ee81e8b603c8b93112b697ee2d048df2c08c970916c0cae15e41945d84654d602cd1c3f915f2723b6d7da05eb35d81b1ca1e6a50aef338eb791b6cf6a2224b51d88824aa72aef7bbd32b36e215cefe0aabc2f68d25989730789a8e0023f27fe7f955d01b7f8e2730b9e110e3bf5b08709b98f24aec0862de7355903e00b568acb8cb0614ae03e88765062419fc81b27d9fb0b07a793605e140fe40c5879340268d336439f13f14990b8d810f372f8cd4158c9bfb1131860e1807f665219c67dba59f85510753a1fd28f2ba8fe8ad701e92d799c81826e0aac6f5d3c8e70f029b6b1f1d134da4b0b58eef14057c8448fc777676156332521532dc1cb114c05aa602aa25cbd05c3abfc62c0842d0157919e93d4d332ebdcf9f33ff6c01e88059df995de8c36488a06966fed7cdc087d9979b984db4b41aefd76394d943c89e1c3dd08cc9bc91d9cb70b8d7535c97dbf261dc762de4918055d17a79d8d99717e10c7404e82193d19312c47320aae98b060134fc1e4019f637e011826df87cfae42664a995e31157d0a0532d19f6feaa5a2eb1cbf89d6e9a81183df4ff8e9d40d4ac4c5779c8f7d699216f4d7ca5eae19519b23f8f0527bde950f80c61dbc4d8e52e8dfa552504df52e12045e4c1329633df60bd749419782dc065aa6fe95c6969c41804342ca0803c96eb850e69616b1a3c20fcf0f609901dfb0608df133c012badbbde022adde3be12f045cdfcfc21968f1f5947756185eef49a8d8319c844ebb680ff448bd58d85ca72ee9a16f8f2f99de55863262751f77a6145ac672c0a3f3ea33d394df26fc9b35be9c038c984497f12264a766c5f6b6aecaa2293d00c37f9a00e1097d5a60c424d379a69ff69421735524f1d2e47685f6b3e61f6fd74033e4280ac11680680a89bb40b2c0726384ed47bfb0d1cdc0de6efaffa23ed90ddf0a0b6459e51433de43bca9c307620addb76b2997dbad769268febaae9abfb4a1e59388f6438897b0353d8f16dfd457f972f3631523dcb7052dbb3c90c00940bdde8d737a3d9cc03070f07963cce06dce8213c4c13b070afd485c92869d654aa52c4eecd888a4553d57cfceb0f0d400bd7af57d973137b00562f86af3a63b3eeac8ed948e229fd7d859e0ed751f20bc149fe251de6dc98784b10376d73e54deee4707b2a82a7be79ee72191bb1df8cc5f1abe2797e276beb9a13dff4d586d32b43b495b9aeacb27d76e1bc1e5dd3e5cd4fce80aa43f7eec8588a5384386acfb2d906304ba81093a0e89bee6a37d6b0840603675fed5d624059fd33d0f4185799cf622f561805770dcb44f891e2b872ccdd1547612619334829b27d4bb177a14275411550acff2d30e7a5152a8eb7c09e297f4115d035ec57559d4b96e9b3de7e57f23e05b24eed7f90aef611c7b7b6b89f93220ce954236efc1399c4e48c39af64657ffc49e60b71f7dbfe31f4ee8ea2d17dc209356af5511d37333dd46c9f33575d6099d57ae2f74939e7547238acdddcdf451837da0d87607d9b41993cb47adf98934f66bb50a2d4547d1030d2e631a5501873b3a18c58961631e52f618417e51eb7230979c84bb5dd822af961fe3aca6dfc2c2879fcd980635964e09917d58a775aafd71df1018a736d380ce288e36152976a103b9dc2c0c1b984ce2f0e5424f513762b25cb7c3ebbc9380b24fe50e064ba6aa552acc9f67b802fa7fc045001014b4d7d14e49b1c16837fbf245c1994c993be949fe258655b22af63f907e5922d3e3da81102807c83034e737d490f496650bbdff000bc93895906aea7f41091ddccf364edebcfd28cadebc91a77ca1947345a21af8a6ea1cdb0e0068b72afd757966c558d0565e4f1315dbd14732a0cb5c805dcd417b2592f12b3416891dc25de558dc9e5232fc67a916b03a629b35236230200c2e1b91cbf85e873cf8d7cf4ebd7ac884b70195ee127c662d14fb0cc5a662caad779edc0a236543a23f86e0d9e57c00518173b69812ea121d9163c102bdedc657e3f6589556f7a16f5cefcc4e35203a15394bfd2aeff7705a3bc1d03d50cc7d37112db46e575d4682d66d166b6ea637b3c6e314a2e7c6c4080fc43b7fb62e6c9f688f812b7a6b96f34153f6234932b2b77ff15889f75c8e85b84c5e859dab8cef9dc3eda47759fd2c99226b7edffb75106dc9e869d759679581e90730e2f38b5b980f0857fbf5957d3ef966a22b78b8dbb4a0965ebe40c92e9ecbdd83544b2d90b326a9a080dee3bd9e71334f517bd982fe780c207ec1bf700404135531859928916b897dbcdbbde64fbe0a96d0c57fb1c71d27358c34be0b1fddaaa18991895732e7e292ac1698bfef82f1c3fac98199460a16f664122c3891783bfbc8ace0a3ebb160a539c81c58a2b1957b6ce3613844d9ad24e57a98b174965f53b96a4715167de28dba081abc8481cd97cced3d367ce9f7335031c26a1767886dc0a3b5eef94827c594902a136a1a812911b3b3606ba7558c50f4dbd67bfe7813fc80f093bff6ffedd464a90be07d406ca978119d0e689a3b71cba9aa8edfcc8cbeae397d6db18c688ad55c3dc15747f5114b5d7fa233bae839e230d2ed08563d1e6011249cb8ca9d54e5c608a26dbf83211df5c943c963ee1be6fd3a61ef72ef24c2430a4fbfd0962861a07a1d16bd81a598896e75ebcb0fe3c26dc9616fd8c244a6b7c9b7b1e03749d18ac6cd26c38caa2d277e741ae435214bc7c19e3c3d279b57513dab92244e4e6b18a8317fb5ec3d8cb5151f02a905ff356f6f3966f72f346597adf0dfd04d042568368248e45bf87331e48fbea1248be9c15fb59f7d38010e72b83e3337d64847966f5c37f501365dcad7e317a3394e3ff2ed18d07a472b66d3461f412cb10381e6ec4180b1f8e0438a85bfb11ed20a9f5473823dce194d5c371557fc4879486e058362c9ce0e0925f775d08301ce84d9620c10c25f5a2dbd6d38db49458868e56e2dc40362a50f0dfc6ab7deeace3c4bb2381ef00d2a62c9c2bbae2291796b27e7e064407a8a58745e61f37f7661a2cbaf01501ce58afdc373c0bc8ddacc79810857d8bf41e8de8545855361e3e78066489f56b5256d44f2c7587e6ba46c4ab8f31cfb90a49a18abc394bf590bf60dfe8475a20ede270af672023628a4826b9deea00a8804f8b2a16b881f96b7b0a9361a5c0e69925c97afd6e530c264ddbed29a5de6f7fa6f42130ca6158754c327f0f5f4ae4d89f307677818b438450981093c1603e1e9cef91e91b856c124ff76800560867029e823415e1807d29098279e804b81dd2bfd0a6da94727c4a2e7132118524ebe3064cec44552058c32583662293abcc57775c7dd1d09de7f8eaa250e361ad1dd0cb7621f1eb8917ef5d9d14ede6a68dc94d2628167c0bbd45af1dcc0338a3c0056585f63809a242dc66f1dcdef2217db68d1251dc57d214010411d6bb710fb2a532b7e2954bc2396ec82321d14cdc3dec1ce53626a49b3ff4eabd9c4d277c82122a4be7817fff5bd6baa2f6f32e7539fed2689b626b110d38e8df5e6c714a0c740c0ac03a4d2f076bff1bc268d025216314e3f0180f0ce548c9c380c2ee0abf9b8f2cef662813a48cf5d821d69ba6524eb17789729ca5ed12363b3f3545d128e23f479acefe70ceae4edb47a0744672f89638cce3b25277cb347b6e0b7d6b26a049dc44498a183a9c87d7cd44ab6d5939c65f14a5c337155c37f2eac810850780964bd25317f26c579f014cfa58da351fac77071de73e1bde5027ccb2c00fe12c4264fd9c68e7458ec1e3878cbebdcca6b65ad7d24aafa3c9b025a8b4645be6af8afd0a557e33360d3a363b888cc7065ebea51e03d8570822d5d41e7f9b2edde91c61362f0e0b8de3c2cc6295eeec66832bcebdb931665d128752193649fc96f7bd813fd3a6dcd498086b6bdc2c0a07357651cf40bb2f03391755ca59ee978fb924b21ca2a7a56f8fbaff44144522b66724e2cc31539084df425e90d09b3ebe1a682c58c070467fd1ee66e714a831b927dcd6024195e21ea0ed705e2a9e794030d5b7f5178c99483d006568628f36c43e0b17302c940f33be9083003456f380a15b620ef58d62345443650f3f30f3c8b46fe0533816e112627a2c11a29217b6a7a8b5a6e53fd79afea72311132785d7cdebabd0d675ee3e7c961811d23e85ea383a9b55ef6b3d5e13a8d986904bc22b1f84dc8723ec74e37245539f5f0b99f6af010bf36075a2cd2f52cbc2fc0afce6786bbaabbea251b7aff4dd1041b21ca013d707116d33ef91e8fa03370a0fc10e0ec126967a15b2d01c43805f251f82af3c167bfa4dc811ea3b9cf26ce2b8b0ef14a45daf2a542d5525814f756e9662935d31fa6a25cd477ecaca671a47f6637aa0dc071925dc9ca45ece1f295a48aafff1f2ab5530dad5d4ddb990a0f313a29ebea7c3c19327f1f592f19709197a0bd40c3077e983d40019a5cf81772f601a36e881fbf6577b57d851607b3be00f8b41045c549cf939012fdb78d7550c42d48ac01d3527a7323fd267a4ff5e8c64d59db87defb8d2321afadba2667ab087c381394581c655238d3cc0a9609f72561bf05386b39fcd85495096a2e38278022e80364d114a397c99198ac9e3dc002e3b049f21f0d2694f9a73ee956cf8afe207facf742b3f4cbc36ca131b3524a49f307f35959723402427381377bba411458efec573cc2050a3e02976476e2221d8710f41549d094eae8f292737df9bf9f5d9778a502bfba0fe211a0c28763c6de799ee545d04a21ac7267e286e3e7b5f95f765ef9408c49c73631d09cbbdbd195f62682a3ed276c913e2ae39d2ecf5ef8c13c0159641f12c1907f73bfea1c2e75dad0ca864a67a4e87de64ed6ed9d92ce54c741b84edaa177b0990d0707fdc6f8a0a22a0181d02e4f31a798c4f1420c790bbbcbb8ac92470520c806da090b1011e7a4ec421afde547bc110a56cd92212365a5a729bf5134e53835fcbc9a86549f57e9f9f6914d163316c2176b8d188535997298ccf23e155d393c21ffadfff8d736898c5349801a72af7e63fe089cce603546a6020ab7b947960e7f65470a46111aa6b0a85652725375f07e1e6e13f9e42b82491197812d4e53f8221776df8a4634ebcbd5386cca9f9eff0b9566292d5c9e7eb8b7b063bfd337d389fdc6ac83b2ac0bae01c779d319d510c77a908a0a7110da1f5a9b88c8be6748a8552446dacf2ba0ec29892784329876a72760b0062b5494fbb1e169e5b9554ee088d8ee19d9f71a530c1418ba6496c50797a3465a8d194683e73e405df8f7c5b130f30561def26954f681c90b216eb7d6f6b74fddd03508121bc754659042ab21bddc995efb5248afa72be5a6bd6dcf1d8e90ee2a587fc6744e627a4fc1405394deaa30877e87b5c44c522e6f9b37ec5e04064d9aac5b8283beebd335573e6e179233fe87a8909b127b44f627014d6f7f8fc2943cb44cd5fec42dcde65bf58d29f5752f7a7c5303d6737d5c79205fd77fc00e2dec7656b35d9d1c91689598b65ac52954f8801de777f6f4b4d06b68cea818b7f8074227b7f044f8445d687e5f5fabf2594b3a353a8952500c576a9c8a15420dc74df7ccaa3364535825fa085c95d820c6489dccdaf7244c15b321b0eb98d53fec7f269ca13b70845d046e9bca7b03359c7bdb020652b314e15e788b0cbfc7401f04c627c8efeb9c21d7117c34198d46fb15062be8ce13b428a329323af678f616d5d1929c609c5c9dbf6e3f184afca8fc488f1838cc02b1a3e2da23d5fad90a112ec12186f698c73305ff66a794bdf131ee5400c3d1cc23775b668d9e9d9030c5062e29dc9ec78d081c4b45b1370b50d43603dca16e21cd4d50d8185e9a5584c637dd2a9b8c769ad89feabdd6b5efb074c11a653b68e8d639a8d2275e28c7c2cc291201f44b21fb8768df2477468a9da7cfc1ac17320360b4e75c190ddfbe9f4ca2fac68afbfda99be02429aa9cef6615a21d32a1c260d1b4382bbcbab447b3e8b3b6d2047e6e61f4f7030a0d12bc5e24287623e088405dbbc129a7bf092d924d4b5e590067fe1e921d257a444344c3eaca94056c678da9ae3fac6dcfc4ff0ea03eb9e6003d9dedc1fabaa1f5314c0d2cff929cb1f1c3c42c10d08167285851cf8c9d0787008caba32d2ac3f5a020278d802d21c8f91446d67080f8dee070b0bf4617623396cbdd50a3fb9e3c516adcee398a66b528b28498e4f779b1485068787f6d8c716e5b65ad7c7486fc2d0eaf79ea306366b0cf79747399c2ca7107f2a0ee5794260f5555c73cf46ef0774bd22c7800df2e89996ea650211afddd044f525bee806e119fb7a2b5554e2092dcd28e945a778c49244c64e03ca83b7223214cb7e7e4992872718e6e43ee83a10711db008d50f7b8d0acfb6a11b9a597b304d45b10de1b4e2da16a6298777993413abd82cd03258d423c22a09eb28c23c371b1f258368009b7ec6c38a75cb62c05890df532fbe61dd1fb8df9bf6e983c514e742128f3878b6b62e537086acba1ddde6444c464b52aae2df4a36bdaa5f027bc07c698cb29c4fe51382a48ac9e4d9232ef656748575d04bd1c329cd45a9540a8287ec9e4612b1de71ec5210d87206278fd34d07db4308f80d7c6e0e602c1b3feab155a9a89902a996641b09664485275e5ea2bb2dce4791e20f2edee7d2362399d4a50a43d0eeb8f8556ff7f61585b55a053365990ff694c2b3cc9e59bc0f321aac918b7eced3abb0d4ed107f4ca93ca224c28842b920b9dccd73587121149862eb6c94fcdcb4471a16bb51b03212725942fc1519fab5cb5892b4d9375bc2426b2b18db70d732c3b966980e5434ac5b4d9a2006a058588c87c3868b88fb1ddffbba8209a37467efd18894b4804f9dee137de3bdfd3bc0c73246dd4000fbf0c7632affe07527dcdb86ea4eb3a233f56309c90647d7c2d7fcf73eca96bc7947545afd6202ddabee9440d432efcb352aa68f2e3f8696295b945426e02f4c1864038e24e17baaa8ed9249cb1f5b3c28d428245438f4f8f5655fb50088ea6d2396ef7db55df2422c8ccedde21b9145705505553f2b115f4592dc1b0d19aaac6de93d60d82a70d073e68b827c03fd386d4ad72a636adfe46ead73a5353ff1a3fd3a485fcb7e809654ff077910d144f34e207a3ef156190c09e7788747c786000b6799dd4126293c021079fb1e11501f01ec051571ac7c0d2e04d39a4280df3e79390e14289c14144c1f143525f56c41dfc68cbd238dddbe79e642398aaa16cf2100c4e566821208f344d5cd9b4b0e2dcc1d07b2673c358d705ec7411d4ff25c665506282cf60c2b06410fd505ce4110b3ab75943c565de75d8997a6a25a41b75f8383197652ef468b6b53e8e060683cd0a3ee71800df606aee27348fbaf099bc6d9e78e26dc69025c8415ea7c791668a90a04b74f43344495cdf804022ad7386db464b3e468be9f36174a17765f53c81b34e506ca5d9d782af935cf96bafae741a666ca681f2d8f389fd602cb2b4cc4a77d711ebdcf95fa9964ef0c59959c8ddc0fd3e2804191374f5e4485cf6f4bdd6a25cf90b2f0559e895276e512526410cf34a1849284452e1ac6ef4b50fee2634228b676ab6c1d6aeb1051f64667b0ec1085e8acc3c1a953238e87358d2542d2a07b078b70bc09d32d97cfdace07f02332273654465b95b037e1ba5ea4dd3d50abf7736f3052cc238d6531971e994e175a7520c9d292179e7fa447ce44533e9a72c4957fe7252f717778b30ed99bcac85ef5c1ccdf1a7a9a7f9cc6588d790f25d5272dc6132b8f5693e9590211fc02304a85bd07546489fab458b5789411ffa576492ef11fc5b19fc7b2640e611425b732a3d5ef8430939e3f114bb3676a9c5ff5a133f3f15bcb23bda38f7e8358779f50d7afa5bf2145fbf0bfc592ec55d4326abca7d75eba1c17d5376424b5ffe97b57d0ce8d2bc678629e8b8f6d9d65d23419c8e003221a028f8b7ff72e69a83d2b7ba4d88ad6f8a01c163eafc3601841ef73e7d80efb6f729aa9042b2af68623c19214551e6a5917cf6ca5c5b40a414e7d8c583da6576fb55985e1507a97ef437546642e2c8f5b6f8d8d17c1b5e351915ba066cf3ae68cf875e16bfc0579c913c25ae32f619a15ccbf5949891a712c7500f62d952541b4ffadeed3e908e0830e8863f687d43648fcf38e19fc9680f7b0feeaa3c2cde61fa6584946ab6391440df5955af70707677883b4c55089904253d7742e4bad393155a57b09eb129d907c9f8471bafe5922dffd727f148047742d42cb6761fc1eddce512b0085eeaadc77a3c0cfe32e5b328b4c5dd061bf2833e12faeb5f078bb2c6b86d0ec748928c8d33e58b1c65c5762d9532c489fe4ef95abcc7e0a38f26e55324e5e0c1836aef7bca4db0f1f4639cfaabf1329911c11c432da18b2b3239a6633fa6db5aa25288c8c342085d2868ae7754025d262944aa88b69603de283885a210ea9a7c166787a8670f01db0f48d182a2c21d318b8949e056e072745e6a369d304d762a03b2c8522ad661147858a699a764ae9d70cfa62564888c82e8f316735d7bcf4c05709e934bbe55dc89e7fb98c686a796fa7aa2a5c6daa49c632227f733555881c8093eddf8d0c5a81207e5e5cb66df9443089290c16c269d37f270a112692612b176266f02b4c2fa28df1670673c18bca9ea79ecc0d90839c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">美好的每一天～不连续存在～</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>周志汇总</title>
    <link href="https://blog.phbeats.cn/posts/acdb8d5c9b7b/"/>
    <id>https://blog.phbeats.cn/posts/acdb8d5c9b7b/</id>
    <published>2024-03-19T14:37:12.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ccb101d680da5d138bca0c1ff12f39a013e8cd0532e1d22595195e4f1bbae3a3">e673c8ca06aefc9fd566f76e908c7073bf122394db4047bcd924ce9ea3732824180a4f1db344e311487ba241f1b16c4587f75b861f83fe634c4c300b5ce9c13f6ab2dc51be3173e872c5b9303aab66b98f2d10c9186f542c60bdf6e9e018902100efec3c9b0d9e25eb662a6738083cac0144094eaf56dff4f3d0dac07a1d8fde55b12b81cafe45e830d294450db7709fb63d8646cd7dbfc68602c1aa7bd817e8af19f77f37b3a9914120c5cb5b0f50da53c2241e20617cb37b4d39a1119beb3e073a03515b4a5930f95ae2a3fcf3e482c62a96ff08658ef5f572c32442201c12f96576e6b29cddc71ec72e7ca496a5ed9674904c3ddfb4040e37bd0457a3a51e7b885dc33f80ae91af49c6cfe9ad3576d9cd6d90c341d4b1473f006a8219a96cb109b928364ee5ea8a84eb1df1aa43f86f1a449ac8807a6cd5d14028ff1a150b0647f7bd953905b24c4ac42666bb5aaa1ae35080c1722039bee56539d157a787</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">周志汇总</summary>
    
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/tags/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>图-基于邻接表实现</title>
    <link href="https://blog.phbeats.cn/posts/de48a254d011/"/>
    <id>https://blog.phbeats.cn/posts/de48a254d011/</id>
    <published>2023-10-28T06:30:33.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>使用<code>邻接表</code>作为我的<code>图论算法</code>的基本模板。</p><p><code>图论算法</code>可以使用<code>邻接表</code>和<code>邻接矩阵</code>来作为地基。<br>我选择王道书上的邻接表作为我的模板原因有：</p><ol><li>若要使用<code>邻接矩阵</code>，我有 y 总 的模板。并且也契合，因为可以使用一个<code>二维数组</code>来简化类似邻接矩阵</li><li>我如果是出题人，要指定数据类型，我会选择邻接表，因为考生肯定会优先选择二维数组。</li></ol><h3 id="邻接表的类型描述"><a href="#邻接表的类型描述" class="headerlink" title="邻接表的类型描述"></a>邻接表的类型描述</h3><wavy>我似乎理解错《数据结构》这门考试科目的含义了。它应该重视的是理论，而不是代码的实现，我花费了大量的时间在代码上，这是错误的！因此我打算停更...</wavy>]]></content>
    
    
    <summary type="html">图-基于邻接表实现</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://blog.phbeats.cn/posts/00977ebe8687/"/>
    <id>https://blog.phbeats.cn/posts/00977ebe8687/</id>
    <published>2023-10-27T09:10:02.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>使用<code>链式存储</code>。</p><p>因为书上的大题使用的都是<code>链式存储</code>。所以我也采取这样的方式，作为我的算法模板。</p><h3 id="二叉树的类型描述"><a href="#二叉树的类型描述" class="headerlink" title="二叉树的类型描述"></a>二叉树的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br><span class="hljs-type">int</span> data; <span class="hljs-comment">// 数据域</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> * lchild, * rchild; <span class="hljs-comment">// 左、右孩子指针</span><br>&#125;BiTNode, * BiTree;<br></code></pre></td></tr></table></figure><h3 id="先序递归建树"><a href="#先序递归建树" class="headerlink" title="先序递归建树"></a>先序递归建树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序递归建树</span><br><span class="hljs-function">BiTree <span class="hljs-title">CreateBiTree</span><span class="hljs-params">()</span></span>&#123;<br>BiTNode * root = (BiTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br><span class="hljs-type">int</span> ch;<br>cin &gt;&gt; ch;<br><br><span class="hljs-keyword">if</span>(ch == <span class="hljs-number">-1</span>)&#123;<br>root = <span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>root -&gt; data = ch;<br>root -&gt; lchild = <span class="hljs-built_in">CreateBiTree</span>();<br>root -&gt; rchild = <span class="hljs-built_in">CreateBiTree</span>();<br>&#125;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">PreOrder</span>(root -&gt; lchild);<br><span class="hljs-built_in">PreOrder</span>(root -&gt; rchild);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br><span class="hljs-built_in">InOrder</span>(root -&gt; lchild);<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">InOrder</span>(root -&gt; rchild);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br><span class="hljs-built_in">PostOrder</span>(root -&gt; lchild);<br><span class="hljs-built_in">PostOrder</span>(root -&gt; rchild);<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先序遍历的非递归算法"><a href="#先序遍历的非递归算法" class="headerlink" title="先序遍历的非递归算法"></a>先序遍历的非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">// 一路向左</span><br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 出栈，并转向出栈结点的右子树</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>p = p -&gt; rchild;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于先序遍历的非递归算法：<wavy></p><ol><li><code>根左右</code>，先根的性质，决定了在<code>一路向左</code>的过程，是可以<code>边输出边入栈</code>的。</li><li>模拟递归回溯，也就是<code>else</code>部分，此时已经完成了<code>根左</code>。现就只要出栈，并转向出栈结点的右子树。</li></ol><h3 id="中序遍历的非递归算法"><a href="#中序遍历的非递归算法" class="headerlink" title="中序遍历的非递归算法"></a>中序遍历的非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 中序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">// 一路向左</span><br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 出栈，并转向出栈结点的右子树</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br>p = p -&gt; rchild;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于中序遍历的非递归算法：<wavy></p><ol><li>与<code>先序遍历的非递归算法</code>类似，不同的是<code>什么时候访问结点</code>。</li><li><code>左根右</code>，决定了必须要找到最左边的结点再回溯。</li><li><code>else</code>部分，也就是模拟递归回溯过程，必须要先<code>出栈</code>再拿着那个结点的值访问。</li></ol><h3 id="后序遍历非递归算法"><a href="#后序遍历非递归算法" class="headerlink" title="后序遍历非递归算法"></a>后序遍历非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 后序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><span class="hljs-comment">// 还需要借助一个指针r，记录最近访问过的结点</span><br><span class="hljs-comment">// 因为回溯的过程中，可能是从左边回溯，也可能是从右边回溯</span><br><span class="hljs-comment">// 从左边回溯，那么根结点就没被访问过。</span><br><span class="hljs-comment">// 从右边回溯，那么根结点被访问过。</span><br>BiTNode * r = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123; <span class="hljs-comment">// 一路向左</span><br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 转右</span><br><span class="hljs-built_in">GetTop</span>(s, p);<br><span class="hljs-comment">// 右子树存在，且右子树还没被访问过</span><br><span class="hljs-keyword">if</span>(p -&gt; rchild &amp;&amp; p -&gt; rchild != r)&#123;<br>p = p -&gt; rchild;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 否则出栈</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br>r = p; <span class="hljs-comment">// 标记为最近访问过的结点</span><br>p = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 重置p，这样下次循环会直接弹出栈顶元素。</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于后序遍历的非递归算法：<wavy></p><ol><li>指针<code>r</code>：回溯的过程中，可能是从左边回溯，也可能是从右边回溯。<code>∴</code> 从左边回溯，那么根结点就没被访问过。从右边回溯，那么根结点被访问过。根结点被访问过，说明该直接从栈顶弹出一个元素。</li></ol><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 层序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 辅助队列</span><br>SqQueue q; <span class="hljs-built_in">InitQueue</span>(q);<br><br><span class="hljs-built_in">EnQueue</span>(q, root);<br><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">EmptyQueue</span>(q))&#123;<br>BiTNode * t; <span class="hljs-built_in">DeQueue</span>(q, t);<br>cout &lt;&lt; t -&gt; data &lt;&lt; endl;<br><br><span class="hljs-keyword">if</span>(t -&gt; lchild) <span class="hljs-built_in">EnQueue</span>(q, t -&gt; lchild);<br><span class="hljs-keyword">if</span>(t -&gt; rchild) <span class="hljs-built_in">EnQueue</span>(q, t -&gt; rchild);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">二叉树</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>顺序队列</title>
    <link href="https://blog.phbeats.cn/posts/54e3f3a21b91/"/>
    <id>https://blog.phbeats.cn/posts/54e3f3a21b91/</id>
    <published>2023-10-27T08:33:53.000Z</published>
    <updated>2024-04-04T12:30:12.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>顺序队列，以<code>循环队列</code>为主。</p><p>因为好写，所以采取它作为我的模板。</p><h3 id="顺序队列的类型描述"><a href="#顺序队列的类型描述" class="headerlink" title="顺序队列的类型描述"></a>顺序队列的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>ElemType data[MaxSize]; <span class="hljs-comment">// 存放队列元素</span><br><span class="hljs-type">int</span> front, rear; <span class="hljs-comment">// 队头、队尾指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化队列 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp; q)</span></span>&#123;<br>q.front = q.rear = <span class="hljs-number">0</span>; <span class="hljs-comment">//初始化队头、队尾指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EmptyQueue</span><span class="hljs-params">(SqQueue q)</span></span>&#123;<br><span class="hljs-keyword">if</span>(q.front == q.rear) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 入队</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp; q, ElemType x)</span></span>&#123;<br><span class="hljs-comment">// 队满,报错</span><br><span class="hljs-keyword">if</span>((q.rear + <span class="hljs-number">1</span>) % MaxSize == q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 入队</span><br>q.data[q.rear] = x;<br>q.rear = (q.rear + <span class="hljs-number">1</span>) % MaxSize;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 出队</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp; q, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 队空, 报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">EmptyQueue</span>(q)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 出队</span><br>x = q.data[q.front];<br>q.front = (q.front + <span class="hljs-number">1</span>) % MaxSize;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获得队头元素"><a href="#获得队头元素" class="headerlink" title="获得队头元素"></a>获得队头元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获得队头元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue q, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 队空，报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">EmptyQueue</span>(q)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 获得队头元素</span><br>x = q.data[q.front];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">静态分配的顺序队列</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>顺序栈</title>
    <link href="https://blog.phbeats.cn/posts/15d79a1a4b3e/"/>
    <id>https://blog.phbeats.cn/posts/15d79a1a4b3e/</id>
    <published>2023-10-27T08:04:26.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><wavy>顺序栈比较好写,因此我使用它作为我的算法模板</wavy><h3 id="顺序栈的类型描述"><a href="#顺序栈的类型描述" class="headerlink" title="顺序栈的类型描述"></a>顺序栈的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>ElemType data[MaxSize]; <span class="hljs-comment">// 存放栈中元素</span><br><span class="hljs-type">int</span> top; <span class="hljs-comment">// 栈顶指针</span><br>&#125; SqStack;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp; s)</span></span>&#123;<br>s.top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化栈顶指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断栈空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack s)</span></span>&#123; <br><span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 入栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp; s, ElemType x)</span></span>&#123;<br><span class="hljs-comment">// 看栈是否已满,报错</span><br><span class="hljs-keyword">if</span>(s.top == MaxSize - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 入栈</span><br>s.data[++s.top] = x;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 成功</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 出栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp; s, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">StackEmpty</span>(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 先出栈，再减</span><br>x = s.data[s.top--];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获得栈顶元素"><a href="#获得栈顶元素" class="headerlink" title="获得栈顶元素"></a>获得栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获得栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack s, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 空栈，报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">StackEmpty</span>(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 获取栈顶元素</span><br>x = s.data[s.top];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">静态分配的顺序栈</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师沃卡74110耶加雪菲手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/89001a5236dd/"/>
    <id>https://blog.phbeats.cn/posts/89001a5236dd/</id>
    <published>2023-09-11T14:06:31.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近又买了两款<code>治光师</code>的咖啡豆。</p><p><img src="https://bu.dusays.com/2023/09/11/64ff1c3e0aee9.webp" alt="Screenshot_20230911_214426_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/09/11/64ff1c53bc299.webp" alt="IMG_20230904_174607"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/09/11/64ff1cbb12663.jpg" alt="IMG_20230910_035340"></p><p><img src="https://bu.dusays.com/2023/09/11/64ff1d1fb1cfc.webp" alt="IMG_20230910_035309"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>冲好后，是红茶和柑橘香味。<br>高温表现为：酸质明亮，甜感十足，但还是酸更为突出。</p><p>温度低一点，甜感增强许多。</p><p>低温时，轻微泛苦，甜感更强，但失去香味，茶感还未失去，有点像吃了烂果子的甜感。</p><p>总体评价：中高温很好喝，让人想一直喝。</p>]]></content>
    
    
    <summary type="html">浅尝治光师沃卡74110耶加雪菲手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝辛鹿号码系列手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/9d745f9baaa9/"/>
    <id>https://blog.phbeats.cn/posts/9d745f9baaa9/</id>
    <published>2023-08-08T08:12:00.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前买了<code>辛鹿SOE耶加雪菲</code>，然后我去评论了它的风味描述，店家看到了找我售后，表示他们很抱歉。作为顾客，我觉得辛鹿的这个价格，本身我对他家的豆子就不报有很大期望，我基本上是将<code>辛鹿</code>作为行业性价比龙头来看待的，因为学生党时代，我买过辛鹿的咖啡豆，因为便宜，但是味道也就不多提了。</p><p>店家这次给我补偿了一些豆子希望我尝尝，然后表示歉意，所以我还是写一篇评测。</p><p><img src="https://bu.dusays.com/2023/08/08/64d1fa8d9e1e8.png" alt="image-20230808161911377"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p>首先上场的是：<code>辛鹿02意式拼配</code>。</p><p>闻起来就知道是深烘系列了，一如既往的焦味，能喝出些许酸味，整体风味均衡。</p><p>应该算是经典老咖啡风味了。</p><p>总体评价：老咖啡、性价比高。</p><p>然后是：<code>辛鹿04精品罗布斯塔</code>。</p><p>闻起来有种不一样的味道，不是纯烟熏味，更多的是大麦茶的味道，而且气泡超多。</p><p><img src="https://bu.dusays.com/2023/08/08/64d22c610c730.webp" alt="IMG_20230808_194509"></p><p><img src="https://bu.dusays.com/2023/08/08/64d22c60a1944.webp" alt="IMG_20230808_194519"></p><p>喝起来绝了！这尼玛纯纯<code>大麦茶</code>！喝一口，剩下的就不喝了。</p><p>总体评价：大麦茶，不推荐！</p><p>在喝完大麦茶之后，现在是：<code>辛鹿05精选蓝山风味</code>。</p><p>第一口下去纯苦，多喝几口，有浅烘的些许热带水果风味。总体挺均衡，风味不突出。</p><p>总体评价：均衡，均衡得想笑。</p><p>最后，是：<code>辛鹿06精品庄园圆豆</code>。</p><p>闻起来好像是浅烘，呜呜呜，连续喝了那么多深烘，人要死啦。尝尝这个豆子怎么样吧。</p><p>额，喝起来是中烘，风味其实感觉像<code>中烘的耶加雪菲</code>，个人感觉比<code>05</code>好喝，起码这个有风味。</p><p>总体评价：中烘耶加雪菲？性价比高，还行。</p>]]></content>
    
    
    <summary type="html">浅尝辛鹿号码系列手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝四人咖啡粉红佳人手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/b8bb6e256940/"/>
    <id>https://blog.phbeats.cn/posts/b8bb6e256940/</id>
    <published>2023-08-08T07:08:36.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这次事件挺有意思的，起因是我给了<code>四人咖啡果丁丁</code>一个中评，然后客服来问我要不要售后，退货也行，我表示不需要，并且表示下次要购买他家的<code>粉红佳人</code>，他说给我先送点喝喝，我起初以为给我补发<code>30 g</code>豆子尝尝鲜，谁知道他家诚意满满，发了<code>100 g</code>。</p><p>不过喝了之后，我表示很不错，他家也是发了一个修改评价，我也是改成了好评+空评价。</p><p><img src="https://bu.dusays.com/2023/08/08/64d1ed5b9ac47.webp" alt="Screenshot_20230808_151607_com.taobao.taobao"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/08/64d1edc1c17af.webp" alt="Screenshot_20230808_151830_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/08/64d1ede675129.webp" alt="IMG_20230808_145826"></p><p><img src="https://bu.dusays.com/2023/08/08/64d1edd1322eb.webp" alt="IMG_20230808_145904"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>你知道什么是<code>花香</code>吗？你知道什么是<code>蜜桃</code>吗？我小啜第一口，全是<code>蜜桃和花香</code>，而不是<code>酸或甜</code>。我怀疑店家给我的是<code>A1</code>品质的豆子，几乎喝不出什么负面的味道。</p><p>中高温，蜜桃风味明显，随后才是酸和甜的草莓风味。低温，酸味开始突出，但是蜜桃风味不减，甜感增强。</p><p>继治光师伊迪朵水洗耶加雪菲之后，又一让我眼前一亮的豆子，很惊艳。</p><p>总体评价：蜜桃、草莓、高品质、性价比高、推荐。</p>]]></content>
    
    
    <summary type="html">浅尝四人咖啡粉红佳人手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师野草莓手冲咖啡(整活)</title>
    <link href="https://blog.phbeats.cn/posts/0e42f4daeb32/"/>
    <id>https://blog.phbeats.cn/posts/0e42f4daeb32/</id>
    <published>2023-08-03T03:50:57.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>买了<code>治光师</code>的另一款咖啡豆，这款咖啡豆是意式拼配，中深烘焙的。之前喝的差不多都是浅烘，不知道这下风味转变能不能接受了呢，应该问题不大，毕竟以前黑咖我都是不加糖的，主打一个不怕苦。</p><p><code>治光师</code>店铺也九周年了，送了一些小玩意，虽然没啥用，姑且也算送了？</p><p><img src="https://bu.dusays.com/2023/08/03/64cb3337d9470.webp" alt="IMG_20230801_181148"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/03/64cb32d81bb8a.webp" alt="Screenshot_20230803_114348_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/03/64cb33549edd7.webp" alt="IMG_20230803_114019"></p><p><img src="https://bu.dusays.com/2023/08/03/64cb335dd702a.webp" alt="IMG_20230803_113927"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>豆子看起来棕亮的，冲好之后闻了一下，一股烟熏味，感觉梦回高中了。</p><p>果然，一口下去就知道<code>老咖啡</code>了。整体喝起来十分不错，不对我口味的是那烟熏味！即使是手冲也能感觉到它油脂丰富（别和我说没压就出不来油脂，我说有就有），它入口绵滑，虽然带有烟熏味，但并没有带其它奇奇怪怪的味道，比如<code>焦炭</code>这种。回味能够感受到<code>柑橘</code>风味。草莓酱我倒是没感觉到，不过毕竟是手冲吧。</p><p>这算整活了吧，因为这豆子要用<code>咖啡机</code>来制作，然而我是手冲！因为我现在还没咖啡机，仅仅是手冲爱好者，但是<code>治光师野草莓</code>又十分有名，我抱着试试看的心态买了这款豆子，尝尝鲜。</p><p>总体评价：中深烘焙、油脂丰富、均衡、性价比高。</p>]]></content>
    
    
    <summary type="html">浅尝治光师野草莓手冲咖啡(整活)</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝四人咖啡果丁丁耶加雪菲手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/9c71bc76a9ad/"/>
    <id>https://blog.phbeats.cn/posts/9c71bc76a9ad/</id>
    <published>2023-07-31T22:53:21.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>四人咖啡送了我一些小玩意，还送了我一包<code>花海</code>，之后我再喝。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/01/64c83b62d354b.jpg" alt="Screenshot_20230801_065234_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b71273d0.webp" alt="IMG_20230801_062901"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b8391dae.webp" alt="IMG_20230801_063010"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b951ee47.webp" alt="IMG_20230801_063637"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b9ea4a2d.webp" alt="IMG_20230801_064028"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>偏高温时，第一口居然是莫名其妙的味道，第二口继续确认，出来的是<code>茶感</code>，随后品<code>茶感</code>的时候容易品出<code>木质</code>和<code>涩味</code>，随后感觉像咬到了一颗焦炭豆子一样，口腔开始发苦。</p><p>温度稍微下来，酸味明亮，茶感明显。但后半段伴随着不好的味道，比如：木质、涩味、烟熏、焦炭。</p><p>其中不好的味道比较突出的是：木质、涩味、焦炭。还是那个问题，喝到瑕疵豆了！</p><p>到了中温才能更好喝出它的风味，耶加雪菲的感觉。不过风味变成：柑橘、焦糖了。</p><p>不过它确实能喝出来，水蜜桃的风味，很神奇哦，不过我是在偏中低温情况喝出来的。高温的表现并不好，因为不好的味道突出太明显了。咖啡豆还真就和运气沾点边，我这批次的豆子应该属于不太理想。去除那些瑕疵风味，我想<code>果丁丁</code>一定非常好喝。</p><p>总体评价：耶加雪菲、些许木质、涩、烟熏焦炭、性价比一般。</p>]]></content>
    
    
    <summary type="html">浅尝四人咖啡果丁丁耶加雪菲手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>王道数据结构链表习题</title>
    <link href="https://blog.phbeats.cn/posts/78005f2f1e1c/"/>
    <id>https://blog.phbeats.cn/posts/78005f2f1e1c/</id>
    <published>2023-07-31T05:32:29.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表经典大题"><a href="#链表经典大题" class="headerlink" title="链表经典大题"></a>链表经典大题</h3><h4 id="递归删除不带头结点的单链表中所有值为-x-的结点"><a href="#递归删除不带头结点的单链表中所有值为-x-的结点" class="headerlink" title="递归删除不带头结点的单链表中所有值为 x 的结点"></a>递归删除不带头结点的单链表中所有值为 x 的结点</h4><p><img src="https://bu.dusays.com/2023/07/31/64c75c76e2b3a.png" alt="image-20230731150204492"></p><p>题目说了是 L 哦。但是我代码写得是 list。偷懒了。</p><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p>板子</p><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归删除不带头结点单链表中 x 的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del_x</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 出口</span><br><span class="hljs-keyword">if</span>(!list) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list -&gt; data == x)&#123;<br><span class="hljs-comment">// 如果当前递归中的结点是应该被删除的结点</span><br>LNode * p = list;<br>list = list -&gt; next; <span class="hljs-comment">// 指向下一个结点</span><br><span class="hljs-built_in">free</span>(p);<br><span class="hljs-comment">// 继续寻找</span><br><span class="hljs-built_in">Del_x</span>(list, x);<br><br><span class="hljs-comment">// 下面这三行代码是绝对不能写！！！死循环</span><br><span class="hljs-comment">// LNode * p = list -&gt; next;</span><br><span class="hljs-comment">// free(list);</span><br><span class="hljs-comment">// Del_x(p, x);</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是应该被删除的结点</span><br><span class="hljs-built_in">Del_x</span>(list -&gt; next, x);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="附赠无头结点的尾插法代码"><a href="#附赠无头结点的尾插法代码" class="headerlink" title="附赠无头结点的尾插法代码"></a>附赠无头结点的尾插法代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 无头结点尾插法建立单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TailInsert</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-built_in">InitList</span>(list);<br><br>LNode * r;<br><br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">9999</span>)&#123;<br>LNode * s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>s -&gt; data = x;<br>s -&gt; next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">// 是第一个结点</span><br><span class="hljs-keyword">if</span>(!list) list = s;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 平常的尾插</span><br>s -&gt; next = r -&gt; next;<br>r -&gt; next = s;<br>&#125;<br>r = s;<br>cin &gt;&gt; x;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除带头结点的单链表中所有值为-x-的结点"><a href="#删除带头结点的单链表中所有值为-x-的结点" class="headerlink" title="删除带头结点的单链表中所有值为 x 的结点"></a>删除带头结点的单链表中所有值为 x 的结点</h4><p><img src="https://bu.dusays.com/2023/07/31/64c76dedf2ece.png" alt="image-20230731161643650"></p><h5 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h5><p>板子</p><h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除带头结点单链表中 x 的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del_x</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br>LNode * pre = list, * cur = list -&gt; next;<br><br><span class="hljs-keyword">while</span>(cur)&#123;<br><span class="hljs-comment">// 当前结点是应该被删除的结点</span><br><span class="hljs-keyword">if</span>(cur -&gt; data == x)&#123;<br>LNode * q = cur;<br>cur = cur -&gt; next;<br>pre -&gt; next = cur;<br><span class="hljs-built_in">free</span>(q);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 当前结点不是应该被删除的结点</span><br>pre = cur;<br>cur = cur -&gt; next;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="从尾到头反向输出带头结点单链表中每个结点的值"><a href="#从尾到头反向输出带头结点单链表中每个结点的值" class="headerlink" title="从尾到头反向输出带头结点单链表中每个结点的值"></a>从尾到头反向输出带头结点单链表中每个结点的值</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb446b8fd07.png" alt="image-20230803135630640"></p><h5 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h5><p>利用栈的思想</p><h5 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 反向输出链表中每个结点的值</span><br><span class="hljs-comment">// 0.在 main 函数中，调用要注意！</span><br><span class="hljs-comment">// 1.Reverse_Print（list -&gt; next); 带头结点</span><br><span class="hljs-comment">// 2.Reverse_Print（list); 不带头结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reverse_Print</span><span class="hljs-params">(LinkList list)</span></span>&#123;<br><span class="hljs-comment">// 出口</span><br><span class="hljs-keyword">if</span>(!list) <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">// 入栈</span><br><span class="hljs-built_in">Reverse_Print</span>(list -&gt; next);<br><br><span class="hljs-comment">// 出栈</span><br>cout &lt;&lt; list -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除带头结点单链表中的唯一最小值"><a href="#删除带头结点单链表中的唯一最小值" class="headerlink" title="删除带头结点单链表中的唯一最小值"></a>删除带头结点单链表中的唯一最小值</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb4502a04bb.png" alt="image-20230803141117604"></p><h5 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>利用 <code>min_pre</code>、<code>cur</code> 两个指针</li><li>利用线性表寻找最小值算法思想</li><li><code>min_pre</code>用来更新保存，目前已知最小值结点的前一个结点</li></ol><h5 id="核心代码-3"><a href="#核心代码-3" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除单链表中唯一最小值结点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_Min</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 如果是空表或只有头节点</span><br><span class="hljs-keyword">if</span>(!list || !list -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 经典前后指针</span><br>LNode * pre = list, * cur = list -&gt; next;<br>    <span class="hljs-comment">// 保存最小值结点的前一个结点</span><br>LNode * min_pre = list;<br><br><span class="hljs-comment">// 假设最小值是第一个节点</span><br>LNode * t = cur;<br><span class="hljs-comment">// 打擂台</span><br><span class="hljs-keyword">while</span>(cur)&#123;<br><span class="hljs-comment">// 如果发现比最小值还要小的</span><br>         <span class="hljs-comment">// 打赢了，新的当 t</span><br><span class="hljs-keyword">if</span>(cur -&gt; data &lt; t -&gt; data)&#123;<br>t = cur;<br>             <span class="hljs-comment">// pre 作为 新的min_pre</span><br>min_pre = pre;<br>&#125;<br><span class="hljs-comment">// 俩指针后移</span><br>pre = cur;<br>cur = cur -&gt; next;<br>&#125;<br><br><span class="hljs-comment">// 删除擂主</span><br>min_pre -&gt; next = t -&gt; next;<br><span class="hljs-built_in">free</span>(t);<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="带头结点的单链表逆置"><a href="#带头结点的单链表逆置" class="headerlink" title="带头结点的单链表逆置"></a>带头结点的单链表逆置</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb637357a20.png" alt="image-20230803162110380"></p><h5 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h5><p>准备<code>pre</code>、<code>cur</code>、<code>r</code> 3个指针，<code>cur</code>指向<code>pre</code>。</p><h5 id="核心代码-4"><a href="#核心代码-4" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表就地逆置</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reverse_LinkList</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 空表或者只有头结点或者只有一个元素</span><br><span class="hljs-keyword">if</span>(!list || !list -&gt; next || !list -&gt; next -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>LNode * pre = list , * cur = list -&gt; next;<br>LNode * r = cur -&gt; next;<br><span class="hljs-comment">// NULL &lt;- cur &lt;- r</span><br>cur -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">while</span>(r)&#123;<br>pre = cur;<br>cur = r;<br>r = r -&gt; next;<br>cur -&gt; next = pre;<br>&#125;<br><br><span class="hljs-comment">// cur才是真正的主元素，r只是拿来判断的边界条件</span><br>list -&gt; next = cur;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单链表的插入排序"><a href="#单链表的插入排序" class="headerlink" title="单链表的插入排序"></a>单链表的插入排序</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32c0724c39.png" alt="image-20230809140236810"></p><h5 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h5><p><a href="/posts/f7271c1a5982/">跳转链接</a></p><h5 id="核心代码-5"><a href="#核心代码-5" class="headerlink" title="核心代码"></a>核心代码</h5><p><a href="/posts/f7271c1a5982/">跳转链接</a></p><h4 id="两个单链表的公共结点"><a href="#两个单链表的公共结点" class="headerlink" title="两个单链表的公共结点"></a>两个单链表的公共结点</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32d21a0968.png" alt="image-20230809140728686"></p><h5 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h5><p>假设有两个单链表<code>A</code>和<code>B</code>。</p><p>单链表<code>A</code>长度为：a</p><p>单链表<code>B</code>长度为：b</p><p>无非两种情况：<code>相交</code>和<code>不相交</code></p><p><img src="https://bu.dusays.com/2023/08/09/64d32ff3099be.png" alt="image-20230809141931085"></p><p>可以利用<code>a + c + b</code> ＝ <code>b + c + a</code>。求出交点。</p><p>这是<code>不相交</code>的情况。</p><p><img src="https://bu.dusays.com/2023/08/09/64d330de84da4.png" alt="image-20230809142327260"></p><p><code>a + b</code> ＝ <code>b + a</code>。</p><p>相遇为<code>NULL</code>，返回<code>NULL</code>。</p><p><code>公式恒成立</code>。</p><h5 id="核心代码-6"><a href="#核心代码-6" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LNode * <span class="hljs-title">findFirstCommonNode</span><span class="hljs-params">(LinkList headA, LinkList headB)</span> </span>&#123;<br>    LNode * p = headA , * q = headB;<br>    <br>    <span class="hljs-keyword">while</span>(p != q)&#123;<br>        p = p ? p -&gt; next : headB;<br>        q = q ? q -&gt; next : headA;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将原单链表A分裂为：奇A表和偶B表"><a href="#将原单链表A分裂为：奇A表和偶B表" class="headerlink" title="将原单链表A分裂为：奇A表和偶B表"></a>将原单链表A分裂为：<code>奇A表</code>和<code>偶B表</code></h4><p><img src="https://bu.dusays.com/2023/08/09/64d33587565fd.png" alt="image-20230809144319763"></p><h5 id="核心思想-7"><a href="#核心思想-7" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>奇偶序号计数<code>i</code>。</li><li><code>ra</code>和<code>rb</code>尾指针。</li><li>将<code>A</code>的<code>next</code>先<code>置空</code>，后面会通过<code>ra</code>来增加结点。</li><li>根据<code>i</code>的奇偶，在<code>ra</code>或者<code>rb</code>后面增加结点<code>p</code>，再更新<code>ra</code>或<code>rb</code>。</li><li><code>ra</code>和<code>rb</code>的<code>next</code>需要<code>置空</code>。</li></ol><h5 id="核心代码-7"><a href="#核心代码-7" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将原单链表A分裂为：`奇A表`和`偶B表`</span><br><span class="hljs-function">LinkList <span class="hljs-title">Re_Create</span><span class="hljs-params">(LinkList &amp; A)</span></span>&#123;<br><span class="hljs-comment">// 准备B表</span><br>LinkList B = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>B -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 准备工作</span><br>LNode * ra = A , * rb = B; <span class="hljs-comment">// A 和 B 的尾指针</span><br>LNode * p = A -&gt; next; <span class="hljs-comment">// 遍历准备工作</span><br><br><span class="hljs-comment">// A 表断开</span><br>A -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 奇偶序列计数</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p)&#123;<br>i++;<br><span class="hljs-comment">// 奇</span><br><span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span>)&#123;<br>ra -&gt; next = p;<br>ra = p;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 偶</span><br>rb -&gt; next = p;<br>rb = p;<br>&#125;<br>p = p -&gt; next;<br>&#125;<br><span class="hljs-comment">// 尾指针置空</span><br>ra -&gt; next = <span class="hljs-literal">NULL</span>;<br>rb -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> B;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="递增有序的单链表，去除相同的元素"><a href="#递增有序的单链表，去除相同的元素" class="headerlink" title="递增有序的单链表，去除相同的元素"></a>递增有序的单链表，去除相同的元素</h4><p><img src="https://bu.dusays.com/2023/08/09/64d33acd8d1ba.png" alt="image-20230809150548410"></p><h5 id="核心思想-8"><a href="#核心思想-8" class="headerlink" title="核心思想"></a>核心思想</h5><p><a href="448d550da686">跳转链接</a></p><h5 id="核心代码-8"><a href="#核心代码-8" class="headerlink" title="核心代码"></a>核心代码</h5><p><a href="448d550da686">跳转链接</a></p><h4 id="带头结点的循环双链表是否对称"><a href="#带头结点的循环双链表是否对称" class="headerlink" title="带头结点的循环双链表是否对称"></a>带头结点的循环双链表是否对称</h4><p><img src="https://bu.dusays.com/2023/08/09/64d33f2db78aa.png" alt="image-20230809152429784"></p><h5 id="核心思想-9"><a href="#核心思想-9" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>设置两个指针<code>p</code>和<code>q</code>。往两个不同的方向走</li><li>结点数是奇数和偶数，是难点。<code>2n + 1</code>和<code>2n</code>。</li></ol><h5 id="核心代码-9"><a href="#核心代码-9" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Symmetry</span><span class="hljs-params">(DLinkList list)</span></span>&#123;<br>    DNode * p = list -&gt; next , * q = list -&gt; prior;<br>    <span class="hljs-comment">// 第二个条件容易写成 p -&gt; next != q;</span><br>    <span class="hljs-keyword">while</span>(p != q &amp;&amp; q -&gt; next != p)&#123;<br>        <span class="hljs-keyword">if</span>(p -&gt; data == q -&gt; data)&#123;<br>            p = p -&gt; next;<br>            q = q -&gt; prior;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单链表判断是否有环"><a href="#单链表判断是否有环" class="headerlink" title="单链表判断是否有环"></a>单链表判断是否有环</h4><p><img src="https://bu.dusays.com/2023/08/09/64d34b2220fb7.png" alt="image-20230809161529567"></p><h5 id="核心思想-10"><a href="#核心思想-10" class="headerlink" title="核心思想"></a>核心思想</h5><ul><li>慢指针一步一步走，快指针两步两步走</li><li>无环：快指针必定会先到达终点（NULL）</li><li>有环：俩指针会相遇，相遇之后，让慢指针回到起点，再让快慢指针同步速度，一步一步走</li><li>当再次相遇的时候，那个点就是环的入口</li></ul><h5 id="核心代码-10"><a href="#核心代码-10" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">entryNodeOfLoop</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode * slow = head , * fast = head;<br><br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-comment">// 有环，相遇了</span><br>            <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果fast是空，那么代表无环，否则代表有环，并且slow == fast成立</span><br>        <span class="hljs-comment">// 而且，如果while循环条件一开始就没满足，那么代表head是空节点亦或者长度为1</span><br>        <span class="hljs-keyword">if</span>(!fast || !fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// slow == fast ， 有环</span><br>        <span class="hljs-comment">// 让slow回去，fast和slow以同样的速度走，再次相遇就是环的入口结点</span><br>        slow = head;<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            slow = slow -&gt; next;<br>            fast = fast -&gt; next;<br>        &#125;<br>        <span class="hljs-comment">// 再次相遇了</span><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br><br>作者：麦高芬<br>链接：https:<span class="hljs-comment">//www.acwing.com/solution/content/153752/</span><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="单链表倒数第-k-个值"><a href="#单链表倒数第-k-个值" class="headerlink" title="单链表倒数第 k 个值"></a>单链表倒数第 k 个值</h4><p><img src="https://bu.dusays.com/2023/08/09/64d34d9156593.png" alt="image-20230809162553225"></p><h5 id="核心思想-11"><a href="#核心思想-11" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>两个指针<code>p</code>和<code>q</code></li><li>先让它们两个相距<code>k</code></li><li>当<code>q</code>遍历完的时候，<code>p</code>就是倒数第<code>k</code>个节点</li></ol><h5 id="核心代码-11"><a href="#核心代码-11" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_K</span><span class="hljs-params">(LinkList list, <span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-comment">// 计数</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>LNode * p = list -&gt; next, * q = list -&gt; next;<br><br><span class="hljs-keyword">while</span>(q)&#123;<br><span class="hljs-comment">// 先让q走 k 步</span><br><span class="hljs-keyword">if</span>(count &lt; k)&#123;<br>count++;<br>q = q -&gt; next;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>p = p -&gt; next;<br>q = q -&gt; next;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 查找失败</span><br><span class="hljs-keyword">if</span>(count &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h4><p><img src="https://bu.dusays.com/2023/08/09/64d35190e4e8b.png" alt="image-20230809164257287"></p><h5 id="核心思想-12"><a href="#核心思想-12" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>先遍历一遍链表，获取链表的长度。</li><li>根据获取到的链表长度，获取链表中间的结点。(向上取整)</li><li>反转后半段链表。</li><li>合并前半段链表和反转后的后半段链表。</li></ol><h5 id="核心代码-12"><a href="#核心代码-12" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rearrangedList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head-&gt;next) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 获取链表的长度</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = head ; p ; p = p -&gt; next) len++;<br>    <br>        <span class="hljs-comment">// 链表中间的结点</span><br>        <span class="hljs-type">int</span> left = (len + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">auto</span> a = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; left - <span class="hljs-number">1</span> ; i++) a = a -&gt; next;<br>    <span class="hljs-comment">// 反转后半段链表，b在前，c在后  </span><br>        <span class="hljs-keyword">auto</span> b = a -&gt; next , c = b -&gt; next;<br>    <span class="hljs-comment">// a-&gt;next 是为了从中间将链表截断；b-&gt;next 是因为此时的 b 是反转后链表的结尾元素</span><br>        a -&gt; next = b -&gt; next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-keyword">while</span>(c)&#123;<br>            <span class="hljs-keyword">auto</span> p = c -&gt; next;<br>            c -&gt; next = b;<br>            b = c; c = p;<br>        &#125;<br>    <br>        <span class="hljs-comment">// 合并链表，注意此时 b 指向反转链表头部</span><br>        <span class="hljs-keyword">auto</span> p = head;<br>        <span class="hljs-keyword">auto</span> q = b;<br>        <span class="hljs-comment">// o -&gt; o -&gt; o -&gt; NULL (p)</span><br>        <span class="hljs-comment">// o -&gt; o -&gt; o -&gt; NULL (q)</span><br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            <span class="hljs-keyword">auto</span> o = q -&gt; next;<br>            q -&gt; next = p -&gt; next;<br>            p -&gt; next = q;<br>            p = q -&gt; next;<br>            q = o;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">王道数据结构链表习题</summary>
    
    
    
    <category term="王道数据结构习题" scheme="https://blog.phbeats.cn/categories/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    
    
    <category term="王道数据结构习题" scheme="https://blog.phbeats.cn/tags/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师肯尼亚圆豆手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/bb95ebed2e97/"/>
    <id>https://blog.phbeats.cn/posts/bb95ebed2e97/</id>
    <published>2023-07-29T22:45:30.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是治光师会员限购9.9包邮的，肯尼亚FCS合作社顶级圆豆批次，水洗处理的浅烘豆子。</p><p>9.9元30g，不妨让我来试试水。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/30/64c5986ae14d5.webp" alt="Screenshot_20230730_064146_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/07/30/64c5987b1a642.webp" alt="IMG_20230730_063602"></p><p><img src="https://bu.dusays.com/2023/07/31/64c74e7532b67.webp" alt="IMG_20230730_063624"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>一到货熟豆闻起来和之前买的<code>菠萝成子危地马拉瑰夏</code>味道差不多。先养养豆。</p><p>第一口下去是它的酸度和甜度，比较突出，酸度明显高于<code>治光师耶加雪菲</code>，最大的亮点是它真的<code>很甜</code>。喝完后回甘有很久很久，感觉喝了蜂蜜一样，不过对于我这种不太喜欢甜的咖啡的人来说，有点偏齁甜了。它的<code>热带水果风味</code>实在太足了，十分好喝，有轻微涩味，不过太能接受了！</p><p>总体评价：烟熏、涩、果酸和甜感突出、性价比高、推荐。</p>]]></content>
    
    
    <summary type="html">浅尝治光师肯尼亚圆豆手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师伊迪朵耶加雪菲手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/32f6f1e29b78/"/>
    <id>https://blog.phbeats.cn/posts/32f6f1e29b78/</id>
    <published>2023-07-23T00:00:02.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这款<code>治光师伊迪朵耶加雪菲</code>是群友推荐的，直接无脑买了。<br>写这篇文章，已经过了好些日子了，这是第二次喝的时候写的评价。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/13/64af5071a51a7.webp" alt="Screenshot_20230713_085908_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf456c60.webp" alt="IMG_20230723_064938"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf52e837.webp" alt="IMG_20230723_065210"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf44e11f.webp" alt="IMG_20230714_081733"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>首先，从豆子品控来看，是十分优秀的。</p><p>高温下，酸很<code>明亮</code>，基本无涩感，值得一提的是<code>茶感</code>很明显，有些许回甘，带<code>清香的甜</code>。</p><p>低温下，酸更加明显，有<code>SeeSaw 甜橙子</code>那味了。<code>茶感</code>更上一层楼。</p><p>目前喝过<code>最棒的耶加雪菲</code>。</p><p>缺点可能就是100g需要45元，喝几次就无了吧。真的，它就是优秀，挑不出什么刺。非要说的话，喝完后还是有些许烟熏感，不过能够接受。</p><p>不过我觉得这种价格配得上这种品质。</p><p>总体评价：浅烘、水果清香、茶感浓郁、性价比适中、推荐回购。</p>]]></content>
    
    
    <summary type="html">浅尝治光师伊迪朵耶加雪菲手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝菠萝成子危地马拉瑰夏手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/fcab5f014e92/"/>
    <id>https://blog.phbeats.cn/posts/fcab5f014e92/</id>
    <published>2023-07-21T23:18:45.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>瑰夏！瑰夏！瑰夏！</p><p>啊，我终于也能喝上瑰夏了，不过这款瑰夏不是出自<code>巴拿马的翡翠庄园</code>的瑰夏。</p><p>而是出自<code>危地马拉的庄园</code>。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/22/64bb06f93ff84.jpg" alt="Screenshot_20230722_062419_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/07/22/64bb0705f2398.jpg" alt="IMG_20230713_190844"></p><p><img src="https://bu.dusays.com/2023/07/22/64bb070c95363.jpg" alt="IMG_20230713_200015"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>根据<code>菠萝成子</code>介绍，入手了这款瑰夏，他说这款瑰夏一定是真的瑰夏。</p><p>这款瑰夏是中烘的，开包后香味给我的感觉是没有之前的豆子香，我层怀疑是不是豆子不新鲜了，密封罐好像很容易就打开了，是否起到了密封效果？嚼了两粒，确定一下，是<code>大麦茶</code>的味道，香香脆脆的。</p><p><code>瑰夏</code>为什么是瑰夏呢？不仅是指品种，还有风味。</p><p>即使是中烘，苦味一点儿也不明显，突出的更多是水果风味，属于那种真的很清香的，带草莓的酸的感觉，有焦糖味，有一点红茶茶感，喝完后给我的感觉是很均衡，<code>为什么感觉刚刚喝的是水？</code>。喝完后，还是能够感觉到明显的烘焙味，喉咙还是有点不太舒服，也许这也就是之前口嚼大麦茶味的缘由吧。</p><p>真的！这尼玛就是水吧，尝试了各种不同的水粉比，果然是水…</p><p>和闻起来一样，喝起来也是如此清淡，好喝倒是一言难尽，不过我不喜欢那种喝完后那种喉咙被烟熏的感觉。</p><p>总体评价：中烘、清淡、烟熏、性价比低。</p>]]></content>
    
    
    <summary type="html">浅尝菠萝成子危地马拉瑰夏手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>王道数据结构算法设计大题汇总</title>
    <link href="https://blog.phbeats.cn/posts/ba547e211266/"/>
    <id>https://blog.phbeats.cn/posts/ba547e211266/</id>
    <published>2023-07-18T08:53:20.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章-线性表"><a href="#第一章-线性表" class="headerlink" title="第一章 线性表"></a>第一章 线性表</h3><ol><li><a href="/posts/f57f98d1b5f4">顺序表</a></li><li><a href="/posts/78005f2f1e1c">链表</a></li></ol>]]></content>
    
    
    <summary type="html">王道数据结构算法设计大题汇总</summary>
    
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/tags/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>王道数据结构顺序表习题</title>
    <link href="https://blog.phbeats.cn/posts/f57f98d1b5f4/"/>
    <id>https://blog.phbeats.cn/posts/f57f98d1b5f4/</id>
    <published>2023-07-18T08:53:00.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序表经典大题"><a href="#顺序表经典大题" class="headerlink" title="顺序表经典大题"></a>顺序表经典大题</h3><h4 id="删除顺序表中的最小值"><a href="#删除顺序表中的最小值" class="headerlink" title="删除顺序表中的最小值"></a>删除顺序表中的最小值</h4><p><img src="https://bu.dusays.com/2023/07/18/64b6140d7eb70.png" alt="image-20230718122418457"></p><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p>遍历表，查找最小值，并记住位置 </p><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_Min</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> &amp; value)</span></span>&#123;<br><span class="hljs-comment">// 表空</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 假定最小值是第1个元素</span><br>value = list.data[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 遍历表，尝试找到更小的元素（从第2个元素开始找起）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; list.length; i++)&#123;<br><span class="hljs-keyword">if</span>(list.data[i] &lt; value)&#123;<br>value = list.data[i];<br>pos = i;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 题目要求：空出的位置由最后一个元素顶替</span><br>list.data[pos] = list.data[list.length - <span class="hljs-number">1</span>];<br><br>list.length--; <span class="hljs-comment">// 这一步是最最最容易忘记的！！！</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="逆置顺序表"><a href="#逆置顺序表" class="headerlink" title="逆置顺序表"></a>逆置顺序表</h4><p><img src="https://bu.dusays.com/2023/07/18/64b619073eeab.png" alt="image-20230718124559870"></p><h5 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h5><p>算法板子…</p><h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 输入非法</span><br>    <span class="hljs-keyword">if</span>(from &gt;= to) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 向上取整</span><br><span class="hljs-type">int</span> mid = (to - from + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mid; i++)&#123;<br><span class="hljs-type">int</span> temp = list.data[from + i];<br>list.data[from + i] = list.data[to - i];<br>list.data[to - i] = temp;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表批量删除指定值-x-元素"><a href="#顺序表批量删除指定值-x-元素" class="headerlink" title="顺序表批量删除指定值 x 元素"></a>顺序表批量删除指定值 x 元素</h4><p><img src="https://bu.dusays.com/2023/07/18/64b61b50f028c.png" alt="image-20230718125544632"></p><h5 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h5><p>利用变量<code>k</code>，从0开始，遍历表，只保留<code>非 x</code> 元素</p><h5 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_x</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-keyword">if</span>(list.data[i] != x)<br>list.data[k++] = list.data[i];<br><br><span class="hljs-comment">// k 才是有效表长</span><br>list.length = k;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表在某条件下的批量删除"><a href="#顺序表在某条件下的批量删除" class="headerlink" title="顺序表在某条件下的批量删除"></a>顺序表在某条件下的批量删除</h4><p><img src="https://bu.dusays.com/2023/07/18/64b626805f0ac.png" alt="image-20230718134328974"></p><h5 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h5><p>算法板子…</p><p><img src="https://bu.dusays.com/2023/07/18/64b629de5c63b.png" alt="image-20230718135751532"></p><h5 id="核心代码-3"><a href="#核心代码-3" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_range</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 题目要求，非法输入判定</span><br><span class="hljs-keyword">if</span>(s &gt;= t) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(i &lt; list.length)&#123;<br><span class="hljs-comment">// 值在[s,t]这个范围内 k++</span><br><span class="hljs-keyword">if</span>(list.data[i] &gt;= s &amp;&amp; list.data[i] &lt;= t) k++;<br><span class="hljs-keyword">else</span> list.data[i - k] = list.data[i]; <span class="hljs-comment">// 不在这个范围则直接位移</span><br>i++;<br>&#125;<br><br><span class="hljs-comment">// 更新表长，删除了 k 个</span><br>list.length -= k;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除顺序表中重复元素"><a href="#删除顺序表中重复元素" class="headerlink" title="删除顺序表中重复元素"></a>删除顺序表中重复元素</h4><p><img src="https://bu.dusays.com/2023/07/18/64b62c656f8fc.png" alt="image-20230718140838298"></p><h5 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h5><p>经典的双指针算法。</p><h5 id="核心代码-4"><a href="#核心代码-4" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_repeat</span><span class="hljs-params">(SqList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">int</span> i,j;<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; j &lt; list.length; j++)<br><span class="hljs-comment">// 出现不同元素</span><br><span class="hljs-keyword">if</span>(list.data[i] != list.data[j])<br><span class="hljs-comment">// 前移 不能写 i++ 必须要写 ++i ！！！！</span><br>             <span class="hljs-comment">// 不同的元素要放在 i 的下一个位置(保证)</span><br>list.data[++i] = list.data[j];<br><br><br>list.length = i + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线性表的-AB-gt-BA-问题"><a href="#线性表的-AB-gt-BA-问题" class="headerlink" title="线性表的 AB =&gt; BA 问题"></a>线性表的 AB =&gt; BA 问题</h4><p><img src="https://bu.dusays.com/2023/07/18/64b631f37d5fe.png" alt="image-20230718143153144"></p><h5 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h5><p><img src="https://bu.dusays.com/2023/07/18/64b6372246520.png" alt="image-20230718145427110"></p><h5 id="核心代码-5"><a href="#核心代码-5" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 输入非法</span><br><span class="hljs-keyword">if</span>(from &gt;= to) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 向上取整</span><br><span class="hljs-type">int</span> mid = (to - from + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mid; i++)&#123;<br><span class="hljs-type">int</span> temp = list.data[from + i];<br>list.data[from + i] = list.data[to - i];<br>list.data[to - i] = temp;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Converse</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-built_in">Reverse</span>(list, <span class="hljs-number">0</span>, m + n - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">Reverse</span>(list, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">Reverse</span>(list, n, m + n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表的二分查找"><a href="#顺序表的二分查找" class="headerlink" title="顺序表的二分查找"></a>顺序表的二分查找</h4><p><img src="https://bu.dusays.com/2023/07/18/64b6380c82626.png" alt="image-20230718145821268"></p><h5 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h5><p>使用<code>折半查找</code>。</p><h5 id="核心代码-6"><a href="#核心代码-6" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SearchExchangeInsert</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 二分</span><br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = list.length - <span class="hljs-number">1</span>, mid;<br><br><span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br><span class="hljs-comment">// 防溢出</span><br>mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span>(list.data[mid] == x) <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list.data[mid] &lt; x) left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 找到了，与它后面那个元素进行交换（要有的话）</span><br><span class="hljs-keyword">if</span>(list.data[mid] == x &amp;&amp; mid != list.length - <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">swap</span>(list.data[mid],list.data[mid + <span class="hljs-number">1</span>]); <span class="hljs-comment">// 偷懒了</span><br>&#125;<br><br><span class="hljs-comment">// 没找到</span><br><span class="hljs-keyword">if</span>(left &gt; right)&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i = list.length - <span class="hljs-number">1</span>; i &gt; right; i--)&#123;<br>list.data[i + <span class="hljs-number">1</span>] = list.data[i];<br>&#125;<br>list.data[i + <span class="hljs-number">1</span>] = x;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表的主元（摩尔投票法）"><a href="#顺序表的主元（摩尔投票法）" class="headerlink" title="顺序表的主元（摩尔投票法）"></a>顺序表的主元（摩尔投票法）</h4><p>题目太长了，就不给了。</p><p>大概意思是<code>主元的数量大于总数量的一半</code></p><h5 id="核心思想-7"><a href="#核心思想-7" class="headerlink" title="核心思想"></a>核心思想</h5><p>算法板子…</p><h5 id="核心代码-7"><a href="#核心代码-7" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(SqList list)</span></span>&#123;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> val;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++)&#123;<br><span class="hljs-keyword">if</span>(!cnt) val = list.data[i], cnt++;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val == list.data[i]) cnt++;<br><span class="hljs-keyword">else</span> cnt--;<br>&#125;<br><br><span class="hljs-comment">// 如果有主元。统计出主元实际出现次数</span><br><span class="hljs-keyword">if</span>(cnt &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = cnt = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-keyword">if</span>(list.data[i] == val) cnt++;<br>&#125;<br><br><span class="hljs-comment">// 主元超过总元素长度的一半</span><br><span class="hljs-keyword">if</span>(cnt &gt; list.length / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> val;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 不存在主元</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表中未出现的最小正整数"><a href="#顺序表中未出现的最小正整数" class="headerlink" title="顺序表中未出现的最小正整数"></a>顺序表中未出现的最小正整数</h4><p><img src="https://bu.dusays.com/2023/07/18/64b64e770a249.png" alt="image-20230718163359493"></p><h5 id="核心思想-8"><a href="#核心思想-8" class="headerlink" title="核心思想"></a>核心思想</h5><p>桶计数</p><h5 id="核心代码-8"><a href="#核心代码-8" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindMissMin</span><span class="hljs-params">(SqList list)</span></span>&#123;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-type">int</span> * B; <span class="hljs-comment">// 桶</span><br>B = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * list.length);<br><span class="hljs-built_in">memset</span>(B, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * list.length); <span class="hljs-comment">// 赋初始值为0</span><br><br><span class="hljs-comment">// 计数</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-comment">// 合法的范围</span><br><span class="hljs-keyword">if</span>(list.data[i] &gt; <span class="hljs-number">0</span> &amp;&amp; list.data[i] &lt;= list.length)<br>B[list.data[i] - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记出现过</span><br><span class="hljs-comment">// 从桶里面找最小整数</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-keyword">if</span>(!B[i]) <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">王道数据结构顺序表习题</summary>
    
    
    
    <category term="王道数据结构习题" scheme="https://blog.phbeats.cn/categories/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    
    
    <category term="王道数据结构习题" scheme="https://blog.phbeats.cn/tags/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>浅尝手冲咖啡汇总</title>
    <link href="https://blog.phbeats.cn/posts/7da784530acd/"/>
    <id>https://blog.phbeats.cn/posts/7da784530acd/</id>
    <published>2023-07-18T03:52:53.000Z</published>
    <updated>2024-04-04T12:30:12.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浅尝手冲咖啡汇总"><a href="#浅尝手冲咖啡汇总" class="headerlink" title="浅尝手冲咖啡汇总"></a>浅尝手冲咖啡汇总</h3><ol><li><a href="/posts/8635f45e7775">SeeSaw 甜橙子</a></li><li><a href="/posts/cb40af96710f">八平方 晴天娃娃</a></li><li><a href="/posts/c19e2a8a5f1a">辛鹿 SOE 耶加雪菲</a></li><li><a href="/posts/fcab5f014e92">菠萝成子 危地马拉 瑰夏</a></li><li><a href="/posts/32f6f1e29b78">治光师 伊迪朵 耶加雪菲</a></li><li><a href="/posts/bb95ebed2e97">治光师 肯尼亚圆豆</a></li><li><a href="/posts/9c71bc76a9ad">四人咖啡 果丁丁</a></li><li><a href="/posts/0e42f4daeb32">治光师 野草莓意式拼配咖啡</a></li><li><a href="/posts/b8bb6e256940">四人咖啡 粉红佳人</a></li><li><a href="/posts/9d745f9baaa9">辛鹿 号码系列</a></li><li><a href="/posts/89001a5236dd">治光师 沃卡74110 耶加雪菲</a></li></ol><div class="tip home"><p>最近很忙，暂时停更…</p></div>]]></content>
    
    
    <summary type="html">浅尝手冲咖啡汇总</summary>
    
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/tags/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
</feed>
