<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phbeats-Blog</title>
  
  <subtitle>记录学习历程和生活感悟</subtitle>
  <link href="https://blog.phbeats.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.phbeats.cn/"/>
  <updated>2024-04-05T12:13:13.396Z</updated>
  <id>https://blog.phbeats.cn/</id>
  
  <author>
    <name>Phbeats</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[AcWing]3765. 表达式树</title>
    <link href="https://blog.phbeats.cn/posts/4d1178f3e0bb/"/>
    <id>https://blog.phbeats.cn/posts/4d1178f3e0bb/</id>
    <published>2024-04-04T11:41:18.000Z</published>
    <updated>2024-04-05T12:13:13.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3765-表达式树"><a href="#AcWing-3765-表达式树" class="headerlink" title="[AcWing]3765. 表达式树"></a><a href="https://www.acwing.com/problem/content/3768/">[AcWing]3765. 表达式树</a></h1><p>请设计一个算法，将给定的表达式树(二叉树)转换为等价的中缀表达式(通过括号反映操作符的计算次序)并输出。</p><p>例如，当下列两棵表达式树作为算法的输入时：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c3f2bab7.png" alt="QQ截图20210708095213.png"></p><p>输出的等价中缀表达式分别为 <code>(a+b)*(c*(-d))</code> 和 <code>(a*b)+(-(c-d))</code>。</p><p><strong>注意</strong>：</p><ul><li>树中至少包含一个运算符。</li><li>当运算符是负号时，左儿子为空，右儿子为需要取反的表达式。</li><li>树中所有叶节点的值均为非负整数。</li></ul><h4 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">输入：二叉树[+, <span class="hljs-number">12</span>, *, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]如下图所示：<br>    +<br>   / \<br>  <span class="hljs-number">12</span>  *<br>     / \<br>    <span class="hljs-number">6</span>   <span class="hljs-number">4</span><br><br>输出：<span class="hljs-number">12</span>+(<span class="hljs-number">6</span>*<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>给定二叉树的非空结点数量保证不超过 <code>1000</code>。</p><p>给定二叉树保证能够转化为合法的中缀表达式。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>很容易想到这是基于树的<code>中序遍历</code>的算法，难点在于加括号的时机。</p><p>通过观察发现，除了根节点，每棵子树都一直在重复做的事情：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c45e6e6b.png" alt="image-20240404195438756"></p><p>那么就会有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">ans += <span class="hljs-string">&quot;(&quot;</span>;<br><span class="hljs-built_in">dfs</span>(root -&gt; left);<br>ans += root -&gt; val;<br><span class="hljs-built_in">dfs</span>(root -&gt; right);<br>ans += <span class="hljs-string">&quot;)&quot;</span>;<br></code></pre></td></tr></table></figure><p>在中序遍历之前需要加上括号。</p><p>可是，有特殊情况：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c5cd7fef.png" alt="image-20240404201019068"></p><p>那么就需要特殊处理。</p><p>当碰到叶子结点的时候就不需要加括号了，直接输出结点值就行。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     string val；</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string ans;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 遇到叶子结点</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;<br>            ans += root -&gt; val;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 非叶子结点</span><br>            ans += <span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>            ans += root -&gt; val;<br>            <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>            ans += <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">expressionTree</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理根节点的特殊情况，直接处理左右子树</span><br>        <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>        ans += root -&gt; val;<br>        <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3765. 表达式树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>第一周总结(4/1 - 4/7)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/216a02683518/"/>
    <id>https://blog.phbeats.cn/posts/216a02683518/</id>
    <published>2024-04-01T13:19:14.000Z</published>
    <updated>2024-04-05T12:13:13.392Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="960fa9e1999f894d1e3c1c4da4931a26ca3427e1d47a7a05cc9cc3a151e9450a">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814870b88c966fecb0cc2e967028af3411eee7300cb80bbf274f423dd19658f7505c530642711d548c2dc40e28f93eae2df7482b8d7f287346b0700bc0a6340105e6ea3aede3f037af485f18b8b3bed1367387e302de213c7661d9311e5de8feb9732ca67c4573b20edc8ef5bc3525464e85c21b047d751374412e1463cf3a1916e8dc86e753f6a76827c450ce814391ede13b13708368897ddf751d3ad12d75ab7133e419f45a4daba29d4481590da59f287b85f357d28fca03170453ea227274644608fd462f2583ae33283f8743e5b57ebae9650ba1c2c522a73c49277e7f818b4431fbe5ff793fea52c249e7afcef85a308419edb0fefad03f15809f45519fe8c7a8708c35d74100c7086b7ad28972b1e75ca4016ebebf8ddae22c333e262e490409525fb7934949c1986f5bf59394f88d55a073260d2e9b32bad061280a3c3f7547da3daf47cc63cb300bee14abb49bcd0f7bd1f45058ce82fd0046ac77c135f286d65eaf6d5ed12ed7924e83ad0334fa05778de1694a2e07af6d3bbce1933d1df1185bd41fbbb61555966780cd1b956db2cd98ab4059b035f4e05b185427297aac2e309731ec3864cbe493628c1a323f7c7f0678fdbbbd543b9be50faa372f255802ffad233e4253df8f50be77c8d2f3883eec44949bf0fd89cbee05bcac4f371567f76fafb487bdc429ebe69466b500a8aa21c0e3e089fb4894690d51f5335d8310ae6f239a25798f80ab4032f07120c450c71f4db18c054d5d514de7be526224019350a0081bff82b60c9cd17939cf1fe770f216a1709512fcc161c60aafea8129526f8783b6e96805b6418b9e492e85302e7c90c0dfc9cabbe3a9c8d4d02538b0af410a88f4495e4d157da46c2a2eb6b5364a300082620b5c81d318717db89e4244cc1a5f0a45770dcfddee2e4439c7c1afa36d3133d8c2a4f27bf1f22b2a280a3913508f079bfc0300059cfbd2d195355391e3fddbbb5f4de98c8b52838389bc102972ee7efd013f965192ab957d30ea0796747e1d0c0f2de5c238fa0a893d2ad408566e0906bde23ef2ef9982dfcc199f9be20392ab5ef94f879e1a0b5f66dd77a072638c141d0040c4af348b5c11db62101c2aaf7e7f9c7a4bb372d47481e9607b6f8fd53b55ecd1673300f10c1af78369d51993ceb290f6159cdd846c220c7f6bba7527b02cbc4dafd56d71bd59e52d0fda33a65ab0ee516bf790519ddafe8f0c7a57fdf04bc858359594e17d52625a5fb083024394830e7c0e525ac40df9ee0bbae992be734668aed0be085ac8a6e3e004e9b652cbf656287c69cb42774eabb13bafb4890d1c864372e599607b4f86c794601463f6478575c635419f5e3f3bdb5c1038ee3a20fdaa774c9bb9a708040c0f8780458c9484e1368840b0d9730ea49510eef659e381f7b5d9be634a188fbff3c18bc1a32c46ab1678ba470cabca8900d55ad519d4d99accffd2f9a002bc9f1e39d351637ab75af6c650cb703ab67a0e9552e82cb4e24c3580c2c603f17bcc07a7a3f5a355e810bd6765a0019d6a059f0e018ca567a1fc75a160e9d2bb9e94907263e5a782ca2c01919fd8ea1b59f7cb1922b12a2f45b7e68bacfcd1c27e37904963a68b22ebd0fa99affdc8b4d577827b4226ef6a410d59e13d1a11dd04d36ae3f8e85671146fe526b764d907521feb41a146b49046a4180ab3dd6738d45c088baa02050913a00b2d64068f2b6690e63fb37fbc29808c2e3c1ddcef5cfa910e24c5fb49881479976efd9b694b41c7925a896c984986e2e0021011ca2c66636f2c5d15869bc414a0600acdb2688d7a656635a8af56a798087dd01e55822df7a2aa88c28fee77a64bed27e5e50831b2add7389fd4228fa24bd2f918b7d6e11597a4c3b4e93aa1c1d4d5884b60fa8c16349e93292ce2ed538ee13c4631d7c03b6e6d86f8d4402261cfc896a060f6408f4e6a13a99aa6bb2d8eb8a6373ebac346c8e90f4711d6c4804807d72e0e5b86aadac4c45f0e7dd4847d5f88cc8e6a4d3cba5cd1d368d85d146fcfced8cf66b0a9b56816034cf6e6941776106960f6e84eabf31645b1a70bb5a308e135bb269309c750efa40a12631d2f26e2141b53c80ed8a254c7a1580d4ab255a2385d71a7c9d2538f034c1d2e248a60e58198a718e70dcde62989e6666baea3cb4da23c3e2ca1442a706a2777844bb810a350f38758952bcc3b0607071728de683dd8313b5afdcf5ba1ccd7b0502834d8709b6d2e6a16556d24af07fbbaeb718bb3e9768bf37a210b5cd07b271e0ba8e471da570660c0cabf0cf84d107326351290bc198cf15ede58fdda97d33ae7361d997d409628bfdd731e35a77cf567155b152781893875089874552470aa139347ca0a8e71f0f4c7cf8a306335925d2040c3b7234bd6ddfa9573a51c7a500052abbae0273af4eba4fd35e94c2843f6c4111bab9043fcc84697e2fe708f27e757f8c8de15d7a38ae7d22dd071b17c4a8ab6824535e1f7a9f616ee1f346cd62131073e1b2430255d53496bcbc2601f60f0e9e5a3ccd52832ab7b0c85f843fa2bf7fb1fe5cd07f4ed7f71eafb2ded35e04ec299fa7ce3bec60f6e163960f43a70974ccf7421af1a071cd5d0918426910bc05c51b87b929943764141b3a376f5c3a977188138be20061b205e505aabf3572a41802e925268e2135954d662f0ab7834acfc51c566b8022c9c15847f26ead1acd7296063976f458454fd17f9b8ce8f6c0ec7f4198ef2fcc27420edcd644c1cf3b5c21ea69e815aed68b80287fe8ecd3cc716e718bfdf991aeace59ae48226975a559405094764aa2311b10d6b5b647c229f11a5b78ce436df33871d8194379b46483cd4f667037309c6339e00d027eb52ac961e23c76c9b0f2cdddeff30b8d9ed077a1c819a1c47fa469221bb182450fe0577766307ec2ef8411b032c04f264b2c4ce0981514d84c33c9002da8d251c727eec982fd643001cbaffdaf8a44c2b4ce1ea403b1228ace8f18f182f6b5fbbaba93bd6b96e8080ed5ba8d0b7489fd0cc031e676d327e208e6b1ac5d31d34a1d6fde98362773731d373a7cc1710cd7663177a4bcd601b1b7d6bac593868cc3ddce2b98585129d9e7303f9ecd9ceba5eb5f299f12fb21378dfdb96eef5d08df3d4cba7a8c034973a904acfd519a753b557109c6d14827bf5269199a16921905144127fa74b6e16f971ba40bd4dc2553b3fef11764d4b59fa1ec36a756ffdf413ba8291c3b11b43e31965ee8cb69eb8cbf513ce3b0b885111c3fbe919723c7b241fc8bca258d450bac0ee186a9f950e9b59e9018eda994a7deefd9a47d13cf3f1ddb30240ed1e294c0498688cdc5a97c807df7405ff68bf8ac05e7a373f3fac6a8457e0bf11d7bdb9597648ce536d5c4677cf520d5819b208021dfe82befe1711f0183e7b29aed6baa0073b3664d2a1e436a638a4f2878c38c11e73da1331da0f3ee45869dc57ed002c5c8ab1d393359df468fe5bde0476eeb55d13e92ce28c6913ad9b489a4a2fee973a041e52e7756b1ead51a49774c047802098196425aba971f370692cb94825a9315ce85f984c76f6a2ee12c091dbf8e983ff6d33042d857e28d00b6f8eb81518ab732e7a73ffd8e869520385c14777460630110cb56cd445c50edcdd41e53da72b9204b378c69ef7727ec281e5579a7ada6727656d08da8b0b361d0dc09a334483a203c4a4d52da1ad3261dc13f8e1835916a53a1e10bdd26651762bde28dd59444ec2d57e23fd43b10d8bc258570cc33e3a8a2850a5c470717aff7421c27896a1104aeb1927b720711c4a2cbb4a65dee5e079173e9107c7eddb8d0485e0c2ac648174a12b8c0b348bc73a1f24294e0ad616db6a90374468115b011f0854284a7c118392d67f2943ea3211470bd5ec9431ca36e2f750a879486a3f9882b7bbae097f02573123533cb18cc72bf3af8ba9224b2df1725ecf89a829601bce8cb94c63ae41fa60bf3e07169e167ee4b449078c5a24df1616b1be4438c8cbc4fc19b499ec37028fe5b3518b25f4de9ec8b6baec08beda830b0e36fd411f6dc1c868ddcf82cc17ca28b6ba46fc66018ffad1652460c27dd5ddcb9df0055620b2c45ef88677ad9a7d4cf924713926494f13d0491a60a86411416f5def9e713c4672dd8bd6cadf2c61552ef038f72c94aefb3575b7e73ac064bb04e6f7c77cd4c9fe868ce84dfd6391584057aefabb670818cd4c57bd730518559a9ff0668fd3aeac4d8928febaee9c4780fdea26e4d587dca54808f1b6e2d195ebfc235d977019cc9db4a39a71bbba90af3275f114e675ee29b403a855247397c9127be09ee2423d55071709f1dc887f01740e8c7bce910af0064fb3152c5874b7cc9c3cca68cdfc4130db3bae6bb72abfe95c8eb028487a9cd36e231d11cbb463d02deae5e82dd7d7765fc1280c6d0d9ade99a465ed1c4d2ccdd1fb191d1074afc952faad9cf592d058cf5936e038c20b3c977e8d403be6a650b511cf28fa88a3f520e8c0a3e8f6f4b13ec1e279694bacae7f7c7d0df6a5f524da99ff14d51bb549cf28d96d83ba225ef2bfe9624eb9ab1dba18cc2b3cd3c92115dfb84fc363172d7251d88e00ce87a54bb2876d1fd58a280300106d475ce7736d949fdd5667a18951c86cc091f12758ea0bbd8ec97a73a8cac305801da58956aaa4348c5ed79bfa6e7b120dd8f35766caf0bd78e76acf0dda360d9f5c19ed70f9c2543a1313ed66d7eca762d8e8cffc034f6fb76f21a284a385c8b289222ee17c85c9fc67abf8c7eff6859d2476ad4fec2058b2715cdcef9da17a96c753e02a39bcbc4cd4ca6e32eb1a4f340af2e619d91bad09dd5ccf0bbabef459e0cbb7d3d2883135cd5643c106058c3446dd54cfc9febe4b86d2436a27e8ffb1e4303441ab83db125f08d835c42d0278ae475a252cf68dd89958c0fd61d03923b4963ebcc7d3ecd97ecfcf9b90177cfc42302274e379291674bf5f77907a1cd0b684a8ad03fe1779a7e93dd406380d8c1edfa80586bd3812b54a8f9384b5128e7dfdddd388f522fb07cd494a972974b7ee8813f6dd4f25a65621b1e2d5d26310f37fe5528956165bf8c4b3d85c652c83d799235f24ad52549779874c936aac421fd0a53078e7d6b6f39ff632206d8a5f43a16ee8f758f4494f6091b067e3ef089637fede94e3837f42f5e94f920b1c1a77a6a82001d953884a61f02a2ec66c6ab1c434b9b5d16c0bb053dba70d31681e19728ac8035999577bb99f0a022a5d99c2b808c20dadc9e5686f7285d7d7f7b298b5595c44fd6958a7915aec2805ad2ca97c006b42a638ad87d33ca107c14efc5a5b6ce925d7a2a6131fec1579e31b179b666327a5b92f4abbd8db19772d9faaa6614163d214b5e79a7ceaf1854dc9f8bad3091884306fefe2844c20908a122e858f0ce4e1ea1606b62750f151d9320cdd74f0d2a8acc4451b2c54e0b2ef429cebbd22f0fb872757702f5eef9b2340e39f117256b28a4545aa45b5fd9cf00231791bf2c4817c2f9ef0ca49e7046c06585775e4b816d2a6bed34e20e9c2b89fb22d44adcb247d119a48ea90bf348aaba24d58b5a3ac5fd13677222b78a3dc6fbe5a5e63517f2155268acf44d2637cceb805a5bf59854a7141269328ee2388eca4ad110b15af6c7ed5cd6fbb2aa5041ca824fc608df623253ff6e4620cae42aa66d846a7fc65d1279c2e86860f831a2e0eee0da8b138fdff4a31ffb4b5dd76f23ec30aedf496579d70c6948255a40d4522dfded288e5dde7e0c817ab4db6b1a4166b0716de33f8280f107fbe8da6989e679dc04af1958bdbed549399b0251e5829a9e47cfe5e9be76cef5e4b66ad86835acbe73411d1b58d63914b43497038994777489f675a48c9d13986a966619a8b53b387f7cd41862812d7be9eacf43c7939fd78a377cb64a899b760ba17f6fe209beafe5445a4f4a43fec9d8a77e9e99994689b1b3c50b0e221838e2b86459a465f261d7f0ba77095d6607947a4bbe10e1ab3f637009df1dcd7e917bf61f4e115e2f2b6e3e7b97b74dc521aff762b69da352b6a4e5c41e9beef5549c1dd5839cc96c99e0c0e90d05e7f85d2367637e10c2320f35ca64abf4cd85c374e6cbe66267f8ef7709608877d094724dce892128d41d1815bf2d8e65d28378761506af6ff1ae30816577a343b739cf65cb9e67fd7e6ab0879ec1ac91ca444cebb888d4cb2b10619f3dbcce4fe600ce59b38d1a3161ab2307884374736155fb855559ae762bef1203bb8c074c93e3f058142e9cc62a00637f4cfe4a6b0c35870dcaec0553a9ea8a9c6b4c7065f5fbee9d1a668fcc3e78e6a62d9bd5e30435cfcce4807087d3eeb49d109a9cb6a51fd8c8874934a2ba90838b8a3bb168253f325fde5aae09441a25f816741257ab31cb15ff8c7e1a48af29b0320384b831d874b6be50ca4a2593ac2987f27027289f88968503ecfd596c9b348843ef88d445ffaadb8dea104503c377058d79c9d64f6105d8ce363ff75cbd9470feb7c6e68ca078ffc3e3d0533ba0b71538447393f9908b21660a6c07d7584ddb1853e06381772a094c8354cf6954cd40f64828e1af303953ea860ab49159ce0fffc513c6e4cf49b92707f77b8c3bf5a9a022adf2b9002b98d607bd72d659744d613f1ae8159995069688aab68dcbd8ddf5e0d8b5928531dac2cfea86277291db0a45c71decfdbde36d14be8f250ae3c412c123bf5aefa919d740fdd0f60e6a29a8937d233b087a86db32aab9e19b4d9795fe1ade7a651b966f41c79c5e2a222aaf8b64bdc36d59001d024763342b86c1882fff4245bfb90f5be59dabd567da95d52aa2719922d85c7f6938d03cab543fab35f2aefd144711227f9f28f0fef2b283debe3fb07c973cc0fa93dc873004c591f882be624e539e4f0a3188f9eae5d6a449b5e47d2dce15cf054bb1dff11e1d64f4a836fcb065a479f17c1307696b372506a471d72e4a1b18b42d2341290f53b5a28cb96dca672f7dce26ded12874fec6eec2e9dbca1e1b6ba5eb7f40d28ecfdf6eabe3726abe644f84fdacb2b73964d3a7aed916fe2ff8e130d902674de11f718c090d3e28c6e275ee6e359c135b6fb7b6ac3fcdbe8bb5a60b16444000acec44a5eb4dae1954c98005daae750184b300b355e31ea2505f35df662dc502abb2d6dd4b9991b96e1fc6a18557807220a554f2dfefd390c6d0ff8a9e11ea349ba8ae7cc94a98146cf852379e5fd370ad57448772ce07c697c51985896588f6d3ad1bc6b52558def395df120547a12c3a7064ad89d20dbfaa99d47129d60b59e662e4b62ec69a26986efbca4175f70b58edbecbc17b92551b19f36d66f19de7505e1593c0bb5949a0600993d41d667acc62304bd1a88d84bd788412f82616ae524580043b1800be26079c3ebc537b8efca8ffc3e696dbe9b5991f7e58553e6d571710a124f130dba7c57dff262c606200ca92b15d7cdce5187b12bf4be97e87ee2348bd454c7ca2b1d6af37206fe6b328e0129e28bbbea03f5511f52f1ad65b7ef62690c0b895804c83a190ae47e5adb0c28ac6216b2ee4a8a1e6de67b6d95c526ccdb5f0287becf343973e6d72407ed02a0fc26014e79eb4fc427e9bdcde607f148cb606598056730884cdcb2b169482255438b339edb68e1f7649027ac986e705e2a49b23808e0252ad6ef6c37039af792ce46c31608554750938f369335057a45c6fc75e99ed7ecf7e9df4a16e27a48c1214fbe8e05369f3b134ae1f3de5a8ee96a619a7bf4327a2a9ea1f6e1367a523c2af7b206997cdd63dc59ee568f8a05ffaa40b4e62f4f7c832041f6a8b039b636c73334eb3bab898c27f5b6118926473e33a8014eaa2f3d482d645e7d66dbdf8c130a8a9ed8bdf54b9c9195cc9ea9c7d3af31cfc55e685d56c3c77488789a2ca993b30f61a662ca9d143779507d1f39347204a5780449f1f5aa31a809cc72a6f5ee0b76d16cd8d9015bcedb258820feb47fac14380691254143b2d23ea133ba842071d1e19ca60a0029e5323078f9af31136312762ae39c9b74b5870b8e80ad647a7c68af7aeb44c9b5fd4261e29cd8bfb14f8db32fd1d7ea2c6994e5a67579b0aa0cafb9f4d9fe43efc9cd548b744c076ed352d649059c4eb8045c5e156e05dfd83f7d21a078d4d6535af6c30f221dfdd856d2bab6c9ff07594b726c02b01a04997c46aba0b2d682f3d054ce67e1b7bbbc7439e9ec2c080ef3ddccce0199cb35a6955ead110467fa3af3e8c98f8f4da7908f444e9f11d695033525934774b1b7565ce8a63ece313e54dceeec9354838babf2b25ee2992578a1c19e09ab4952c7d78af91803f9432fbb4521f3c5b6fe39d85010c7932f26e759bed7460b05123ec6c56684b15347757ad3d471a8f86d1f99887e5216bdf84f59e782a3f7e0757e4c9845ba0c35356b65d0ac2d96c722f20b8715dc4882e881bcd9f989f8b2fcf9b0a8f61ade2b32d3767a4102e6977660b76b3501c7e9c6b57c49d199167cab4f487940aa42988f8800c6f6f7ad53c47768476d363d167ac50d60dc8a2f0f710622c402e228ce746f077b9fec420fc4f6a4535a9235dfe9ccdfa5b9a7c1bf556e69af7dca0716bc003023d2953e41c80591d87b88c204bd4b08a0825fe242897f91f4e400d10010e0e4065c25da4ef9e1b312d463a5a12298561815e834fe05b27e86357bf7f6302e1955f94b435bebe48acfe5910e32d9f84009f177d6d3160a3638dbfc2e2dd4f1fa855b5d20f9998bde470b891ff94f87f38780bb578eacc174371fd71512374e790640787d857a4a6d908bcfbae3ec1ae351507ff1a92214ca7f13c5aa23464967e303171f67d2041fc9326156b16a7398518d573d6ec1f0998328071f2f284bd58089643eb364e49ce29ea7b1ea661ad611c7b6437f4a79ddd3f254b3ffddf92669c78e41d9302215962b6875e398193beb0f2b67dc2ddaa404f748c9975601fe9c4c82e3f26f757a8c74fe2e9bf769c3fa85bc8a2ad375c4577b37ecda50bbdced9976cfd5b652ee50a86a7dda0b726a4ab5c8c6ad13ed7c36ee984e4bddc1a8d11d3c126e8fdd506f586b173c9c3073a39c2016ab2187806f074a98c542c8f4110e8c5417dc479aa305f6116b869fc4177c0950ff44cc555068d78809cf0ad056b3fbb361c7f2067828fb45853aff0aca7eb64597dbdc31bc499b3b4df963fa398b7e9a5da2e6ba55571c3b52fb68cbabede15cb60de8b4af6334f0846543bcc701e8f0b6fcc0916516f1cdc6d3bc960fd48f538d5af249f1c4215686f07e1355f6162b8e1a8b75601e86f04e9a026f18b00c97641edac359785ef9820c1d77d6ebe61100c0a9e7c3867e8d4dbf692a0010d8c78e88d69c6318bb4b09b36447110707bac307fd626176d6c86c6c82d3be948d1703485b3d2eccd76081bef461e5b6197b2a3dee044cedacd01cf098de3a63add0c162936f710d174e081b256c2841853ffe364a2b3de6cada898efcd7f49b9c02e1d354eee97f213b531c5991ed7c078fcc9b13c7f90e0782b23bea286fe4668c324e3c1826aa31e9b4a21c8517bb9eb8308eadb46a78834b31b3d8f62c4b5f3aa056b190195783ec67e2da6b7b95ddc694ed84498718e9a80c1cf296c817e1b4a8643825d1af624fefb9bb1d8e99aa2ac1fa88a979231f7348cab98a4f585f13b9fc1102a529532e4d0bf1c2492fbb574e0a1c9ac569a7846fd97d73b36397976eb804f1cab438c349ce92a6b61ef50fd74e78a9d4313a285c159b4811a5c71c8668b21b4fe826b887cb7e0fb18f5454b00cb588ad4120a563a34aced939dac83ef109024622a412e5e80f2c24f28108ecc040f2d08b4d9f429d7d17288282256dc66b3bd564f1e8527e032e635f792e68fc4813d3175a44e2d8679674a75a2b5f2b511386cd7069c0f2a0974c6cc6fc709e3be80c321192fd6002aefddc3aef736fc7be597c6efb328a827b6b9fac04c5a1412fcce80d9921643ad950dbff994bd1974200d66a7514e3d0b6b30de607cfc4a07ca31d5dfc4f53dff627eb3d1abff8ac90ad375571b1dd5bcd1fe97116880df270bf9bb81e4f703fff4e6579020183cc05a65a8533fd46c1985a8e91a3d1df772e49290975b4eaf169bf713952d44629a5ca42fbf70a6d522a9cb53aa4307bd7444f672580393275e1d5fcc412815ee49fc0739873b54829fc0d9232e731afd4ed3ba4a3ba70fd1de02de69a14ada1a8d8f39c0f266e4943d921291e6f5c73360b3b4a540b19543e30216451c41c59d92b1230a3c9c92abacd64fd3da1bcc0b7e6891e1d5aba0a826a93a6582c61f7f9a52b1cde7e4bd4543685bf7edd19036bd0d47df6cde7da435ad68fa190194e0450cdf072eedc9f93b2dd6e3cec09a97ab34b2745fc94a493a63c32fb0a7e5a127244825c9e3822c4ff099a7105129b214c4058897e76a9100cc7ffed3c3a09994ce1c56b0624425a6b31be17cbd088dc082f26fe3904adf44fc67621884f210bfbd24ea936621d182a45df3fed6e1c61c34d400f82d157beace2bcf1516425f409c63be0df5f6a04092e1a74a5b56274be2fb3801aa5e51763374a265dabaeb37f3c367e293a98599ac87187104c04799a1c519e2e46a23335aface468b6e7b9d91692c23100b003491cb4ad3ae7ef95af9dd531a373c8f268beefdec811080d44a09755832aca07a475f99cb708b79ef922212109568b95fec0bc6bca60d187a341b3e0b1f341380f17526af7bd5bcc45d5592d07dd40c671584f0f7df60b33527796a6b7242c52d035c3f901cdd8233faeaaf472e32922decb5f046eb691a492c0be4a561213ee044d6c3a46afd46563b2998d9b529d98b459ef797ed7d0f0f69529a5850b833f9897e8274b931ec96e1369254b4bafc119cbc11fbb1036b555fcc255c24c5626d865b885b5f8e12bf60f8b6aaa5fdb539f08a19c622bbb160913fbef6fcac60b0e2558cb822cd3f9e64768d0b154ee77e73f366d68dbaffeba3bc81fee335a72d1f2a203f0fdc098a78b2282ff973f3ac6d068a6606e35e86952f92308f423ef5187f3cfa0e0c9370870e050ac6a00cf120763042869c30306ddc5eb9b2655b3d3071e98535e8f49ccd409a18f7dc0767b7e290e39bded94e90318cdb1576e1208babe82ab3f40b0a4e137a461be7d36</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第一周总结(4/1 - 4/7)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>美好的每一天～不连续存在～</title>
    <link href="https://blog.phbeats.cn/posts/ca2f7778875d/"/>
    <id>https://blog.phbeats.cn/posts/ca2f7778875d/</id>
    <published>2024-03-19T14:53:45.000Z</published>
    <updated>2024-04-05T12:13:13.392Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5d893d3309874d9dc871523aa756d908ad221fb8d2a337f96e383ce33cee4680">e673c8ca06aefc9fd566f76e908c7073bf122394db4047bcd924ce9ea37328240a38cdea58412a376dfb2c4084c8672e19e7fec2a499cc6cfafe0f544c575fc22968d157ace4fc995bc36c6fc521fa9124d0e79762ed71cfa3cbcfcd4f2370559b60818db7bb6248fa9ec9043fefa6dd542fad9625b40ee414f98f8b4d4229f43045d6de6524382334aa4bed97a16c7bc05e200ebf0b391e85dd57d31d13a06bce177e062841c4bb1b41ab134bc77b3f70b96877878da8e45570bc5c4ee08c33ad15d85aee225e68d757cf0aac34fe97b285f3215fbf412a760af5f6f3691597d84ad90fda5219954d39ea8b1e3644a3240473aaf12cd8cf5aed44a9fe285f0c4207a2772aa01f08ef95291a83d3b0eabe0f6ad0e1ae7a23e6ef964e46f8eb8ed46a8e5c2ae3a3c780cc8ab09d94cf1cb6195cbc0489e14bd2f9ee4863ff555244fda4fe3a65be8fd19f23892a7fe1c8ecb04b6348ba842687d71ddd21456506718cb68994c50b19946737e56a1d0489649d5b15fe3f02639a4bfdb432b111bc7cf3593ac49ab49886c252d62d4d2f54a19cb18bd9a0b28fb89a9891b679cdd2693f8e8c129a53eb5ec1b9f2d33f2c8824f4e9cd870abe7ca2aac942d1118ee7ce0c27f79c5b3629cf0ab9219a52fa209b52ba4aad6af95aac24d6f56fd33ed14b04453498d782395ff5b2b93ba5f45a1e32398aeffeeffbd03fbabd58b079fe1d1ccb6be2dd3cb2590438d42256c6e4fb4a558a72582cc0f05253116d6b494b98bc165fe6dbae9212bc1401d0229d4e9d0ca4610c2fd6acaad1de300846d215bfc72ce50c8228081235ba8b3a3bc70bda5b380c0bdd728c3e1e9325c6699354524eeca4bf58819b11f200d98f183411dc236030cbc2404ae0d1dc99eb3d559cb6f10818f7b5939cb0ca8984afc5cfa8c0d76b10ba53898ca567f69d6ae36ff666d0ef2e4f0712c4f35f212e5169804774a618d6d703150f7fe46dce77b67aa6fbc7d211ca34476e8417e2f475dc04d18af0c4e956522b8e1d3849ae0f61c2fd586d6de11cdba44563f40ac8f5d672f433664526571bebfbbfec29cc15ce3d99732dbaf3c7c9ad582e1ccbd5fcd4f56782f6fa7ce9b27f4278168615fa9deb18c695db7a811d540163ba1ac95dc5ac6b295484b9b36db403764f9d3da60eeb897cc34a382a951861a5f332942e154c7cc6aeeab1aabbaa844492ba828f41846f7473accab0ede2ec57fe4671abcea4af076abdb200673ce23fdc53eae1badf7181490e19bfe80b61fc96eb72a44c2a5c242b17d6f9bf7d18e6b3eade8b2dba36411ec5b1b53fe6527013a26055e6debb33cc623454471bf55ea73a58e02ef1ee0bdeda0627a009a7c0793c8c601de92d8164d884df5257037c1758bd3dd7af875db2f1e0f2b6b893d1312da0617bcaca088ee3066f40deec20a2bfd0615fe7c020b49957b7e1c19f21228d0ea4805163a4263962f0a5c1808582e88aa2225d0bdf4c32eb23b9c3fe7cc62bb457820bdbcadc59808d9f4330fa3c0d162ddd17e56263512de4ae83de03c405bee19d23cf746140c286f8487c7128e47a6da914e56ccc320f2a6f0a91dc3e59ba9000afd25b8ef0b068f5e0ee2b1428217d84ca8f7ec80c306bd2101f58d26f5257ac202bb41f29f17f793dcf24cad481bf832eb526fd5fc52070193fab29bbd7598107288781f1c7f99efc66fe41c93166589380b8eafc01fea33f4e5fc4bf6b451d610ae7f428b089461b707dab20967ab009c8ee146d82304091c304950b937b023f426a83b3a571e9f1cea15dfce4d759f9a0760c1f17f3d58b56312d83a42ece10ee4fb23e47e968c1c91bcb8c0bfc13d80afc928d81860df2b4c2d7cc707e9aec836e67b9ef843c2b4798424e5511fe693f14a3c35748a1c66287d9e178bf075627b97c7667e44333bc166630720694835bd801d3c49ee4638ead95e882ddaf8bf53842dd98ae9cd6b33410d394205529ae76345eb1ebc250b400faae5095b84d0309bfd77efd0035631e16297030d82aab47d8518a26fb23a676a56d2ded1bedc745eb40fbe7c2519084ba9d00b161d027a435a8b2e2b166b3721fd54f717f7d865c69bba5619edd74326a81ae06afbd3bc0f15844c52e6a8b7eb778a229d2b6f94fda580e0168144bc1c969a95c7c9f796dcaa5530bb14fd033bc6f13329f93c489b9609cbeec967cbc90a9b144a4f7d7f694daafc18a80215528bd1acf9f507ace00a21ccad7a56493610d6f3ec8a14c64c642f759d448789b6b8e6ac67071749bb6f88379e1066d5f8130c73f52e48356e49bacfb7505408545b8f2e9660d61f3fbbe195cfb12839e6ff136d84fd09d36be050b3c8455131e877807e5217a133bdee12b39a326759227542ebc0240913fa20cc23a48f335748f863f916ea253183ced3ae84068976330e95430f8f5ca7f3dde01875c6e2ca1481356c713db8ef633fc6f875bde045431a653904d57e3b5b2b1cb519d883554515f1178b89048fb99c85f8a28d2ff84029505cf47ad3d222c3b8e474e498421f01f6dba043419411429dde8d032993cbb266a87569ee3bdc35d3194157e7f2921c5ab2993f9901cc46e126232ae15edeec2ec1acab3a727e459525131a33f5975b307b67298e5c2214e259450339a065988adc3437ecb529d7964fa0d4b94313693944406422876143f68899ccf492021406172742ff5c476f3cf288318017e1b63322b93e9299f015109c873fd54ede705160f30074720ce9db22de289a000582dd02517165477926e5d43e5f1f70b5efa9887b56ba7fe4189d0495601d62b4c4990ba00e4688f2952fbd1dc95b9b8bc736b2bd923a87f2aea9b5286667933b0b3281c4fe2408208ed1d6c089535d524c5cdb890541e4b94d674657770bc80fbbfef071a63aa1ed80947cc7e2b18832b3a87c27e56f1dc43b717a17bfd85835601ff46b236d53fe25e22bbcc8f962ef15a09b1e25b812d4ddb258de49ad22212e1148515068d64272925aacbdda388e470963a12a6c893aca328e75518810bcea52aabdceaa0be3de7ca50d3fecfccccb10e92c8c7ab5c1c363db000181075504f323b2fccab63549e22e8224551d79ee74f24a9d6f54635799712051707529f98e2527fe61e5f503f4445a3654070e6616b5ce654691761ffcc13157c9db5c2fb2e891bc370f33c39d78c7ec7f4f88c7fde41082f41995a33f7476c042baed56e1475544b3659ae9856071ec54c8af8827bbb8a9b9d9c68b6e9f7e0fca00790268499c30e2d88376a9c5940decca1f8b106326302f99131549bdf4e4abcc8a2a182aaa80adb92e12df5e205e6c143cea8be921742e711002a10a0c5baa321a2cff7f6e0c32ae216259a62ddc2593d14d39538fd99c2baa6fc31dbeafed2625e716b2ddacbc673ec2c011004f331cd023d6eea571e2a6867470c4754f344fdd733ea15460dae6f35bc169f14903327b400ff817eac220c480beed9548f00fbd36009395a9eac5589b373da906b0cef40d1bf254db51b734d16a539069940f4f04980439404880cdee2c6d7403e0316906e29abd30ee3b60402c6f83885a14b0a851b007a9401d61d1ae7e490d53244ad1d5e8349bc9243fc278a7e15f3f798bf84e5ef2d89a4eb9b45188319eb1b360e8b6ad5258017f632021356079b170dbedba062078a14861343b87f28cd4edc51035ece6c55080edd02674b0dee8bfa8719a2f77be8c533ddbaea2e9227b8851d1ea2e905d0f9b9c2fbce913fbdfd30554e65fb8f5ec3639ae3683ee38d33404517ba5bf5d2da8e20daa5536372efef1028e8eff07397055d293e2ca674fe66ab73544e11b19f3b991df5913d28c9bd046302576037d65730ef6edeadd452e82a4ed92a44549e3aa020558d1c7b66ba7cec2d35b6a31fdc797a8c5c3de4195382a35afd259aa350f87977669b09d08c2e9e88feb63713491d071bfa2f34290493b3a02bcf2053bc1489fd9130dbdc768da45473fe379e25b4a3b869bbb97aa8dead2a63632c59c466b864e547c97f2e42c663dd3c1fa5af2322a267d9b79f1403c206f247730cd13bc0db2107a5bce777f18172a43a8a4e5afc471ccb0f7439b210d51fe10381c808decbcfefc8dd9fba7fc3a039e002623859a21c262587907a1215057cbe0ec465ba93c4b6e62154571381d8ac759eb03e7441f8b9f338d35daea43831a661beebe5927568d6eb72c6da3dba83a74ab0129619840e8ce4b54b9d20963c6643b9788e97a0e277406ffa7c3413ba9eeea876f091f6e57564895e84c38922d3aadde45bb919bdb06cb1524c8286d0729da8bc4bd1d4a569e02ab9a7a5a1e0fca14d39af9c339e8c6cc35ba982798c72da17e869870264fbeb8e1bee3e5070ad44ea78e0d183e0e50ced0aa6d4b517c548cfdd59b97308082363a7895c68567f53fc255afcc917b4b3a859c1a901c2df9812644352938091aa0976e79be0431105e1228a156f283ac6c038aac9c7ac87a77426b35aa3ef5194e8758ca7d7e6dac85b89b5fa2ddc1d51b9655b0e795e14d91ef7303945b51d09444376db672cc4471d34b1394d9b9021ef84200e83a922a6411d44d9df0a8e0df03bb962453cfdfe40b8aab9e6e1a61472f0630fcced8eb7e4d9ffb13c8891f3f7a8204653d1fa30e5b14e850806ef98b4071b6a7930b711a769f5988cba12a618d3cf56cd93719e502480ec117be84f6858bf63b0b3039e2fd7d07dba135784242d342570ec5eb225df0186df871f3022e91cb63211e5013add618af7363871a6b1a709186f0b6cfe2408763527249a8949981ba1ecc7c0fd865fead0d75b59c1107dd2c3dd8318ebc474342a0fa6fca7c5f15fc816de61d71d41190fa7a23faf2f0b7a0966e9b049fe4f99a3d4ff2c958eb18a19fd0a651dfc27638ec81cf444ecd7f403061f47f88e148494a21ae56b15fbb430f489fc7bf29b4afb6bdc36ff3a4e59cf603c11ac328ddb4e06e9b37d3bd8828109a406bc283e28a766593d78e99b70a668416deb1a95d74b6af9190ba179d1e4b1b46bd05089cb7e83edd65064e8832c521bbd8198b91d5c08b714121a715f52c6215bdcdcbcf74ec7b9a40a3d61cd6cbc5006355dbdf22f86f20e7404c8f7412d76369de09b156ccc71486a47de826f9a0a5776ce22e2079ba9af7641dedca77215673d47d163c6a315cb0a4f3cba26b584f906a6ce212c0b82bf5a3a5a34102fba6ce49e165777827d1b46ffce868d9447820773d8f3cf38b99aece709861fdd03953e96eca29fb7e25f6fac21f79d06f8a4e5d7f30c5102cebc0f3b55c5d18deb56c3054bcc53f0b3417020649c9dc291773f766c75b6f4f55f464dd199d8e1311f4f58977a0de7ee9aabdf0405f6f490717a1662a89ef9476978d6ef64476f9ce1cb01baec9e9f4c884bb39478ff2af89af0fe1cbdc5b1e7a1817627074da4428128d22bd9a53cc066d398e6528aba80cdc65c344e4638a3aa610b801ee059ccbbe9327336e6ebded3a36ae0ff5bd43d4732e70ff92cb76591eabbbfee3e0b327394d4b021901afe2859c02e774e4a1497dda750d4a59c851a34958d0a8407df60ae458011fc30e1c571f45a88a784bd651ef5b6f44242c15f218976491fe4be4674ab1e9f334bd5d92767f6679245f2a4290b993d9425fffc40c593a4f58f1f6cd81f71003e122c426c92865645341ea3c2224297b55c223f667c203a7323936beb6334016791af5b5977a44b9c9d6a1ee5890719e0993314a6d17007bfd9683ca86ae8bf7905cfbacf1b110a261fbe03c7e791a7a23e3a1f4b381c7c195d1f4d294311ee230315fa93e79d74804d52e95e65274a4b24fd4c2fa555d62d8765f3b8c1aac9b49cfe19f37d3ee0841ddc5f00d8e34533ab1e38883c60bcd4b7002da224091f877ab7c3dba719f90d27cf8db497f316964592690931731ad7d34ea9cb79f69694c6a4d9daeccb6366e6c2ca451ab542eafc3ba3ab49e4710e5a69297ca35dde21460cc23d5383d660a02e2587ae02eba5bce3375d56cb11a0f920f0c86425bcf80e342bc97715064c98042361d2f184be255011b36fe8ead3e6b2c2da928e8d4779e8577f87d42e30ab6b114de7c5748e3ff4221da819db746d8827d62c9a9ba26cfd389ab985c97ffcd4091df46ea2e4f20d8f2a5c40aed5b090400286a180f8a8a9096a447544782a529502acd0ab285c80132a45c9d5aff7674d9d40ec4c7ed3df45aff01e27b3c7c02cba072b3701ce0d5668a5ff747434f0493e2ac05135b7b21264fd4f9ea00da8fe8a2adcc2c020e760d2e69b8b1b7423d6342aedfa7c4f6cbf08959781a98caf38b3309ce523994479691a0cd7dc5084c0e5554188e9ec169648f47db8fea21e12df4a19ccfcad45f8454d9883ffdead0f7ac196aeb826d55f3d8ac8d5f9ed1169613d63b97cdcb25573c4b7f040c4c96cffb90a6919620e1d9a61b681bdb6374b4a251762c4902b9e563b605b995420c438ef37aa2f93635226200e167a282277e1debfb0fba55c7059f8d9d3a150430cab7ea7f946cdc06bb0e6a2a6c27b91bbb58126bedc4f7f1b48316d78955624cb55df7c1a01a304f34186134db298a53466e25d2e093f1b1302e036a54282984089be2c26e03023af3be633256577f4b0432d49070ca912768095c27d08185ccd4564896fed1b11b2a35e7f5c677dd4e8d8d44ba71873fee2d00644bca21d42e6459a3bc3319865542400d1b03eb4ec9d5d1eba21d9b5c86e6e9d20944c8d58649328349032fd527358ddb74cd730c6071d0ad238455ead4eff10a8f7fa30e9c164bf3afa535189ddcec87805b63d7fd33b064bf25ac6644a04ee80155cc5c2ede9b2f181b3a31d51c337ac9ac332a7e740dd90fa8f33f752fbd602a817e02fc4ee2f71681e266dd9b9b6288d47314e1c748bd43c755d6cad0ea09eb6360aee4a7311cba5bf4883501cf95152235210b8f255e4dc21e3b9fa4553debc479dba1754d8a051725c43c400c8ddf94be3b8184ec20485f21f09a8273b4a4a8651908c6062403cae22fc76507c1a2ea0d1c262951bb22b0f3a07719127e3d30c47c2fc4de53e07562d88219c85f1bc167e808ba370d89e1aa4bf88c14ba02d682d4c4c0ced58ca93147833c1b61ae02e87f75034f03bb7d1f00db08ca9f2c755f6a18826d61b110d5f1674cad7876a9038cf493228245e987082f0cb77de2f36cf257762b6b6b59ce58c13c67d1f33b3b4386f4489e9ebcdf06ed300cb41bcfccc24cae3c402b7563ca4ff1f56e051bf30d63482760f0b2cacc2f0340b1e24e34ebce976e95dec65b0f74ff8aea2bc24b72a574ed382d94c30a0374dc7e350f75669d47f4a538ef5747dd4b88bbeb21deff566f7b8d1f0ee2b7457876b00bc8b8c45a14348892d13643ba094ad054970f6028c5807942ae2b9f7789064191410602c41b886a2cbb3bb2233060e88c1142185cf466d04f96e14649de1dd0f292325026b218aa814898699188b25a75db6b51551b19566b66080022aafb389c91a016e27cb8d4b22ff6c4f8c1d7ff9b36ff2504c1a04a7dfc0e325cb3dea1345881390906b053289bf6e15a8f1fe43f9a395d320be25ea4101dc135809f28c17b75a31b14a186f1a4381c6d4d0284e79733fabf4cf6dd4055b90ebd1c8230b2fe4b540280cc21ab05925a49802602986d6fdc6aa5d94ed9b12d296e028c3890cbc64d293227c11cbc24d3219ee36ee8d7bf159306c6c7d23c523dfba47d9b91256dc8382731540fdc8192cc418b9a5b8e9972d0fda8f23b719b198f2affcc03f58a516e5bee473e6788d18a17b22865d4491fb8b7d34716390fd9b238fc51881b2f31dd5ddc64909d9dc3caaec00bd768100ab045c51511f20dee9a8c67684ee9635a5035bd6959e0a009537658b10d86d9fc997da36fd72836bcb55c70926add4543c739c7b04994e4c6a656839597da82b5141d4b7b673316b7a77404202ff2f7c9d375c1d850d351e0f5392dea9dd4e2fa70a4884f9557676f219ea043773958c43276867e7f2fdd15cd9b8050abd043ef425999a2a416559bde3625cdd17ba82340d42a35386f887e4a92572da8c676006f5226a82249a95dcccab276c07f339bd980eafb840c78a71d8a599493760848ddc6e97b6f489e4045c51d9dd1dd89a37727f76012e8f65094eb8b15a024c11ee513e576e34b00cb952c5d87c9cf36dd4ccb2f108907d942f86466ce6cf9edcdc22e004c51a6aa967a26d89e868fa93f3eaaee7c4336b2301c8ee7b6d016594a47f6bb842e218cc03fac50b65c6f7e31da917a84ca0f5e07ed8f782ff4c77529b7cba9a70a236c6ebcf00584c0654f3ef6ce9deaafb3fffe3bb66dd2b52988d3b2907bed4ddb194d62f2126d907fea4da793759f1366dc3b40e55c563b632702a440dc412a0a4f6b7e9ba6bad4b6795ccbbf3461eddc6e5695edba89767a1c0667bcf01efb314fa712a42bd57ae4e037b60d60f39411571f350df2418cf801f915da26a15006118b13ca3bf195676c13dad38b0bd45e19c9eeea6ec2c152cfe4a9ca49deb77d33a3038aa1c78ebfa4f2f54f1286aac9d23b6ca40756edce5bafbaba826f1d6495005be37636862c1671bd47e3c87208d7371d79f02cbb567add173bbc3dc986c69dd49183478060f515f6f49b783316aba979be97a5d314d73df8cf145803eaf6e93920b84a5fe4c8d5b69300205dda1cb5619fb1ea81bce6d71349de5b9c1a547158357a813eb9e7ef570fa69318ee8e1acae522ad9295198a31db52f4614eee8a30e2c60e32f607e9df03c0d9a3b0600c79d2cf89904894363a8bb948b415d015fbbcbb37daeb556b6ab4a2f1ad0904a9a6113751bb62e9d19780f8a64df062a84794b63ec76fe4dc02e8fda927e2be3a75919a257d826773beddc8093fd91a7ecc72af791ec47008e3255d66e958c794a5d574e5f4e9d582ed4025350e0ebcca03ef33674d58e85475332c81d7cbe6ea3d458064d5b96b2149911c66e8970a5db08ec8c61ebbf19c692a4e64ec86b8d7d46121b9ab1252c07ad2f8d2eb2840783586822120a7be2d93e7a9d3da06c4731d93ae78e9efdf88e716a07ab31e7c494b81c6ed12f8b275c270a71f2f742f722ec43164d862a2f384d239d8a24321ebfdccf0b0b58c3e3919b7039712b52afaa1ca7a64db956eb6b330ea0cff869c6075d49aabedf6e4399aa2712f2a3aa6d70c5dd0d30d8db8376ee8e6a7c1c923a0bf0d50fae00ee0bdd3c027fa3a7b3c422cbf92600029a85fbc6131a926a323bea59fe47e62082fcc0ac282c2ddf31488a820ccc530fc5d91f6e6a4be12e9daa7fae8b2ca5aeff2fad1eac5e2ce363696c94ed4e572e541e8e19662732cc99228c786cc39c718a4317dc9ac7dd07ef394c1acff8a6c784fd7f051bfb629201526912e7e9dab33e66193431566f3c267612d5ffac2a18af3e42af7e5e3c2e4900b484df2c8814cdae17de55c0e3f5ff18d2c30a167b54f1e37f66bcb5c75633e95b483d6059793b34eed6920f1bcb3b2e975e8e10114df3763e50cc09d74e09d53cc480386d531f3646e7111b9c63a38d5a0539c8038c6a814848091d303d48846d11a4aa5c01878ffa99908dd18627c4c1ba74646560f71c621967a4f1a8a3573f55e7fb2f67c26c598f65bcfbfd8989e6df7c0d477fcea404ae11f83aa3aad39b90df76cc4d34b308a30f0e5704843806d32fcdd200ba88cb2a44f03c406ff6b0d00526ff0e2ef76afaec360da1eab5221395dcfe7394df720a54d13b3c5d60d326da818bc3fdf2fd26e11d8b3ad2aa41453cd43455eb68c00d3b902926a209a1ba2397e1ef78799478a1610c02317e47ccc2a6ad94112c546d34635fd65e5caf5767575127d0f3869f89d4e300d1be84c17593ceae0719e0732637cf3e7a08af6e47fb0099ef36dde8833e51e01bbd36fbdc4327ab6a055e9eba0484574938a6caedab886e08debd788d7523b319c955c0508c884e62f273653e05981632cd31a87bacc443c77a8694caad02de4a2b25120d44479fe316e9ef08d4501fd0ec8110e7b5a150f34bfe738881ca437818638f6881ec345072634bdabe2c270b517b265a29d68bdb80bd70407efe4fbbe14a4caceaddf51169e703cd8bde5625f31a9bafc2d295c7a3808b0c02eaa7ae1a5d4c317fad27cdbb2fc4261c79a4b3b1fbcaf3e6923c79e4568a5dae5310a0e2aaf02c5c127cedc7a536161cab4d74354c1fa4a1ad630375be9d74a8fc8fc29ef5ee361fe0d83419d6d1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">美好的每一天～不连续存在～</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>周志汇总</title>
    <link href="https://blog.phbeats.cn/posts/acdb8d5c9b7b/"/>
    <id>https://blog.phbeats.cn/posts/acdb8d5c9b7b/</id>
    <published>2024-03-19T14:37:12.000Z</published>
    <updated>2024-04-05T12:13:13.396Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ccb101d680da5d138bca0c1ff12f39a013e8cd0532e1d22595195e4f1bbae3a3">e673c8ca06aefc9fd566f76e908c7073bf122394db4047bcd924ce9ea3732824180a4f1db344e311487ba241f1b16c4587f75b861f83fe634c4c300b5ce9c13f6ab2dc51be3173e872c5b9303aab66b98f2d10c9186f542c60bdf6e9e018902100efec3c9b0d9e25eb662a6738083cac0144094eaf56dff4f3d0dac07a1d8fde55b12b81cafe45e830d294450db7709fb63d8646cd7dbfc68602c1aa7bd817e8af19f77f37b3a9914120c5cb5b0f50da53c2241e20617cb37b4d39a1119beb3e073a03515b4a5930f95ae2a3fcf3e482c62a96ff08658ef5f572c32442201c12f96576e6b29cddc71ec72e7ca496a5ed9674904c3ddfb4040e37bd0457a3a51e7b885dc33f80ae91af49c6cfe9ad3576d9cd6d90c341d4b1473f006a8219a96cb109b928364ee5ea8a84eb1df1aa43f86f1a449ac8807a6cd5d14028ff1a150b0647f7bd953905b24c4ac42666bb5aaa1ae35080c1722039bee56539d157a787</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">周志汇总</summary>
    
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/tags/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>图-基于邻接表实现</title>
    <link href="https://blog.phbeats.cn/posts/de48a254d011/"/>
    <id>https://blog.phbeats.cn/posts/de48a254d011/</id>
    <published>2023-10-28T06:30:33.000Z</published>
    <updated>2024-04-05T12:13:13.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>使用<code>邻接表</code>作为我的<code>图论算法</code>的基本模板。</p><p><code>图论算法</code>可以使用<code>邻接表</code>和<code>邻接矩阵</code>来作为地基。<br>我选择王道书上的邻接表作为我的模板原因有：</p><ol><li>若要使用<code>邻接矩阵</code>，我有 y 总 的模板。并且也契合，因为可以使用一个<code>二维数组</code>来简化类似邻接矩阵</li><li>我如果是出题人，要指定数据类型，我会选择邻接表，因为考生肯定会优先选择二维数组。</li></ol><h3 id="邻接表的类型描述"><a href="#邻接表的类型描述" class="headerlink" title="邻接表的类型描述"></a>邻接表的类型描述</h3><wavy>我似乎理解错《数据结构》这门考试科目的含义了。它应该重视的是理论，而不是代码的实现，我花费了大量的时间在代码上，这是错误的！因此我打算停更...</wavy>]]></content>
    
    
    <summary type="html">图-基于邻接表实现</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://blog.phbeats.cn/posts/00977ebe8687/"/>
    <id>https://blog.phbeats.cn/posts/00977ebe8687/</id>
    <published>2023-10-27T09:10:02.000Z</published>
    <updated>2024-04-05T12:13:13.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>使用<code>链式存储</code>。</p><p>因为书上的大题使用的都是<code>链式存储</code>。所以我也采取这样的方式，作为我的算法模板。</p><h3 id="二叉树的类型描述"><a href="#二叉树的类型描述" class="headerlink" title="二叉树的类型描述"></a>二叉树的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br><span class="hljs-type">int</span> data; <span class="hljs-comment">// 数据域</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> * lchild, * rchild; <span class="hljs-comment">// 左、右孩子指针</span><br>&#125;BiTNode, * BiTree;<br></code></pre></td></tr></table></figure><h3 id="先序递归建树"><a href="#先序递归建树" class="headerlink" title="先序递归建树"></a>先序递归建树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序递归建树</span><br><span class="hljs-function">BiTree <span class="hljs-title">CreateBiTree</span><span class="hljs-params">()</span></span>&#123;<br>BiTNode * root = (BiTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br><span class="hljs-type">int</span> ch;<br>cin &gt;&gt; ch;<br><br><span class="hljs-keyword">if</span>(ch == <span class="hljs-number">-1</span>)&#123;<br>root = <span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>root -&gt; data = ch;<br>root -&gt; lchild = <span class="hljs-built_in">CreateBiTree</span>();<br>root -&gt; rchild = <span class="hljs-built_in">CreateBiTree</span>();<br>&#125;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">PreOrder</span>(root -&gt; lchild);<br><span class="hljs-built_in">PreOrder</span>(root -&gt; rchild);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br><span class="hljs-built_in">InOrder</span>(root -&gt; lchild);<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">InOrder</span>(root -&gt; rchild);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br><span class="hljs-built_in">PostOrder</span>(root -&gt; lchild);<br><span class="hljs-built_in">PostOrder</span>(root -&gt; rchild);<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先序遍历的非递归算法"><a href="#先序遍历的非递归算法" class="headerlink" title="先序遍历的非递归算法"></a>先序遍历的非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">// 一路向左</span><br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 出栈，并转向出栈结点的右子树</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>p = p -&gt; rchild;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于先序遍历的非递归算法：<wavy></p><ol><li><code>根左右</code>，先根的性质，决定了在<code>一路向左</code>的过程，是可以<code>边输出边入栈</code>的。</li><li>模拟递归回溯，也就是<code>else</code>部分，此时已经完成了<code>根左</code>。现就只要出栈，并转向出栈结点的右子树。</li></ol><h3 id="中序遍历的非递归算法"><a href="#中序遍历的非递归算法" class="headerlink" title="中序遍历的非递归算法"></a>中序遍历的非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 中序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">// 一路向左</span><br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 出栈，并转向出栈结点的右子树</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br>p = p -&gt; rchild;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于中序遍历的非递归算法：<wavy></p><ol><li>与<code>先序遍历的非递归算法</code>类似，不同的是<code>什么时候访问结点</code>。</li><li><code>左根右</code>，决定了必须要找到最左边的结点再回溯。</li><li><code>else</code>部分，也就是模拟递归回溯过程，必须要先<code>出栈</code>再拿着那个结点的值访问。</li></ol><h3 id="后序遍历非递归算法"><a href="#后序遍历非递归算法" class="headerlink" title="后序遍历非递归算法"></a>后序遍历非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 后序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><span class="hljs-comment">// 还需要借助一个指针r，记录最近访问过的结点</span><br><span class="hljs-comment">// 因为回溯的过程中，可能是从左边回溯，也可能是从右边回溯</span><br><span class="hljs-comment">// 从左边回溯，那么根结点就没被访问过。</span><br><span class="hljs-comment">// 从右边回溯，那么根结点被访问过。</span><br>BiTNode * r = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123; <span class="hljs-comment">// 一路向左</span><br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 转右</span><br><span class="hljs-built_in">GetTop</span>(s, p);<br><span class="hljs-comment">// 右子树存在，且右子树还没被访问过</span><br><span class="hljs-keyword">if</span>(p -&gt; rchild &amp;&amp; p -&gt; rchild != r)&#123;<br>p = p -&gt; rchild;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 否则出栈</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br>r = p; <span class="hljs-comment">// 标记为最近访问过的结点</span><br>p = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 重置p，这样下次循环会直接弹出栈顶元素。</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于后序遍历的非递归算法：<wavy></p><ol><li>指针<code>r</code>：回溯的过程中，可能是从左边回溯，也可能是从右边回溯。<code>∴</code> 从左边回溯，那么根结点就没被访问过。从右边回溯，那么根结点被访问过。根结点被访问过，说明该直接从栈顶弹出一个元素。</li></ol><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 层序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 辅助队列</span><br>SqQueue q; <span class="hljs-built_in">InitQueue</span>(q);<br><br><span class="hljs-built_in">EnQueue</span>(q, root);<br><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">EmptyQueue</span>(q))&#123;<br>BiTNode * t; <span class="hljs-built_in">DeQueue</span>(q, t);<br>cout &lt;&lt; t -&gt; data &lt;&lt; endl;<br><br><span class="hljs-keyword">if</span>(t -&gt; lchild) <span class="hljs-built_in">EnQueue</span>(q, t -&gt; lchild);<br><span class="hljs-keyword">if</span>(t -&gt; rchild) <span class="hljs-built_in">EnQueue</span>(q, t -&gt; rchild);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">二叉树</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>顺序队列</title>
    <link href="https://blog.phbeats.cn/posts/54e3f3a21b91/"/>
    <id>https://blog.phbeats.cn/posts/54e3f3a21b91/</id>
    <published>2023-10-27T08:33:53.000Z</published>
    <updated>2024-04-05T12:13:13.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>顺序队列，以<code>循环队列</code>为主。</p><p>因为好写，所以采取它作为我的模板。</p><h3 id="顺序队列的类型描述"><a href="#顺序队列的类型描述" class="headerlink" title="顺序队列的类型描述"></a>顺序队列的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>ElemType data[MaxSize]; <span class="hljs-comment">// 存放队列元素</span><br><span class="hljs-type">int</span> front, rear; <span class="hljs-comment">// 队头、队尾指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化队列 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp; q)</span></span>&#123;<br>q.front = q.rear = <span class="hljs-number">0</span>; <span class="hljs-comment">//初始化队头、队尾指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EmptyQueue</span><span class="hljs-params">(SqQueue q)</span></span>&#123;<br><span class="hljs-keyword">if</span>(q.front == q.rear) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 入队</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp; q, ElemType x)</span></span>&#123;<br><span class="hljs-comment">// 队满,报错</span><br><span class="hljs-keyword">if</span>((q.rear + <span class="hljs-number">1</span>) % MaxSize == q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 入队</span><br>q.data[q.rear] = x;<br>q.rear = (q.rear + <span class="hljs-number">1</span>) % MaxSize;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 出队</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp; q, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 队空, 报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">EmptyQueue</span>(q)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 出队</span><br>x = q.data[q.front];<br>q.front = (q.front + <span class="hljs-number">1</span>) % MaxSize;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获得队头元素"><a href="#获得队头元素" class="headerlink" title="获得队头元素"></a>获得队头元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获得队头元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue q, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 队空，报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">EmptyQueue</span>(q)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 获得队头元素</span><br>x = q.data[q.front];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">静态分配的顺序队列</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>顺序栈</title>
    <link href="https://blog.phbeats.cn/posts/15d79a1a4b3e/"/>
    <id>https://blog.phbeats.cn/posts/15d79a1a4b3e/</id>
    <published>2023-10-27T08:04:26.000Z</published>
    <updated>2024-04-05T12:13:13.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><wavy>顺序栈比较好写,因此我使用它作为我的算法模板</wavy><h3 id="顺序栈的类型描述"><a href="#顺序栈的类型描述" class="headerlink" title="顺序栈的类型描述"></a>顺序栈的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>ElemType data[MaxSize]; <span class="hljs-comment">// 存放栈中元素</span><br><span class="hljs-type">int</span> top; <span class="hljs-comment">// 栈顶指针</span><br>&#125; SqStack;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp; s)</span></span>&#123;<br>s.top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化栈顶指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断栈空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack s)</span></span>&#123; <br><span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 入栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp; s, ElemType x)</span></span>&#123;<br><span class="hljs-comment">// 看栈是否已满,报错</span><br><span class="hljs-keyword">if</span>(s.top == MaxSize - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 入栈</span><br>s.data[++s.top] = x;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 成功</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 出栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp; s, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">StackEmpty</span>(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 先出栈，再减</span><br>x = s.data[s.top--];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获得栈顶元素"><a href="#获得栈顶元素" class="headerlink" title="获得栈顶元素"></a>获得栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获得栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack s, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 空栈，报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">StackEmpty</span>(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 获取栈顶元素</span><br>x = s.data[s.top];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">静态分配的顺序栈</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师沃卡74110耶加雪菲手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/89001a5236dd/"/>
    <id>https://blog.phbeats.cn/posts/89001a5236dd/</id>
    <published>2023-09-11T14:06:31.000Z</published>
    <updated>2024-04-05T12:13:13.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近又买了两款<code>治光师</code>的咖啡豆。</p><p><img src="https://bu.dusays.com/2023/09/11/64ff1c3e0aee9.webp" alt="Screenshot_20230911_214426_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/09/11/64ff1c53bc299.webp" alt="IMG_20230904_174607"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/09/11/64ff1cbb12663.jpg" alt="IMG_20230910_035340"></p><p><img src="https://bu.dusays.com/2023/09/11/64ff1d1fb1cfc.webp" alt="IMG_20230910_035309"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>冲好后，是红茶和柑橘香味。<br>高温表现为：酸质明亮，甜感十足，但还是酸更为突出。</p><p>温度低一点，甜感增强许多。</p><p>低温时，轻微泛苦，甜感更强，但失去香味，茶感还未失去，有点像吃了烂果子的甜感。</p><p>总体评价：中高温很好喝，让人想一直喝。</p>]]></content>
    
    
    <summary type="html">浅尝治光师沃卡74110耶加雪菲手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝辛鹿号码系列手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/9d745f9baaa9/"/>
    <id>https://blog.phbeats.cn/posts/9d745f9baaa9/</id>
    <published>2023-08-08T08:12:00.000Z</published>
    <updated>2024-04-05T12:13:13.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前买了<code>辛鹿SOE耶加雪菲</code>，然后我去评论了它的风味描述，店家看到了找我售后，表示他们很抱歉。作为顾客，我觉得辛鹿的这个价格，本身我对他家的豆子就不报有很大期望，我基本上是将<code>辛鹿</code>作为行业性价比龙头来看待的，因为学生党时代，我买过辛鹿的咖啡豆，因为便宜，但是味道也就不多提了。</p><p>店家这次给我补偿了一些豆子希望我尝尝，然后表示歉意，所以我还是写一篇评测。</p><p><img src="https://bu.dusays.com/2023/08/08/64d1fa8d9e1e8.png" alt="image-20230808161911377"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p>首先上场的是：<code>辛鹿02意式拼配</code>。</p><p>闻起来就知道是深烘系列了，一如既往的焦味，能喝出些许酸味，整体风味均衡。</p><p>应该算是经典老咖啡风味了。</p><p>总体评价：老咖啡、性价比高。</p><p>然后是：<code>辛鹿04精品罗布斯塔</code>。</p><p>闻起来有种不一样的味道，不是纯烟熏味，更多的是大麦茶的味道，而且气泡超多。</p><p><img src="https://bu.dusays.com/2023/08/08/64d22c610c730.webp" alt="IMG_20230808_194509"></p><p><img src="https://bu.dusays.com/2023/08/08/64d22c60a1944.webp" alt="IMG_20230808_194519"></p><p>喝起来绝了！这尼玛纯纯<code>大麦茶</code>！喝一口，剩下的就不喝了。</p><p>总体评价：大麦茶，不推荐！</p><p>在喝完大麦茶之后，现在是：<code>辛鹿05精选蓝山风味</code>。</p><p>第一口下去纯苦，多喝几口，有浅烘的些许热带水果风味。总体挺均衡，风味不突出。</p><p>总体评价：均衡，均衡得想笑。</p><p>最后，是：<code>辛鹿06精品庄园圆豆</code>。</p><p>闻起来好像是浅烘，呜呜呜，连续喝了那么多深烘，人要死啦。尝尝这个豆子怎么样吧。</p><p>额，喝起来是中烘，风味其实感觉像<code>中烘的耶加雪菲</code>，个人感觉比<code>05</code>好喝，起码这个有风味。</p><p>总体评价：中烘耶加雪菲？性价比高，还行。</p>]]></content>
    
    
    <summary type="html">浅尝辛鹿号码系列手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝四人咖啡粉红佳人手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/b8bb6e256940/"/>
    <id>https://blog.phbeats.cn/posts/b8bb6e256940/</id>
    <published>2023-08-08T07:08:36.000Z</published>
    <updated>2024-04-05T12:13:13.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这次事件挺有意思的，起因是我给了<code>四人咖啡果丁丁</code>一个中评，然后客服来问我要不要售后，退货也行，我表示不需要，并且表示下次要购买他家的<code>粉红佳人</code>，他说给我先送点喝喝，我起初以为给我补发<code>30 g</code>豆子尝尝鲜，谁知道他家诚意满满，发了<code>100 g</code>。</p><p>不过喝了之后，我表示很不错，他家也是发了一个修改评价，我也是改成了好评+空评价。</p><p><img src="https://bu.dusays.com/2023/08/08/64d1ed5b9ac47.webp" alt="Screenshot_20230808_151607_com.taobao.taobao"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/08/64d1edc1c17af.webp" alt="Screenshot_20230808_151830_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/08/64d1ede675129.webp" alt="IMG_20230808_145826"></p><p><img src="https://bu.dusays.com/2023/08/08/64d1edd1322eb.webp" alt="IMG_20230808_145904"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>你知道什么是<code>花香</code>吗？你知道什么是<code>蜜桃</code>吗？我小啜第一口，全是<code>蜜桃和花香</code>，而不是<code>酸或甜</code>。我怀疑店家给我的是<code>A1</code>品质的豆子，几乎喝不出什么负面的味道。</p><p>中高温，蜜桃风味明显，随后才是酸和甜的草莓风味。低温，酸味开始突出，但是蜜桃风味不减，甜感增强。</p><p>继治光师伊迪朵水洗耶加雪菲之后，又一让我眼前一亮的豆子，很惊艳。</p><p>总体评价：蜜桃、草莓、高品质、性价比高、推荐。</p>]]></content>
    
    
    <summary type="html">浅尝四人咖啡粉红佳人手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师野草莓手冲咖啡(整活)</title>
    <link href="https://blog.phbeats.cn/posts/0e42f4daeb32/"/>
    <id>https://blog.phbeats.cn/posts/0e42f4daeb32/</id>
    <published>2023-08-03T03:50:57.000Z</published>
    <updated>2024-04-05T12:13:13.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>买了<code>治光师</code>的另一款咖啡豆，这款咖啡豆是意式拼配，中深烘焙的。之前喝的差不多都是浅烘，不知道这下风味转变能不能接受了呢，应该问题不大，毕竟以前黑咖我都是不加糖的，主打一个不怕苦。</p><p><code>治光师</code>店铺也九周年了，送了一些小玩意，虽然没啥用，姑且也算送了？</p><p><img src="https://bu.dusays.com/2023/08/03/64cb3337d9470.webp" alt="IMG_20230801_181148"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/03/64cb32d81bb8a.webp" alt="Screenshot_20230803_114348_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/03/64cb33549edd7.webp" alt="IMG_20230803_114019"></p><p><img src="https://bu.dusays.com/2023/08/03/64cb335dd702a.webp" alt="IMG_20230803_113927"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>豆子看起来棕亮的，冲好之后闻了一下，一股烟熏味，感觉梦回高中了。</p><p>果然，一口下去就知道<code>老咖啡</code>了。整体喝起来十分不错，不对我口味的是那烟熏味！即使是手冲也能感觉到它油脂丰富（别和我说没压就出不来油脂，我说有就有），它入口绵滑，虽然带有烟熏味，但并没有带其它奇奇怪怪的味道，比如<code>焦炭</code>这种。回味能够感受到<code>柑橘</code>风味。草莓酱我倒是没感觉到，不过毕竟是手冲吧。</p><p>这算整活了吧，因为这豆子要用<code>咖啡机</code>来制作，然而我是手冲！因为我现在还没咖啡机，仅仅是手冲爱好者，但是<code>治光师野草莓</code>又十分有名，我抱着试试看的心态买了这款豆子，尝尝鲜。</p><p>总体评价：中深烘焙、油脂丰富、均衡、性价比高。</p>]]></content>
    
    
    <summary type="html">浅尝治光师野草莓手冲咖啡(整活)</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝四人咖啡果丁丁耶加雪菲手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/9c71bc76a9ad/"/>
    <id>https://blog.phbeats.cn/posts/9c71bc76a9ad/</id>
    <published>2023-07-31T22:53:21.000Z</published>
    <updated>2024-04-05T12:13:13.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>四人咖啡送了我一些小玩意，还送了我一包<code>花海</code>，之后我再喝。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/01/64c83b62d354b.jpg" alt="Screenshot_20230801_065234_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b71273d0.webp" alt="IMG_20230801_062901"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b8391dae.webp" alt="IMG_20230801_063010"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b951ee47.webp" alt="IMG_20230801_063637"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b9ea4a2d.webp" alt="IMG_20230801_064028"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>偏高温时，第一口居然是莫名其妙的味道，第二口继续确认，出来的是<code>茶感</code>，随后品<code>茶感</code>的时候容易品出<code>木质</code>和<code>涩味</code>，随后感觉像咬到了一颗焦炭豆子一样，口腔开始发苦。</p><p>温度稍微下来，酸味明亮，茶感明显。但后半段伴随着不好的味道，比如：木质、涩味、烟熏、焦炭。</p><p>其中不好的味道比较突出的是：木质、涩味、焦炭。还是那个问题，喝到瑕疵豆了！</p><p>到了中温才能更好喝出它的风味，耶加雪菲的感觉。不过风味变成：柑橘、焦糖了。</p><p>不过它确实能喝出来，水蜜桃的风味，很神奇哦，不过我是在偏中低温情况喝出来的。高温的表现并不好，因为不好的味道突出太明显了。咖啡豆还真就和运气沾点边，我这批次的豆子应该属于不太理想。去除那些瑕疵风味，我想<code>果丁丁</code>一定非常好喝。</p><p>总体评价：耶加雪菲、些许木质、涩、烟熏焦炭、性价比一般。</p>]]></content>
    
    
    <summary type="html">浅尝四人咖啡果丁丁耶加雪菲手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>王道数据结构链表习题</title>
    <link href="https://blog.phbeats.cn/posts/78005f2f1e1c/"/>
    <id>https://blog.phbeats.cn/posts/78005f2f1e1c/</id>
    <published>2023-07-31T05:32:29.000Z</published>
    <updated>2024-04-05T12:13:13.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表经典大题"><a href="#链表经典大题" class="headerlink" title="链表经典大题"></a>链表经典大题</h3><h4 id="递归删除不带头结点的单链表中所有值为-x-的结点"><a href="#递归删除不带头结点的单链表中所有值为-x-的结点" class="headerlink" title="递归删除不带头结点的单链表中所有值为 x 的结点"></a>递归删除不带头结点的单链表中所有值为 x 的结点</h4><p><img src="https://bu.dusays.com/2023/07/31/64c75c76e2b3a.png" alt="image-20230731150204492"></p><p>题目说了是 L 哦。但是我代码写得是 list。偷懒了。</p><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p>板子</p><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归删除不带头结点单链表中 x 的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del_x</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 出口</span><br><span class="hljs-keyword">if</span>(!list) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list -&gt; data == x)&#123;<br><span class="hljs-comment">// 如果当前递归中的结点是应该被删除的结点</span><br>LNode * p = list;<br>list = list -&gt; next; <span class="hljs-comment">// 指向下一个结点</span><br><span class="hljs-built_in">free</span>(p);<br><span class="hljs-comment">// 继续寻找</span><br><span class="hljs-built_in">Del_x</span>(list, x);<br><br><span class="hljs-comment">// 下面这三行代码是绝对不能写！！！死循环</span><br><span class="hljs-comment">// LNode * p = list -&gt; next;</span><br><span class="hljs-comment">// free(list);</span><br><span class="hljs-comment">// Del_x(p, x);</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是应该被删除的结点</span><br><span class="hljs-built_in">Del_x</span>(list -&gt; next, x);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="附赠无头结点的尾插法代码"><a href="#附赠无头结点的尾插法代码" class="headerlink" title="附赠无头结点的尾插法代码"></a>附赠无头结点的尾插法代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 无头结点尾插法建立单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TailInsert</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-built_in">InitList</span>(list);<br><br>LNode * r;<br><br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">9999</span>)&#123;<br>LNode * s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>s -&gt; data = x;<br>s -&gt; next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">// 是第一个结点</span><br><span class="hljs-keyword">if</span>(!list) list = s;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 平常的尾插</span><br>s -&gt; next = r -&gt; next;<br>r -&gt; next = s;<br>&#125;<br>r = s;<br>cin &gt;&gt; x;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除带头结点的单链表中所有值为-x-的结点"><a href="#删除带头结点的单链表中所有值为-x-的结点" class="headerlink" title="删除带头结点的单链表中所有值为 x 的结点"></a>删除带头结点的单链表中所有值为 x 的结点</h4><p><img src="https://bu.dusays.com/2023/07/31/64c76dedf2ece.png" alt="image-20230731161643650"></p><h5 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h5><p>板子</p><h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除带头结点单链表中 x 的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del_x</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br>LNode * pre = list, * cur = list -&gt; next;<br><br><span class="hljs-keyword">while</span>(cur)&#123;<br><span class="hljs-comment">// 当前结点是应该被删除的结点</span><br><span class="hljs-keyword">if</span>(cur -&gt; data == x)&#123;<br>LNode * q = cur;<br>cur = cur -&gt; next;<br>pre -&gt; next = cur;<br><span class="hljs-built_in">free</span>(q);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 当前结点不是应该被删除的结点</span><br>pre = cur;<br>cur = cur -&gt; next;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="从尾到头反向输出带头结点单链表中每个结点的值"><a href="#从尾到头反向输出带头结点单链表中每个结点的值" class="headerlink" title="从尾到头反向输出带头结点单链表中每个结点的值"></a>从尾到头反向输出带头结点单链表中每个结点的值</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb446b8fd07.png" alt="image-20230803135630640"></p><h5 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h5><p>利用栈的思想</p><h5 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 反向输出链表中每个结点的值</span><br><span class="hljs-comment">// 0.在 main 函数中，调用要注意！</span><br><span class="hljs-comment">// 1.Reverse_Print（list -&gt; next); 带头结点</span><br><span class="hljs-comment">// 2.Reverse_Print（list); 不带头结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reverse_Print</span><span class="hljs-params">(LinkList list)</span></span>&#123;<br><span class="hljs-comment">// 出口</span><br><span class="hljs-keyword">if</span>(!list) <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">// 入栈</span><br><span class="hljs-built_in">Reverse_Print</span>(list -&gt; next);<br><br><span class="hljs-comment">// 出栈</span><br>cout &lt;&lt; list -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除带头结点单链表中的唯一最小值"><a href="#删除带头结点单链表中的唯一最小值" class="headerlink" title="删除带头结点单链表中的唯一最小值"></a>删除带头结点单链表中的唯一最小值</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb4502a04bb.png" alt="image-20230803141117604"></p><h5 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>利用 <code>min_pre</code>、<code>cur</code> 两个指针</li><li>利用线性表寻找最小值算法思想</li><li><code>min_pre</code>用来更新保存，目前已知最小值结点的前一个结点</li></ol><h5 id="核心代码-3"><a href="#核心代码-3" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除单链表中唯一最小值结点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_Min</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 如果是空表或只有头节点</span><br><span class="hljs-keyword">if</span>(!list || !list -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 经典前后指针</span><br>LNode * pre = list, * cur = list -&gt; next;<br>    <span class="hljs-comment">// 保存最小值结点的前一个结点</span><br>LNode * min_pre = list;<br><br><span class="hljs-comment">// 假设最小值是第一个节点</span><br>LNode * t = cur;<br><span class="hljs-comment">// 打擂台</span><br><span class="hljs-keyword">while</span>(cur)&#123;<br><span class="hljs-comment">// 如果发现比最小值还要小的</span><br>         <span class="hljs-comment">// 打赢了，新的当 t</span><br><span class="hljs-keyword">if</span>(cur -&gt; data &lt; t -&gt; data)&#123;<br>t = cur;<br>             <span class="hljs-comment">// pre 作为 新的min_pre</span><br>min_pre = pre;<br>&#125;<br><span class="hljs-comment">// 俩指针后移</span><br>pre = cur;<br>cur = cur -&gt; next;<br>&#125;<br><br><span class="hljs-comment">// 删除擂主</span><br>min_pre -&gt; next = t -&gt; next;<br><span class="hljs-built_in">free</span>(t);<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="带头结点的单链表逆置"><a href="#带头结点的单链表逆置" class="headerlink" title="带头结点的单链表逆置"></a>带头结点的单链表逆置</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb637357a20.png" alt="image-20230803162110380"></p><h5 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h5><p>准备<code>pre</code>、<code>cur</code>、<code>r</code> 3个指针，<code>cur</code>指向<code>pre</code>。</p><h5 id="核心代码-4"><a href="#核心代码-4" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表就地逆置</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reverse_LinkList</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 空表或者只有头结点或者只有一个元素</span><br><span class="hljs-keyword">if</span>(!list || !list -&gt; next || !list -&gt; next -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>LNode * pre = list , * cur = list -&gt; next;<br>LNode * r = cur -&gt; next;<br><span class="hljs-comment">// NULL &lt;- cur &lt;- r</span><br>cur -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">while</span>(r)&#123;<br>pre = cur;<br>cur = r;<br>r = r -&gt; next;<br>cur -&gt; next = pre;<br>&#125;<br><br><span class="hljs-comment">// cur才是真正的主元素，r只是拿来判断的边界条件</span><br>list -&gt; next = cur;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单链表的插入排序"><a href="#单链表的插入排序" class="headerlink" title="单链表的插入排序"></a>单链表的插入排序</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32c0724c39.png" alt="image-20230809140236810"></p><h5 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h5><p><a href="/posts/f7271c1a5982/">跳转链接</a></p><h5 id="核心代码-5"><a href="#核心代码-5" class="headerlink" title="核心代码"></a>核心代码</h5><p><a href="/posts/f7271c1a5982/">跳转链接</a></p><h4 id="两个单链表的公共结点"><a href="#两个单链表的公共结点" class="headerlink" title="两个单链表的公共结点"></a>两个单链表的公共结点</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32d21a0968.png" alt="image-20230809140728686"></p><h5 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h5><p>假设有两个单链表<code>A</code>和<code>B</code>。</p><p>单链表<code>A</code>长度为：a</p><p>单链表<code>B</code>长度为：b</p><p>无非两种情况：<code>相交</code>和<code>不相交</code></p><p><img src="https://bu.dusays.com/2023/08/09/64d32ff3099be.png" alt="image-20230809141931085"></p><p>可以利用<code>a + c + b</code> ＝ <code>b + c + a</code>。求出交点。</p><p>这是<code>不相交</code>的情况。</p><p><img src="https://bu.dusays.com/2023/08/09/64d330de84da4.png" alt="image-20230809142327260"></p><p><code>a + b</code> ＝ <code>b + a</code>。</p><p>相遇为<code>NULL</code>，返回<code>NULL</code>。</p><p><code>公式恒成立</code>。</p><h5 id="核心代码-6"><a href="#核心代码-6" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LNode * <span class="hljs-title">findFirstCommonNode</span><span class="hljs-params">(LinkList headA, LinkList headB)</span> </span>&#123;<br>    LNode * p = headA , * q = headB;<br>    <br>    <span class="hljs-keyword">while</span>(p != q)&#123;<br>        p = p ? p -&gt; next : headB;<br>        q = q ? q -&gt; next : headA;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将原单链表A分裂为：奇A表和偶B表"><a href="#将原单链表A分裂为：奇A表和偶B表" class="headerlink" title="将原单链表A分裂为：奇A表和偶B表"></a>将原单链表A分裂为：<code>奇A表</code>和<code>偶B表</code></h4><p><img src="https://bu.dusays.com/2023/08/09/64d33587565fd.png" alt="image-20230809144319763"></p><h5 id="核心思想-7"><a href="#核心思想-7" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>奇偶序号计数<code>i</code>。</li><li><code>ra</code>和<code>rb</code>尾指针。</li><li>将<code>A</code>的<code>next</code>先<code>置空</code>，后面会通过<code>ra</code>来增加结点。</li><li>根据<code>i</code>的奇偶，在<code>ra</code>或者<code>rb</code>后面增加结点<code>p</code>，再更新<code>ra</code>或<code>rb</code>。</li><li><code>ra</code>和<code>rb</code>的<code>next</code>需要<code>置空</code>。</li></ol><h5 id="核心代码-7"><a href="#核心代码-7" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将原单链表A分裂为：`奇A表`和`偶B表`</span><br><span class="hljs-function">LinkList <span class="hljs-title">Re_Create</span><span class="hljs-params">(LinkList &amp; A)</span></span>&#123;<br><span class="hljs-comment">// 准备B表</span><br>LinkList B = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>B -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 准备工作</span><br>LNode * ra = A , * rb = B; <span class="hljs-comment">// A 和 B 的尾指针</span><br>LNode * p = A -&gt; next; <span class="hljs-comment">// 遍历准备工作</span><br><br><span class="hljs-comment">// A 表断开</span><br>A -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 奇偶序列计数</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p)&#123;<br>i++;<br><span class="hljs-comment">// 奇</span><br><span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span>)&#123;<br>ra -&gt; next = p;<br>ra = p;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 偶</span><br>rb -&gt; next = p;<br>rb = p;<br>&#125;<br>p = p -&gt; next;<br>&#125;<br><span class="hljs-comment">// 尾指针置空</span><br>ra -&gt; next = <span class="hljs-literal">NULL</span>;<br>rb -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> B;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="递增有序的单链表，去除相同的元素"><a href="#递增有序的单链表，去除相同的元素" class="headerlink" title="递增有序的单链表，去除相同的元素"></a>递增有序的单链表，去除相同的元素</h4><p><img src="https://bu.dusays.com/2023/08/09/64d33acd8d1ba.png" alt="image-20230809150548410"></p><h5 id="核心思想-8"><a href="#核心思想-8" class="headerlink" title="核心思想"></a>核心思想</h5><p><a href="448d550da686">跳转链接</a></p><h5 id="核心代码-8"><a href="#核心代码-8" class="headerlink" title="核心代码"></a>核心代码</h5><p><a href="448d550da686">跳转链接</a></p><h4 id="带头结点的循环双链表是否对称"><a href="#带头结点的循环双链表是否对称" class="headerlink" title="带头结点的循环双链表是否对称"></a>带头结点的循环双链表是否对称</h4><p><img src="https://bu.dusays.com/2023/08/09/64d33f2db78aa.png" alt="image-20230809152429784"></p><h5 id="核心思想-9"><a href="#核心思想-9" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>设置两个指针<code>p</code>和<code>q</code>。往两个不同的方向走</li><li>结点数是奇数和偶数，是难点。<code>2n + 1</code>和<code>2n</code>。</li></ol><h5 id="核心代码-9"><a href="#核心代码-9" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Symmetry</span><span class="hljs-params">(DLinkList list)</span></span>&#123;<br>    DNode * p = list -&gt; next , * q = list -&gt; prior;<br>    <span class="hljs-comment">// 第二个条件容易写成 p -&gt; next != q;</span><br>    <span class="hljs-keyword">while</span>(p != q &amp;&amp; q -&gt; next != p)&#123;<br>        <span class="hljs-keyword">if</span>(p -&gt; data == q -&gt; data)&#123;<br>            p = p -&gt; next;<br>            q = q -&gt; prior;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单链表判断是否有环"><a href="#单链表判断是否有环" class="headerlink" title="单链表判断是否有环"></a>单链表判断是否有环</h4><p><img src="https://bu.dusays.com/2023/08/09/64d34b2220fb7.png" alt="image-20230809161529567"></p><h5 id="核心思想-10"><a href="#核心思想-10" class="headerlink" title="核心思想"></a>核心思想</h5><ul><li>慢指针一步一步走，快指针两步两步走</li><li>无环：快指针必定会先到达终点（NULL）</li><li>有环：俩指针会相遇，相遇之后，让慢指针回到起点，再让快慢指针同步速度，一步一步走</li><li>当再次相遇的时候，那个点就是环的入口</li></ul><h5 id="核心代码-10"><a href="#核心代码-10" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">entryNodeOfLoop</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode * slow = head , * fast = head;<br><br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-comment">// 有环，相遇了</span><br>            <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果fast是空，那么代表无环，否则代表有环，并且slow == fast成立</span><br>        <span class="hljs-comment">// 而且，如果while循环条件一开始就没满足，那么代表head是空节点亦或者长度为1</span><br>        <span class="hljs-keyword">if</span>(!fast || !fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// slow == fast ， 有环</span><br>        <span class="hljs-comment">// 让slow回去，fast和slow以同样的速度走，再次相遇就是环的入口结点</span><br>        slow = head;<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            slow = slow -&gt; next;<br>            fast = fast -&gt; next;<br>        &#125;<br>        <span class="hljs-comment">// 再次相遇了</span><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br><br>作者：麦高芬<br>链接：https:<span class="hljs-comment">//www.acwing.com/solution/content/153752/</span><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="单链表倒数第-k-个值"><a href="#单链表倒数第-k-个值" class="headerlink" title="单链表倒数第 k 个值"></a>单链表倒数第 k 个值</h4><p><img src="https://bu.dusays.com/2023/08/09/64d34d9156593.png" alt="image-20230809162553225"></p><h5 id="核心思想-11"><a href="#核心思想-11" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>两个指针<code>p</code>和<code>q</code></li><li>先让它们两个相距<code>k</code></li><li>当<code>q</code>遍历完的时候，<code>p</code>就是倒数第<code>k</code>个节点</li></ol><h5 id="核心代码-11"><a href="#核心代码-11" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_K</span><span class="hljs-params">(LinkList list, <span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-comment">// 计数</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>LNode * p = list -&gt; next, * q = list -&gt; next;<br><br><span class="hljs-keyword">while</span>(q)&#123;<br><span class="hljs-comment">// 先让q走 k 步</span><br><span class="hljs-keyword">if</span>(count &lt; k)&#123;<br>count++;<br>q = q -&gt; next;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>p = p -&gt; next;<br>q = q -&gt; next;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 查找失败</span><br><span class="hljs-keyword">if</span>(count &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h4><p><img src="https://bu.dusays.com/2023/08/09/64d35190e4e8b.png" alt="image-20230809164257287"></p><h5 id="核心思想-12"><a href="#核心思想-12" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>先遍历一遍链表，获取链表的长度。</li><li>根据获取到的链表长度，获取链表中间的结点。(向上取整)</li><li>反转后半段链表。</li><li>合并前半段链表和反转后的后半段链表。</li></ol><h5 id="核心代码-12"><a href="#核心代码-12" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rearrangedList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head-&gt;next) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 获取链表的长度</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = head ; p ; p = p -&gt; next) len++;<br>    <br>        <span class="hljs-comment">// 链表中间的结点</span><br>        <span class="hljs-type">int</span> left = (len + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">auto</span> a = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; left - <span class="hljs-number">1</span> ; i++) a = a -&gt; next;<br>    <span class="hljs-comment">// 反转后半段链表，b在前，c在后  </span><br>        <span class="hljs-keyword">auto</span> b = a -&gt; next , c = b -&gt; next;<br>    <span class="hljs-comment">// a-&gt;next 是为了从中间将链表截断；b-&gt;next 是因为此时的 b 是反转后链表的结尾元素</span><br>        a -&gt; next = b -&gt; next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-keyword">while</span>(c)&#123;<br>            <span class="hljs-keyword">auto</span> p = c -&gt; next;<br>            c -&gt; next = b;<br>            b = c; c = p;<br>        &#125;<br>    <br>        <span class="hljs-comment">// 合并链表，注意此时 b 指向反转链表头部</span><br>        <span class="hljs-keyword">auto</span> p = head;<br>        <span class="hljs-keyword">auto</span> q = b;<br>        <span class="hljs-comment">// o -&gt; o -&gt; o -&gt; NULL (p)</span><br>        <span class="hljs-comment">// o -&gt; o -&gt; o -&gt; NULL (q)</span><br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            <span class="hljs-keyword">auto</span> o = q -&gt; next;<br>            q -&gt; next = p -&gt; next;<br>            p -&gt; next = q;<br>            p = q -&gt; next;<br>            q = o;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">王道数据结构链表习题</summary>
    
    
    
    <category term="王道数据结构习题" scheme="https://blog.phbeats.cn/categories/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    
    
    <category term="王道数据结构习题" scheme="https://blog.phbeats.cn/tags/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师肯尼亚圆豆手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/bb95ebed2e97/"/>
    <id>https://blog.phbeats.cn/posts/bb95ebed2e97/</id>
    <published>2023-07-29T22:45:30.000Z</published>
    <updated>2024-04-05T12:13:13.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是治光师会员限购9.9包邮的，肯尼亚FCS合作社顶级圆豆批次，水洗处理的浅烘豆子。</p><p>9.9元30g，不妨让我来试试水。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/30/64c5986ae14d5.webp" alt="Screenshot_20230730_064146_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/07/30/64c5987b1a642.webp" alt="IMG_20230730_063602"></p><p><img src="https://bu.dusays.com/2023/07/31/64c74e7532b67.webp" alt="IMG_20230730_063624"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>一到货熟豆闻起来和之前买的<code>菠萝成子危地马拉瑰夏</code>味道差不多。先养养豆。</p><p>第一口下去是它的酸度和甜度，比较突出，酸度明显高于<code>治光师耶加雪菲</code>，最大的亮点是它真的<code>很甜</code>。喝完后回甘有很久很久，感觉喝了蜂蜜一样，不过对于我这种不太喜欢甜的咖啡的人来说，有点偏齁甜了。它的<code>热带水果风味</code>实在太足了，十分好喝，有轻微涩味，不过太能接受了！</p><p>总体评价：烟熏、涩、果酸和甜感突出、性价比高、推荐。</p>]]></content>
    
    
    <summary type="html">浅尝治光师肯尼亚圆豆手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师伊迪朵耶加雪菲手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/32f6f1e29b78/"/>
    <id>https://blog.phbeats.cn/posts/32f6f1e29b78/</id>
    <published>2023-07-23T00:00:02.000Z</published>
    <updated>2024-04-05T12:13:13.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这款<code>治光师伊迪朵耶加雪菲</code>是群友推荐的，直接无脑买了。<br>写这篇文章，已经过了好些日子了，这是第二次喝的时候写的评价。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/13/64af5071a51a7.webp" alt="Screenshot_20230713_085908_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf456c60.webp" alt="IMG_20230723_064938"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf52e837.webp" alt="IMG_20230723_065210"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf44e11f.webp" alt="IMG_20230714_081733"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>首先，从豆子品控来看，是十分优秀的。</p><p>高温下，酸很<code>明亮</code>，基本无涩感，值得一提的是<code>茶感</code>很明显，有些许回甘，带<code>清香的甜</code>。</p><p>低温下，酸更加明显，有<code>SeeSaw 甜橙子</code>那味了。<code>茶感</code>更上一层楼。</p><p>目前喝过<code>最棒的耶加雪菲</code>。</p><p>缺点可能就是100g需要45元，喝几次就无了吧。真的，它就是优秀，挑不出什么刺。非要说的话，喝完后还是有些许烟熏感，不过能够接受。</p><p>不过我觉得这种价格配得上这种品质。</p><p>总体评价：浅烘、水果清香、茶感浓郁、性价比适中、推荐回购。</p>]]></content>
    
    
    <summary type="html">浅尝治光师伊迪朵耶加雪菲手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝菠萝成子危地马拉瑰夏手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/fcab5f014e92/"/>
    <id>https://blog.phbeats.cn/posts/fcab5f014e92/</id>
    <published>2023-07-21T23:18:45.000Z</published>
    <updated>2024-04-05T12:13:13.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>瑰夏！瑰夏！瑰夏！</p><p>啊，我终于也能喝上瑰夏了，不过这款瑰夏不是出自<code>巴拿马的翡翠庄园</code>的瑰夏。</p><p>而是出自<code>危地马拉的庄园</code>。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/22/64bb06f93ff84.jpg" alt="Screenshot_20230722_062419_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/07/22/64bb0705f2398.jpg" alt="IMG_20230713_190844"></p><p><img src="https://bu.dusays.com/2023/07/22/64bb070c95363.jpg" alt="IMG_20230713_200015"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>根据<code>菠萝成子</code>介绍，入手了这款瑰夏，他说这款瑰夏一定是真的瑰夏。</p><p>这款瑰夏是中烘的，开包后香味给我的感觉是没有之前的豆子香，我层怀疑是不是豆子不新鲜了，密封罐好像很容易就打开了，是否起到了密封效果？嚼了两粒，确定一下，是<code>大麦茶</code>的味道，香香脆脆的。</p><p><code>瑰夏</code>为什么是瑰夏呢？不仅是指品种，还有风味。</p><p>即使是中烘，苦味一点儿也不明显，突出的更多是水果风味，属于那种真的很清香的，带草莓的酸的感觉，有焦糖味，有一点红茶茶感，喝完后给我的感觉是很均衡，<code>为什么感觉刚刚喝的是水？</code>。喝完后，还是能够感觉到明显的烘焙味，喉咙还是有点不太舒服，也许这也就是之前口嚼大麦茶味的缘由吧。</p><p>真的！这尼玛就是水吧，尝试了各种不同的水粉比，果然是水…</p><p>和闻起来一样，喝起来也是如此清淡，好喝倒是一言难尽，不过我不喜欢那种喝完后那种喉咙被烟熏的感觉。</p><p>总体评价：中烘、清淡、烟熏、性价比低。</p>]]></content>
    
    
    <summary type="html">浅尝菠萝成子危地马拉瑰夏手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>王道数据结构算法设计大题汇总</title>
    <link href="https://blog.phbeats.cn/posts/ba547e211266/"/>
    <id>https://blog.phbeats.cn/posts/ba547e211266/</id>
    <published>2023-07-18T08:53:20.000Z</published>
    <updated>2024-04-05T12:13:13.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章-线性表"><a href="#第一章-线性表" class="headerlink" title="第一章 线性表"></a>第一章 线性表</h3><ol><li><a href="/posts/f57f98d1b5f4">顺序表</a></li><li><a href="/posts/78005f2f1e1c">链表</a></li></ol>]]></content>
    
    
    <summary type="html">王道数据结构算法设计大题汇总</summary>
    
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/tags/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>王道数据结构顺序表习题</title>
    <link href="https://blog.phbeats.cn/posts/f57f98d1b5f4/"/>
    <id>https://blog.phbeats.cn/posts/f57f98d1b5f4/</id>
    <published>2023-07-18T08:53:00.000Z</published>
    <updated>2024-04-05T12:13:13.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序表经典大题"><a href="#顺序表经典大题" class="headerlink" title="顺序表经典大题"></a>顺序表经典大题</h3><h4 id="删除顺序表中的最小值"><a href="#删除顺序表中的最小值" class="headerlink" title="删除顺序表中的最小值"></a>删除顺序表中的最小值</h4><p><img src="https://bu.dusays.com/2023/07/18/64b6140d7eb70.png" alt="image-20230718122418457"></p><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p>遍历表，查找最小值，并记住位置 </p><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_Min</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> &amp; value)</span></span>&#123;<br><span class="hljs-comment">// 表空</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 假定最小值是第1个元素</span><br>value = list.data[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 遍历表，尝试找到更小的元素（从第2个元素开始找起）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; list.length; i++)&#123;<br><span class="hljs-keyword">if</span>(list.data[i] &lt; value)&#123;<br>value = list.data[i];<br>pos = i;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 题目要求：空出的位置由最后一个元素顶替</span><br>list.data[pos] = list.data[list.length - <span class="hljs-number">1</span>];<br><br>list.length--; <span class="hljs-comment">// 这一步是最最最容易忘记的！！！</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="逆置顺序表"><a href="#逆置顺序表" class="headerlink" title="逆置顺序表"></a>逆置顺序表</h4><p><img src="https://bu.dusays.com/2023/07/18/64b619073eeab.png" alt="image-20230718124559870"></p><h5 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h5><p>算法板子…</p><h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 输入非法</span><br>    <span class="hljs-keyword">if</span>(from &gt;= to) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 向上取整</span><br><span class="hljs-type">int</span> mid = (to - from + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mid; i++)&#123;<br><span class="hljs-type">int</span> temp = list.data[from + i];<br>list.data[from + i] = list.data[to - i];<br>list.data[to - i] = temp;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表批量删除指定值-x-元素"><a href="#顺序表批量删除指定值-x-元素" class="headerlink" title="顺序表批量删除指定值 x 元素"></a>顺序表批量删除指定值 x 元素</h4><p><img src="https://bu.dusays.com/2023/07/18/64b61b50f028c.png" alt="image-20230718125544632"></p><h5 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h5><p>利用变量<code>k</code>，从0开始，遍历表，只保留<code>非 x</code> 元素</p><h5 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_x</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-keyword">if</span>(list.data[i] != x)<br>list.data[k++] = list.data[i];<br><br><span class="hljs-comment">// k 才是有效表长</span><br>list.length = k;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表在某条件下的批量删除"><a href="#顺序表在某条件下的批量删除" class="headerlink" title="顺序表在某条件下的批量删除"></a>顺序表在某条件下的批量删除</h4><p><img src="https://bu.dusays.com/2023/07/18/64b626805f0ac.png" alt="image-20230718134328974"></p><h5 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h5><p>算法板子…</p><p><img src="https://bu.dusays.com/2023/07/18/64b629de5c63b.png" alt="image-20230718135751532"></p><h5 id="核心代码-3"><a href="#核心代码-3" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_range</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 题目要求，非法输入判定</span><br><span class="hljs-keyword">if</span>(s &gt;= t) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(i &lt; list.length)&#123;<br><span class="hljs-comment">// 值在[s,t]这个范围内 k++</span><br><span class="hljs-keyword">if</span>(list.data[i] &gt;= s &amp;&amp; list.data[i] &lt;= t) k++;<br><span class="hljs-keyword">else</span> list.data[i - k] = list.data[i]; <span class="hljs-comment">// 不在这个范围则直接位移</span><br>i++;<br>&#125;<br><br><span class="hljs-comment">// 更新表长，删除了 k 个</span><br>list.length -= k;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除顺序表中重复元素"><a href="#删除顺序表中重复元素" class="headerlink" title="删除顺序表中重复元素"></a>删除顺序表中重复元素</h4><p><img src="https://bu.dusays.com/2023/07/18/64b62c656f8fc.png" alt="image-20230718140838298"></p><h5 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h5><p>经典的双指针算法。</p><h5 id="核心代码-4"><a href="#核心代码-4" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_repeat</span><span class="hljs-params">(SqList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">int</span> i,j;<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; j &lt; list.length; j++)<br><span class="hljs-comment">// 出现不同元素</span><br><span class="hljs-keyword">if</span>(list.data[i] != list.data[j])<br><span class="hljs-comment">// 前移 不能写 i++ 必须要写 ++i ！！！！</span><br>             <span class="hljs-comment">// 不同的元素要放在 i 的下一个位置(保证)</span><br>list.data[++i] = list.data[j];<br><br><br>list.length = i + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线性表的-AB-gt-BA-问题"><a href="#线性表的-AB-gt-BA-问题" class="headerlink" title="线性表的 AB =&gt; BA 问题"></a>线性表的 AB =&gt; BA 问题</h4><p><img src="https://bu.dusays.com/2023/07/18/64b631f37d5fe.png" alt="image-20230718143153144"></p><h5 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h5><p><img src="https://bu.dusays.com/2023/07/18/64b6372246520.png" alt="image-20230718145427110"></p><h5 id="核心代码-5"><a href="#核心代码-5" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 输入非法</span><br><span class="hljs-keyword">if</span>(from &gt;= to) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 向上取整</span><br><span class="hljs-type">int</span> mid = (to - from + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mid; i++)&#123;<br><span class="hljs-type">int</span> temp = list.data[from + i];<br>list.data[from + i] = list.data[to - i];<br>list.data[to - i] = temp;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Converse</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-built_in">Reverse</span>(list, <span class="hljs-number">0</span>, m + n - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">Reverse</span>(list, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">Reverse</span>(list, n, m + n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表的二分查找"><a href="#顺序表的二分查找" class="headerlink" title="顺序表的二分查找"></a>顺序表的二分查找</h4><p><img src="https://bu.dusays.com/2023/07/18/64b6380c82626.png" alt="image-20230718145821268"></p><h5 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h5><p>使用<code>折半查找</code>。</p><h5 id="核心代码-6"><a href="#核心代码-6" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SearchExchangeInsert</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 二分</span><br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = list.length - <span class="hljs-number">1</span>, mid;<br><br><span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br><span class="hljs-comment">// 防溢出</span><br>mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span>(list.data[mid] == x) <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list.data[mid] &lt; x) left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 找到了，与它后面那个元素进行交换（要有的话）</span><br><span class="hljs-keyword">if</span>(list.data[mid] == x &amp;&amp; mid != list.length - <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">swap</span>(list.data[mid],list.data[mid + <span class="hljs-number">1</span>]); <span class="hljs-comment">// 偷懒了</span><br>&#125;<br><br><span class="hljs-comment">// 没找到</span><br><span class="hljs-keyword">if</span>(left &gt; right)&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i = list.length - <span class="hljs-number">1</span>; i &gt; right; i--)&#123;<br>list.data[i + <span class="hljs-number">1</span>] = list.data[i];<br>&#125;<br>list.data[i + <span class="hljs-number">1</span>] = x;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表的主元（摩尔投票法）"><a href="#顺序表的主元（摩尔投票法）" class="headerlink" title="顺序表的主元（摩尔投票法）"></a>顺序表的主元（摩尔投票法）</h4><p>题目太长了，就不给了。</p><p>大概意思是<code>主元的数量大于总数量的一半</code></p><h5 id="核心思想-7"><a href="#核心思想-7" class="headerlink" title="核心思想"></a>核心思想</h5><p>算法板子…</p><h5 id="核心代码-7"><a href="#核心代码-7" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(SqList list)</span></span>&#123;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> val;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++)&#123;<br><span class="hljs-keyword">if</span>(!cnt) val = list.data[i], cnt++;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val == list.data[i]) cnt++;<br><span class="hljs-keyword">else</span> cnt--;<br>&#125;<br><br><span class="hljs-comment">// 如果有主元。统计出主元实际出现次数</span><br><span class="hljs-keyword">if</span>(cnt &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = cnt = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-keyword">if</span>(list.data[i] == val) cnt++;<br>&#125;<br><br><span class="hljs-comment">// 主元超过总元素长度的一半</span><br><span class="hljs-keyword">if</span>(cnt &gt; list.length / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> val;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 不存在主元</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表中未出现的最小正整数"><a href="#顺序表中未出现的最小正整数" class="headerlink" title="顺序表中未出现的最小正整数"></a>顺序表中未出现的最小正整数</h4><p><img src="https://bu.dusays.com/2023/07/18/64b64e770a249.png" alt="image-20230718163359493"></p><h5 id="核心思想-8"><a href="#核心思想-8" class="headerlink" title="核心思想"></a>核心思想</h5><p>桶计数</p><h5 id="核心代码-8"><a href="#核心代码-8" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindMissMin</span><span class="hljs-params">(SqList list)</span></span>&#123;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-type">int</span> * B; <span class="hljs-comment">// 桶</span><br>B = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * list.length);<br><span class="hljs-built_in">memset</span>(B, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * list.length); <span class="hljs-comment">// 赋初始值为0</span><br><br><span class="hljs-comment">// 计数</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-comment">// 合法的范围</span><br><span class="hljs-keyword">if</span>(list.data[i] &gt; <span class="hljs-number">0</span> &amp;&amp; list.data[i] &lt;= list.length)<br>B[list.data[i] - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记出现过</span><br><span class="hljs-comment">// 从桶里面找最小整数</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-keyword">if</span>(!B[i]) <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">王道数据结构顺序表习题</summary>
    
    
    
    <category term="王道数据结构习题" scheme="https://blog.phbeats.cn/categories/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    
    
    <category term="王道数据结构习题" scheme="https://blog.phbeats.cn/tags/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>浅尝手冲咖啡汇总</title>
    <link href="https://blog.phbeats.cn/posts/7da784530acd/"/>
    <id>https://blog.phbeats.cn/posts/7da784530acd/</id>
    <published>2023-07-18T03:52:53.000Z</published>
    <updated>2024-04-05T12:13:13.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浅尝手冲咖啡汇总"><a href="#浅尝手冲咖啡汇总" class="headerlink" title="浅尝手冲咖啡汇总"></a>浅尝手冲咖啡汇总</h3><ol><li><a href="/posts/8635f45e7775">SeeSaw 甜橙子</a></li><li><a href="/posts/cb40af96710f">八平方 晴天娃娃</a></li><li><a href="/posts/c19e2a8a5f1a">辛鹿 SOE 耶加雪菲</a></li><li><a href="/posts/fcab5f014e92">菠萝成子 危地马拉 瑰夏</a></li><li><a href="/posts/32f6f1e29b78">治光师 伊迪朵 耶加雪菲</a></li><li><a href="/posts/bb95ebed2e97">治光师 肯尼亚圆豆</a></li><li><a href="/posts/9c71bc76a9ad">四人咖啡 果丁丁</a></li><li><a href="/posts/0e42f4daeb32">治光师 野草莓意式拼配咖啡</a></li><li><a href="/posts/b8bb6e256940">四人咖啡 粉红佳人</a></li><li><a href="/posts/9d745f9baaa9">辛鹿 号码系列</a></li><li><a href="/posts/89001a5236dd">治光师 沃卡74110 耶加雪菲</a></li></ol><div class="tip home"><p>最近很忙，暂时停更…</p></div>]]></content>
    
    
    <summary type="html">浅尝手冲咖啡汇总</summary>
    
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/tags/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
</feed>
