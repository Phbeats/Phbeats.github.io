<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phbeats-Blog</title>
  
  <subtitle>记录学习历程和生活感悟</subtitle>
  <link href="https://blog.phbeats.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.phbeats.cn/"/>
  <updated>2024-07-04T07:45:16.740Z</updated>
  <id>https://blog.phbeats.cn/</id>
  
  <author>
    <name>Phbeats</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>有向图的拓扑序列</title>
    <link href="https://blog.phbeats.cn/posts/ef6a4cd7f55c/"/>
    <id>https://blog.phbeats.cn/posts/ef6a4cd7f55c/</id>
    <published>2024-07-04T03:16:47.000Z</published>
    <updated>2024-07-04T07:45:16.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-848-有向图的拓扑序列"><a href="#AcWing-848-有向图的拓扑序列" class="headerlink" title="[AcWing.848. 有向图的拓扑序列]"></a><a href="https://www.acwing.com/problem/content/850/">[AcWing.848. 有向图的拓扑序列]</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的有向图，点的编号是 <code>1</code> 到 <code>n</code>，图中可能存在重边和自环。</p><p>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 <code>-1</code>。</p><p>若一个由图中所有点构成的序列 <code>A</code> 满足：对于图中的每条边 <code>(x, y)</code>，<code>x</code> 在 <code>A</code> 中都出现在 <code>y</code> 之前，则称 <code>A</code> 是该图的一个拓扑序列。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <code>n</code> 和 <code>m</code>。</p><p>接下来 <code>m</code> 行，每行包含两个整数 <code>x</code> 和 <code>y</code>，表示存在一条从点 <code>x</code> 到点 <code>y</code> 的有向边 <code>(x, y)</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</p><p>否则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n,m &lt; 10^5</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 3<br>1 2<br>2 3<br>1 3<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1 2 3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>首先，存在拓扑序列，必定是<code>有向无环图</code>，如果是<code>有向有环图一定没有拓扑序列</code>，无向图更别说了。</p><p><code>核心思想</code>：</p><ol><li>n个节点，将入度为0的节点全部入队</li><li>删除掉所有入度为0的节点，在这个过程中，被删掉的节点不妨设为<code>t</code></li><li>遍历<code>t</code>节点的邻边节点，让<code>t</code>节点的所有邻边节点<code>入度减1</code>，如果<code>邻边节点入度被减之后恰好为0</code>，则入队</li></ol><p>此题，n的数量达到了10^5。所以需要使用邻接表，当然邻接矩阵算法也写下来，用于借鉴。<br>时间复杂度分别为<code>o(n + m)</code>和<code>o(n^2)</code>。</p><p><code>需要注意的是</code>：<br>邻接矩阵的重边造成的影响需要在加边的时候进行判断，维护入度，不让重边的出现导致入度混乱。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!g[a][b])&#123;<br>    <span class="hljs-comment">// 加边</span><br>&#125;<br></code></pre></td></tr></table></figure><br>或者，在topsort的时候将重边一起删掉，也意味着重边入度也要减少<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(g[t][j]) --g[t][j],--d[j];<br></code></pre></td></tr></table></figure><br><code>使用邻接表</code>就不需要加判断了，因为邻接表在加边的时候，重边不仅加进去了，在<code>topsort</code>的时候<br>它会处理重边，所以入度一直是正确的。</p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 最大节点的数量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-comment">// 节点数，边数</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> id;<br>    Node * next;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _id): <span class="hljs-built_in">id</span>(_id), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<br>&#125; * head[N]; <span class="hljs-comment">// 邻接表</span><br><br><span class="hljs-comment">// 入度，队列</span><br><span class="hljs-type">int</span> d[N], q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 有向图头插法加边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-comment">// 创建b节点</span><br>    Node * p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(b);<br>    <span class="hljs-comment">// b节点的next指向原来节点a指向的next</span><br>    p -&gt; next = head[a];<br>    <span class="hljs-comment">// 节点a指向节点b</span><br>    head[a] = p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 将所有入度为0的节点加入队列之中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span>(!d[i])<br>            q[++tt] = i;<br>            <br>    <span class="hljs-comment">// 删除掉所有入度为0的节点</span><br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh++];<br>        <br>        <span class="hljs-comment">// 遍历t节点的邻边节点</span><br>        <span class="hljs-keyword">for</span>(Node * p = head[t]; p; p = p -&gt; next)&#123;<br>            <span class="hljs-comment">// 周边节点入度-1，如果入度为0，则加入队列</span><br>            <span class="hljs-keyword">if</span>(--d[p -&gt; id] == <span class="hljs-number">0</span>)&#123;<br>                q[++tt] = p -&gt; id;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// n个节点都应该被删掉一次，那么tt达到 n - 1</span><br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-comment">// a -&gt; b</span><br>        <span class="hljs-built_in">add</span>(a, b);<br>        d[b]++; <span class="hljs-comment">// b的入度+1</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果图有环</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">topsort</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 合法拓扑序列恰好是 0 ~ tt，这里写成 &lt; n也无妨，输出那n个节点(0 ~ n - 1)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>; <span class="hljs-comment">// 假设最多有1000个顶点</span><br><br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">// 邻接矩阵表示图</span><br><span class="hljs-type">int</span> d[N]; <span class="hljs-comment">// 入度数组</span><br><span class="hljs-type">int</span> q[N], tt = <span class="hljs-number">-1</span>, hh = <span class="hljs-number">0</span>; <span class="hljs-comment">// 队列及其指针</span><br><span class="hljs-comment">// 节点数、边数</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 遍历所有节点，入度为0的点全部入队</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!d[i]) &#123;<br>            q[++tt] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 装填完毕，删除当前节点，周边节点的入度-1，看是否为0，如果满足它们也入队</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt) &#123;<br>        <span class="hljs-type">int</span> t = q[hh++];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (g[t][j]) &#123; <span class="hljs-comment">// 如果存在边t-&gt;j</span><br>                <span class="hljs-comment">// 由于重边的影响，比如两次 2 -&gt; 3</span><br>                <span class="hljs-comment">// 需要一口气将3的入度-2</span><br>                <span class="hljs-keyword">while</span>(g[t][j]) --g[t][j],--d[j];<br>                <br>                <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">0</span>) &#123;<br>                    q[++tt] = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        g[a][b]++; <span class="hljs-comment">// 边数+1</span><br>        d[b]++; <span class="hljs-comment">// b的入度+1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">topsort</span>()) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n ; i++) &#123;<br>            cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">有向图的拓扑序列</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>朴素邻接矩阵版Dijkstra求最短路</title>
    <link href="https://blog.phbeats.cn/posts/6d0f7c8cf39d/"/>
    <id>https://blog.phbeats.cn/posts/6d0f7c8cf39d/</id>
    <published>2024-07-01T02:49:03.000Z</published>
    <updated>2024-07-04T07:45:16.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-849-Dijkstra求最短路-I"><a href="#AcWing-849-Dijkstra求最短路-I" class="headerlink" title="[AcWing.849. Dijkstra求最短路 I]"></a><a href="https://www.acwing.com/problem/content/851/">[AcWing.849. Dijkstra求最短路 I]</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 <code>1</code> 号点到 <code>n</code> 号点的最短距离，如果无法从 <code>1</code> 号点走到 <code>n</code> 号点，则输出 <code>-1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>n</code> 和 <code>m</code>。</p><p>接下来 <code>m</code> 行每行包含三个整数 <code>x,y,z</code>，表示存在一条从点 <code>x</code> 到点 <code>y</code> 的有向边，边长为 <code>z</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 <code>1</code> 号点到 <code>n</code> 号点的最短距离。</p><p>如果路径不存在，则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 500</code>,<br><code>1 &lt; m &lt; 10^5</code>,<br>图中涉及边长均不超过10000。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 3<br>1 2 2<br>2 3 1<br>1 3 4<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>朴素Dijkstra</code>可以用来求<code>有向图</code>的<code>单源最短路</code>(一个点到其余点的最短距离，一般默认是求起点1到其余点的距离)，<code>无向图</code>可以看作特殊的<code>有向图</code>，只需要建图的时候<code>建两条边</code>即可。</p><p><code>邻接矩阵</code>版，主要变量名解释:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 最大点、边的数组容量、正无穷</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">100010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-comment">// 点、边</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-comment">// 使用邻接矩阵表示图</span><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-comment">// 源点距离其它点的距离</span><br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-comment">// 该点是否已经属于最短路集合中</span><br><span class="hljs-type">bool</span> st[N];<br></code></pre></td></tr></table></figure></p><p><code>易错点：</code></p><ol><li>main函数一开始<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 很重要的一点！一开始就将邻接矩阵的距离都初始化为无穷大</span><br><span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br></code></pre></td></tr></table></figure></li><li>dijkstra函数内一开始<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化源点距离数组为无穷大</span><br><span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br></code></pre></td></tr></table></figure></li><li>dijkstra逻辑细节别都嵌套到for循环里面去了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 枚举所有点（这层循环要求点的编号也能对应上，从1开始）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>    <span class="hljs-comment">// 如果这个点还没有被纳入最短路集合里面</span><br>    <span class="hljs-comment">// t是-1，或者 有点j存在使得 有更短的路径</span><br>    <span class="hljs-comment">// 更新 t</span><br>    <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))&#123;<br>        t = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 确定这个t点是最短路集合里面的点</span><br>st[t] = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 由于t这个点加入，需要更新一下距离</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>    <span class="hljs-comment">// g[t][j]是边权</span><br>    dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 最大点、边的数组容量、正无穷</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">100010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-comment">// 点、边</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-comment">// 使用邻接矩阵表示图</span><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-comment">// 源点距离其它点的距离</span><br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-comment">// 该点是否已经属于最短路集合中</span><br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 初始化源点距离数组为无穷大</span><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    <span class="hljs-comment">// 源点距离源点它自己的距离为0，源点默认为1</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 枚举所有点（n次），虽然dist[1] = 0，但实际上它还没加入最短路集合中。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-comment">// 保存当前循环，距离最短的点</span><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-comment">// 枚举所有点（这层循环要求点的编号也能对应上，从1开始）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-comment">// 如果这个点还没有被纳入最短路集合里面</span><br>            <span class="hljs-comment">// t是-1，或者 有点j存在使得 有更短的路径</span><br>            <span class="hljs-comment">// 更新 t</span><br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))&#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 确定这个t点是最短路集合里面的点</span><br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 由于t这个点加入，需要更新一下距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-comment">// g[t][j]是边权</span><br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 从源点到终点的距离</span><br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-comment">// 很重要的一点！一开始就将邻接矩阵的距离都初始化为无穷大</span><br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <br>    <span class="hljs-comment">// 建图</span><br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-comment">// 保证没有重边，如果有重边，保留一个最小的边就行</span><br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 求最短路</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">dijkstra</span>();<br>    <br>    <span class="hljs-comment">// 如果结果是正无穷，输出-1，否则输出结果</span><br>    <span class="hljs-keyword">if</span>(res == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">朴素邻接矩阵版Dijkstra求最短路</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>第十四周总结(7/01 - 7/07)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/db40b2dad0b6/"/>
    <id>https://blog.phbeats.cn/posts/db40b2dad0b6/</id>
    <published>2024-06-30T10:40:50.000Z</published>
    <updated>2024-07-04T07:45:16.736Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="d4f5909a4a47e7f79a6e41ddcffdd7c8da6b518b693b103a4adff9b5668ab0f9">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08147c59532d54d08f48755ebc43be9739e8ff98267cb1bed9efe9c4b40f47e84b22cf58a8f15cc8c52a2cd7e58f2b15aff58daf2425eedca3f9aed9e40db2d22eb050eea48a82cb726c40209a0a25d470b0002aa3e0ff848b07644019e9ee5f35426ffe3535dd0a39f3aad1bb140b33856c2f85ac3a1587ec10fd7ee7908d14381699f2284632748cc65165c7a2cc916b6f937f088c7e4f8686b9f06f8e488b70e8bc0072b313ae1bfc32f09e648860374c11051d94a934d680e302d8f7863bc15d6b47bcbb45c1dcb8863456c23b47323798f033fcaff831603a4cb12250db1834a15fba84c2ac8529fc8bc841c8e83578182235a9eb8e4cd0f95c840a4cbd8fdbd30bb832e1857c0b4efb36e98d09a53ad9e8a696acf266b7453867064b3f023eca715f0e7ff08bd0a034656044f43436a4c56b8ca52ffbdfc0badf7b3143926ddce53a3127b253028b94bb2e740ea831697936c1e4e0bacd6a3cf5ee8a98319419666cfdff3dff8dae70c62dcb8f529916f2f7be0331fff0f9ee02b34e2ff7c346305a0512a936da714ce702606c720d15774d1da274bed6ad97604fda1c384ee19c3929048ec5b99d37a691f92d02a52938205db27fa0701d426a6a960c2d4095b996ff15abc75b1548686bfa7e5babac8c83032a1752ec07400ee5079537b594451c17c10b902f37eeb75e2fcf11f6a4060c5f14e733ed92197c536743dc823faf46338f14073474c7ff74ad5841acbeeab3770335922dcd26e6f4a463bda94b1167bdfb83fda96494e622c8bfb94d462741f315cc4f6ff3d9c9aaa541abc92ae12e5603b7d7fbdc877c2252968c631e236b9fa325210aad50a310faff8348133714910018af4b122c388f41c5235d9d66760701df6a1bbed9cbbf37c1d6f5fc057f79fc741108ea0f0d14366213012c85b331a9cdf0498bc2b58cb4f4931b50875e1bc5656ae1dc1267ff0f3693bfe6263be8b75cd26cce4bceb1c787cd541ab992b577dd9944d0b05710d10d79963177cd1c85db1d86425352dd5ad048bfa80f50c74b3d21f38d003a6e651774796c0d1a87b70fd68f004fcfd934737e6a4e042e2b6f378f16ec20a85781a0040e2a29c957c95e6cafc9ed25be63b8d3d8b92930e60a35b01864ce74ce8f93e204f53ab72b580f86d2ea1fb65bb4ae034159bc8e7898616bb9efc333a035fc5d8bbdff30207265042ff664e798f762016a8267ce0e7c36f24408505cf33a8af7632cb52f655564e377855bbf5e4853024da75d60bd50cbb1b86440e72562f1eded2ff6d582c9df44b1abaabdca96b43cde6c09c187b16b0204d9fc0cd8af9a91f94913bd2e18368f778854329f29b92da523443e29957b73af36774c2885efb1ea39f051ea98fe8d8226b22d4a9ab90f28b4eb26563d4a5e7f0900c3b308c03c7a7e2dd95dd643dcffb572ebdda5582d68de87c34925dba62902ad59d36219d4c245179e006fcf1e0ef7d393cad00e6d3961a335760f4e6c0ed148681e2220c00a5d24df9e9d88f625c11fed88d7f2dc0f30ead32d2655f9e1c63fa36503b0315817de84af6494ab51a9faf223c128c16e27a8e4d247a3b7b2865fa3b39d0cfba28d22e5519161f603051363340cff64d9c127350eb5924f9b199767d3250a8876f51fb5542e643d2774684b02aa24eca4feeafc26815b47a71ffdcb0bcce51dd7a4e3751fed67a07cfeda8291ff6c797b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十四周总结(7/01 - 7/07)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>游戏（约瑟夫）</title>
    <link href="https://blog.phbeats.cn/posts/08d4ec6ea429/"/>
    <id>https://blog.phbeats.cn/posts/08d4ec6ea429/</id>
    <published>2024-06-27T14:27:25.000Z</published>
    <updated>2024-07-04T07:45:16.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing3253-游戏"><a href="#AcWing3253-游戏" class="headerlink" title="[AcWing3253. 游戏]"></a><a href="https://www.acwing.com/problem/content/3256/">[AcWing3253. 游戏]</a></h1><p>有 <code>n</code> 个小朋友围成一圈玩游戏，小朋友从 <code>1</code> 至 <code>n</code> 编号，<code>2</code> 号小朋友坐在 <code>1</code> 号小朋友的顺时针方向，<code>3</code> 号小朋友坐在 <code>2</code> 号小朋友的顺时针方向，……，<code>1</code> 号小朋友坐在 <code>n</code> 号小朋友的顺时针方向。</p><p>游戏开始，从 <code>1</code> 号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加 <code>1</code>。</p><p>若一个小朋友报的数为 <code>k</code> 的倍数或其末位数（即数的个位）为 <code>k</code>，则该小朋友被淘汰出局，不再参加以后的报数。</p><p>当游戏中只剩下一个小朋友时，该小朋友获胜。</p><p>例如，当 <code>n=5, k=2</code> 时：</p><ul><li><code>1</code> 号小朋友报数 <code>1</code>；</li><li><code>2</code> 号小朋友报数 <code>2</code> 淘汰；</li><li><code>3</code> 号小朋友报数 <code>3</code>；</li><li><code>4</code> 号小朋友报数 <code>4</code> 淘汰；</li><li><code>5</code> 号小朋友报数 <code>5</code>；</li><li><code>1</code> 号小朋友报数 <code>6</code> 淘汰；</li><li><code>3</code> 号小朋友报数 <code>7</code>；</li><li><code>5</code> 号小朋友报数 <code>8</code> 淘汰；</li><li><code>3</code> 号小朋友获胜。</li></ul><p>给定 <code>n</code> 和 <code>k</code>，请问最后获胜的小朋友编号为多少？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一行，包括两个整数 <code>n</code> 和 <code>k</code>，意义如题目所述。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行，包含一个整数，表示获胜的小朋友编号。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于所有评测用例，<code>1 ≤ n ≤ 1000</code>，<code>1 ≤ k ≤ 9</code>。</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 2<br></code></pre></td></tr></table></figure><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">7 3<br></code></pre></td></tr></table></figure><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">4<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>这是经典的<code>约瑟夫问题</code>。采用数组模拟，但要注意：没有环，但是怎么实现环的效果呢？<br><code>采用重新入队的方式</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, k;<br>    <br>    <span class="hljs-comment">// n个小朋友，幸运数字k</span><br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-comment">// 小朋友排队等待枪毙</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) q[++tt] = i;<br>    <br>    <span class="hljs-comment">// 编号</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// n个小朋友枪毙 n - 1 个,枪毙的号码是幸运数字的k的倍数或末尾数为k，剩下一个</span><br>    <span class="hljs-comment">// 以小朋友剩下个数为循环跳出条件 tt - hh = 0的情况代表队列还有一个小朋友</span><br>    <span class="hljs-keyword">while</span>(tt - hh &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 如果当前编号的小朋友不该枪毙</span><br>        <span class="hljs-keyword">if</span>(j % k &amp;&amp; j % <span class="hljs-number">10</span> != k)&#123;<br>            <span class="hljs-comment">// 重新排队</span><br>            q[++tt] = q[hh];<br>            ++hh;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ++hh; <span class="hljs-comment">// 该枪毙就枪毙</span><br>        &#125;<br>        j++;<br>    &#125;<br>    <span class="hljs-comment">// 输出剩下的唯一一个在队首的小朋友</span><br>    cout &lt;&lt; q[hh] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">游戏（约瑟夫）</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="队列" scheme="https://blog.phbeats.cn/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>第十三周总结(6/24 - 6/30)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/d5f2e2961333/"/>
    <id>https://blog.phbeats.cn/posts/d5f2e2961333/</id>
    <published>2024-06-26T10:40:59.000Z</published>
    <updated>2024-07-04T07:45:16.736Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="09f894fe7ec59ac6645c91ea07b7a111a7a3798f069806cdac791ec924e6c7a9">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08140bf1b865a9bb93d44a17eb956a683bb8b5bd30e57ee3a4cc89c4a5728505ffc646f33f78a2bc0245e60f7b2c80a47000fbf0a2fef7cd843b851041c54b3d9a0ed35e4abc888a7693654c9a78fc8d65caa651593b2ed8f6668429cde5394266dc4987c4d4da136c446db5babc754301104691ca2447db7b170bec4ca925b9ed716081a4327be6c230823f8f586bd9f0051587645bdb8d8e2161b940ef0ffeaa416e09c6c86d0344a605665336d48a68fcbe82175e5b7b9f569ccc95e8884d87e34ee47ed82180612bd4046015bdb7cb8dfa9f2fb4ea8b313ab3edf1ba4843abbd14d7eb86940a153e86eeec225af50b4630c9138f2a63ce2bec40a8e7caf6be409d60752221b6ae2bc205d081d4a8d3a7bb127ee89b7004f30dce9b66e4beb44e817eb2716a5b71ab6509213225c215906272774dc36363997e7e6a493cd4319a2004d76b7fb082d613f841494c8512cee586c05f9b9eae91adcfcb43375dc3abc9fa4bb0340e6b4e29911b3b510b4463e57bf938d8203b47549a3d9c571a1767719a8ccf294216f952806f0e85c069f5ed7ba87f7d093aff00c254747167f40a4aa498c6e1ac0a5e3248d74352d23a18aac0da098635a081842d8bf634cf629cec3f5cafbcf78d915bd18ef2a7ecbbe55d6d2149cdc0747aa58a9f0baa1fe6b7294f47840f4770a08db905e0f0027561ed7cfcc3f0d0eacaa5607dfc26fd7d2765a9b21d7c615aea9c49a7d16072a504815cc35b012509818c33c68d34cdd708553b9c5c0ef9d9317104a89537f1b757cd491e0867d8ab33a8b08b3b3cb76b70661da9c47e7a4a84445584300d95baf1c23a1da840d0a8a843e2950207e2e3fce87a15c71117d36d663f15f5355133505decd493a28c588f1dee18145fa3434752ec73da7d23f7d9b2fac38a889f938f2d4c90e1626b39e53225f221313839c565368bc988153637a100f751dfcb7791723bce5642bd7437762861a05549cef7a737ebdbce5ff2e4db9be3cadb293a42155aeb0ff5fb6ae20230012fb703a302092f88d4e295200d3baf4a026394a75973e8f84f6ef1ad09ef2c128e6a7114304fdda1f4d3ec7e39377b0a1c8b28553ea76e34437b70d3ca8579002486f725e427364021c6622e99e53716ca11520fee474e65ee163706f353d3e37785627418908ab14eb28de56b42ce3cdd0e330d1aa1f4a954c8cd23a35813dbe6479185ade435557c3a82d957c774c944daf300f5c118c3f99cb916ad2440bf22ea76b2e50521c81b6b6c488d3cc99475c9de363d90ab149fa12fb52026de0eda3d9ffeb7b99721d025fe768e85b4947dfb230c44724accbea69c9cff1af6c6ef28e68fd9c74a63402c23ed84a0e05f857f1f18ff3d9cfd6dad6f13eba54063300ee7200247efce1098b643cc6852d2c1b2f36c4f533a48eb9715a451e953e04cdbe04b77972c36c25f3874f95a402566ff6a9dcc0ef273b547adf98ff43df1f2879b4b3ef410577b9f8eefcbf88bcafb41a9d973f227539218af1534b9b7057971dec016f5c2581903c6f4e420db6a2a0f281bcb76450b0dc975301b6750161dda64a78e6d7ef05bcb5de4a12a059bf3fdc443f054ce4c61928f86e42bad1372bf67a309eb82341114b17ad040ea5b5eeea066cd</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十三周总结(6/24 - 6/30)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口内求最大值和最小值</title>
    <link href="https://blog.phbeats.cn/posts/37333600838e/"/>
    <id>https://blog.phbeats.cn/posts/37333600838e/</id>
    <published>2024-06-17T03:13:21.000Z</published>
    <updated>2024-07-04T07:45:16.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-154-滑动窗口内求最大值和最小值"><a href="#AcWing-154-滑动窗口内求最大值和最小值" class="headerlink" title="[AcWing. 154. 滑动窗口内求最大值和最小值]"></a><a href="https://www.acwing.com/problem/content/156/">[AcWing. 154. 滑动窗口内求最大值和最小值]</a></h1><p>给定一个大小为 <code>n &lt; 10^6</code> 的数组。</p><p>有一个大小为 <code>k</code> 的滑动窗口，它从数组的最左边移动到最右边。</p><p>你只能在窗口中看到 <code>k</code> 个数字。</p><p>每次滑动窗口向右移动一个位置。</p><p>以下是一个例子：</p><p>该数组为 <code>[1 3 -1 -3 5 3 6 7]</code>，<code>k</code> 为 <code>3</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">窗口位置</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th></tr></thead><tbody><tr><td style="text-align:center">[1 3 -1] -3 5 3 6 7</td><td style="text-align:center">-1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1 [3 -1 -3] 5 3 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1 3 [-1 -3 5] 3 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">1 3 -1 [-3 5 3] 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">1 3 -1 -3 [5 3 6] 7</td><td style="text-align:center">3</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">1 3 -1 -3 5 [3 6 7]</td><td style="text-align:center">3</td><td style="text-align:center">7</td></tr></tbody></table></div><p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含两行。</p><p>第一行包含两个整数 <code>n</code> 和 <code>k</code>，分别代表数组长度和滑动窗口的长度。</p><p>第二行有 <code>n</code> 个整数，代表数组的具体数值。</p><p>同行数据之间用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出包含两个。</p><p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p><p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">8 3<br>1 3 -1 -3 5 3 6 7<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1 -3 -3 -3 3 3</span><br>3 3 5 5 6 7<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>滑动窗口，每次滑动一个单位，<code>窗口内求最大最小值</code>。</p><p>借图：</p><p><img src="https://cdn.acwing.com/media/article/image/2022/03/05/55289_0923cf569c-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.PNG" alt="滑动窗口"></p><p><code>题外话</code>：在一个从小到大排列的数列中，若左边的数比右边的数大，就称作逆序数啊，如：1，3，5，4，6 中，5就是逆序数啊，看看5在题目中有没有用，若是没有用，那该题就有单调性。</p><ol><li><p>使用双端单调队列：利用双端单调队列来高效维护滑动窗口的最小值和最大值。</p></li><li><p>维护窗口边界：在每次滑动时，检查队列头部的元素是否已经滑出窗口范围，如果是则移除。</p></li><li><p>保持单调性：<br>对于最小值，保持队列单调递增，移除队列中比当前元素大的元素。<br>对于最大值，保持队列单调递减，移除队列中比当前元素小的元素。<br>插入新元素：将当前元素的索引插入队列。</p></li><li><p>输出结果：当窗口大小达到要求时，队首元素即为当前窗口的最小值或最大值。</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-comment">// 数组和双端单调队列</span><br><span class="hljs-type">int</span> a[N], q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 数组元素个数和滑动窗口的长度</span><br><span class="hljs-type">int</span> n, k;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br><br>    <span class="hljs-comment">// 输入元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br><br>    <span class="hljs-comment">// 求滑动窗口的最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 维护窗口，i - k + 1 是窗口的左边界</span><br>        <span class="hljs-comment">// 如果队首元素的索引已经小于当前窗口的左边界</span><br>        <span class="hljs-comment">// 说明该元素已经滑出窗口，需要将队首指针 hh 向后移动以排除这个元素</span><br>        <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) ++hh;<br>        <br>        <span class="hljs-comment">// 保持队列单调递增，排除不可能的最小值</span><br>        <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) --tt;<br>        <br>        <span class="hljs-comment">// 当前元素入队</span><br>        q[++tt] = i;<br><br>        <span class="hljs-comment">// 输出当前窗口的最小值</span><br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= k) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 重置队列指针</span><br>    hh = <span class="hljs-number">0</span>;<br>    tt = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">// 求滑动窗口的最大值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 维护窗口，i - k + 1 是窗口的左边界</span><br>        <span class="hljs-comment">// 如果队首元素的索引已经小于当前窗口的左边界</span><br>        <span class="hljs-comment">// 说明该元素已经滑出窗口，需要将队首指针 hh 向后移动以排除这个元素</span><br>        <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) ++hh;<br><br>        <span class="hljs-comment">// 保持队列单调递减，排除不可能的最大值</span><br>        <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) --tt;<br><br>        <span class="hljs-comment">// 当前元素入队</span><br>        q[++tt] = i;<br><br>        <span class="hljs-comment">// 输出当前窗口的最大值</span><br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= k) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">滑动窗口内求最大值和最小值</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="单调队列" scheme="https://blog.phbeats.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>第十二周总结(6/17 - 6/23)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/a2f37b955b1d/"/>
    <id>https://blog.phbeats.cn/posts/a2f37b955b1d/</id>
    <published>2024-06-16T09:37:30.000Z</published>
    <updated>2024-07-04T07:45:16.736Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ad25a5db3d4c415dbd1b34b8825422846845a22dbb31a514a09e779f110114ef">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08146a9702094cd1a87e411844db555d73d0d99577c1ad9192add1e11493d1c76a7191b633bdc9d9aa5df18e842899784479f8bba74239f5d00921a78e4546707d54def317dd8679f14d5bdf60d3e0bc4ba8cab6453e59c2ebcded5b7ccbd6c117516ff3bf706e19766ce97c4e694461b07d7451a1129e843298860d835d7916d23eccbbad19246234795e44a96eb8e78c9fdc24c03b3052438c34253c3e71064ea8e3ec5d6fa13c84e18496b5ec1e1781b5aa61e9343dc5dc5fa6d4a2164cdc753410f081a5adc3b345c142d25ccf6063800728650b787c54ad0b2df2ac185480f1bfb7125ad8ad7140a5b126a085450379c2f7cb7bb9ebdb91e73cbc514e31bf6e11df2be3b92bd99a29e9145a76ed8e4ea91558c2864bb0a0cb85ead8ec7ceaa1324888d9706276eba597567083868431124639f7daefc373cd48e57eb5c48d373cf081c9ccbfbea848760f4386ecb581fc34aee73a613765befb1187e8f68b103f8720e98b4e6ae3c02de4b49cc8de65547b88daf197dcd76e9fff56e0afd7bad82f68bc02047d1c59068dc2c914d8c05848516da156315099fcdac6a37e5d12e257d43e3ec518743a62a03a516f863d07225e9311edde5f681542e96d709e915b1ac43752c1169dc6da36ed5908ec0e7810383a82d3b8fb80ca74f40e1fcc065de3dd09a4125019897fbfb40279c3bab43a56ab2e861a3a56a2db24b7695af338e08f49a539838d8b9117bc7159e1018ca6ccb5b24c9042e67aa4cc40f352f805bd4f77dfcb45ec693bc895fbc0169eeed7aadf3debd6991f5d5ce798ad253c8380697288c3cb31cc6e80bb3a2b52f8811cd0408840a6b9a5bb4c774f4aee25f4fc0814401afb664efc2dee616ce63ec99a5c455322ae2cf159af06386fd4614d94511b2d252058c8003bcf4e157aa45f5bc4f20178b2285c7d70c5f199231e9e6ba4734662412308dbf2e50e2e36bb63b4ef05c31b79a78d94598e44339c609da9cc0ee0f33821e25b48d73c381e2c46ef645b18c90fd71400d25bf160244da0ff038ea010fa0240edb573a773efaa86b407dea9c5dd1f122389cceb5ac7f0e1422281a5dfabbde836609ba4a407a7bed81f72e7f7fae331082f94043f5264f71b45d14c0c78f8adb6bcbb4d2cf0df42c4a8ca5fe165af913608b6df4bd92996d9f9ea0ee115ddc2b9e96744f8745537337d1978749ce2d9b9fafab574a4f121cdaea092140ac70af03466c15cebcbef12c61e0bc54f870ecd82eea28e904f329c9fdeec726f2d9b0b3d90b136879513b32db196a2333001826d196d065f16a010335d87e8f252e4f41418b66a1f492c2c81512d0778ef2ffbdaaa90897c07a4516b85b9d4ced8a14d6e40d91b4ffdf123762f86e1b22e8d0aff63deba99cc303ec1225d8bcfcfcaf1574d33167f273216f203541de0e9805e9bba5609ccdfe314720bd8c4815a4ecab64157eaa9d5926a3030151fd8a5e3f8af2e37b5481789ec41c9eb84b1d20a8f310f2c7e30f7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十二周总结(6/17 - 6/23)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://blog.phbeats.cn/posts/3be02f72e427/"/>
    <id>https://blog.phbeats.cn/posts/3be02f72e427/</id>
    <published>2024-06-11T12:19:11.000Z</published>
    <updated>2024-07-04T07:45:16.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-20-用两个栈实现队列"><a href="#AcWing-20-用两个栈实现队列" class="headerlink" title="[AcWing. 20. 用两个栈实现队列]"></a><a href="https://www.acwing.com/problem/content/36/">[AcWing. 20. 用两个栈实现队列]</a></h1><p>请用栈实现一个队列，支持如下四种操作：</p><ul><li>push(x) – 将元素x插到队尾；</li><li>pop() – 将队首的元素弹出，并返回该元素；</li><li>peek() – 返回队首元素；</li><li>empty() – 返回队列是否为空；</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用栈的标准操作：<code>push to top</code>，<code>peek/pop from top</code>, <code>size</code> 和 <code>is empty</code>；</li><li>如果你选择的编程语言没有栈的标准库，你可以使用list或者deque等模拟栈的操作；</li><li>输入数据保证合法，例如，在队列为空时，不会进行<code>pop</code>或者<code>peek</code>等操作；</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>每组数据操作命令数量 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyQueue queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyQueue</span>();<br><br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>queue.<span class="hljs-built_in">peek</span>();  <span class="hljs-comment">// returns 1</span><br>queue.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// returns 1</span><br>queue.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// returns false</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2024/06/11/66684222ae1fc.png" alt="image-20240611202459520"></p><p><img src="https://bu.dusays.com/2024/06/11/666842358a6bf.png" alt="image-20240611202525947"></p><p>借助辅助栈，可以让<code>主栈只剩下一个元素</code>，然后拿一个变量保存它后执行<code>pop</code>或者<code>peek</code>逻辑返回它。</p><p>过程中，拿变量保存它之后，需要<code>将辅助栈中的元素们回到主栈中</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 存放数字的主栈</span><br>    <span class="hljs-type">int</span> stk[<span class="hljs-number">100010</span>];<br>    <span class="hljs-comment">// 辅助栈</span><br>    <span class="hljs-type">int</span> tmp_stk[<span class="hljs-number">100010</span>];<br>    <span class="hljs-comment">// 主栈的</span><br>    <span class="hljs-type">int</span> tt;<br>    <span class="hljs-comment">// 辅助栈的</span><br>    <span class="hljs-type">int</span> tmp_tt;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br>        tt = <span class="hljs-number">0</span>;<br>        tmp_tt = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        stk[tt++] = x;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 存放数字的栈只剩下一个元素，其它的全部入栈辅助栈里面</span><br>        <span class="hljs-keyword">while</span>(tt)&#123;<br>            tmp_stk[tmp_tt++] = stk[--tt];<br>        &#125;<br>        <span class="hljs-comment">// 被删除的元素</span><br>        <span class="hljs-type">int</span> k = stk[tt];<br>        --tt;<br>        <br>        <span class="hljs-comment">// 然后将辅助栈内的元素移回去</span><br>        <span class="hljs-keyword">while</span>(tmp_tt)&#123;<br>            stk[tt++] = tmp_stk[--tmp_tt];<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 存放数字的栈只剩下一个元素，其它的全部入栈辅助栈里面</span><br>        <span class="hljs-keyword">while</span>(tt)&#123;<br>            tmp_stk[tmp_tt++] = stk[--tt];<br>        &#125;<br>        <span class="hljs-comment">// 此时栈顶元素</span><br>        <span class="hljs-type">int</span> k = stk[tt];<br>        <span class="hljs-comment">// 将辅助栈内的元素移回去</span><br>        <span class="hljs-keyword">while</span>(tmp_tt)&#123;<br>            stk[tt++] = tmp_stk[--tmp_tt];<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !tt;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * bool param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">用两个栈实现队列</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="栈" scheme="https://blog.phbeats.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>第十一周总结(6/10 - 6/16)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/9289cdf65c7c/"/>
    <id>https://blog.phbeats.cn/posts/9289cdf65c7c/</id>
    <published>2024-06-09T14:44:21.000Z</published>
    <updated>2024-07-04T07:45:16.736Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="26acdd6576cffb00f722a00e85d9401b49488f76c3ebac4cf745830086eec53a">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08147449db493c1f9e603c98a3b5133ce4de802616652d3f205977b31755f193b35ba184f76bc90f80929641f24f6b91e895a765e7d8e4403777988edcec349e04f5571adcf038631137f1f40ff2c1a607071c06052e689aa7fd460c4bf34e06596844db7515db5bd8181668fa6d121bc8800e28aea4c193c09ed8b1d37d89d434178db3f51f67da77b3d69bf02f3a8306fe7a9ff4c1d538c162f56c034c9d5d1dd4c0daba590d9ff30aefa71d02cb4fc38c78b11bf8258fa0730330b547fd5c49dc16e4e0aeccbe1717e50bd63b126b45422fafc40ec9ee96dea81017a543a48baa2244a0bbcdbf09df392328fd9d051ae9e65a479e696875ca13d7b64613b589bfd9efb1d533527efcdc2032746ad305240093b86ccb0c3a74d57ac096ae1b830549d7e0f8e913b331df1e479667022bb2a28a03d7a384f525f0a5083102d6dd3e418d59d1b7edbc0122c4cbcc25bcc053c39058cf2af4e6f813adb027378e46a0deab289cddf2b756a99ec43b6082df3182e3fd92ad4de202a4791cf714ed4b96c2f3763ceb5661fb71a63cc73af4e2bd089ed2e6980311f613354be4961b2ccaff9949b12c8a67368d05b107b8e15256431d561d233d51cd58ddbcb16ed1cf7be6253cca030d4ddd0da13485121a65391f34a9716bd417fed2dadf723d2ba9f7045890679eb1d4bc56626cc7722fa0f1833e001364f1870f111390e6701a639509b7c55883f5e2cf7f63f0c0f27f5b5c7ace70f638b27481dfdf971688162990a1f7c81c70701c04797bffbb9dfd1ceec871f8dfbd71d8cebc394edbb51c04172e8c30d2e31c53d60e737faa9977f662b9272f57646d5896452dafa06c60d09f3b0ed69d56808164be825db84446638cc7851c797c40a0ef597f933110b18773442fa0c02735a7c1e3a6f9591ed975250ec8cb9f2a4eff19a4f7594542c1aa3b902532886354a506090474476c98b5710ea2dbe581e1c48a212296523b95dce1201c9854a77a7213176ab3cb4a78ea01bf628c9465b68d628733c2de4ccdae2ec5304a65112b5de905a0907a3b50e208f6935c90df08d4ae5118dce2f67e9e4d101aac6c0313624aa662049e912f905f88adbaa40fcbe8082781cc99a9b8ac221ed6679b5b7ffdb261c2b42bbb77d307bd04a9df86655d42011060cff589e5d261cb3153f7b80589ade19ae650209a20c77696bb96e1b700d701bc14ba707dc40ac281f810bf18c8309490630e9e205aa05d0f5f9a0bb633a290542a416823d0b82ada65ff48720be4d6cd7877ba9f0b04cb94f9ac542cafc35cc79615a1e265ad70daaebdf96e8ec40d1bd83a908065</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十一周总结(6/10 - 6/16)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>直方图中最大矩形</title>
    <link href="https://blog.phbeats.cn/posts/410b68f36e34/"/>
    <id>https://blog.phbeats.cn/posts/410b68f36e34/</id>
    <published>2024-06-09T09:27:51.000Z</published>
    <updated>2024-07-04T07:45:16.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-131-直方图中最大的矩形"><a href="#AcWing-131-直方图中最大的矩形" class="headerlink" title="[AcWing]131. 直方图中最大的矩形"></a><a href="https://www.acwing.com/problem/content/description/133/">[AcWing]131. 直方图中最大的矩形</a></h1><p>直方图是由在公共基线处对齐的一系列矩形组成的多边形。</p><p>矩形具有相等的宽度，但可以具有不同的高度。</p><p>例如，图例左侧显示了由高度为 <code>2,1,4,5,1,3,3</code> 的矩形组成的直方图，矩形的宽度都为 <code>1</code>：</p><p><img src="https://cdn.acwing.com/media/article/image/2019/01/14/19_eac6c46017-2559_1.jpg" alt="2559_1.jpg"></p><p>通常，直方图用于表示离散分布，例如，文本中字符的频率。</p><p>现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。</p><p>图例右图显示了所描绘直方图的最大对齐矩形。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含几个测试用例。</p><p>每个测试用例占据一行，用以描述一个直方图，并以整数 <code>n</code> 开始，表示组成直方图的矩形数目。</p><p>然后跟随 <code>n</code> 个整数 <code>h_1，…，h_n</code>。</p><p>这些数字以从左到右的顺序表示直方图的各个矩形的高度。</p><p>每个矩形的宽度为 <code>1</code>。</p><p>同行数字用空格隔开。</p><p>当输入用例为 <code>n=0</code> 时，结束输入，且该用例不用考虑。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。</p><p>每个数据占一行。</p><p>请注意，此矩形必须在公共基线处对齐。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 100000</code>,<br><code>0 &lt; h_i &lt; 1000000000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">7 2 1 4 5 1 3 3<br>4 1000 1000 1000 1000<br>0<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">8<br>4000<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>对于每个矩阵，基于单调栈的算法，<code>从左往右，从右往左，可以算出各自矩阵的最近且最小的矩阵位置是多少</code>。</p><p><img src="https://bu.dusays.com/2024/06/09/6665b6961d895.png" alt="image-20240609203648376"></p><p><img src="https://bu.dusays.com/2024/06/10/666703e9110d9.png" alt="image-20240610214630320"></p><p>边界预处理在这里的作用主要是为了避免在处理第一个和最后一个矩形时出现特殊情况。具体来说，当你从左到右遍历矩形并尝试找到它们的左边界时，对于第一个矩形（i=1），如果没有额外的预处理，你就没有办法找到一个左侧比它矮的矩形来确定其左边界，因为 h[0] 不存在。同样地，当你从右到左遍历矩形并尝试找到它们的右边界时，对于最后一个矩形（i=n），如果没有额外的预处理，你也没有办法找到一个右侧比它矮的矩形来确定其右边界，因为 h[n+1] 不存在。</p><p>具体来说：</p><p>当从左到右遍历时，对于第一个柱子 h[1]，如果没有 h[0] 作为哨兵，并且 h[1] 是所有柱子中最高的，那么 l[1] 将不会被正确设置（因为没有比它矮的柱子在左侧）。但是，由于我们设置了 h[0] = -1（一个比所有实际柱子都小的值），l[1] 就会被正确地设置为 0（或者说，没有柱子在 h[1] 的左侧）。<br>当从右到左遍历时，对于最后一个柱子 h[n]，如果没有 h[n+1] 作为哨兵，并且 h[n] 是所有柱子中最高的，那么 r[n] 将不会被正确设置（因为没有比它矮的柱子在右侧）。但是，由于我们设置了 h[n+1] = -1，r[n] 就会被正确地设置为 n+1（或者说，没有柱子在 h[n] 的右侧）。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 爆int</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-comment">// h装每个矩形的高，l装每个矩形的左边界，r装每个矩形的右边界</span><br><span class="hljs-comment">// q是双端单调队列</span><br><span class="hljs-type">int</span> h[N], l[N], r[N], q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    <br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n, n)&#123;<br>        <span class="hljs-comment">// 输入每个矩形的高</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; h[i];<br>        <br>        <span class="hljs-comment">// 让h[0]和h[n + 1]值为 -1，这样就不用处理边界问题了（什么边界问题？）</span><br>        h[<span class="hljs-number">0</span>] = h[n + <span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br>        q[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 开始维护单调队列，从左往右</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-comment">// 维护</span><br>            <span class="hljs-keyword">while</span>(tt &amp;&amp; h[i] &lt;= h[q[tt]]) tt--;<br>            <span class="hljs-comment">// 左边界</span><br>            l[i] = q[tt];<br>            q[++tt] = i;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 准备维护单调队列，从右往左</span><br>        tt = <span class="hljs-number">0</span>;<br>        q[<span class="hljs-number">0</span>] = n + <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i ; i--)&#123;<br>            <span class="hljs-comment">// 维护</span><br>            <span class="hljs-keyword">while</span>(tt &amp;&amp; h[i] &lt;= h[q[tt]]) tt--;<br>            <span class="hljs-comment">// 右边界</span><br>            r[i] = q[tt];<br>            q[++tt] = i;<br>        &#125;<br>        <br>        ll res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, (ll)h[i] * (r[i] - l[i] - <span class="hljs-number">1</span>));<br>        &#125;<br>        <br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">直方图中最大矩形</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="单调队列" scheme="https://blog.phbeats.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="单调栈" scheme="https://blog.phbeats.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://blog.phbeats.cn/posts/c2dbcb3c40df/"/>
    <id>https://blog.phbeats.cn/posts/c2dbcb3c40df/</id>
    <published>2024-06-05T13:28:05.000Z</published>
    <updated>2024-07-04T07:45:16.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-830-单调栈"><a href="#AcWing-830-单调栈" class="headerlink" title="[AcWing]830. 单调栈"></a><a href="https://www.acwing.com/problem/content/832/">[AcWing]830. 单调栈</a></h1><p>给定一个长度为 <code>N</code> 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 <code>-1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>N</code>，表示数列长度。</p><p>第二行包含 <code>N</code> 个整数，表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 <code>N</code> 个整数，其中第 <code>i</code> 个数表示第 <code>i</code> 个数的左边第一个比它小的数，如果不存在则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; N &lt; 10^5</code><br><code>1 &lt; 数列中元素 &lt; 10^9</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5<br>3 4 2 7 5<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1 3 -1 2 2</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>给定一个序列，求每一个数的左边离它最近的<code>小于等于</code>或<code>大于等于</code>它的数是什么。<br><code>单调栈需要维护一个单调的栈</code>。</p><p>注意：插入元素时需要与栈顶元素比较，<code>以单调增为例子</code>。<br><code>更小则取而代之全部</code>，否则，<code>正常入栈</code>。</p><ol><li><code>筛选操作</code>：先保证栈顶元素就是新插入元素离得最近且最小的元素</li><li><code>输出操作</code>：输出离x最近且最小的元素，如果没有就输出-1</li><li><code>入栈操作</code>：x入栈，栈从数组下标1开始使用</li></ol><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(n --)&#123;<br>        <span class="hljs-type">int</span> x; cin &gt;&gt; x;<br>        <br>        <span class="hljs-comment">// 维护栈，单调递增</span><br>        <span class="hljs-comment">// 单调栈不为空且压栈元素x比栈顶元素小，则删除它们</span><br>        <span class="hljs-keyword">while</span>(tt &amp;&amp; x &lt;= stk[tt]) tt--;<br>        <br>        <span class="hljs-comment">// 单调栈顶剩下的总是离x最近的，比x小的数</span><br>        <span class="hljs-comment">// 单调栈里面还有元素</span><br>        <span class="hljs-keyword">if</span>(tt) cout &lt;&lt; stk[tt] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <br>        stk[++tt] = x;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码实现2（单调队列）"><a href="#代码实现2（单调队列）" class="headerlink" title="代码实现2（单调队列）"></a>代码实现2（单调队列）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> a[N], q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n; cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-comment">// 维护单调队列</span><br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) --tt;<br>        <br>        <span class="hljs-comment">// 如果单调队列不为空，队尾是最近的，比当前更小的元素</span><br>        <span class="hljs-keyword">if</span>(hh &lt;= tt) cout &lt;&lt; a[q[tt]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;-1 &quot;</span>;<br>        <br>        q[++tt] = i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">单调栈</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="单调队列" scheme="https://blog.phbeats.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="单调栈" scheme="https://blog.phbeats.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>包含min函数的栈</title>
    <link href="https://blog.phbeats.cn/posts/9c0080b038b9/"/>
    <id>https://blog.phbeats.cn/posts/9c0080b038b9/</id>
    <published>2024-06-04T12:46:59.000Z</published>
    <updated>2024-07-04T07:45:16.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-41-包含min函数的栈"><a href="#AcWing-41-包含min函数的栈" class="headerlink" title="[AcWing 41. 包含min函数的栈]"></a><a href="https://www.acwing.com/problem/content/90/">[AcWing 41. 包含min函数的栈]</a></h1><p>设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。</p><ul><li>push(x)–将元素x插入栈中</li><li>pop()–移除栈顶元素</li><li>top()–得到栈顶元素</li><li>getMin()–得到栈中最小元素</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>操作命令总数 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">MinStack minStack = new MinStack();<br>minStack.push(-1);<br>minStack.push(3);<br>minStack.push(-4);<br>minStack.getMin();   --&gt; Returns -4.<br>minStack.pop();<br>minStack.top();      --&gt; Returns 3.<br>minStack.getMin();   --&gt; Returns -1.<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>普通栈：<code>来者不拒</code><br>这种情况的单调栈：<code>只接受不大于栈顶的元素</code></p><p>单调栈的栈顶永远是最新的最小值。</p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">/** initialize your data structure here. */</span>  <br>    <span class="hljs-type">int</span> stk[<span class="hljs-number">100010</span>];  <br>    <span class="hljs-type">int</span> stk_min[<span class="hljs-number">100010</span>];  <br>    <span class="hljs-type">int</span> tt;  <span class="hljs-comment">// 用于 stk 数组的栈顶指针  </span><br>    <span class="hljs-type">int</span> tt_min;  <span class="hljs-comment">// 用于 stk_min 数组的栈顶指针，它总是指向当前最小值  </span><br>      <br>    <span class="hljs-built_in">MinStack</span>() &#123;  <br>        tt = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化栈为空  </span><br>        tt_min = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化最小栈也为空  </span><br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;  <br>        stk[++tt] = x; <br>        <span class="hljs-comment">// 单调栈为空或者压栈的元素不大于栈顶元素</span><br>        <span class="hljs-keyword">if</span>(!tt_min || x &lt;= stk_min[tt_min]) &#123;  <br>            stk_min[++tt_min] = x;  <br>        &#125;  <br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">if</span>(stk[tt] == stk_min[tt_min]) &#123;  <br>            tt_min--;  <br>        &#125;  <br>        tt--;  <br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> stk[tt];  <br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> stk_min[tt_min];  <br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-comment">// 普通栈</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; stackValue;<br>    <span class="hljs-comment">// 单调栈，只放入不大于栈顶的元素</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; stackMin;<br>    <br>    <span class="hljs-built_in">MinStack</span>() &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 普通栈来者不拒</span><br>        stackValue.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-comment">// 单调栈只接受不大于栈顶的元素，除非一个都没有</span><br>        <span class="hljs-keyword">if</span> (stackMin.<span class="hljs-built_in">empty</span>() || x &lt;= stackMin.<span class="hljs-built_in">top</span>())<br>            stackMin.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 要弹出的元素和单调栈的栈顶元素相同，那么同时弹出，否则只弹出普通栈的</span><br>        <span class="hljs-keyword">if</span> (stackMin.<span class="hljs-built_in">top</span>() == stackValue.<span class="hljs-built_in">top</span>()) stackMin.<span class="hljs-built_in">pop</span>();<br>        stackValue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackValue.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackMin.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">包含min函数的栈</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="栈" scheme="https://blog.phbeats.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>第十周总结(6/03 - 6/09)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/0a859ba849e1/"/>
    <id>https://blog.phbeats.cn/posts/0a859ba849e1/</id>
    <published>2024-06-02T09:09:55.000Z</published>
    <updated>2024-07-04T07:45:16.736Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="dfac9c66e127ca62388030cd503a80e2068589524f343742de4dc74deebefba1">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b081456281f2c01e4e1c6dd2c48af7d023157575d46a0949c2fa1f81762e092a7613379916b95be85df407c438133ae7bab74dd25ee3075a11ba0b566f8b78d6d143f9eb214759f3ba39a567b35948cd9418aec66de3b9da4f25e1f1ab0709739a5ec4d5f9cea67ee771fa57ca7a240f5e2a2babee79ff899d7905c9294e7d130535b84f17b1377dfe343c7feb6aa19e744d68b9f487bfbfce3b3ea53b68663de5ea7851e7451ae3b2b71a7f23cb4a4b7c1c9adfffb49643fdfe338cbc798ccc7077df099cc0022517c845830610baa108e852737f83e807e3244dc6154cea74371bae1f27498db6f15df23afc3c015d49d4cbcedfa8f584aa91f3ce6aadfed721927dcd922fb24e397c302c5590cd1f8cce6426fc921c088f9f75aea4966dabf966431978fb94d6702b1f842461f84a585e51f03ccae7da76c37a32d0f27de307ea7d15a55aa45536cd8a94838904496f81be912933fb156a147e489ace1b61c4a093982dcdd94b394fc15f8d0f32bde29088dab9c94fc83b50afd0834da0dd65d3b78bd8e048ec9229af2685ee7633cea8afd403be23790a6c1dd2078ccdc1b780e9d188da6d1e1fcdb11cba58666c7d054f347af1174073785f94e932ff4b7baacecc1de1d80feaddfcb7731c0e7278fced2963b9e657699570146ed26f717226a13190cc127f0fddf2d505ca77c9f0c5472601db549807d1c4990554ffee0abd0062348e8bf3e366df8ed7bcbb981a708fd20e43527d33eba98a070b4a63411e54d626cc4a87109acb3f44b1b33b57ce064fa6d14d71c7c6381479eb4d4ccb1fae87bed6af6512af3b412b4eb8cc314f34d5053cc32a8e988e0e289c1b88ffeab7796c4c53f4bfc2358e2a2f02c329e9ba36addbe0c8d2c65ef79f3c10c062497bbbb1bec14a2546bf2ba4887ae345411b3e87bca32eed0626d8625e5b611df646cf3ac77d1558642d2333dfdb5f83004d617ea139cb0d2fe2c1edf37986b3e1032f92a2c26a106aea3ede691c55d8a0409415d32d830b9f21fcacc56a9a4f1f9b8f9688d63eb1bc3c85346329fa7ce5e6c98109695953ff91f3c216fb92ce5dfe48fcb43e01827481298bf1b9faed60aa75ef4d7549725b7780c3a563985cf28fb99ee71729ecfae21457d117776601ec72281a60c83c24fa0a93582cb2174b9259148d9010637d976dd728adb0d19cb31e1c77a2775e519855e1f1cf27610cf45253d8c0a229c0074e2f9b49f7156cadcbc50d98a59ccd6bd1be82edf25f1bc7caa3fe4f56b627c3688322986a72a87b833527c9b97ab8652802fa6781ddd34eaf99b913b565900200a619bfe0da0ff3eec3f6494bae0e8baf7a0217d37f95a70dd2c9d24c5379a7195a536afeb07782ec3379c7aed9e7560b1be9374d90bee3b835adcf0f1e0bfefe89854df5a9f5f5c382101fcd92cdc2e64752bc441036c5946808ffba6579d19bae919c478b0a7d1393cd91ae1e3a40825a4bb7d69cabc8a85b432e14fdd9419ed1f161a7cf5a7b668be93af4cfd5ace2a597b7677ca1d1e9b9bf28fbccafd9de0e32370f65c214ce7e43dbba8c6dc2fdd40cfcb562fb5278fb67a3bc67aef3618da8234c5890fffaf6fb78d20b8e6eaa46692ae005780dc36f89420071fb7608f75ac4e0175d0a8173a433c2309dadf5a3420c06a5f44ab12eb22bc824413a8862262cc1820b3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十周总结(6/03 - 6/09)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>第九周总结(5/27 - 6/02)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/c2105732bf66/"/>
    <id>https://blog.phbeats.cn/posts/c2105732bf66/</id>
    <published>2024-05-26T08:57:53.000Z</published>
    <updated>2024-07-04T07:45:16.736Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6c6fedf055c6ce4e46cf2ea1b0be891c619d7e8e3eccf2f7ee6db10de8f41ff9">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08148cf6dcb42af7797b6d01e75b6cf044093e979b81a2f60dde267d9c3b86e9a47aa9be9d8578b305af0cdab91dc7dfc6d952c517b0ca8d56c450bc8d2940a3cfdd4caa239302df946ef7c0919a6b41f42980d8a9d7c8de8f2038a91eb486803d528b7075906c68bef55c0e7d8208b45dcd28358d968714c0d220a24a586c9fb907e1561931b4bc50f563ed52d765f26144b21f9bdbf1014ff307cc7bc19a1ad01d26e55a5722834c799e18288def744c78b5b27c2a2f57da11b78fd90d485c054dc2d30f28d6ebc91da508fef116baf912eb5b2bc519872781b5c76ce3dad2d22159ae333da74901ea86432d9937fdf3169cc9aa08310d5fdb98a28ecf506bee51672503fb29b6aa339df55278fcf0ccb413c1f4a26ddfb3e371cc0277654b8f95a14dce9dc8c864cae54876e6459595440e51a61c007042287f9a7814806fd1e781341cf0e18945fca687cfc113dce2756da0b914959af71f527abe6d21c855b55cf717a3e693d69f8b8e392a7029ffdafd23ed9965775eb5465c2d8efd099b169c9582350702878efcee7b7d5f53957bcddbdb6a2f9b4d3aef8b645f699e33993601f1ad41440cf35d43a90e9b21f8be8219762661e74fc5836f79980b3e72aac26fe408f59606ad020f1f15a1ffd1bd51ce157c6a985fdcaf6e34036f766ac492a7c8a360528d846170dc45960558de19252a7b45c0ecce3e5443bb59e68a8585c232b1a0351e492515cc38fcc9d424b48798f2678432d634fc7e857102662a16d66e41503881d97660a5e77f73490d9f5bcf956f5d27e15db64e269e73b1bb8a95bee3b040960c524f090f178d6fda8ee7eec1c1074c2b343ba8bb37ba49353475d8dea1197149b93d71150c6a093127a2ee020668bed2aa85cfbe25769b9f33a67676843c940b8631ba1113c4aa2f45757e095715167aad449bf8e18999ae3a90c3e4248185a34f3a59f6e1ece222090f32e7233728809b8e4b33faee8121b2188ede9a89e08ac28609272b70da83b28d05725f1fe91b64effde810a9ba175487b870423c66079e84c48141d0541f85228442b82ce6ed5c959dcbc9482ca85a86ab2e37df5c0c68c5c4174f1fb33faa401385d58624e9dcd0a1a5be369dc8d20a97bee0ded866670ad98ba241313329df694be09d92572287a0a390cb0751f03bf2f5b553c932821ebcd6723ddd67f7cd659e49cbf0c49418f01b1a37f2dcc49fab8aa0ef20c44147e9ce5f173049bec5c4835869edecf1b8b9dcbb3ffe1762f2f7ff0ac457fd40e8d35c1fd440c824eacd3ae9430c0d4ca18a82baf66b43ac7ca07d2b392af9a705190a4c0a142ec51b5bef566bfdbc965d31246c411f1202fc5653fa12a6f38436175829bb400abbaa09024b72d40799af10b6e27894d7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第九周总结(5/27 - 6/02)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>第八周总结(5/20 - 5/26)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/e00fcfa54b2c/"/>
    <id>https://blog.phbeats.cn/posts/e00fcfa54b2c/</id>
    <published>2024-05-19T09:09:25.000Z</published>
    <updated>2024-07-04T07:45:16.736Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="05fa4451d83a051b19c8d1ab593483d316ab199530e626db9f4044e23f1df7ae">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08146e5d80279bfc5b7c843ef5834902ee6f904c219358a09c8c1e1c121f4f6661093f4613885d4e54d31998c24a60ba8aecc2daa47404a0382222359da04367570b0d2d4de51823a997490772d04d27dab26d54f1c1a1fe60496f1e0090044ac961953dfaf3b9e7082484f474b31f2542c000f9e8dcdd62e0a41906af1cb69fde596f60c8db2753e4d89effd8ad57da12d06d3f0d40ac52c9464e1739d1e4cdfb0a0d280e7b0a2de74ef2373be97050217653cfe53d554af4447b9505edc9626f0512645fcfe125fe02715ab5505eddb5894e2b4114eaa31bb753642ee35db3bbc7cab983ed9d5a0156f9ab971e5642fa29fd2d784862d5e0e89a45f9930bcf0b5b672b494b1fa61d8b4365db3a9f6700b0d7759bcac0a7e16f96baf377079dd738f3056125abd404f3c62e60fc05f7790b9130592673e24afd1aad966dc1b740d286487f94af838fff5d8d31e83c270b93a07d3676dacde8a32fb7c054be223ee3d81b67dc9e090c8b3efda1c5e6aa6e9bfd54a72aebf9b290af33bf413043eeb2c4efbc383cbcf20471fe49bf880f9b5acfaf6a65b3fbab157f7828732d0b14782760fde76e5c1f8f0e449c6baa0ae5cbbe7bde9b33babbdb81c8a53fb3688bc87197204968c050f8c779b6880a1b5945212a9a7995baceb44d08884fbe47a4c08d6c67d263eca3f51283c25b10825543a5f645aae0c83fb81399b5be3b948adfe46af1a988ff0154adc511452a654c91d8761c71c8936478fe088612afb24bea6eb6c89c48680b85e612c5616d6d6cb3c1bd27da65c03f8d1eb872612d9ca00d26815937579fa885e0d7849d29fcc142be8049259d584fe28b51a9a02cf2beb48faf59c4a260bdb2b60a6fd984e779e7822571583d2da97e66a48046515b0894f2ce4d39dd23e31b048ba021ea1995c1388cc2e7fb6b967199d516f5103f9232a723542acfff3cc09c237c47757a75fe637d8e25c2d6f27fae986a579ff92580c3f72e7c2c371dce119c113b71613a8e70b0c1e4a14d5130d6f838efd0e55568488918c78635af52107920c9fe3195285a45f135327fe8566ff5bac1e8464dbfb57fa3f25a34e93df5bbbc5d3e58744ac975a67ccb5a9d3bfec8418c74161c78caf047dfd86b6a9a15201872dadbbfa8a2756e122411d8fe8de26247b58747ab146088eef7a2a64f13f736f9593929b6c1034150fc0483f4e89b3a34dfeb0b0780f40757857060d7543d23e3d3b08fcf44bbee47f2cb5399b47854c2119e5ac8583d26e4ea490f8873235de0e90992c8e8509fe7ab2e72af01a525085b2903ddbf48d994d4f8ce39c77a28329e3b3b6a3d31485b2e15eeff15b9287bedea6c0330d33e0a7c62a95d60ab33ddc5355a3637e2e793492d9318ea0eec67b0624c6189204370eae4e3188f974ed39ad8893082048632a0289607a3e3897583286c910f4291e48b429582e69afd16143590ea6000101405e4a6db00c1585652de94d7339f98da0fbd491506d8b384adad9792980c64b0d7f0960843387c6897bc2a59cd1ddd39e2d137d4b9d7e7101879940166d1a462dea192abddc275043230f961f0b2680971d7c34de23908a016f7ec736d863c22516eb9e3725429585cd0b8195c0eac48249221a24e9c212b486b2dd5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第八周总结(5/20 - 5/26)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]3757. 重排链表</title>
    <link href="https://blog.phbeats.cn/posts/15cb5950f25b/"/>
    <id>https://blog.phbeats.cn/posts/15cb5950f25b/</id>
    <published>2024-05-14T13:17:44.000Z</published>
    <updated>2024-07-04T07:45:16.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3757-重排链表"><a href="#AcWing-3757-重排链表" class="headerlink" title="[AcWing]3757. 重排链表"></a><a href="https://www.acwing.com/problem/content/3760/">[AcWing]3757. 重排链表</a></h1><p>一个包含 <code>n</code> 个元素的线性链表 <code>L = (a_1,a_2,…,a_&#123;n-2&#125;,a_&#123;n-1&#125;,a_n)</code>。</p><p>现在要对其中的结点进行重新排序，得到一个新链表 <code>L’ = (a_1,a_n,a_2,a_&#123;n-1&#125;,a_3,a_&#123;n-2&#125;…)</code></p><h4 id="样例1："><a href="#样例1：" class="headerlink" title="样例1："></a>样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;2-&gt;3-&gt;4<br><br>输出：1-&gt;4-&gt;2-&gt;3<br></code></pre></td></tr></table></figure><h4 id="样例2："><a href="#样例2：" class="headerlink" title="样例2："></a>样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;2-&gt;3-&gt;4-&gt;5<br><br>输出：1-&gt;5-&gt;2-&gt;4-&gt;3<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 1000</code>,<br><code>1 &lt; a_i &lt; 10000</code></p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2024/05/14/66435bd78bd41.png" alt="image-20240514204050974"></p><p><code>将链表分成左右两部分，右边那一部分进行逆置，然后将两个链表合并</code>。</p><p>前半段是较长的，切断点应该是向上取整，尽可能让前半段长。</p><p><img src="https://bu.dusays.com/2024/05/14/66435c81b8b12.png" alt="image-20240514204345071"></p><p>选其中一种情况讨论。</p><p><img src="https://bu.dusays.com/2024/05/14/6643611cc4cc8.png" alt="image-20240514210325505"></p><p><code>step1是合并链表的过程</code>。</p><p><code>s</code>节点是需要提前保存的，用来维护<code>q</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rearrangedList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 题目说链表节点满足：1≤n≤1000，只有一个节点，则什么也不做</span><br>        <span class="hljs-keyword">if</span>(!head -&gt; next) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 先计算分割点</span><br>        <br>        <span class="hljs-comment">// 求长度</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(ListNode * p = head; p ; p = p -&gt; next) len++;<br>        <br>        <span class="hljs-comment">// 向上取整</span><br>        <span class="hljs-type">int</span> left = (len + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// 找到分割点处的尾节点</span><br>        ListNode * a = head;<br>        <span class="hljs-comment">// 移动 left - 1 次</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) a = a -&gt; next;<br>        <br>        <span class="hljs-comment">// 右边的链表，由于要进行翻转因此有两个指针</span><br>        ListNode * b = a -&gt; next, * c = b -&gt; next;<br>        <br>        <span class="hljs-comment">// 先置空</span><br>        a -&gt; next = <span class="hljs-literal">NULL</span>; b -&gt; next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// 进行反转</span><br>        <span class="hljs-keyword">while</span>(c)&#123;<br>            <span class="hljs-comment">// 记录排头兵的next，方便维护b</span><br>            ListNode * p = c -&gt; next;<br>            <span class="hljs-comment">// 反转</span><br>            c -&gt; next = b;<br>            b = c; c = p;<br>        &#125;<span class="hljs-comment">// 跳出循环, b就是反转后第一个节点</span><br>        <br>        <span class="hljs-comment">// 合并链表</span><br>        ListNode * p = head, * q = b;<br>        <span class="hljs-comment">// 选 q，是因为 q 比较短</span><br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            <span class="hljs-comment">// 提前备份，维护q</span><br>            ListNode * s = q -&gt; next;<br>            <span class="hljs-comment">// 合并</span><br>            q -&gt; next = p -&gt; next;<br>            p -&gt; next = q;<br>            <span class="hljs-comment">// 新的开始</span><br>            p = q -&gt; next;<br>            q = s;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3757. 重排链表</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>第七周总结(5/13 - 5/19)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/18dce1045e76/"/>
    <id>https://blog.phbeats.cn/posts/18dce1045e76/</id>
    <published>2024-05-12T12:50:07.000Z</published>
    <updated>2024-07-04T07:45:16.736Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="be23e89b95f5745738aae2478d786862b2b5b1b7e21991b2941ed1a61997148d">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814cfa77eab28e95f83ea7aea878afae15fad98aff38f6f399a48e8c2f97bf75cac877f7546d614d49ec38eb5221108a411ccb11bb60f246ecb18aeea3b62b05b7c15f35f2de669450cf88414a96ccf0065acd319d65aa3d73cbc0d697a153fc64d5c1032fdc09e92eb73a91aa0acd65130cb5827d7e429e70061fac1e1a07e2966363901d827259668497fb1b49a207d4b4230affc6ce758a058b94fa01d250b3e7c3f7e265b5ae028a1662a67d25c8a8f902312bf9609b9c7d1b0241eb84dcd1301d6ccfbe100a3a350d21eeb5967b0ca0cb60e4c680de2a0742a5390bc13ad6ec464dfdee422e0f26607c37cd2c16e7e13dc0b3361514c13604f7ff74c6f8d57aee576e341e6c14c0dbc9bedc554cd92df2d7520427221b01771800336a6d2cbb680068fe5936c23b3685f0c977724277c1160704df1c9fbab60ed7a66341297cf803b14733ddc73676d0df294c177868ceb18360e12b6e9495d226829fea442642e93d6c5598230e2c84628af82e744b6b2ff8a230261848b90968a1029656784881d5a0c1d919c5efecd4ecaa023e4b45a677ff7adeb1981c85510cfa60b554cd1918184dd747ab827f39f60c3f469bf8a1c8a58ac953a05ba31bf4f5f7d548ba9ff2c6e31e9c3fa4bcf8c4c1fbf39d214fbd746d627ddc1b1002796de8328c83832d744e305d86540cd6075fb4897a848d4be686ed8e4b153cc5bfe43d0a61c5c0c83c09fa39cfce3befad521bbc7a3eddd8d70f58dee192e32898a432825c1182d91b6392d063c57b3dd37700a8e0c829779735d7ffb3bb46226404f2c40ab1e4bf6159130484a35e5dbd5845839ff590b8b41ac83e984658159e3503a1732e0fac343e0161fdfdf51020a7ce6e3ec56d1755871e36c924cf06d767dc66b560dfaed2e9690e37324e41adfea89664ee49764d95db6f2eb4c7c26ab5929782cd79bebe3d2d4bc66213749856055d934ed833b86a1dd87532fceafd87a2cc35559a47075844f2a7688dab1322a7a1b5600f305fefb61d00cf85293ec88dff66e062d8e9c7312d552f407143a10cdf57572e5cdfb324ed1f0d41fc4aaef6714566acf8be605d44ab58f0231d96f3a9a64114ac31f61e3b9b1781784aca179e165c7a2cc333fddcd3b24c02f1220592f6d27e5d7e9ede888a0cf1f9441ea6afa1c91c1f6d016a9a5c6e9f116d5c6d2e7e5c0c0aabb8d9d90c6de56440ae94f3bcdede8cac6e20e311fc6d5e8a98007add58366dac951b3d3059a39ad3e68d68b226a78a9aa19b53eebef9ede1d377c0f1c8a76a0e6bd75035d99b39426db267466b230621435c09bf33bb62d43073b73e574a79677463bf052663b68d75e452afa1926a6b9748b971d45b8a76a2369f42fb3582ab83cd3abf30d43a5e53ebf9eaa6371233f3c67fbb733d836c1e823a4d3b7fb4b81105ddb42c24107bdef3cc39afc111fdb061bc6e85b28eebd413fc80457ea98dc5fd2b844135a9432ec788aeae5b3e3a7954ee77e43add723ad3a1cf4f22d3928245aaa1cc82da88f3da4d7195b9c580f7613f7ede3cbf5b94779a684ac419b5a5b9ec0f7643cdd7e53f976c1c9d242ab371b540d4ef0242c03df23d125046ec2a8342fdeffdf98f73fee7959eafba28c106bc7b66ae4aa42d5a1059d26ff0eef7b1c9c29133fbef80f0e1ec88ecfd486edf7dc0a497dad5c1ecefe639055d5ec9968096f0fc389d0474adb75ddffa9749cb03f5d0b0ab673b3f299bab676db085b34386af17a936c13faf99cb5bf8f55304af7bd500c1083bbe864ee2ee1d0a437144fc845862737293ae8254353fc8da7898a0d4f2408cf47929c45cd52392fbeaae743c48381cb6acc011c3f5760460bfa6c24a4425401920ea5e967bd37d886697c8ebbc77b6d448bbe8c9f68965c256184eafeee270311acd5a553b6d2f8354c9f300a78af6ca1ba2e797686803866f15f44fd04678c8d6e14ff66b5e8ca110853ec26dee0663073c4ef4a1b98a0863ecc7c9bcece115d616d58bb21d747fa122bf5ae601ea65bf36940dca5ef1e636ca1ad807ed0189171c6f62ce73b05bef1e32dfa009fa661ccc853e579c0095a7d593f6170738d589447a121d2d4cdad0af7aa1fdf83d79913da2853847b224392672c29e6d9c2c224dd19f9a83d2ec606a373a9c80c4f2f82b460c05412e54be71e270fb7e1cb94ac8dde8b55cdb79ee4d8d55015bc47c3238cbf515976279130a5cbb60ffb20ca62b7ac4c5e5213c337ce8c22391033fb32384dceffa808fd1fd4e74b3e7df222ee26738077075d18f9cf189e4cf89df8e475fc150d382aa3ed6e6f1ad9d08de8d612</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第七周总结(5/13 - 5/19)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing] 66. 两个链表的第一个公共节点</title>
    <link href="https://blog.phbeats.cn/posts/0a6333a85e34/"/>
    <id>https://blog.phbeats.cn/posts/0a6333a85e34/</id>
    <published>2024-05-10T11:34:56.000Z</published>
    <updated>2024-07-04T07:45:16.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-66-两个链表的第一个公共节点"><a href="#AcWing-66-两个链表的第一个公共节点" class="headerlink" title="[AcWing] 66. 两个链表的第一个公共节点"></a><a href="https://www.acwing.com/problem/content/62/">[AcWing] 66. 两个链表的第一个公共节点</a></h1><p>输入两个链表，找出它们的第一个公共结点。</p><p>当不存在公共节点时，返回空节点。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>链表长度 <code>[1,2000]</code>。<br>保证两个链表不完全相同，即两链表的头结点不相同。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">给出两个链表如下所示：<br>A：        a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗            <br>B:     b1 → b2 → b3<br><br>输出第一个公共节点c1<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>两个链表，两种情况，<code>相交</code>和<code>不相交</code>。</p><h4 id="相交"><a href="#相交" class="headerlink" title="相交"></a>相交</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32ff3099be.png" alt="两个链表的第一个公共节点"></p><p><code>a + c + b</code> = <code>b + c + a</code>，它们相遇的时候一定是两个链表的第一个公共节点。</p><h3 id="不相交"><a href="#不相交" class="headerlink" title="不相交"></a>不相交</h3><p><img src="https://bu.dusays.com/2023/08/09/64d330de84da4.png" alt="两个链表的第一个公共节点2"></p><p><code>a + b</code> = <code>b + a</code>，下一步它们都会走向<code>NULL</code>，而<code>NULL === NULL</code>。看作相遇。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">findFirstCommonNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode * p = headA, * q = headB;<br>        <br>        <span class="hljs-comment">// p从headA开始走，走完从headB开始走</span><br>        <span class="hljs-comment">// q从headB开始走，走完从headA开始走</span><br>        <br>        <span class="hljs-comment">// 不管两个链表相交还是不相交. 根据 a + c + b = b + c + a 原理</span><br>        <span class="hljs-comment">// 它们一定相交</span><br>        <span class="hljs-keyword">while</span>(p != q)&#123;<br>            <span class="hljs-comment">// 如果p走到末尾</span><br>            <span class="hljs-keyword">if</span>(!p) p = headB;<br>            <span class="hljs-keyword">else</span> p = p -&gt; next;<br>            <br>            <span class="hljs-comment">// 如果q走到末尾</span><br>            <span class="hljs-keyword">if</span>(!q) q = headA;<br>            <span class="hljs-keyword">else</span> q = q -&gt; next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing] 66. 两个链表的第一个公共节点</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]3756. 筛选链表</title>
    <link href="https://blog.phbeats.cn/posts/5a709920de81/"/>
    <id>https://blog.phbeats.cn/posts/5a709920de81/</id>
    <published>2024-05-08T12:11:58.000Z</published>
    <updated>2024-07-04T07:45:16.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3756-筛选链表"><a href="#AcWing-3756-筛选链表" class="headerlink" title="[AcWing]3756. 筛选链表"></a><a href="https://www.acwing.com/problem/content/3759/">[AcWing]3756. 筛选链表</a></h1><p>一个单链表中有 <code>m</code> 个结点，每个结点上的元素的绝对值不超过 <code>n</code>。</p><p>现在，对于链表中元素的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。</p><p>请输出筛选后的新链表。</p><p>例如，单链表 <code>21 -&gt; -15 -&gt; -15 -&gt; -7 -&gt; 15</code>，在进行筛选和删除后，变为 <code>21 -&gt; -15 -&gt; -7</code>。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：21-&gt;-15-&gt;-15-&gt;-7-&gt;15<br><br>输出：21-&gt;-15-&gt;-7<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; m &lt; 1000</code>,<br><code>1 &lt; n &lt; 10000</code></p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>如果要筛选掉重复的元素，那么必须要有记录每个数字是否出现过的<code>bool st[N]</code>。</p><p>而且链表中的第1个元素一定是没出现过的，可以直接标记<code>st</code>为<code>true</code>。</p><p><img src="https://bu.dusays.com/2024/05/08/663b74242dace.png" alt="image-20240508204615900"></p><p>对于<code>p</code>和<code>q</code>，删除点有讲究，如果是删除<code>q</code>，那么成本小得多。</p><p>所以<code>q</code>就作为被检查节点</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">filterList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 标记该数字是否已经出现过了</span><br>        <span class="hljs-type">bool</span> st[<span class="hljs-number">10010</span>] = &#123;&#125;;<br>        <br>        <span class="hljs-comment">// 第1个元素一定没有出现过</span><br>        st[ <span class="hljs-built_in">abs</span>(head -&gt; val) ] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 当前没重复元素的最后一个节点的地址</span><br>        ListNode * p = head;<br>        <span class="hljs-comment">// 当前被检查的节点存在</span><br>        <span class="hljs-keyword">while</span>(p -&gt; next)&#123;<br>            <span class="hljs-comment">// 当前正在被检查的节点</span><br>            ListNode * q = p -&gt; next;<br>            <br>            <span class="hljs-keyword">if</span>(st[<span class="hljs-built_in">abs</span>(q -&gt; val)])&#123;<br>                <span class="hljs-comment">// 如果出现过了，删除</span><br>                p -&gt; next = q -&gt; next;<br>                <span class="hljs-keyword">delete</span> q;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 如果没有出现过</span><br>                st[<span class="hljs-built_in">abs</span>(q -&gt; val)] = <span class="hljs-literal">true</span>;<br>                p = p -&gt; next;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3756. 筛选链表</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>第六周总结(5/06 - 5/12)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/a395edc2fc97/"/>
    <id>https://blog.phbeats.cn/posts/a395edc2fc97/</id>
    <published>2024-05-05T12:09:48.000Z</published>
    <updated>2024-07-04T07:45:16.736Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="72fbfab78a350ffcf08d36f00df4c78945e0677809efcf441993cbdfbbce1bfb">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b081447d9b719472bd5775668a255d225b23d438f1a71fbc386340f8f54f64e69f613c8fba85fa24fa98799869a309cab3465099a986368de14b981d817357654a9f6a41178c10bc425825db9852a0014c379de9db8bb49852180e57b06cb94bef8bdd4faa062bce36065914b1e4d92bfefb86611685a234cb1efbb68825526b2d9c41eeb8edeb1e21517ae269aa5cbcb1baae8dbac5223501967e134c96f384146525fffc0a82ebde5665cd91defb7cd454d566e36b1ec3fce46270b6ca9c913825ba1a53291fcb3732db836afceac4b752ccf782a8ec60093b5660e42253adbe1e40931dc23fcde98992382bef19895b680ffa0307c0f8554b2815c324b1282f79bd446d1102f63970efca2d911bb65db1db07ffc4d222159c1a40232b7235d218be157c6e77cb3ace1d18184828d63550443c19d16ae1b9419c6f8de3fccd75601cca48f39fd3bb6e933190271938d8205095f2731d7c1f38144de83efbd489bfe49ee7bbd85dd8d2f5c2986f0b46f99a0ae6aef5dce39e61164ee947352eb5b0d0c146b7b08f503b4c9d24bb9455e22d4715667f78081ba0fce08543b3c5e4715dd6302f81a5aa96c43bbf6e05a5827d85d63993ba82a7f1176cf41855d7d2d6682ac7cd599ab5d2e8f05fd29a856f1909ab1de80f326eab27ce50231e460aefa70c14714d35dad01d1e2d0faeb951f7ac78b043e1aac53b342091de77946fa03ab9860ecfdf062b41f23623260b4d5241bb1a08eb99da57aa6e27684ed45b04b5545b59c7c11aa015a45ca1818cec5af5e5002c8f372c524bdd8443f85f8fc5acafe07122f5217bf7c9d6c062db43d0ad3896b3b3ac67324ad53c341b311dcb03db7f9fa762c3032722dd57cef8c83751729fbb91affd39ad49c5789af87653818b9d42d3159de8799648b09f6c3ab29a511d6d3cf8b8471efbda234fcded546f1ca7d174b732267f30997b5434fb87aaffa4fd490ab5034f7395a27ab80c8789c706ea625204fb016565943dd42b6935afaddb3139d322ddffe4bb187b31def7b03b080231a8ffcf2e3644e7eb44a6f5b43acbc28b39cd54eebb2c4a14250a27e359116e38aaf99d642ecc66277417dfc69500a687c60d217a81cacdb940f561c08a48970b029b1c06bc5b1bfb804e468f31584e596e44cda6d58381e7edc744debf76982c89196a19364c20b563bcb5e7c2a161bb0c37de8a37ee676faeb685169d7ea2eea56961e79252ffe6049d30858e9272473b0281f47e3bcdfcc910ac868be7a043d6451ddba539d69701490d83a0d0c43e90c2d1e9d80328bddb54f48efa1907b5f1ebbcee5b83f5d3f810f68e09088c9d1850b90f023253830ee1fc16f8ca71d9d8b78384db1b6ff8b9d2ace2ef6bcd0b8f47ff0f8edd81468b03514decc5466432322ea71698d83d9fdeecfb5555159fff302e154a9998fff4f18fb9cb1eb1d4ff337b011ddc16430c0092d551978686771fc829b0c593e0d9359faecbd37bb14424b5d037dc363760dba8e67491d7e1d926c82b0291ed8065a30e0a4f0b2727b99020d139fa3566dcc21c510035a79f9603af6a6ef30f6952e62bf38fff582eaee5453afbcbaedc2675a305f954f2d847a28faa3cb1a58191086e4a3a328adf4e1b7f19ab469fbe9c31fff860f59d591b7d85790e234d7f2160e3739fcae2dc8cc7403d65fb7dd0409193f9ce364f6c84f109e12d65422dd724e6746139256061a0290070f2b7de3882d3017ccc94c5a4d3dcf72043604b5b0ac36cd5a8cacc6a818d17e948f410a3cb9635ef5f1cd15f92d4d6d65c5eb1b196ca6f8e6b8f804b493de77a59fb2e78f528aa7fd587f547e00b4131bf5dfc2fcd6904939ba328bc45463163f304eb556e5eaeb460dff005ba4cc3a2ccde498e98c5abc071addd2a43c09acc2624af722d3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第六周总结(5/06 - 5/12)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
</feed>
