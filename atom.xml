<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phbeats-Blog</title>
  
  <subtitle>记录学习历程和生活感悟</subtitle>
  <link href="https://blog.phbeats.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.phbeats.cn/"/>
  <updated>2024-06-17T03:24:31.637Z</updated>
  <id>https://blog.phbeats.cn/</id>
  
  <author>
    <name>Phbeats</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>滑动窗口内求最大值和最小值</title>
    <link href="https://blog.phbeats.cn/posts/37333600838e/"/>
    <id>https://blog.phbeats.cn/posts/37333600838e/</id>
    <published>2024-06-17T03:13:21.000Z</published>
    <updated>2024-06-17T03:24:31.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-154-滑动窗口内求最大值和最小值"><a href="#AcWing-154-滑动窗口内求最大值和最小值" class="headerlink" title="[AcWing. 154. 滑动窗口内求最大值和最小值]"></a><a href="https://www.acwing.com/problem/content/156/">[AcWing. 154. 滑动窗口内求最大值和最小值]</a></h1><p>给定一个大小为 <code>n &lt; 10^6</code> 的数组。</p><p>有一个大小为 <code>k</code> 的滑动窗口，它从数组的最左边移动到最右边。</p><p>你只能在窗口中看到 <code>k</code> 个数字。</p><p>每次滑动窗口向右移动一个位置。</p><p>以下是一个例子：</p><p>该数组为 <code>[1 3 -1 -3 5 3 6 7]</code>，<code>k</code> 为 <code>3</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">窗口位置</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th></tr></thead><tbody><tr><td style="text-align:center">[1 3 -1] -3 5 3 6 7</td><td style="text-align:center">-1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1 [3 -1 -3] 5 3 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1 3 [-1 -3 5] 3 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">1 3 -1 [-3 5 3] 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">1 3 -1 -3 [5 3 6] 7</td><td style="text-align:center">3</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">1 3 -1 -3 5 [3 6 7]</td><td style="text-align:center">3</td><td style="text-align:center">7</td></tr></tbody></table></div><p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含两行。</p><p>第一行包含两个整数 <code>n</code> 和 <code>k</code>，分别代表数组长度和滑动窗口的长度。</p><p>第二行有 <code>n</code> 个整数，代表数组的具体数值。</p><p>同行数据之间用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出包含两个。</p><p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p><p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">8 3<br>1 3 -1 -3 5 3 6 7<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1 -3 -3 -3 3 3</span><br>3 3 5 5 6 7<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>滑动窗口，每次滑动一个单位，<code>窗口内求最大最小值</code>。</p><p>借图：</p><p><img src="https://cdn.acwing.com/media/article/image/2022/03/05/55289_0923cf569c-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.PNG" alt="滑动窗口"></p><p><code>题外话</code>：在一个从小到大排列的数列中，若左边的数比右边的数大，就称作逆序数啊，如：1，3，5，4，6 中，5就是逆序数啊，看看5在题目中有没有用，若是没有用，那该题就有单调性。</p><ol><li><p>使用双端单调队列：利用双端单调队列来高效维护滑动窗口的最小值和最大值。</p></li><li><p>维护窗口边界：在每次滑动时，检查队列头部的元素是否已经滑出窗口范围，如果是则移除。</p></li><li><p>保持单调性：<br>对于最小值，保持队列单调递增，移除队列中比当前元素大的元素。<br>对于最大值，保持队列单调递减，移除队列中比当前元素小的元素。<br>插入新元素：将当前元素的索引插入队列。</p></li><li><p>输出结果：当窗口大小达到要求时，队首元素即为当前窗口的最小值或最大值。</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-comment">// 数组和双端单调队列</span><br><span class="hljs-type">int</span> a[N], q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 数组元素个数和滑动窗口的长度</span><br><span class="hljs-type">int</span> n, k;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br><br>    <span class="hljs-comment">// 输入元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br><br>    <span class="hljs-comment">// 求滑动窗口的最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 维护窗口，i - k + 1 是窗口的左边界</span><br>        <span class="hljs-comment">// 如果队首元素的索引已经小于当前窗口的左边界</span><br>        <span class="hljs-comment">// 说明该元素已经滑出窗口，需要将队首指针 hh 向后移动以排除这个元素</span><br>        <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) ++hh;<br>        <br>        <span class="hljs-comment">// 保持队列单调递增，排除不可能的最小值</span><br>        <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) --tt;<br>        <br>        <span class="hljs-comment">// 当前元素入队</span><br>        q[++tt] = i;<br><br>        <span class="hljs-comment">// 输出当前窗口的最小值</span><br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= k) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 重置队列指针</span><br>    hh = <span class="hljs-number">0</span>;<br>    tt = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">// 求滑动窗口的最大值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 维护窗口，i - k + 1 是窗口的左边界</span><br>        <span class="hljs-comment">// 如果队首元素的索引已经小于当前窗口的左边界</span><br>        <span class="hljs-comment">// 说明该元素已经滑出窗口，需要将队首指针 hh 向后移动以排除这个元素</span><br>        <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) ++hh;<br><br>        <span class="hljs-comment">// 保持队列单调递减，排除不可能的最大值</span><br>        <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) --tt;<br><br>        <span class="hljs-comment">// 当前元素入队</span><br>        q[++tt] = i;<br><br>        <span class="hljs-comment">// 输出当前窗口的最大值</span><br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= k) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">滑动窗口内求最大值和最小值</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="栈" scheme="https://blog.phbeats.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>第十二周总结(6/17 - 6/23)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/a2f37b955b1d/"/>
    <id>https://blog.phbeats.cn/posts/a2f37b955b1d/</id>
    <published>2024-06-16T09:37:30.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="86845d31eea6dba83df15beb42c727aec0a2645b01746e8a64105d16d1675ba1">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08146a9702094cd1a87e411844db555d73d0d99577c1ad9192add1e11493d1c76a7191b633bdc9d9aa5df18e842899784479f8bba74239f5d00921a78e4546707d54def317dd8679f14d5bdf60d3e0bc4ba8cab6453e59c2ebcded5b7ccbd6c117516ff3bf706e19766ce97c4e694461b07d7451a1129e843298860d835d7916d23eccbbad19246234795e44a96eb8e78c9fdc24c03b3052438c34253c3e71064ea8e3ec5d6fa13c84e18496b5ec1e1781b5aa61e9343dc5dc5fa6d4a2164cdc753410f081a5adc3b345c142d25ccf6063800728650b787c54ad0b2df2ac185480f1bfb7125ad8ad7140a5b126a085450379c2f7cb7bb9ebdb91e73cbc514e31bf6e11df2be3b92bd99a29e9145a76ed8e4ea91558c2864bb0a0cb85ead8ec7ceaa1324888d9706276eba597567083868431bd9e33d251c2a6150d9296b2427f085d7c33cefe7fbb638489cc57f18bf4611ac3bc3a3160b01eb83ca2d60edd1c75abb1995d86a4cf6dc30c8dea9475c4f964f1bb0242492fa4ee5fdc8e083fcec1d948a26fb3fe06e01637d1de3697db252d501350260c7c9f130a10b9982b6058d74ac5cfed3c6906f9307e6409f5dc2a1420c0f7e0c8303dbb1aa40c2d326471bf438318c66012c932dfd0182a66e7c17a5426c4786a696389de00b6b87bfca61660411e4fc73acb4101d9cd5dfca0309ec46142bacaf149516ce9ba548d1e5006870240b8532a2898bbd3aa4b9b357ae5c851ebd2703841cc29376a17bf5b34ff2dc3c7f7799eeab90d0b0322269beccf6c497482aa723d159513b605716390d1c0ec18e3fdabe06f99566089f46515a1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十二周总结(6/17 - 6/23)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://blog.phbeats.cn/posts/3be02f72e427/"/>
    <id>https://blog.phbeats.cn/posts/3be02f72e427/</id>
    <published>2024-06-11T12:19:11.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-20-用两个栈实现队列"><a href="#AcWing-20-用两个栈实现队列" class="headerlink" title="[AcWing. 20. 用两个栈实现队列]"></a><a href="https://www.acwing.com/problem/content/36/">[AcWing. 20. 用两个栈实现队列]</a></h1><p>请用栈实现一个队列，支持如下四种操作：</p><ul><li>push(x) – 将元素x插到队尾；</li><li>pop() – 将队首的元素弹出，并返回该元素；</li><li>peek() – 返回队首元素；</li><li>empty() – 返回队列是否为空；</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用栈的标准操作：<code>push to top</code>，<code>peek/pop from top</code>, <code>size</code> 和 <code>is empty</code>；</li><li>如果你选择的编程语言没有栈的标准库，你可以使用list或者deque等模拟栈的操作；</li><li>输入数据保证合法，例如，在队列为空时，不会进行<code>pop</code>或者<code>peek</code>等操作；</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>每组数据操作命令数量 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyQueue queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyQueue</span>();<br><br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>queue.<span class="hljs-built_in">peek</span>();  <span class="hljs-comment">// returns 1</span><br>queue.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// returns 1</span><br>queue.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// returns false</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2024/06/11/66684222ae1fc.png" alt="image-20240611202459520"></p><p><img src="https://bu.dusays.com/2024/06/11/666842358a6bf.png" alt="image-20240611202525947"></p><p>借助辅助栈，可以让<code>主栈只剩下一个元素</code>，然后拿一个变量保存它后执行<code>pop</code>或者<code>peek</code>逻辑返回它。</p><p>过程中，拿变量保存它之后，需要<code>将辅助栈中的元素们回到主栈中</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 存放数字的主栈</span><br>    <span class="hljs-type">int</span> stk[<span class="hljs-number">100010</span>];<br>    <span class="hljs-comment">// 辅助栈</span><br>    <span class="hljs-type">int</span> tmp_stk[<span class="hljs-number">100010</span>];<br>    <span class="hljs-comment">// 主栈的</span><br>    <span class="hljs-type">int</span> tt;<br>    <span class="hljs-comment">// 辅助栈的</span><br>    <span class="hljs-type">int</span> tmp_tt;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br>        tt = <span class="hljs-number">0</span>;<br>        tmp_tt = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        stk[tt++] = x;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 存放数字的栈只剩下一个元素，其它的全部入栈辅助栈里面</span><br>        <span class="hljs-keyword">while</span>(tt)&#123;<br>            tmp_stk[tmp_tt++] = stk[--tt];<br>        &#125;<br>        <span class="hljs-comment">// 被删除的元素</span><br>        <span class="hljs-type">int</span> k = stk[tt];<br>        --tt;<br>        <br>        <span class="hljs-comment">// 然后将辅助栈内的元素移回去</span><br>        <span class="hljs-keyword">while</span>(tmp_tt)&#123;<br>            stk[tt++] = tmp_stk[--tmp_tt];<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 存放数字的栈只剩下一个元素，其它的全部入栈辅助栈里面</span><br>        <span class="hljs-keyword">while</span>(tt)&#123;<br>            tmp_stk[tmp_tt++] = stk[--tt];<br>        &#125;<br>        <span class="hljs-comment">// 此时栈顶元素</span><br>        <span class="hljs-type">int</span> k = stk[tt];<br>        <span class="hljs-comment">// 将辅助栈内的元素移回去</span><br>        <span class="hljs-keyword">while</span>(tmp_tt)&#123;<br>            stk[tt++] = tmp_stk[--tmp_tt];<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !tt;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * bool param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">用两个栈实现队列</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="栈" scheme="https://blog.phbeats.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>第十一周总结(6/10 - 6/16)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/9289cdf65c7c/"/>
    <id>https://blog.phbeats.cn/posts/9289cdf65c7c/</id>
    <published>2024-06-09T14:44:21.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="26acdd6576cffb00f722a00e85d9401b49488f76c3ebac4cf745830086eec53a">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08147449db493c1f9e603c98a3b5133ce4de802616652d3f205977b31755f193b35ba184f76bc90f80929641f24f6b91e895a765e7d8e4403777988edcec349e04f5571adcf038631137f1f40ff2c1a607071c06052e689aa7fd460c4bf34e06596844db7515db5bd8181668fa6d121bc8800e28aea4c193c09ed8b1d37d89d434178db3f51f67da77b3d69bf02f3a8306fe7a9ff4c1d538c162f56c034c9d5d1dd4c0daba590d9ff30aefa71d02cb4fc38c78b11bf8258fa0730330b547fd5c49dc16e4e0aeccbe1717e50bd63b126b45422fafc40ec9ee96dea81017a543a48baa2244a0bbcdbf09df392328fd9d051ae9e65a479e696875ca13d7b64613b589bfd9efb1d533527efcdc2032746ad305240093b86ccb0c3a74d57ac096ae1b830549d7e0f8e913b331df1e479667022bb2a28a03d7a384f525f0a5083102d6dd3e418d59d1b7edbc0122c4cbcc25bcc053c39058cf2af4e6f813adb027378e46a0deab289cddf2b756a99ec43b6082df3182e3fd92ad4de202a4791cf714ed4b96c2f3763ceb5661fb71a63cc73af4e2bd089ed2e6980311f613354be4961b2ccaff9949b12c8a67368d05b107b8e15256431d561d233d51cd58ddbcb16ed1cf7be6253cca030d4ddd0da13485121a65391f34a9716bd417fed2dadf723d2ba9f7045890679eb1d4bc56626cc7722fa0f1833e001364f1870f111390e6701a639509b7c55883f5e2cf7f63f0c0f27f5b5c7ace70f638b27481dfdf971688162990a1f7c81c70701c04797bffbb9dfd1ceec871f8dfbd71d8cebc394edbb51c04172e8c30d2e31c53d60e737faa9977f662b9272f57646d5896452dafa06c60d09f3b0ed69d56808164be825db84446638cc7851c797c40a0ef597f933110b18773442fa0c02735a7c1e3a6f9591ed975250ec8cb9f2a4eff19a4f7594542c1aa3b902532886354a506090474476c98b5710ea2dbe581e1c48a212296523b95dce1201c9854a77a7213176ab3cb4a78ea01bf628c9465b68d628733c2de4ccdae2ec5304a65112b5de905a0907a3b50e208f6935c90df08d4ae5118dce2f67e9e4d101aac6c0313624aa662049e912f905f88adbaa40fcbe8082781cc99a9b8ac221ed6679b5b7ffdb261c2b42bbb77d307bd04a9df86655d42011060cff589e5d261cb3153f7b80589ade19ae650209a20c77696bb96e1b700d701bc14ba707dc40ac281f810bf18c8309490630e9e205aa05d0f5f9a0bb633a290542a416823d0b82ada65ff48720be4d6cd7877ba9f0b04cb94f9ac542cafc35cc79615a1e265ad70daaebdf96e8ec40d1bd83a908065</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十一周总结(6/10 - 6/16)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>直方图中最大矩形</title>
    <link href="https://blog.phbeats.cn/posts/410b68f36e34/"/>
    <id>https://blog.phbeats.cn/posts/410b68f36e34/</id>
    <published>2024-06-09T09:27:51.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-131-直方图中最大的矩形"><a href="#AcWing-131-直方图中最大的矩形" class="headerlink" title="[AcWing]131. 直方图中最大的矩形"></a><a href="https://www.acwing.com/problem/content/description/133/">[AcWing]131. 直方图中最大的矩形</a></h1><p>直方图是由在公共基线处对齐的一系列矩形组成的多边形。</p><p>矩形具有相等的宽度，但可以具有不同的高度。</p><p>例如，图例左侧显示了由高度为 <code>2,1,4,5,1,3,3</code> 的矩形组成的直方图，矩形的宽度都为 <code>1</code>：</p><p><img src="https://cdn.acwing.com/media/article/image/2019/01/14/19_eac6c46017-2559_1.jpg" alt="2559_1.jpg"></p><p>通常，直方图用于表示离散分布，例如，文本中字符的频率。</p><p>现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。</p><p>图例右图显示了所描绘直方图的最大对齐矩形。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含几个测试用例。</p><p>每个测试用例占据一行，用以描述一个直方图，并以整数 <code>n</code> 开始，表示组成直方图的矩形数目。</p><p>然后跟随 <code>n</code> 个整数 <code>h_1，…，h_n</code>。</p><p>这些数字以从左到右的顺序表示直方图的各个矩形的高度。</p><p>每个矩形的宽度为 <code>1</code>。</p><p>同行数字用空格隔开。</p><p>当输入用例为 <code>n=0</code> 时，结束输入，且该用例不用考虑。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。</p><p>每个数据占一行。</p><p>请注意，此矩形必须在公共基线处对齐。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 100000</code>,<br><code>0 &lt; h_i &lt; 1000000000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">7 2 1 4 5 1 3 3<br>4 1000 1000 1000 1000<br>0<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">8<br>4000<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>对于每个矩阵，基于单调栈的算法，<code>从左往右，从右往左，可以算出各自矩阵的最近且最小的矩阵位置是多少</code>。</p><p><img src="https://bu.dusays.com/2024/06/09/6665b6961d895.png" alt="image-20240609203648376"></p><p><img src="https://bu.dusays.com/2024/06/10/666703e9110d9.png" alt="image-20240610214630320"></p><p>边界预处理在这里的作用主要是为了避免在处理第一个和最后一个矩形时出现特殊情况。具体来说，当你从左到右遍历矩形并尝试找到它们的左边界时，对于第一个矩形（i=1），如果没有额外的预处理，你就没有办法找到一个左侧比它矮的矩形来确定其左边界，因为 h[0] 不存在。同样地，当你从右到左遍历矩形并尝试找到它们的右边界时，对于最后一个矩形（i=n），如果没有额外的预处理，你也没有办法找到一个右侧比它矮的矩形来确定其右边界，因为 h[n+1] 不存在。</p><p>具体来说：</p><p>当从左到右遍历时，对于第一个柱子 h[1]，如果没有 h[0] 作为哨兵，并且 h[1] 是所有柱子中最高的，那么 l[1] 将不会被正确设置（因为没有比它矮的柱子在左侧）。但是，由于我们设置了 h[0] = -1（一个比所有实际柱子都小的值），l[1] 就会被正确地设置为 0（或者说，没有柱子在 h[1] 的左侧）。<br>当从右到左遍历时，对于最后一个柱子 h[n]，如果没有 h[n+1] 作为哨兵，并且 h[n] 是所有柱子中最高的，那么 r[n] 将不会被正确设置（因为没有比它矮的柱子在右侧）。但是，由于我们设置了 h[n+1] = -1，r[n] 就会被正确地设置为 n+1（或者说，没有柱子在 h[n] 的右侧）。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 爆int</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-comment">// h装每个矩形的高，l装每个矩形的左边界，r装每个矩形的右边界</span><br><span class="hljs-comment">// q是双端单调队列</span><br><span class="hljs-type">int</span> h[N], l[N], r[N], q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    <br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n, n)&#123;<br>        <span class="hljs-comment">// 输入每个矩形的高</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; h[i];<br>        <br>        <span class="hljs-comment">// 让h[0]和h[n + 1]值为 -1，这样就不用处理边界问题了（什么边界问题？）</span><br>        h[<span class="hljs-number">0</span>] = h[n + <span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br>        q[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 开始维护单调队列，从左往右</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-comment">// 维护</span><br>            <span class="hljs-keyword">while</span>(tt &amp;&amp; h[i] &lt;= h[q[tt]]) tt--;<br>            <span class="hljs-comment">// 左边界</span><br>            l[i] = q[tt];<br>            q[++tt] = i;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 准备维护单调队列，从右往左</span><br>        tt = <span class="hljs-number">0</span>;<br>        q[<span class="hljs-number">0</span>] = n + <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i ; i--)&#123;<br>            <span class="hljs-comment">// 维护</span><br>            <span class="hljs-keyword">while</span>(tt &amp;&amp; h[i] &lt;= h[q[tt]]) tt--;<br>            <span class="hljs-comment">// 右边界</span><br>            r[i] = q[tt];<br>            q[++tt] = i;<br>        &#125;<br>        <br>        ll res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, (ll)h[i] * (r[i] - l[i] - <span class="hljs-number">1</span>));<br>        &#125;<br>        <br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">直方图中最大矩形</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="栈" scheme="https://blog.phbeats.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://blog.phbeats.cn/posts/c2dbcb3c40df/"/>
    <id>https://blog.phbeats.cn/posts/c2dbcb3c40df/</id>
    <published>2024-06-05T13:28:05.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-830-单调栈"><a href="#AcWing-830-单调栈" class="headerlink" title="[AcWing]830. 单调栈"></a><a href="https://www.acwing.com/problem/content/832/">[AcWing]830. 单调栈</a></h1><p>给定一个长度为 <code>N</code> 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 <code>-1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>N</code>，表示数列长度。</p><p>第二行包含 <code>N</code> 个整数，表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 <code>N</code> 个整数，其中第 <code>i</code> 个数表示第 <code>i</code> 个数的左边第一个比它小的数，如果不存在则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; N &lt; 10^5</code><br><code>1 &lt; 数列中元素 &lt; 10^9</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5<br>3 4 2 7 5<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1 3 -1 2 2</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>给定一个序列，求每一个数的左边离它最近的<code>小于等于</code>或<code>大于等于</code>它的数是什么。<br><code>单调栈需要维护一个单调的栈</code>。</p><p>注意：插入元素时需要与栈顶元素比较，<code>以单调增为例子</code>。<br><code>更小则取而代之全部</code>，否则，<code>正常入栈</code>。</p><ol><li><code>筛选操作</code>：先保证栈顶元素就是新插入元素离得最近且最小的元素</li><li><code>输出操作</code>：输出离x最近且最小的元素，如果没有就输出-1</li><li><code>入栈操作</code>：x入栈，栈从数组下标1开始使用</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(n --)&#123;<br>        <span class="hljs-type">int</span> x; cin &gt;&gt; x;<br>        <br>        <span class="hljs-comment">// 维护栈，单调递增</span><br>        <span class="hljs-comment">// 单调栈不为空且压栈元素x比栈顶元素小，则删除它们</span><br>        <span class="hljs-keyword">while</span>(tt &amp;&amp; x &lt;= stk[tt]) tt--;<br>        <br>        <span class="hljs-comment">// 单调栈顶剩下的总是离x最近的，比x小的数</span><br>        <span class="hljs-comment">// 单调栈里面还有元素</span><br>        <span class="hljs-keyword">if</span>(tt) cout &lt;&lt; stk[tt] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <br>        stk[++tt] = x;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">单调栈</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="栈" scheme="https://blog.phbeats.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>包含min函数的栈</title>
    <link href="https://blog.phbeats.cn/posts/9c0080b038b9/"/>
    <id>https://blog.phbeats.cn/posts/9c0080b038b9/</id>
    <published>2024-06-04T12:46:59.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-41-包含min函数的栈"><a href="#AcWing-41-包含min函数的栈" class="headerlink" title="[AcWing 41. 包含min函数的栈]"></a><a href="https://www.acwing.com/problem/content/90/">[AcWing 41. 包含min函数的栈]</a></h1><p>设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。</p><ul><li>push(x)–将元素x插入栈中</li><li>pop()–移除栈顶元素</li><li>top()–得到栈顶元素</li><li>getMin()–得到栈中最小元素</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>操作命令总数 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">MinStack minStack = new MinStack();<br>minStack.push(-1);<br>minStack.push(3);<br>minStack.push(-4);<br>minStack.getMin();   --&gt; Returns -4.<br>minStack.pop();<br>minStack.top();      --&gt; Returns 3.<br>minStack.getMin();   --&gt; Returns -1.<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>普通栈：<code>来者不拒</code><br>这种情况的单调栈：<code>只接受不大于栈顶的元素</code></p><p>单调栈的栈顶永远是最新的最小值。</p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">/** initialize your data structure here. */</span>  <br>    <span class="hljs-type">int</span> stk[<span class="hljs-number">100010</span>];  <br>    <span class="hljs-type">int</span> stk_min[<span class="hljs-number">100010</span>];  <br>    <span class="hljs-type">int</span> tt;  <span class="hljs-comment">// 用于 stk 数组的栈顶指针  </span><br>    <span class="hljs-type">int</span> tt_min;  <span class="hljs-comment">// 用于 stk_min 数组的栈顶指针，它总是指向当前最小值  </span><br>      <br>    <span class="hljs-built_in">MinStack</span>() &#123;  <br>        tt = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化栈为空  </span><br>        tt_min = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化最小栈也为空  </span><br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;  <br>        stk[++tt] = x; <br>        <span class="hljs-comment">// 单调栈为空或者压栈的元素不大于栈顶元素</span><br>        <span class="hljs-keyword">if</span>(!tt_min || x &lt;= stk_min[tt_min]) &#123;  <br>            stk_min[++tt_min] = x;  <br>        &#125;  <br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">if</span>(stk[tt] == stk_min[tt_min]) &#123;  <br>            tt_min--;  <br>        &#125;  <br>        tt--;  <br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> stk[tt];  <br>    &#125;  <br>      <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> stk_min[tt_min];  <br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-comment">// 普通栈</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; stackValue;<br>    <span class="hljs-comment">// 单调栈，只放入不大于栈顶的元素</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; stackMin;<br>    <br>    <span class="hljs-built_in">MinStack</span>() &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 普通栈来者不拒</span><br>        stackValue.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-comment">// 单调栈只接受不大于栈顶的元素，除非一个都没有</span><br>        <span class="hljs-keyword">if</span> (stackMin.<span class="hljs-built_in">empty</span>() || x &lt;= stackMin.<span class="hljs-built_in">top</span>())<br>            stackMin.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 要弹出的元素和单调栈的栈顶元素相同，那么同时弹出，否则只弹出普通栈的</span><br>        <span class="hljs-keyword">if</span> (stackMin.<span class="hljs-built_in">top</span>() == stackValue.<span class="hljs-built_in">top</span>()) stackMin.<span class="hljs-built_in">pop</span>();<br>        stackValue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackValue.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackMin.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">包含min函数的栈</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="栈" scheme="https://blog.phbeats.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>第十周总结(6/03 - 6/09)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/0a859ba849e1/"/>
    <id>https://blog.phbeats.cn/posts/0a859ba849e1/</id>
    <published>2024-06-02T09:09:55.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="dfac9c66e127ca62388030cd503a80e2068589524f343742de4dc74deebefba1">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b081456281f2c01e4e1c6dd2c48af7d023157575d46a0949c2fa1f81762e092a7613379916b95be85df407c438133ae7bab74dd25ee3075a11ba0b566f8b78d6d143f9eb214759f3ba39a567b35948cd9418aec66de3b9da4f25e1f1ab0709739a5ec4d5f9cea67ee771fa57ca7a240f5e2a2babee79ff899d7905c9294e7d130535b84f17b1377dfe343c7feb6aa19e744d68b9f487bfbfce3b3ea53b68663de5ea7851e7451ae3b2b71a7f23cb4a4b7c1c9adfffb49643fdfe338cbc798ccc7077df099cc0022517c845830610baa108e852737f83e807e3244dc6154cea74371bae1f27498db6f15df23afc3c015d49d4cbcedfa8f584aa91f3ce6aadfed721927dcd922fb24e397c302c5590cd1f8cce6426fc921c088f9f75aea4966dabf966431978fb94d6702b1f842461f84a585e51f03ccae7da76c37a32d0f27de307ea7d15a55aa45536cd8a94838904496f81be912933fb156a147e489ace1b61c4a093982dcdd94b394fc15f8d0f32bde29088dab9c94fc83b50afd0834da0dd65d3b78bd8e048ec9229af2685ee7633cea8afd403be23790a6c1dd2078ccdc1b780e9d188da6d1e1fcdb11cba58666c7d054f347af1174073785f94e932ff4b7baacecc1de1d80feaddfcb7731c0e7278fced2963b9e657699570146ed26f717226a13190cc127f0fddf2d505ca77c9f0c5472601db549807d1c4990554ffee0abd0062348e8bf3e366df8ed7bcbb981a708fd20e43527d33eba98a070b4a63411e54d626cc4a87109acb3f44b1b33b57ce064fa6d14d71c7c6381479eb4d4ccb1fae87bed6af6512af3b412b4eb8cc314f34d5053cc32a8e988e0e289c1b88ffeab7796c4c53f4bfc2358e2a2f02c329e9ba36addbe0c8d2c65ef79f3c10c062497bbbb1bec14a2546bf2ba4887ae345411b3e87bca32eed0626d8625e5b611df646cf3ac77d1558642d2333dfdb5f83004d617ea139cb0d2fe2c1edf37986b3e1032f92a2c26a106aea3ede691c55d8a0409415d32d830b9f21fcacc56a9a4f1f9b8f9688d63eb1bc3c85346329fa7ce5e6c98109695953ff91f3c216fb92ce5dfe48fcb43e01827481298bf1b9faed60aa75ef4d7549725b7780c3a563985cf28fb99ee71729ecfae21457d117776601ec72281a60c83c24fa0a93582cb2174b9259148d9010637d976dd728adb0d19cb31e1c77a2775e519855e1f1cf27610cf45253d8c0a229c0074e2f9b49f7156cadcbc50d98a59ccd6bd1be82edf25f1bc7caa3fe4f56b627c3688322986a72a87b833527c9b97ab8652802fa6781ddd34eaf99b913b565900200a619bfe0da0ff3eec3f6494bae0e8baf7a0217d37f95a70dd2c9d24c5379a7195a536afeb07782ec3379c7aed9e7560b1be9374d90bee3b835adcf0f1e0bfefe89854df5a9f5f5c382101fcd92cdc2e64752bc441036c5946808ffba6579d19bae919c478b0a7d1393cd91ae1e3a40825a4bb7d69cabc8a85b432e14fdd9419ed1f161a7cf5a7b668be93af4cfd5ace2a597b7677ca1d1e9b9bf28fbccafd9de0e32370f65c214ce7e43dbba8c6dc2fdd40cfcb562fb5278fb67a3bc67aef3618da8234c5890fffaf6fb78d20b8e6eaa46692ae005780dc36f89420071fb7608f75ac4e0175d0a8173a433c2309dadf5a3420c06a5f44ab12eb22bc824413a8862262cc1820b3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十周总结(6/03 - 6/09)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>第九周总结(5/27 - 6/02)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/c2105732bf66/"/>
    <id>https://blog.phbeats.cn/posts/c2105732bf66/</id>
    <published>2024-05-26T08:57:53.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6c6fedf055c6ce4e46cf2ea1b0be891c619d7e8e3eccf2f7ee6db10de8f41ff9">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08148cf6dcb42af7797b6d01e75b6cf044093e979b81a2f60dde267d9c3b86e9a47aa9be9d8578b305af0cdab91dc7dfc6d952c517b0ca8d56c450bc8d2940a3cfdd4caa239302df946ef7c0919a6b41f42980d8a9d7c8de8f2038a91eb486803d528b7075906c68bef55c0e7d8208b45dcd28358d968714c0d220a24a586c9fb907e1561931b4bc50f563ed52d765f26144b21f9bdbf1014ff307cc7bc19a1ad01d26e55a5722834c799e18288def744c78b5b27c2a2f57da11b78fd90d485c054dc2d30f28d6ebc91da508fef116baf912eb5b2bc519872781b5c76ce3dad2d22159ae333da74901ea86432d9937fdf3169cc9aa08310d5fdb98a28ecf506bee51672503fb29b6aa339df55278fcf0ccb413c1f4a26ddfb3e371cc0277654b8f95a14dce9dc8c864cae54876e6459595440e51a61c007042287f9a7814806fd1e781341cf0e18945fca687cfc113dce2756da0b914959af71f527abe6d21c855b55cf717a3e693d69f8b8e392a7029ffdafd23ed9965775eb5465c2d8efd099b169c9582350702878efcee7b7d5f53957bcddbdb6a2f9b4d3aef8b645f699e33993601f1ad41440cf35d43a90e9b21f8be8219762661e74fc5836f79980b3e72aac26fe408f59606ad020f1f15a1ffd1bd51ce157c6a985fdcaf6e34036f766ac492a7c8a360528d846170dc45960558de19252a7b45c0ecce3e5443bb59e68a8585c232b1a0351e492515cc38fcc9d424b48798f2678432d634fc7e857102662a16d66e41503881d97660a5e77f73490d9f5bcf956f5d27e15db64e269e73b1bb8a95bee3b040960c524f090f178d6fda8ee7eec1c1074c2b343ba8bb37ba49353475d8dea1197149b93d71150c6a093127a2ee020668bed2aa85cfbe25769b9f33a67676843c940b8631ba1113c4aa2f45757e095715167aad449bf8e18999ae3a90c3e4248185a34f3a59f6e1ece222090f32e7233728809b8e4b33faee8121b2188ede9a89e08ac28609272b70da83b28d05725f1fe91b64effde810a9ba175487b870423c66079e84c48141d0541f85228442b82ce6ed5c959dcbc9482ca85a86ab2e37df5c0c68c5c4174f1fb33faa401385d58624e9dcd0a1a5be369dc8d20a97bee0ded866670ad98ba241313329df694be09d92572287a0a390cb0751f03bf2f5b553c932821ebcd6723ddd67f7cd659e49cbf0c49418f01b1a37f2dcc49fab8aa0ef20c44147e9ce5f173049bec5c4835869edecf1b8b9dcbb3ffe1762f2f7ff0ac457fd40e8d35c1fd440c824eacd3ae9430c0d4ca18a82baf66b43ac7ca07d2b392af9a705190a4c0a142ec51b5bef566bfdbc965d31246c411f1202fc5653fa12a6f38436175829bb400abbaa09024b72d40799af10b6e27894d7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第九周总结(5/27 - 6/02)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>第八周总结(5/20 - 5/26)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/e00fcfa54b2c/"/>
    <id>https://blog.phbeats.cn/posts/e00fcfa54b2c/</id>
    <published>2024-05-19T09:09:25.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="05fa4451d83a051b19c8d1ab593483d316ab199530e626db9f4044e23f1df7ae">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08146e5d80279bfc5b7c843ef5834902ee6f904c219358a09c8c1e1c121f4f6661093f4613885d4e54d31998c24a60ba8aecc2daa47404a0382222359da04367570b0d2d4de51823a997490772d04d27dab26d54f1c1a1fe60496f1e0090044ac961953dfaf3b9e7082484f474b31f2542c000f9e8dcdd62e0a41906af1cb69fde596f60c8db2753e4d89effd8ad57da12d06d3f0d40ac52c9464e1739d1e4cdfb0a0d280e7b0a2de74ef2373be97050217653cfe53d554af4447b9505edc9626f0512645fcfe125fe02715ab5505eddb5894e2b4114eaa31bb753642ee35db3bbc7cab983ed9d5a0156f9ab971e5642fa29fd2d784862d5e0e89a45f9930bcf0b5b672b494b1fa61d8b4365db3a9f6700b0d7759bcac0a7e16f96baf377079dd738f3056125abd404f3c62e60fc05f7790b9130592673e24afd1aad966dc1b740d286487f94af838fff5d8d31e83c270b93a07d3676dacde8a32fb7c054be223ee3d81b67dc9e090c8b3efda1c5e6aa6e9bfd54a72aebf9b290af33bf413043eeb2c4efbc383cbcf20471fe49bf880f9b5acfaf6a65b3fbab157f7828732d0b14782760fde76e5c1f8f0e449c6baa0ae5cbbe7bde9b33babbdb81c8a53fb3688bc87197204968c050f8c779b6880a1b5945212a9a7995baceb44d08884fbe47a4c08d6c67d263eca3f51283c25b10825543a5f645aae0c83fb81399b5be3b948adfe46af1a988ff0154adc511452a654c91d8761c71c8936478fe088612afb24bea6eb6c89c48680b85e612c5616d6d6cb3c1bd27da65c03f8d1eb872612d9ca00d26815937579fa885e0d7849d29fcc142be8049259d584fe28b51a9a02cf2beb48faf59c4a260bdb2b60a6fd984e779e7822571583d2da97e66a48046515b0894f2ce4d39dd23e31b048ba021ea1995c1388cc2e7fb6b967199d516f5103f9232a723542acfff3cc09c237c47757a75fe637d8e25c2d6f27fae986a579ff92580c3f72e7c2c371dce119c113b71613a8e70b0c1e4a14d5130d6f838efd0e55568488918c78635af52107920c9fe3195285a45f135327fe8566ff5bac1e8464dbfb57fa3f25a34e93df5bbbc5d3e58744ac975a67ccb5a9d3bfec8418c74161c78caf047dfd86b6a9a15201872dadbbfa8a2756e122411d8fe8de26247b58747ab146088eef7a2a64f13f736f9593929b6c1034150fc0483f4e89b3a34dfeb0b0780f40757857060d7543d23e3d3b08fcf44bbee47f2cb5399b47854c2119e5ac8583d26e4ea490f8873235de0e90992c8e8509fe7ab2e72af01a525085b2903ddbf48d994d4f8ce39c77a28329e3b3b6a3d31485b2e15eeff15b9287bedea6c0330d33e0a7c62a95d60ab33ddc5355a3637e2e793492d9318ea0eec67b0624c6189204370eae4e3188f974ed39ad8893082048632a0289607a3e3897583286c910f4291e48b429582e69afd16143590ea6000101405e4a6db00c1585652de94d7339f98da0fbd491506d8b384adad9792980c64b0d7f0960843387c6897bc2a59cd1ddd39e2d137d4b9d7e7101879940166d1a462dea192abddc275043230f961f0b2680971d7c34de23908a016f7ec736d863c22516eb9e3725429585cd0b8195c0eac48249221a24e9c212b486b2dd5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第八周总结(5/20 - 5/26)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]3757. 重排链表</title>
    <link href="https://blog.phbeats.cn/posts/15cb5950f25b/"/>
    <id>https://blog.phbeats.cn/posts/15cb5950f25b/</id>
    <published>2024-05-14T13:17:44.000Z</published>
    <updated>2024-06-17T03:24:31.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3757-重排链表"><a href="#AcWing-3757-重排链表" class="headerlink" title="[AcWing]3757. 重排链表"></a><a href="https://www.acwing.com/problem/content/3760/">[AcWing]3757. 重排链表</a></h1><p>一个包含 <code>n</code> 个元素的线性链表 <code>L = (a_1,a_2,…,a_&#123;n-2&#125;,a_&#123;n-1&#125;,a_n)</code>。</p><p>现在要对其中的结点进行重新排序，得到一个新链表 <code>L’ = (a_1,a_n,a_2,a_&#123;n-1&#125;,a_3,a_&#123;n-2&#125;…)</code></p><h4 id="样例1："><a href="#样例1：" class="headerlink" title="样例1："></a>样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;2-&gt;3-&gt;4<br><br>输出：1-&gt;4-&gt;2-&gt;3<br></code></pre></td></tr></table></figure><h4 id="样例2："><a href="#样例2：" class="headerlink" title="样例2："></a>样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;2-&gt;3-&gt;4-&gt;5<br><br>输出：1-&gt;5-&gt;2-&gt;4-&gt;3<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 1000</code>,<br><code>1 &lt; a_i &lt; 10000</code></p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2024/05/14/66435bd78bd41.png" alt="image-20240514204050974"></p><p><code>将链表分成左右两部分，右边那一部分进行逆置，然后将两个链表合并</code>。</p><p>前半段是较长的，切断点应该是向上取整，尽可能让前半段长。</p><p><img src="https://bu.dusays.com/2024/05/14/66435c81b8b12.png" alt="image-20240514204345071"></p><p>选其中一种情况讨论。</p><p><img src="https://bu.dusays.com/2024/05/14/6643611cc4cc8.png" alt="image-20240514210325505"></p><p><code>step1是合并链表的过程</code>。</p><p><code>s</code>节点是需要提前保存的，用来维护<code>q</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rearrangedList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 题目说链表节点满足：1≤n≤1000，只有一个节点，则什么也不做</span><br>        <span class="hljs-keyword">if</span>(!head -&gt; next) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 先计算分割点</span><br>        <br>        <span class="hljs-comment">// 求长度</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(ListNode * p = head; p ; p = p -&gt; next) len++;<br>        <br>        <span class="hljs-comment">// 向上取整</span><br>        <span class="hljs-type">int</span> left = (len + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// 找到分割点处的尾节点</span><br>        ListNode * a = head;<br>        <span class="hljs-comment">// 移动 left - 1 次</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) a = a -&gt; next;<br>        <br>        <span class="hljs-comment">// 右边的链表，由于要进行翻转因此有两个指针</span><br>        ListNode * b = a -&gt; next, * c = b -&gt; next;<br>        <br>        <span class="hljs-comment">// 先置空</span><br>        a -&gt; next = <span class="hljs-literal">NULL</span>; b -&gt; next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// 进行反转</span><br>        <span class="hljs-keyword">while</span>(c)&#123;<br>            <span class="hljs-comment">// 记录排头兵的next，方便维护b</span><br>            ListNode * p = c -&gt; next;<br>            <span class="hljs-comment">// 反转</span><br>            c -&gt; next = b;<br>            b = c; c = p;<br>        &#125;<span class="hljs-comment">// 跳出循环, b就是反转后第一个节点</span><br>        <br>        <span class="hljs-comment">// 合并链表</span><br>        ListNode * p = head, * q = b;<br>        <span class="hljs-comment">// 选 q，是因为 q 比较短</span><br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            <span class="hljs-comment">// 提前备份，维护q</span><br>            ListNode * s = q -&gt; next;<br>            <span class="hljs-comment">// 合并</span><br>            q -&gt; next = p -&gt; next;<br>            p -&gt; next = q;<br>            <span class="hljs-comment">// 新的开始</span><br>            p = q -&gt; next;<br>            q = s;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3757. 重排链表</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>第七周总结(5/13 - 5/19)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/18dce1045e76/"/>
    <id>https://blog.phbeats.cn/posts/18dce1045e76/</id>
    <published>2024-05-12T12:50:07.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="be23e89b95f5745738aae2478d786862b2b5b1b7e21991b2941ed1a61997148d">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814cfa77eab28e95f83ea7aea878afae15fad98aff38f6f399a48e8c2f97bf75cac877f7546d614d49ec38eb5221108a411ccb11bb60f246ecb18aeea3b62b05b7c15f35f2de669450cf88414a96ccf0065acd319d65aa3d73cbc0d697a153fc64d5c1032fdc09e92eb73a91aa0acd65130cb5827d7e429e70061fac1e1a07e2966363901d827259668497fb1b49a207d4b4230affc6ce758a058b94fa01d250b3e7c3f7e265b5ae028a1662a67d25c8a8f902312bf9609b9c7d1b0241eb84dcd1301d6ccfbe100a3a350d21eeb5967b0ca0cb60e4c680de2a0742a5390bc13ad6ec464dfdee422e0f26607c37cd2c16e7e13dc0b3361514c13604f7ff74c6f8d57aee576e341e6c14c0dbc9bedc554cd92df2d7520427221b01771800336a6d2cbb680068fe5936c23b3685f0c977724277c1160704df1c9fbab60ed7a66341297cf803b14733ddc73676d0df294c177868ceb18360e12b6e9495d226829fea442642e93d6c5598230e2c84628af82e744b6b2ff8a230261848b90968a1029656784881d5a0c1d919c5efecd4ecaa023e4b45a677ff7adeb1981c85510cfa60b554cd1918184dd747ab827f39f60c3f469bf8a1c8a58ac953a05ba31bf4f5f7d548ba9ff2c6e31e9c3fa4bcf8c4c1fbf39d214fbd746d627ddc1b1002796de8328c83832d744e305d86540cd6075fb4897a848d4be686ed8e4b153cc5bfe43d0a61c5c0c83c09fa39cfce3befad521bbc7a3eddd8d70f58dee192e32898a432825c1182d91b6392d063c57b3dd37700a8e0c829779735d7ffb3bb46226404f2c40ab1e4bf6159130484a35e5dbd5845839ff590b8b41ac83e984658159e3503a1732e0fac343e0161fdfdf51020a7ce6e3ec56d1755871e36c924cf06d767dc66b560dfaed2e9690e37324e41adfea89664ee49764d95db6f2eb4c7c26ab5929782cd79bebe3d2d4bc66213749856055d934ed833b86a1dd87532fceafd87a2cc35559a47075844f2a7688dab1322a7a1b5600f305fefb61d00cf85293ec88dff66e062d8e9c7312d552f407143a10cdf57572e5cdfb324ed1f0d41fc4aaef6714566acf8be605d44ab58f0231d96f3a9a64114ac31f61e3b9b1781784aca179e165c7a2cc333fddcd3b24c02f1220592f6d27e5d7e9ede888a0cf1f9441ea6afa1c91c1f6d016a9a5c6e9f116d5c6d2e7e5c0c0aabb8d9d90c6de56440ae94f3bcdede8cac6e20e311fc6d5e8a98007add58366dac951b3d3059a39ad3e68d68b226a78a9aa19b53eebef9ede1d377c0f1c8a76a0e6bd75035d99b39426db267466b230621435c09bf33bb62d43073b73e574a79677463bf052663b68d75e452afa1926a6b9748b971d45b8a76a2369f42fb3582ab83cd3abf30d43a5e53ebf9eaa6371233f3c67fbb733d836c1e823a4d3b7fb4b81105ddb42c24107bdef3cc39afc111fdb061bc6e85b28eebd413fc80457ea98dc5fd2b844135a9432ec788aeae5b3e3a7954ee77e43add723ad3a1cf4f22d3928245aaa1cc82da88f3da4d7195b9c580f7613f7ede3cbf5b94779a684ac419b5a5b9ec0f7643cdd7e53f976c1c9d242ab371b540d4ef0242c03df23d125046ec2a8342fdeffdf98f73fee7959eafba28c106bc7b66ae4aa42d5a1059d26ff0eef7b1c9c29133fbef80f0e1ec88ecfd486edf7dc0a497dad5c1ecefe639055d5ec9968096f0fc389d0474adb75ddffa9749cb03f5d0b0ab673b3f299bab676db085b34386af17a936c13faf99cb5bf8f55304af7bd500c1083bbe864ee2ee1d0a437144fc845862737293ae8254353fc8da7898a0d4f2408cf47929c45cd52392fbeaae743c48381cb6acc011c3f5760460bfa6c24a4425401920ea5e967bd37d886697c8ebbc77b6d448bbe8c9f68965c256184eafeee270311acd5a553b6d2f8354c9f300a78af6ca1ba2e797686803866f15f44fd04678c8d6e14ff66b5e8ca110853ec26dee0663073c4ef4a1b98a0863ecc7c9bcece115d616d58bb21d747fa122bf5ae601ea65bf36940dca5ef1e636ca1ad807ed0189171c6f62ce73b05bef1e32dfa009fa661ccc853e579c0095a7d593f6170738d589447a121d2d4cdad0af7aa1fdf83d79913da2853847b224392672c29e6d9c2c224dd19f9a83d2ec606a373a9c80c4f2f82b460c05412e54be71e270fb7e1cb94ac8dde8b55cdb79ee4d8d55015bc47c3238cbf515976279130a5cbb60ffb20ca62b7ac4c5e5213c337ce8c22391033fb32384dceffa808fd1fd4e74b3e7df222ee26738077075d18f9cf189e4cf89df8e475fc150d382aa3ed6e6f1ad9d08de8d612</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第七周总结(5/13 - 5/19)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing] 66. 两个链表的第一个公共节点</title>
    <link href="https://blog.phbeats.cn/posts/0a6333a85e34/"/>
    <id>https://blog.phbeats.cn/posts/0a6333a85e34/</id>
    <published>2024-05-10T11:34:56.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-66-两个链表的第一个公共节点"><a href="#AcWing-66-两个链表的第一个公共节点" class="headerlink" title="[AcWing] 66. 两个链表的第一个公共节点"></a><a href="https://www.acwing.com/problem/content/62/">[AcWing] 66. 两个链表的第一个公共节点</a></h1><p>输入两个链表，找出它们的第一个公共结点。</p><p>当不存在公共节点时，返回空节点。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>链表长度 <code>[1,2000]</code>。<br>保证两个链表不完全相同，即两链表的头结点不相同。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">给出两个链表如下所示：<br>A：        a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗            <br>B:     b1 → b2 → b3<br><br>输出第一个公共节点c1<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>两个链表，两种情况，<code>相交</code>和<code>不相交</code>。</p><h4 id="相交"><a href="#相交" class="headerlink" title="相交"></a>相交</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32ff3099be.png" alt="两个链表的第一个公共节点"></p><p><code>a + c + b</code> = <code>b + c + a</code>，它们相遇的时候一定是两个链表的第一个公共节点。</p><h3 id="不相交"><a href="#不相交" class="headerlink" title="不相交"></a>不相交</h3><p><img src="https://bu.dusays.com/2023/08/09/64d330de84da4.png" alt="两个链表的第一个公共节点2"></p><p><code>a + b</code> = <code>b + a</code>，下一步它们都会走向<code>NULL</code>，而<code>NULL === NULL</code>。看作相遇。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">findFirstCommonNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode * p = headA, * q = headB;<br>        <br>        <span class="hljs-comment">// p从headA开始走，走完从headB开始走</span><br>        <span class="hljs-comment">// q从headB开始走，走完从headA开始走</span><br>        <br>        <span class="hljs-comment">// 不管两个链表相交还是不相交. 根据 a + c + b = b + c + a 原理</span><br>        <span class="hljs-comment">// 它们一定相交</span><br>        <span class="hljs-keyword">while</span>(p != q)&#123;<br>            <span class="hljs-comment">// 如果p走到末尾</span><br>            <span class="hljs-keyword">if</span>(!p) p = headB;<br>            <span class="hljs-keyword">else</span> p = p -&gt; next;<br>            <br>            <span class="hljs-comment">// 如果q走到末尾</span><br>            <span class="hljs-keyword">if</span>(!q) q = headA;<br>            <span class="hljs-keyword">else</span> q = q -&gt; next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing] 66. 两个链表的第一个公共节点</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]3756. 筛选链表</title>
    <link href="https://blog.phbeats.cn/posts/5a709920de81/"/>
    <id>https://blog.phbeats.cn/posts/5a709920de81/</id>
    <published>2024-05-08T12:11:58.000Z</published>
    <updated>2024-06-17T03:24:31.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3756-筛选链表"><a href="#AcWing-3756-筛选链表" class="headerlink" title="[AcWing]3756. 筛选链表"></a><a href="https://www.acwing.com/problem/content/3759/">[AcWing]3756. 筛选链表</a></h1><p>一个单链表中有 <code>m</code> 个结点，每个结点上的元素的绝对值不超过 <code>n</code>。</p><p>现在，对于链表中元素的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。</p><p>请输出筛选后的新链表。</p><p>例如，单链表 <code>21 -&gt; -15 -&gt; -15 -&gt; -7 -&gt; 15</code>，在进行筛选和删除后，变为 <code>21 -&gt; -15 -&gt; -7</code>。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：21-&gt;-15-&gt;-15-&gt;-7-&gt;15<br><br>输出：21-&gt;-15-&gt;-7<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; m &lt; 1000</code>,<br><code>1 &lt; n &lt; 10000</code></p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>如果要筛选掉重复的元素，那么必须要有记录每个数字是否出现过的<code>bool st[N]</code>。</p><p>而且链表中的第1个元素一定是没出现过的，可以直接标记<code>st</code>为<code>true</code>。</p><p><img src="https://bu.dusays.com/2024/05/08/663b74242dace.png" alt="image-20240508204615900"></p><p>对于<code>p</code>和<code>q</code>，删除点有讲究，如果是删除<code>q</code>，那么成本小得多。</p><p>所以<code>q</code>就作为被检查节点</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">filterList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 标记该数字是否已经出现过了</span><br>        <span class="hljs-type">bool</span> st[<span class="hljs-number">10010</span>] = &#123;&#125;;<br>        <br>        <span class="hljs-comment">// 第1个元素一定没有出现过</span><br>        st[ <span class="hljs-built_in">abs</span>(head -&gt; val) ] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 当前没重复元素的最后一个节点的地址</span><br>        ListNode * p = head;<br>        <span class="hljs-comment">// 当前被检查的节点存在</span><br>        <span class="hljs-keyword">while</span>(p -&gt; next)&#123;<br>            <span class="hljs-comment">// 当前正在被检查的节点</span><br>            ListNode * q = p -&gt; next;<br>            <br>            <span class="hljs-keyword">if</span>(st[<span class="hljs-built_in">abs</span>(q -&gt; val)])&#123;<br>                <span class="hljs-comment">// 如果出现过了，删除</span><br>                p -&gt; next = q -&gt; next;<br>                <span class="hljs-keyword">delete</span> q;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 如果没有出现过</span><br>                st[<span class="hljs-built_in">abs</span>(q -&gt; val)] = <span class="hljs-literal">true</span>;<br>                p = p -&gt; next;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3756. 筛选链表</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>第六周总结(5/06 - 5/12)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/a395edc2fc97/"/>
    <id>https://blog.phbeats.cn/posts/a395edc2fc97/</id>
    <published>2024-05-05T12:09:48.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="72fbfab78a350ffcf08d36f00df4c78945e0677809efcf441993cbdfbbce1bfb">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b081447d9b719472bd5775668a255d225b23d438f1a71fbc386340f8f54f64e69f613c8fba85fa24fa98799869a309cab3465099a986368de14b981d817357654a9f6a41178c10bc425825db9852a0014c379de9db8bb49852180e57b06cb94bef8bdd4faa062bce36065914b1e4d92bfefb86611685a234cb1efbb68825526b2d9c41eeb8edeb1e21517ae269aa5cbcb1baae8dbac5223501967e134c96f384146525fffc0a82ebde5665cd91defb7cd454d566e36b1ec3fce46270b6ca9c913825ba1a53291fcb3732db836afceac4b752ccf782a8ec60093b5660e42253adbe1e40931dc23fcde98992382bef19895b680ffa0307c0f8554b2815c324b1282f79bd446d1102f63970efca2d911bb65db1db07ffc4d222159c1a40232b7235d218be157c6e77cb3ace1d18184828d63550443c19d16ae1b9419c6f8de3fccd75601cca48f39fd3bb6e933190271938d8205095f2731d7c1f38144de83efbd489bfe49ee7bbd85dd8d2f5c2986f0b46f99a0ae6aef5dce39e61164ee947352eb5b0d0c146b7b08f503b4c9d24bb9455e22d4715667f78081ba0fce08543b3c5e4715dd6302f81a5aa96c43bbf6e05a5827d85d63993ba82a7f1176cf41855d7d2d6682ac7cd599ab5d2e8f05fd29a856f1909ab1de80f326eab27ce50231e460aefa70c14714d35dad01d1e2d0faeb951f7ac78b043e1aac53b342091de77946fa03ab9860ecfdf062b41f23623260b4d5241bb1a08eb99da57aa6e27684ed45b04b5545b59c7c11aa015a45ca1818cec5af5e5002c8f372c524bdd8443f85f8fc5acafe07122f5217bf7c9d6c062db43d0ad3896b3b3ac67324ad53c341b311dcb03db7f9fa762c3032722dd57cef8c83751729fbb91affd39ad49c5789af87653818b9d42d3159de8799648b09f6c3ab29a511d6d3cf8b8471efbda234fcded546f1ca7d174b732267f30997b5434fb87aaffa4fd490ab5034f7395a27ab80c8789c706ea625204fb016565943dd42b6935afaddb3139d322ddffe4bb187b31def7b03b080231a8ffcf2e3644e7eb44a6f5b43acbc28b39cd54eebb2c4a14250a27e359116e38aaf99d642ecc66277417dfc69500a687c60d217a81cacdb940f561c08a48970b029b1c06bc5b1bfb804e468f31584e596e44cda6d58381e7edc744debf76982c89196a19364c20b563bcb5e7c2a161bb0c37de8a37ee676faeb685169d7ea2eea56961e79252ffe6049d30858e9272473b0281f47e3bcdfcc910ac868be7a043d6451ddba539d69701490d83a0d0c43e90c2d1e9d80328bddb54f48efa1907b5f1ebbcee5b83f5d3f810f68e09088c9d1850b90f023253830ee1fc16f8ca71d9d8b78384db1b6ff8b9d2ace2ef6bcd0b8f47ff0f8edd81468b03514decc5466432322ea71698d83d9fdeecfb5555159fff302e154a9998fff4f18fb9cb1eb1d4ff337b011ddc16430c0092d551978686771fc829b0c593e0d9359faecbd37bb14424b5d037dc363760dba8e67491d7e1d926c82b0291ed8065a30e0a4f0b2727b99020d139fa3566dcc21c510035a79f9603af6a6ef30f6952e62bf38fff582eaee5453afbcbaedc2675a305f954f2d847a28faa3cb1a58191086e4a3a328adf4e1b7f19ab469fbe9c31fff860f59d591b7d85790e234d7f2160e3739fcae2dc8cc7403d65fb7dd0409193f9ce364f6c84f109e12d65422dd724e6746139256061a0290070f2b7de3882d3017ccc94c5a4d3dcf72043604b5b0ac36cd5a8cacc6a818d17e948f410a3cb9635ef5f1cd15f92d4d6d65c5eb1b196ca6f8e6b8f804b493de77a59fb2e78f528aa7fd587f547e00b4131bf5dfc2fcd6904939ba328bc45463163f304eb556e5eaeb460dff005ba4cc3a2ccde498e98c5abc071addd2a43c09acc2624af722d3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第六周总结(5/06 - 5/12)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]35. 反转链表</title>
    <link href="https://blog.phbeats.cn/posts/2097c5abe775/"/>
    <id>https://blog.phbeats.cn/posts/2097c5abe775/</id>
    <published>2024-05-03T12:50:44.000Z</published>
    <updated>2024-06-17T03:24:31.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-35-反转链表"><a href="#AcWing-35-反转链表" class="headerlink" title="[AcWing]35. 反转链表"></a><a href="https://www.acwing.com/problem/content/33/">[AcWing]35. 反转链表</a></h1><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p><p><strong>思考题：</strong></p><ul><li>请同时实现迭代版本和递归版本。</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>链表长度 <code>[0,30]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入:<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-literal">NULL</span><br><br>输出:<span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>先分析理想情况</p><p><img src="https://bu.dusays.com/2024/05/03/6634df9defdf9.png" alt="image-20240503205906942"></p><p>分析较为苛刻的情况</p><p><img src="https://bu.dusays.com/2024/05/03/6634e0232c079.png" alt="image-20240503210127943"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 只有当链表一个元素都没有才返回空</span><br><span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 只有当链表一个元素都没有才返回空</span><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 迭代版本</span><br>        ListNode * p = head;<br>        ListNode * q = head -&gt; next;<br>    <br>        <span class="hljs-comment">// 当q不为空，则可以一直反转</span><br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            ListNode * t = q -&gt; next;<br>            q -&gt; next = p;<br>            p = q;<br>            q = t;<br>        &#125;<br>        <br>        head -&gt; next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// q为空，p是原来链表中的最后一个元素</span><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]35. 反转链表</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>第五周总结(4/29 - 5/05)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/85a455bed5d5/"/>
    <id>https://blog.phbeats.cn/posts/85a455bed5d5/</id>
    <published>2024-04-29T11:26:06.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="119c3e33974b5bc638c4883c92d80c7812602266195769950c12ea008c792151">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08149440b265571a5a7ec46d02fbd8532beeb82a238ea588828539567ce9a75dc174b49773c4aa6b00588a520d0915ca8e3f54793cfd93f33c0a4eee66004549ad97e4fa2e967f3318874369148cbed3863b3ce275b16fc419fcc5f542e74b188a2309b8323a25e7315092778008831571e8c9ba3ecdad9ffd3127c25c7099abacd7385ee48de3dc0ce644425469d8bd051c1ac810d9d17999878d51068493b0bcc96eaa7eebb38e1c5cc50bf5791ae3b8f56fccd3417213f17917ba9dd6cd5357d9f9b5a2e5b61fdf48db4ed61341dd00b2ac501b236fcf12f501c67763163144195544f38824f72631b598eac4fea9539885015414a9a3d66d4fbd1cf16e956c75ab17359945cdb4e99252fe0be9d3e610c712b1b5f5e5c7e93f9075579b2e38533b3bd8583199f4059da85afb7766142198e3ada491d3368b94d2d58147aae3a1ff4f73e48619f49a7363bc3120cb328c4e690b97d042c52a8557311bffd94bf2a7d3df59b3d4c5615d8f766b85a7dd5dc38fbf4e6c41c9fdd0d64ebe448be031d54ee5b4958666771ac029a2c8ebf7118a8b86aa6ad37843c9874be6e05eee76902469e8c5079a57439f12bb7c893bd5c82da30282668aae8616799fab66ae2932e815b04ec3f44dda059df3d80f851b472e9b8d33ad59aea3f80323262f39f05e27a135e7613beff1299469c0c6bfb13e98d2edb7722bcbd52c033ee18336b146755711f70b9a732384fabcbe8de8ef9379b1c5c241c5450d92e52a0373258bb3c9cca18a67bd8658441c7a623420bd921fd7624d99745e5fb71f68a15336182ae565d9fe8f621b21ce3e794ef6ac19dae5c2a159d2db412d90ff044beb0f4441ae36d1ba74ae7e2a6cabedaf958f0ad52576f520f7e91d819ff12757760a233d57c40714d51b4ef9ee999fe15d4a0502eb8196a40af473512b3593ee37f9c5b4fe4f27df88b4407ee0f7ccf9a61f91b3ecca896152499c758b1b1185d75fb248581b229f6443bd334e0e9693ff57455654883a72a3877542acb2a09442050c3133fa3058facfcefcfd7848eef9a2d93d685e19c6a6d7041e7d7c369c0636d8b968c60b12c03c29be35b2fbd05ffe286284d332e30f3038f96d20e61a836c5883bb82fdc95dde28e4e385857e8c8084ef53eca9b90dd720aedf1aced6a8ba232450dc541b80d912f68d3b9e9eae39c805d2b5b9bbfd07c8c4ea43dcb7e50a39e8b64ba3d11c1dab5658ab0179820fb94a8ce1aa699957d52460fdf3c908994fe8af89c9be86c9b1756243cd2bfca2716dc7a1b6c4320ed0cec7d122ca8bd88814e246baf8eb02014b81dd36af7cc393944e6cf8b57b243f9cddf1f0f49fbaaa16c723969b22ac5b29a6e54483370b09cbcf9f8082fba2dffe6496e430e7248ad750f61f941aa13f841c65c3dc4918ac3c5843ab0b1dad217942f3590fe33c09aaba8705293346ea1141fa6a5325e24edc6e6c5f9cf9146cb31c4d4e5722a61bf17ae97ddfd51425462151119133a97f123db796b779dffc8bd30ab89d034ca62c98ffb4d1ee8e4e699dfaf2b43eaeb06d65d050bdf3ef18ad2920c43a6463a1f802dee7c3d542eb602fa9efaf19d988bb5933a0a0c65b8463c4f9fe80a95b9657d837b904a08ddc6f20f1d88edea8a8d93101c79bd3a51351d55c3b30cf9b4d0fae3580a2384af788eea296f4f00a893ea9f3afa91da0474bd867ddc79b91289a73e13f1459d17e170324e471ddacc6316486ca2365c213a15d3ab90a6c11d36e6322694fc3b7597847b0fdd17ef540d106d4c6c8fa0575b2567b7a15b1eaf2ba4c9fa12fd8aa934cb12fcc09436f3a4fde3058626b8b0a87ac00aca66f8fb2e084632ff4f3f75bf3ed454f4e1cdce53a7d64e3ebc524cd835c6a313c55114ffded1226c2532297c7a5b19caf102dcc60243fcfa530cf4568df2e0409402f6ea61e6397e65fd1a9b16e50440481e4beeacd9c0bc0c84e64743ef093f51d965883f2c0a82c11621a462e4c2c122e9a38aed7511c3a9bd68743233795a2e55d5de4a886b6b5213525137f42f3fda1d947df7b2fc8648ea6ea86bb75785ef6eb9e4b4a587a270e53f27cf9abc7a06d3260e0cb366287993d522ae504e7329a8d6f3070d2ab0bb5568fbcc1cddea74228a19f75f5b529b23c406d81acb21fa42550a527621d60a9e23cf5e3aebe897be285d096d977262d494d1efc316c44acc332bd67c715572e83bd68619bf63e7703125829aae7f89dd64153fb6cfb55bb7f4bad7ac1402d7d534505632654d3fa434c14e0b3e7b977f9b726aec97978a4960c7041a6e87d9ddcebe732e832ea72ce9c5bd5e745b5c01fea7c485f7b81584e324f1d9b8b70480903ee30e34f4125084bad79f7d3f8cc6c09bcb80345f9dc00bdbfe4c736944713fc519f9e336ddbc6b631b615062ec427b27b2da802ced0bd8d3ec48a79853c222ec266a35c9b2d0f23019f002ded200a5fdaa56d74c7ead97d3a6d593201af450ab5bde47c884e5e599eb07bcdec913af970b2226434ef3112ac51ded3e94af1d7997742eb874cd9de90cb9ad323d54c7ab44310d3d3211b33760a622d97516a36a5cbebdb8a6046751d992c8935d36cb80fa3adc015fd3199c107d340d6e9eb8a7089c38f1a4cd2bcf36d1866db0b4fa6ad99baf40b4af93979884b5197b83664fc98cfc4085c6d4f804a06c8861b5a21efccb4a72d50d28ca6be86078422d00db550896f69c28d4e44d667aa513906c3f539d38f95de329b16f91caf0e18def03dde40ecfbad095874b1a91761a6bda7473784175a0361778f7ae706c844cc924a23580bb6eada715d37973197b80eebafcb80748faaeec545b8c2c5ee9541511a16d8a3a0d2a8fec30f64cdfdd8675464c434f9320e55d0372c1569cc75c7e468e21656c7e108722b006b8dff6342494ac4b7e26bc5514ab65c29d70efe6b41b0185d6a80c8d032459f60e1dce2dcab1d035d85ef7c7a72a2d8bd6edf4eaf2203ea2af684ebaa9b60f528f7b5ff937225ed9195bcaec6fd446e2ad92b8092b2d33801dd8d56ae79024dbba2c4e18a62347d1b4dbcb23f6d874f4dbd74c798480b36d108772c6302</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第五周总结(4/29 - 5/05)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>第四周总结(4/22 - 4/28)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/e67d1afdd8f3/"/>
    <id>https://blog.phbeats.cn/posts/e67d1afdd8f3/</id>
    <published>2024-04-21T11:59:19.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="028ffd2e0fc6afe4ebf9836bd1666d5a32b0eb0fcdae0f066a826f662322d5b8">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814dd28c6c18edca31e1555a8485cd273625e25395c9f1c3aea939741d0bfa2f12a0aeb4c1d8cc993704f2a677a3202850096330a427b75265891b1a548643f6866a2af112c9c35c420c639b21c412b0a309a6c516de92c941c8b5f75a220e6dc3c472b304eae7cdefa406c0769129f0eabf84ac5ce473a55fefb13320b8b35a288ba2ce2409078c405a791a52b8c6208996435723bb5a8702b9e928a187ceb98d5e3bdd7cd8483f34496f283cb4a10f3e45dbb744c8b968194b575695a51d47c4f2e28e534556c5f5df69844c3eb61f0b0b17ac7fe3b67a5c1c83bcf626c57954584e4b49e0c2e66d95148ed7ac80a4327ca27c4aab8246a73ef3a41c645939fe58d430d7c7c75f8408b0e53bfc632de8ffa343607066a76b2238da758611feb2bab70c2c9f85732c132affb395bd427ba38b3f658cc5e2ffcbe86ae3132bfd99697b1dba1b87f0f0097eba194fc7ffef7015b34700485afea89ba7ba7d04e8585ce8fb1cd9e48b69fd72f0f01bfe3781d01c74086401dfc9818435f1d979831c0f276414304e4c22418ecb28dd5722219c73d435b4b1fc6adcc43f9bcbe58e9db1c490f841ab3a9686c7fda8fdc13860ada1286184bdf0e71c630c5763cf988d2673a209eee41eb9d11120e6d0e61e052498e574ee87c16021b41729634752cc2bc5abf028b00682d0431ed977b41442730e6198c131a225a2e2de0072da2ab48edf003cd808ac10868d837f3e6eb7854cbd2d3dc7b772b13d2dcbf8ce740b870f9aa5241e68d6e3a4409a571bd71f58a36fa8a1e8011401419d5fc569c8e8de99aeeb5e570efa0fde28fc0c3db9da3946c3536fc9d92e9cb123659994df584ef38a38d4a6287744fa562e78cfaa29bec80c1b4866cac6f7ec7a880b52381996915395a5b3b0e176a56531db74e4d620f3e1042ac52cbeeeb4f5e5abba6a6b6870d68ef16a7349b897bc35918035d06a858dd1732a60df2d2b2dbaadd719e0eee2ddec5897a30cef5452f6c68791861f8ec8833466cd8ebec43347e62fab76258e2b0bd133d4aa1a3394b53580342a741a6a5a54c64b9c503aca650797685ffa4769a7844ddef7ea5f62ff0a9422b4978f2daf4da1c50129188a78c29855b16960eb1609ae398ebd78691cb6f3affe227f114be5e0037fa44394597cd9aa53b6444c5d9151b938a3e1f503672fa3f8a934442b218dbf4c5eba56dad9339fb4011ab43d5ced978fd446c9987a7f9fb419fb31679914f0d536e09813879613a26dfa42ffc7c8ba8875ed4759bba5ae221360459fc5a2cb959525abc35295e77e8a213fa5e3272b5ac1800faf3e96a8f561eaa6b776a30ff151d4a42830c99f8936ba9770a6f554d1b9a96e38977f7e7d9d550cc6d59a83589b49fb8571a7f4aef86c17ee8484c12357d3207afa1af7ea57d4519202fa670baacd417ba8a3a6f828dba4ea2a98260a4c96a423c42b8aa44119f00f5b5dc04991a835850874a0813e935ffc51414447e8c0a73db49b7b086333573f1d14c5a40e6824b86a52974b3eedde0d8529648b526925d6c6463f4a299af9a86c55c8faea01bd51ed7589cb39a2f2a1ed941bdcf8699251158b969a9ec7a65d5e1714d10eb425cd90f8817608b55d64d9bcf34dbf718c4aab804866b4ed2e79c4bc3bebd5e8a233e3900f8c86b353332a08f60827a5c9df2ea84a91e39afb4a64818c012855aabb334b4d292f1e477512af03a8902c5a233c58062f532f631315da35486bef7695c65251649ff9a1a680051c7239eab223441c9e7fc20aab541ccf84be64fd050d5aa48af6eb096ba4b927809bea632b86af5762836872361a95a16c2774ecd0bffba5f1d7d29669bfe9a504b36d2f4cfb98f737182e73e8248272a6db51632ab3bcff68095badfd988d1597fef34ce6a3e8d31cf1bafc74e9f89a64c75b20695dd23ce95e6781d8477df4c6271fb65e673b292be9c5c4d325c54b9a9474432fc73757118ab541c2aa9cf27876826812b81db5c8ad218718ea89a98eaea93dd73aeb963d934e9d069a392230d55044356713872c3f5c3e1f1feac2e664025033657e630d788bff791873bb082326885716377f6ad6d960661cfbb6fe801f960b901e2eb923d0100cc82860588e356cb0e030aa75905f58cb6a7b1c87507b3446f2c6c0e042759b6a8748e35bf11b0a67ad96ef8ad97b109be497be9d17a5cc2f5cc5d4f2264fc1a527b30fa81e5186baef53dcdbdcc65271165efd58a7c228dfe95c30b6c93db966849c5a2d9aa3e2c2e7dbe7b47adc70ab8b6f7a3d887d5dff2dde55b1ebe5766e62fcd61bb8c4b7119e25cf4f0d4bf1733d527a14c066290a2c20cf11dd99af20b95b9e531e11119491a9ab41f1a902daed890d27ce51141b2fd91131156f2c84fbe02fa4b3ceeaa4c7fb80d44e4d63e0870636af64aa0a9abbc5ff0771ffabbe90c38a76ae9bc6fe21c6fb49f7273167ec551f5d57779d0c68c35eb245f9dba863df082c4cfb3b3c4477ff855ea6fb7382952982cdf390a3c3f92c0d2b5c0fb3d30637b9bd35b41588287d267dec3d53ea319c13aecdc24b8e694976a2d6449e68068d222d9cd08e3a055ddc42c5767968161e62e5ebc3449d73bb525833b2eebbb60fa8be7a7217ff8cdaf1746a1f122185abb6a6bb9e06e753456db872c0f99cc4ad9b79f2e0446214b9fe10645c6fbc9ce10edb58d0869d6d359acfb103a34cd08d7ce997bddb44ebeb6923b9becda5e85ec509e6d3eb2c04a21940b5395de8755c03cfb920b84e8b20074cf96b87265900c11f50cf86f1af154aea48a55f057397c1bed1c0705096346ef798a446d7d2789c6686bb3ba458bd600a803b547c32a48bfc2a6dd6f2cfc0acab3f873e7d794cd355f16ceff04c1661b7e6084fe1a406675daa8a268e925f85a77d968e4a8467abae314b06bc5e354ae4cdb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第四周总结(4/22 - 4/28)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]842. 全排列数字</title>
    <link href="https://blog.phbeats.cn/posts/2eede509a240/"/>
    <id>https://blog.phbeats.cn/posts/2eede509a240/</id>
    <published>2024-04-19T11:55:28.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-842-全排列数字"><a href="#AcWing-842-全排列数字" class="headerlink" title="[AcWing]842. 全排列数字"></a><a href="https://www.acwing.com/problem/content/844/">[AcWing]842. 全排列数字</a></h1><p>给定一个整数 <code>n</code>，将数字 <code>1 ~ n</code> 排成一排，将会有很多种排列方法。</p><p>现在，请你按照字典序将所有的排列方法输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个整数 <code>n</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>按字典序输出所有排列方案，每个方案占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 7</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>此题，适合用来理解<code>DFS</code>。<code>DFS</code>可以用<code>树</code>模型来理解。</p><p><img src="https://bu.dusays.com/2024/04/19/6622634b9d95a.png" alt="image-20240419202755100"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 从1开始全排列的数字长度</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-comment">// 数字是否被用过了</span><br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-comment">// 值</span><br><span class="hljs-type">int</span> path[N];<br><br><span class="hljs-comment">// 关于数字1的全排列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-comment">// 数字u 为 n + 1说明 1~n 已经进行全排列了，此时直接输出</span><br>    <span class="hljs-keyword">if</span>(u &gt; n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            cout &lt;&lt; path[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 进行全排列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-comment">// 如果这个数字还没用过</span><br>            <span class="hljs-keyword">if</span>(!st[i])&#123;<br>                <span class="hljs-comment">// 就用一下这个数字</span><br>                st[i] = <span class="hljs-literal">true</span>;<br>                path[u] = i;<br>                <span class="hljs-comment">// u + 1 数字的全排列</span><br>                <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 恢复现场</span><br>                st[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-comment">// 使用的path空间下标1开始，同时也是从1开始全排列</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]842. 全排列数字</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="DFS" scheme="https://blog.phbeats.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]3766. 二叉树的带权路径长度</title>
    <link href="https://blog.phbeats.cn/posts/6049e4bb40ad/"/>
    <id>https://blog.phbeats.cn/posts/6049e4bb40ad/</id>
    <published>2024-04-17T12:17:11.000Z</published>
    <updated>2024-06-17T03:24:31.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3766-二叉树的带权路径长度"><a href="#AcWing-3766-二叉树的带权路径长度" class="headerlink" title="[AcWing]3766. 二叉树的带权路径长度"></a><a href="https://www.acwing.com/problem/content/3769/">[AcWing]3766. 二叉树的带权路径长度</a></h1><p>二叉树的带权路径长度(WPL)是二叉树中所有叶结点的带权路径长度之和，也就是每个叶结点的深度与权值之积的总和。</p><p>给定一棵二叉树 <code>T</code>，请你计算并输出它的 WPL。</p><p>注意，根节点的深度为 <code>0</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">输入：二叉树[<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]如下图所示：<br>    <span class="hljs-number">8</span><br>   / \<br>  <span class="hljs-number">12</span>  <span class="hljs-number">2</span><br>     / \<br>    <span class="hljs-number">6</span>   <span class="hljs-number">4</span><br><br>输出：<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>二叉树结点数量不超过 <code>1000</code>。<br>每个结点的权值均为不超过 <code>100</code> 的非负整数。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>从根结点到各叶结点的路径长度</code> * <code>相应叶节点权值</code> 之和。</p><p><img src="https://bu.dusays.com/2024/04/17/661fc561aba08.png" alt="image-20240417204932311"></p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 只有叶子节点才承载有效的信息</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;<br>            ans += depth * root -&gt; val;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 否则dfs</span><br>            <span class="hljs-built_in">dfs</span>(root -&gt; left, depth + <span class="hljs-number">1</span>);            <br>            <span class="hljs-built_in">dfs</span>(root -&gt; right, depth + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 只结算叶子结点的</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right) <span class="hljs-keyword">return</span> depth * root -&gt; val;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root -&gt; left, depth + <span class="hljs-number">1</span>) + <span class="hljs-built_in">dfs</span>(root -&gt; right, depth + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3766. 二叉树的带权路径长度</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
