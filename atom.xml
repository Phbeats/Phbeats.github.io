<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phbeats-Blog</title>
  
  <subtitle>记录学习历程和生活感悟</subtitle>
  <link href="https://blog.phbeats.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.phbeats.cn/"/>
  <updated>2023-05-01T07:35:18.825Z</updated>
  <id>https://blog.phbeats.cn/</id>
  
  <author>
    <name>Phbeats</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高精度除法</title>
    <link href="https://blog.phbeats.cn/posts/ca4465c5974d/"/>
    <id>https://blog.phbeats.cn/posts/ca4465c5974d/</id>
    <published>2023-04-28T14:41:04.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<div class="note success simple"><p>再学完这个知识点，我再休息</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/01/644f6b6cb6fda.png" alt="image-20230428224911582"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp; r)</span></span>&#123;<br>    <span class="hljs-comment">// 默认A大于b</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 除法是从最高位开始 &lt;-</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 保存的时候是从高到低，需要反转一下</span><br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    <span class="hljs-type">int</span> r; <span class="hljs-comment">// 余数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">div</span>(A, b, r);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>    <br>    cout &lt;&lt; endl &lt;&lt; r;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">高精度除法</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="高精度算法" scheme="https://blog.phbeats.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>高精度乘法</title>
    <link href="https://blog.phbeats.cn/posts/d222ff48c8bc/"/>
    <id>https://blog.phbeats.cn/posts/d222ff48c8bc/</id>
    <published>2023-04-28T13:39:39.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<div class="note success simple"><p>学累了就出去走走吧</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/01/644f6b65b32ba.png" alt="image-20230428221023505"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-comment">// 默认A 大于 b</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果t很大可能会留有剩余</span><br>    <span class="hljs-keyword">while</span>(t)&#123;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">mul</span>(A, b);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">高精度乘法</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="高精度算法" scheme="https://blog.phbeats.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>高精度减法</title>
    <link href="https://blog.phbeats.cn/posts/c87c248906c2/"/>
    <id>https://blog.phbeats.cn/posts/c87c248906c2/</id>
    <published>2023-04-28T13:02:27.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<div class="note success simple"><p>不要有强迫症，面对眼前的难题，可以跳过，回头再处理。</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/01/644f6b58d3634.png" alt="image-20230428213513607"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b5d16368.png" alt="image-20230428213521595"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 比较两个数谁大谁小，如果A大于B返回true，反之</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span>&#123;<br>    <span class="hljs-comment">// 如果两个数字位数不同</span><br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 如果两个数字位数相同，直接从最高位开始比较 方向提示：&lt;-</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span>(B[i] != A[i])<br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>            <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span>&#123;<br>    <span class="hljs-comment">// A一定是大于B的</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <br>    <span class="hljs-comment">// 进位</span><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 去除高位0，同时要保证结果长度大于1，不能1 - 1 = 0把答案0也给消了</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    string a, b;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-comment">// 如果A比B大</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A, B))&#123;<br>        C = <span class="hljs-built_in">sub</span>(A, B);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>        <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 如果A比B小</span><br>        C = <span class="hljs-built_in">sub</span>(B, A);<br>        <span class="hljs-comment">// 还需要输出减号</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">高精度减法</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="高精度算法" scheme="https://blog.phbeats.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>高精度加法</title>
    <link href="https://blog.phbeats.cn/posts/759ae4655658/"/>
    <id>https://blog.phbeats.cn/posts/759ae4655658/</id>
    <published>2023-04-27T12:13:25.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><div class="note success simple"><p>你有下大雨去网吧的勇气，却没有下小雨去图书馆的勇气吗</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用数组模拟平常我们的竖式计算。例如：</p><p><img src="https://bu.dusays.com/2023/05/01/644f6b0aa04aa.png" alt="image-20230427202700060"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b12b49a4.png" alt="image-20230428202609403"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b186bf4d.png" alt="image-20230428203007184"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b1e05ea1.png" alt="image-20230428203255775"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b2160933.png" alt="image-20230428203857482"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span>&#123;<br>    <span class="hljs-comment">// 为了方便计算，让A中保存较长的数字， B中保存较短的数字</span><br>    <span class="hljs-keyword">if</span>(B.<span class="hljs-built_in">size</span>() &gt; A.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br>    <br>    <span class="hljs-comment">// 保存最终的结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <br>    <span class="hljs-comment">// 以 A 为基准，开始按位计算</span><br>    <span class="hljs-comment">// 每位的进位</span><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        t += A[i];<br>        <span class="hljs-comment">// 如果B位置还没遍历完</span><br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        <span class="hljs-comment">// 9 + 9 = 18, 1 + 2 = 3。取余即可，进位交给 t /= 10 做</span><br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 如果是18, 那么下次t初始值会变成1</span><br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">// 最终，还需要判断进位上是否还有数</span><br>    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 字符串形式读取两个数</span><br>    string a, b;<br>    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-comment">// 用来保存两个数字</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>    <span class="hljs-comment">// 倒序保存，记得转数字</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">add</span>(A, B);<br>    <br>    <span class="hljs-comment">// 输出计算之后的结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">高精度加法</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="高精度算法" scheme="https://blog.phbeats.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]88. 树中两个结点的最低公共祖先</title>
    <link href="https://blog.phbeats.cn/posts/02073ceab06d/"/>
    <id>https://blog.phbeats.cn/posts/02073ceab06d/</id>
    <published>2023-04-24T14:26:36.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-88-树中两个结点的最低公共祖先"><a href="#AcWing-88-树中两个结点的最低公共祖先" class="headerlink" title="[AcWing]88. 树中两个结点的最低公共祖先"></a><a href="https://www.acwing.com/problem/content/84/">[AcWing]88. 树中两个结点的最低公共祖先</a></h1><p>给出一个二叉树，输入两个树节点，求它们的最低公共祖先。</p><p>一个树节点的祖先节点包括它本身。</p><p><strong>注意：</strong></p><ul><li>输入的二叉树不为空；</li><li>输入的两个节点一定不为空，且是二叉树中的节点；</li></ul><!-- --><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[0,500]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]如下图所示：<br>    8<br>   / \<br>  12  2<br>     / \<br>    6   4<br><br>1. 如果输入的树节点为2和12，则输出的最低公共祖先为树节点8。<br><br>2. 如果输入的树节点为2和6，则输出的最低公共祖先为树节点2。<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/04/24/64468eb3c9247.png" alt="image-20230424221354590"></p><ol><li>如果<code>p</code>、<code>q</code>分别存在于这棵子树的左右两边，返回这棵子树的根，它就是最低公共祖先。</li><li>否则，<code>p</code>、<code>q</code>只可能全存在于这棵子树的左边、或者全存在于这棵子树的右边。</li><li>如果当前节点恰好是<code>p</code>或<code>q</code>中的一个，那么它就是最低公共祖先。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-comment">// 由于题目说了，输入的树不为空，并且p、q是树中的元素</span><br>        <span class="hljs-comment">// 就是说一定能够找到树中两个节点的最低公共祖先</span><br>        <span class="hljs-comment">// 遇到叶子节点</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// 左边找一下、右边找一下，遇到p、q节点就保存</span><br>        TreeNode * left = <span class="hljs-built_in">lowestCommonAncestor</span>(root -&gt; left, p, q);<br>        TreeNode * right = <span class="hljs-built_in">lowestCommonAncestor</span>(root -&gt; right, p, q);<br>        <br>        <span class="hljs-comment">// 如果p、q分别存在于这棵子树的左右两边，返回这棵子树的根，它就是p、q的最低公共祖先</span><br>        <span class="hljs-keyword">if</span>(left &amp;&amp; right) <span class="hljs-keyword">return</span> root;<br>        <br>        <span class="hljs-comment">// 那么p、q只可能全存在于这棵子树的左边、或者全存在于这棵子树的右边</span><br>        <span class="hljs-comment">// 如果当前节点恰好是p或q中的一个，那么它就是最低公共祖先</span><br>        <span class="hljs-keyword">if</span>(root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        <br>        <span class="hljs-comment">// 如果最低公共祖先在左边，返回左边的最低公共祖先</span><br>        <span class="hljs-comment">// 如果最低公共祖先在右边，返回右边的最低公共祖先</span><br>        <span class="hljs-keyword">if</span>(left) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>遍历整棵子树，时间复杂度<code>O(n)</code>。</p>]]></content>
    
    
    <summary type="html">[AcWing]88. 树中两个结点的最低公共祖先</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]72. 平衡二叉树</title>
    <link href="https://blog.phbeats.cn/posts/4c34c5a2d3db/"/>
    <id>https://blog.phbeats.cn/posts/4c34c5a2d3db/</id>
    <published>2023-04-24T12:56:47.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-72-平衡二叉树"><a href="#AcWing-72-平衡二叉树" class="headerlink" title="[AcWing]72. 平衡二叉树"></a><a href="https://www.acwing.com/problem/content/68/">[AcWing]72. 平衡二叉树</a></h1><p>输入一棵二叉树的根结点，判断该树是不是平衡二叉树。</p><p>如果某二叉树中任意结点的左右子树的深度相差不超过 <code>1</code>，那么它就是一棵平衡二叉树。</p><p><strong>注意：</strong></p><ul><li>规定空树也是一棵平衡二叉树。</li></ul><!-- --><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[0,500]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：二叉树[5,7,11,null,null,12,9,null,null,null,null]如下所示，<br>    5<br>   / \<br>  7  11<br>    /  \<br>   12   9<br><br>输出：true<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>在统计二叉树的深度的代码基础上，实时判断当前节点的左右子树的深度差是否大于1，如果是则不是平衡二叉树</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认是平衡二叉树，如果判断过程中当前节点的左右子树的深度差大于1，则改为false</span><br>    <span class="hljs-type">bool</span> res = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span></span>&#123;<br>        <span class="hljs-comment">// 空树深度为0</span><br>        <span class="hljs-comment">// DFS结束，那层空节点不算深度，返回0</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果不是空树,计算当前节点的左右子树深度</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>        <br>        <span class="hljs-comment">// 如果左右子树深度之差大于1，则不是平衡二叉树</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(left - right) &gt; <span class="hljs-number">1</span>) res = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 返回 包括当前节点的，二叉树的深度</span><br>        <span class="hljs-comment">// + 1 是因为当前节点也算1个深度，记得从下往上看</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]72. 平衡二叉树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]70. 二叉搜索树的第k个结点</title>
    <link href="https://blog.phbeats.cn/posts/58544f92f8ea/"/>
    <id>https://blog.phbeats.cn/posts/58544f92f8ea/</id>
    <published>2023-04-21T15:05:31.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-70-二叉搜索树的第k个结点"><a href="#AcWing-70-二叉搜索树的第k个结点" class="headerlink" title="[AcWing]70. 二叉搜索树的第k个结点"></a><a href="https://www.acwing.com/problem/content/66/">[AcWing]70. 二叉搜索树的第k个结点</a></h1><p>给定一棵二叉搜索树，请找出其中的第 <code>k</code> 小的结点。</p><p>你可以假设树和 <code>k</code> 都存在，并且 <code>1≤k≤</code> 树的总结点数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[1,500]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [2, 1, 3, null, null, null, null] ，k = 3<br><br>    2<br>   / \<br>  1   3<br><br>输出：3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>中序遍历二叉搜索树，找到第k个节点。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    TreeNode * res;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> &amp; k)</span></span>&#123;<br>        <span class="hljs-comment">// 中序遍历</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-built_in">dfs</span>(root -&gt; left, k);<br>        <br>        k--;<br>        <span class="hljs-keyword">if</span>(!k) res = root;<br>        <span class="hljs-comment">// 剪枝（找到了答案，右子树显然不需要遍历了）</span><br>        <span class="hljs-keyword">if</span>(k &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(root -&gt; right, k);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">kthNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 中序遍历，找到第k个节点</span><br>        <span class="hljs-built_in">dfs</span>(root, k);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>每个节点最多被遍历一次，因此时间复杂度是<code>O(n)</code></p>]]></content>
    
    
    <summary type="html">[AcWing]70. 二叉搜索树的第k个结点</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]71. 二叉树的深度</title>
    <link href="https://blog.phbeats.cn/posts/348ff2382b5d/"/>
    <id>https://blog.phbeats.cn/posts/348ff2382b5d/</id>
    <published>2023-04-21T15:05:31.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-71-二叉树的深度"><a href="#AcWing-71-二叉树的深度" class="headerlink" title="[AcWing]71. 二叉树的深度"></a><a href="https://www.acwing.com/problem/content/67/">[AcWing]71. 二叉树的深度</a></h1><p>输入一棵二叉树的根结点，求该树的深度。</p><p>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[0,500]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]如下图所示：<br>    8<br>   / \<br>  12  2<br>     / \<br>    6   4<br><br>输出：3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>对二叉树进行DFS遍历，在这个过程中，进入下一子树，则<code>depth + 1</code>。<br>取左右子树<code>depth</code>的最大值。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>        <span class="hljs-comment">// 如果遍历到了树底，返回深度</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> depth;<br>        <span class="hljs-comment">// 有左子树就遍历左子树，有右子树就遍历右子树</span><br>        <span class="hljs-comment">// 取两个子树的最大深度</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(root -&gt; left, depth + <span class="hljs-number">1</span>), <span class="hljs-built_in">dfs</span>(root -&gt; right, depth + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">treeDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>DFS遍历，每个节点只被遍历一次，时间复杂度是<code>O(n)</code>。</p>]]></content>
    
    
    <summary type="html">[AcWing]71. 二叉树的深度</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]49. 二叉搜索树与双向链表</title>
    <link href="https://blog.phbeats.cn/posts/154a15c68d1b/"/>
    <id>https://blog.phbeats.cn/posts/154a15c68d1b/</id>
    <published>2023-04-21T13:52:10.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-49-二叉搜索树与双向链表"><a href="#AcWing-49-二叉搜索树与双向链表" class="headerlink" title="[AcWing]49. 二叉搜索树与双向链表"></a><a href="https://www.acwing.com/problem/content/87/">[AcWing]49. 二叉搜索树与双向链表</a></h1><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</p><p>要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p><strong>注意</strong>：</p><ul><li>需要返回双向链表最左侧的节点。</li></ul><p>例如，输入下图中左边的二叉搜索树，则输出右边的排序双向链表。</p><p><img src="https://www.acwing.com/media/article/image/2018/12/02/19_23bee494f5-QQ截图20181202052830.png" alt="QQ截图20181202052830.png"></p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[0,500]</code>。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>中序遍历的基本代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * cur)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!cur) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-built_in">dfs</span>(cur -&gt; left);<br><br>    cout &lt;&lt; cur -&gt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>    <span class="hljs-built_in">dfs</span>(cur -&gt; right);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据观察，考虑在二叉树的中序遍历的基础上，利用 <code>pre</code> 和 <code>cur</code> 来进行 <code>双链表</code>的构建。</p><ol><li>先找到<code>双链表</code>的第一个节点，它是中序遍历的第一个节点。</li><li>定义一个指针<code>cur</code>，指向当前处理的节点。</li><li>如果<code>cur</code>的左子树不为空，则递归处理左子树。</li><li>将<code>cur</code>与其前驱节点（即中序遍历中<code>cur</code>的前一个节点）连接起来。</li><li>更新前驱节点为<code>cur</code>。</li><li>处理<code>cur</code>的右子树，重复步骤2-4。</li></ol><p><img src="https://bu.dusays.com/2023/04/21/64429cd6d4474.png" alt="image-20230421222517569"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    TreeNode * head, * pre;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * cur)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!cur) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-built_in">dfs</span>(cur -&gt; left);<br>        <br>        <span class="hljs-comment">// 先找到中序遍历第一个节点作为双链表的head</span><br>        <span class="hljs-comment">// 只有当dfs(cur -&gt; left)压栈全部完毕才可能执行这行if，因此head一定是中序遍历的第一个元素</span><br>        <span class="hljs-keyword">if</span>(!pre) head = cur;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 将cur与其前驱节点连接起来</span><br>            pre -&gt; right = cur;<br>            <span class="hljs-comment">// 构成双向</span><br>            cur -&gt; left = pre;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 将当前的节点变成下一次回溯的前驱节点</span><br>        pre = cur;<br>        <br>        <span class="hljs-built_in">dfs</span>(cur -&gt; right);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convert</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 在中序遍历的基础上，做点改变 中序遍历：左根右</span><br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度<code>O(n)</code>：对于每个节点最多只会被访问两次，因此总的时间复杂度为<code>O(n)</code>。</li><li>空间复杂度<code>O(n)</code>：在最坏情况下，退化成单链表，空间复杂度为<code>O(n)</code>。</li></ul>]]></content>
    
    
    <summary type="html">[AcWing]49. 二叉搜索树与双向链表</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]46. 二叉搜索树的后序遍历序列</title>
    <link href="https://blog.phbeats.cn/posts/d46bd558c265/"/>
    <id>https://blog.phbeats.cn/posts/d46bd558c265/</id>
    <published>2023-04-19T09:58:27.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-46-二叉搜索树的后序遍历序列"><a href="#AcWing-46-二叉搜索树的后序遍历序列" class="headerlink" title="[AcWing]46. 二叉搜索树的后序遍历序列"></a><a href="https://www.acwing.com/problem/content/44/">[AcWing]46. 二叉搜索树的后序遍历序列</a></h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。</p><p>如果是则返回true，否则返回false。</p><p>假设输入的数组的任意两个数字都互不相同。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>数组长度 <code>[0,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：[4, 8, 6, 12, 16, 14, 10]<br><br>输出：true<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/04/20/64415023411af.png" alt="image-20230420220541552"></p><p><wavy>初始划分阶段</wavy>：</p><ol><li>数组最后一个元素一定是根元素，然后<code>从左往右</code>找到<code>第一个比根元素大</code>的下标，记为<code>k</code>。</li><li>左区间就是<code>[0, k - 1]</code>，右区间是<code>[k, n - 1]</code>。（n为数组长度)</li><li>然后对子区间做同样的划分。</li></ol><p><wavy>注意事项<wavy>：</p><ol><li>区间长度为0，则后续遍历序列合法。</li><li>只有包含<code>k</code>的右区间可能会出现小于根节点的情况，因为左边已经在找<code>k</code>的过程中排除了非法情况（左区间中有比根节点大的元素）。</li></ol><p><img src="https://bu.dusays.com/2023/04/20/644150271b857.png" alt="image-20230420224540132"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;<span class="hljs-type">int</span>&gt; &amp; seq)</span></span>&#123;<br>        <span class="hljs-comment">// 如果区间长度小于等于1，说明一切合法</span><br>        <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 找到根节点</span><br>        <span class="hljs-type">int</span> root = seq[r];<br>        <br>        <span class="hljs-comment">// 从左往右找到第一个比根大的元素下标</span><br>        <span class="hljs-type">int</span> k = l;<br>        <span class="hljs-keyword">while</span>(k &lt; r &amp;&amp; seq[k] &lt; root) k++;<br>  <br>        <span class="hljs-comment">// 如果右区间有比根元素小的元素，一定不合法</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k; i &lt; r; i++)<br>            <span class="hljs-keyword">if</span>(seq[i] &lt; root)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-comment">// 左区间和右区间同时划分</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(l, k - <span class="hljs-number">1</span>, seq) &amp;&amp; <span class="hljs-built_in">dfs</span>(k, r - <span class="hljs-number">1</span>, seq);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verifySequenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; sequence)</span> </span>&#123;<br>        <span class="hljs-comment">// 整个区间长度[0, n - 1]。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, sequence.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, sequence);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度<code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code>：<code>dfs</code>中有一个while循环，最坏情况会循环O(n)次，一共执行O(n)次<code>dfs</code>，所以时间复杂度是<code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code>。其实也就是退化成单链表了。</li><li>空间复杂度<code>O(n)</code>：退化成单链表空间占用<code>O(n)</code>。</li></ul>]]></content>
    
    
    <summary type="html">[AcWing]46. 二叉搜索树的后序遍历序列</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]47. 二叉树中和为某一值的路径</title>
    <link href="https://blog.phbeats.cn/posts/e407ed0acd1f/"/>
    <id>https://blog.phbeats.cn/posts/e407ed0acd1f/</id>
    <published>2023-04-19T09:58:27.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-47-二叉树中和为某一值的路径"><a href="#AcWing-47-二叉树中和为某一值的路径" class="headerlink" title="[AcWing]47. 二叉树中和为某一值的路径"></a><a href="https://www.acwing.com/problem/content/45/">[AcWing]47. 二叉树中和为某一值的路径</a></h1><p>输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。</p><p>从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><p>保证树中结点值均不小于 <code>0</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中结点的数量 <code>[0,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">给出二叉树如下所示，并给出num=22。<br>      5<br>     / \<br>    4   6<br>   /   / \<br>  12  13  6<br> /  \    / \<br>9    1  5   1<br><br>输出：[[5,4,12,1],[5,6,6,5]]<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>DFS的过程中，在遇到叶子节点的时候进行累加求和，并且提交<code>path</code>作为<code>ans</code>之一。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <br>    <span class="hljs-comment">// 节点，当前累计的值，目标值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> target)</span></span>&#123;<br>        <span class="hljs-comment">// 遇到叶子节点下面的空节点，或者是棵空树，什么也不做，反正返回的是ans</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 将当前遇到节点加入路径集合</span><br>        path.<span class="hljs-built_in">push_back</span>(root -&gt; val);<br>        <span class="hljs-comment">// 进行累加计算</span><br>        sum += root -&gt; val;<br>        <br>        <span class="hljs-comment">// 有左子树就开始递归左子树</span><br>        <span class="hljs-keyword">if</span>(root -&gt; left) <span class="hljs-built_in">dfs</span>(root -&gt; left, sum, target);<br>        <span class="hljs-comment">// 有右子树就开始递归右子树</span><br>        <span class="hljs-keyword">if</span>(root -&gt; right) <span class="hljs-built_in">dfs</span>(root -&gt; right, sum, target);<br>        <span class="hljs-comment">// 剩下的情况就是，左子树和右子树都没有，说明是当前节点是叶子节点</span><br>        <span class="hljs-comment">// 订正：不一定是左子树和右子树都没有，或许它是只有一个子树，因此不能无脑开始计算并且提交答案</span><br>        <span class="hljs-comment">// 确定是叶子节点才能计算并且提交答案</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;<br>            <span class="hljs-keyword">if</span>(sum == target) ans.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 不成功也不管了，反正最终会提交一个ans</span><br>        <br>        <span class="hljs-comment">// 每次dfs都需要恢复现场</span><br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findPath</span>(TreeNode* root, <span class="hljs-type">int</span> sum) &#123;<br>        <span class="hljs-comment">// 从根节点找到每个分支的叶子节点</span><br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>, sum);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><wavy>注意事项</wavy>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">path.<span class="hljs-built_in">push_back</span>(root -&gt; val);<br><br>path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 恢复现场</span><br></code></pre></td></tr></table></figure><p>在DFS过程中，上面这两行到底怎么理解？</p><p>DFS的过程中，可以用函数调用栈来表示。如果调用四次DFS，则有四个DFS压入栈中，<code>path</code>也会有四个节点的值。在DFS出栈的过程中，如果不恢复现场，则会出现<code>函数调用栈空了，但path的里面值依旧没有减少</code>。</p><p>归根结底，四次DFS，<code>path</code>会加入四个节点的值，通过<code>path.pop_back()</code>会清除掉这四个节点的值。这样能够保证DFS在结束一个分支，再次开启新的分支的时候<code>path</code>是干净的。</p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul><li>最坏时间复杂度<code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code>：在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶子节点的路径都符合题目要求。路径的数目为<code>O(n)</code>，并且每一条路径的节点个数也为 O(n)。要想将n个路径的所有节点都统计起来，需要的时间复杂度是<code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code>。</li><li>平均时间复杂度<code>O(n)</code>：由于每个节点最多只会被访问一次，所以时间复杂度是<code>O(n)</code>。</li></ul><p>但是注意：在大多数情况下，二叉树不会退化成链表，因此大部分情况下的时间复杂度都是线性的。</p><p>我认为时间复杂度还是能看做<code>O(n)</code>。</p>]]></content>
    
    
    <summary type="html">[AcWing]47. 二叉树中和为某一值的路径</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]45. 之字形打印二叉树</title>
    <link href="https://blog.phbeats.cn/posts/de0ff6a9d060/"/>
    <id>https://blog.phbeats.cn/posts/de0ff6a9d060/</id>
    <published>2023-04-19T09:35:14.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-45-之字形打印二叉树"><a href="#AcWing-45-之字形打印二叉树" class="headerlink" title="[AcWing]45. 之字形打印二叉树"></a><a href="https://www.acwing.com/problem/content/description/43/">[AcWing]45. 之字形打印二叉树</a></h1><p>请实现一个函数按照之字形顺序从上向下打印二叉树。</p><p>即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点的数量 <code>[0,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入如下图所示二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]<br>    8<br>   / \<br>  12  2<br>     / \<br>    6   4<br>输出：[[8], [2, 12], [6, 4]]<br></code></pre></td></tr></table></figure><h3 id="算法思路1、2"><a href="#算法思路1、2" class="headerlink" title="算法思路1、2"></a>算法思路1、2</h3><p>在之前的题的基础上，添加了条件判断</p><p>详情参考<a href="/6929c8c24cea">分行从上往下打印二叉树</a></p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">printFromTopToBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 空树，返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        <br>        <span class="hljs-comment">// 基于BFS的分行操作</span><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 从根节点开始BFS</span><br>        <br>        <span class="hljs-comment">// 当前层是否需要逆置</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">// 下一层的节点数量</span><br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 保存每层的值</span><br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-comment">// 一口气将当前层的节点，全放入队列</span><br>            <span class="hljs-keyword">while</span>(len --)&#123;<br>                TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <br>                level.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>                <br>                <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>                <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>            &#125;<br>            <span class="hljs-comment">// 逆置判断</span><br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                <span class="hljs-built_in">reverse</span>(level.<span class="hljs-built_in">begin</span>(), level.<span class="hljs-built_in">end</span>());<br>            &#125;<br>                <br>            <span class="hljs-comment">// 下一层必定与当前层BFS的顺序相反</span><br>            flag = !flag;<br>            <span class="hljs-comment">// 提交当前层</span><br>            ans.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">printFromTopToBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 空树，返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        <br>        <span class="hljs-comment">// 基于BFS的分行操作</span><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 从根节点开始BFS</span><br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 代表这层结束</span><br>        <br>        <span class="hljs-comment">// 存储每层的节点值</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; level;<br>        <br>        <span class="hljs-comment">// 表示是否需要将 level 集合逆置(从右到左)</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <br>            <span class="hljs-comment">// 如果当前层结束了</span><br>            <span class="hljs-keyword">if</span>(!t)&#123;<br>                <span class="hljs-comment">// 如果下一层没有节点了</span><br>                <span class="hljs-comment">// 比如：4 NULL，while循环拿出4，放入level之后，取出NULL，进入这个if条件里面</span><br>                <span class="hljs-comment">// level不是空，因此提交 level 到 ans 里面</span><br>                <span class="hljs-comment">// 队列里面剩下的是 NULL，再拿出来，此时判断level，为空，break掉</span><br>                <span class="hljs-comment">// 这也就是下一层没有节点的情况</span><br>                <span class="hljs-keyword">if</span>(level.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 当前层结束了，下一行还有节点，根据类型提交level，再给下一层增加结束标识符</span><br>                <span class="hljs-comment">// 如果需要逆置</span><br>                <span class="hljs-keyword">if</span>(flag)&#123;<br>                    <span class="hljs-built_in">reverse</span>(level.<span class="hljs-built_in">begin</span>(), level.<span class="hljs-built_in">end</span>());<br>                &#125;<br>                ans.<span class="hljs-built_in">push_back</span>(level);<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>                <span class="hljs-comment">// 为了下一次，level容器是空的，还需要还原空状态</span><br>                level.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-comment">// 下一层必定与当前层BFS的顺序相反</span><br>                flag = !flag;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 当前层没结束,正常BFS</span><br>            level.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>            <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>            <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>由于树中每个节点仅会进队出队一次，所以时间复杂度是<code>O(n)</code></p>]]></content>
    
    
    <summary type="html">[AcWing]45. 之字形打印二叉树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]44. 分行从上往下打印二叉树</title>
    <link href="https://blog.phbeats.cn/posts/6929c8c24cea/"/>
    <id>https://blog.phbeats.cn/posts/6929c8c24cea/</id>
    <published>2023-04-15T11:31:13.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-44-分行从上往下打印二叉树"><a href="#AcWing-44-分行从上往下打印二叉树" class="headerlink" title="[AcWing]44. 分行从上往下打印二叉树"></a><a href="https://www.acwing.com/problem/content/42/">[AcWing]44. 分行从上往下打印二叉树</a></h1><p>从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点的数量 <code>[0,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null]<br>    8<br>   / \<br>  12  2<br>     /<br>    6<br>   /<br>  4<br><br>输出：[[8], [12, 2], [6], [4]]<br></code></pre></td></tr></table></figure><h3 id="算法思想1"><a href="#算法思想1" class="headerlink" title="算法思想1"></a>算法思想1</h3><p>已知不分行的做法是使用<code>BFS</code>层序遍历这棵树。</p><p>在此基础上，做出一些改变，即可得到不分行的做法。</p><p>问：<wavy>在BFS的过程中，能否知道当前队列中有多少节点？</wavy></p><p>答：可以。<wavy>队列的容量就是当前层的节点数量</wavy></p><p>那么，在第1层，只有根节点，队列容量是1，当前层节点数量是1。</p><p>在第2层，有2个节点，队列容量是2，当前层节点数量是2。</p><p>原<code>BFS</code>每次只能弹出一个节点，如果我们一次性弹出<code>当前层数</code>的节点呢？然后将它放入小集合。</p><p>这样一轮结束，将小集合放入大集合。</p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">printFromTopToBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 如果是空树返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        <br>        <span class="hljs-comment">// BFS</span><br>        queue&lt;TreeNode *&gt; q;<br>        <span class="hljs-comment">// 从根节点开始扩展</span><br>        q.<span class="hljs-built_in">push</span>(root);<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">// 当前层的元素个数</span><br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <br>            <span class="hljs-comment">// 用来保存当前层的值的集合</span><br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <br>            <span class="hljs-comment">// 一次性将当前层的所有节点弹出</span><br>            <span class="hljs-keyword">while</span>(len --)&#123;<br>                <span class="hljs-comment">// 从队头开始弹出</span><br>                TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 记录这层值的元素</span><br>                level.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>                <br>                <span class="hljs-comment">// 为一次性弹出下层节点做准备</span><br>                <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>                <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>            &#125;<br>            <span class="hljs-comment">// 将小集合放入大集合</span><br>            ans.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="算法思想2"><a href="#算法思想2" class="headerlink" title="算法思想2"></a>算法思想2</h3><p><img src="https://bu.dusays.com/2023/04/19/643fb3cee443e.png" alt="image-20230419172627366"></p><p>代码实现2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">printFromTopToBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 空树，返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        <br>        <span class="hljs-comment">// 基于BFS的分行操作</span><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 从根节点开始BFS</span><br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 代表这层结束</span><br>        <br>        <span class="hljs-comment">// 存储每层的节点值</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; level;<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <br>            <span class="hljs-comment">// 如果当前层结束了</span><br>            <span class="hljs-keyword">if</span>(!t)&#123;<br>                <span class="hljs-comment">// 如果下一层没有节点了</span><br>                <span class="hljs-comment">// 比如：4 NULL，while循环拿出4，放入level之后，取出NULL，进入这个if条件里面</span><br>                <span class="hljs-comment">// level不是空，因此提交 level 到 ans 里面</span><br>                <span class="hljs-comment">// 队列里面剩下的是 NULL，再拿出来，此时判断level，为空，break掉</span><br>                <span class="hljs-comment">// 这也就是下一层没有节点的情况</span><br>                <span class="hljs-keyword">if</span>(level.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 当前层结束了，下一行还有节点，先提交level，再给下一层增加结束标识符</span><br>                ans.<span class="hljs-built_in">push_back</span>(level);<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>                <span class="hljs-comment">// 为了下一次，level容器是空的，还需要还原空状态</span><br>                level.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 当前层没结束,正常BFS</span><br>            level.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>            <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>            <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>由于树中每个节点仅会进队出队一次，所以时间复杂度是<code>O(n)</code></p>]]></content>
    
    
    <summary type="html">[AcWing]44. 分行从上往下打印二叉树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]43. 不分行从上往下打印二叉树</title>
    <link href="https://blog.phbeats.cn/posts/b0ff145d2003/"/>
    <id>https://blog.phbeats.cn/posts/b0ff145d2003/</id>
    <published>2023-04-15T10:40:31.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-43-不分行从上往下打印二叉树"><a href="#AcWing-43-不分行从上往下打印二叉树" class="headerlink" title="[AcWing]43. 不分行从上往下打印二叉树"></a><a href="https://www.acwing.com/problem/content/41/">[AcWing]43. 不分行从上往下打印二叉树</a></h1><p>从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点的数量 <code>[0,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null]<br>    8<br>   / \<br>  12  2<br>     /<br>    6<br>   /<br>  4<br><br>输出：[8, 12, 2, 6, 4]<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>显然，这是二叉树的层序遍历，使用 <code>BFS</code>就行。</p><p>我们从根节点开始按宽度优先的顺序遍历整棵树，每次先扩展左儿子，再扩展右儿子。</p><p>这样我们会：</p><ol><li>先扩展根节点；</li><li>再依次扩展根节点的左右儿子，也就是从左到右扩展第二层节点；</li><li>再依次从左到右扩展第三层节点；</li><li>依次类推</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <br>        <span class="hljs-comment">// 如果是空树，则返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>        <br>        <span class="hljs-comment">// 开始BFS</span><br>        queue&lt;TreeNode *&gt; q;<br>        <span class="hljs-comment">// 从根节点开始扩展</span><br>        q.<span class="hljs-built_in">push</span>(root);<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">// 取出队头元素</span><br>            TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <br>            <span class="hljs-comment">//题目要求输出序列，需要将它放入集合中</span><br>            res.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>            <br>            <span class="hljs-comment">// 拓展根节点的左右节点（如果存在的话）</span><br>            <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>            <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>BFS时每个节点仅被遍历一次，所以时间复杂度是 <code>O(n)</code>。</p>]]></content>
    
    
    <summary type="html">[AcWing]43. 不分行从上往下打印二叉树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]39. 对称的二叉树</title>
    <link href="https://blog.phbeats.cn/posts/49a255ffe500/"/>
    <id>https://blog.phbeats.cn/posts/49a255ffe500/</id>
    <published>2023-04-14T13:33:45.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-39-对称的二叉树"><a href="#AcWing-39-对称的二叉树" class="headerlink" title="[AcWing]39. 对称的二叉树"></a><a href="https://www.acwing.com/problem/content/38/">[AcWing]39. 对称的二叉树</a></h1><p>请实现一个函数，用来判断一棵二叉树是不是对称的。</p><p>如果一棵二叉树和它的镜像一样，那么它是对称的。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">如下图所示二叉树[1,2,2,3,4,4,3,null,null,null,null,null,null,null,null]为对称二叉树：<br>    1<br>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br><br>如下图所示二叉树[1,2,2,null,4,4,3,null,null,null,null,null,null]不是对称二叉树：<br>    1<br>   / \<br>  2   2<br>   \ / \<br>   4 4  3<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p><img src="https://bu.dusays.com/2023/04/14/6439692818a87.png" alt="image-20230414225426092"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* pA, TreeNode* pB)</span></span>&#123;<br>        <span class="hljs-comment">// 如果左根节点和右根节点有一个为空，那么只有它两都为空的时候才是true，否则是false</span><br>        <span class="hljs-keyword">if</span>(!pA || !pB) <span class="hljs-keyword">return</span> !pA &amp;&amp; !pB;<br>        <span class="hljs-comment">// 左右根节点都存在的情况</span><br>        <span class="hljs-comment">// 左右节点根节点值不同，则不对称</span><br>        <span class="hljs-keyword">if</span>(pA -&gt; val != pB -&gt; val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 左右根节点都存在，且值相同，比较他们的子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(pA -&gt; left, pB -&gt; right) &amp;&amp; <span class="hljs-built_in">dfs</span>(pA -&gt; right, pB -&gt; left);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果根节点是空的那么一定是对称的（规定如此）</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 判断左右子树是不是镜像的</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root -&gt; left, root -&gt; right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>从上到下每个节点仅被遍历一遍，所以时间复杂度是 <code>O(n)</code>。</p>]]></content>
    
    
    <summary type="html">[AcWing]39. 对称的二叉树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]38. 二叉树的镜像</title>
    <link href="https://blog.phbeats.cn/posts/f218078c7891/"/>
    <id>https://blog.phbeats.cn/posts/f218078c7891/</id>
    <published>2023-04-11T12:53:20.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-38-二叉树的镜像"><a href="#AcWing-38-二叉树的镜像" class="headerlink" title="[AcWing]38. 二叉树的镜像"></a><a href="https://www.acwing.com/problem/content/description/37/">[AcWing]38. 二叉树的镜像</a></h1><p>输入一个二叉树，将它变换为它的镜像。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入树：<br>      8<br>     / \<br>    6  10<br>   / \ / \<br>  5  7 9 11<br><br> [8,6,10,5,7,9,11,null,null,null,null,null,null,null,null] <br>输出树：<br>      8<br>     / \<br>    10  6<br>   / \ / \<br>  11 9 7  5<br><br> [8,10,6,11,9,7,5,null,null,null,null,null,null,null,null]<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>仔细观察发现，镜像就是：<wavy>交换左右子树，对于子树中的左右子节点也进行交换。</wavy><br>利用这个性质，抽象一下就是：递归遍历这个树，交换其<code>左右子树</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mirror</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归到空的节点，就跳出，什么也不做</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 交换左右子树</span><br>        <span class="hljs-built_in">mirror</span>(root -&gt; left);<br>        <span class="hljs-built_in">mirror</span>(root -&gt; right);<br>        <span class="hljs-built_in">swap</span>(root -&gt; left, root -&gt; right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的代码虽然简单，但还是可以分析一下。</p><ol><li>从宏观上来看：这是个交换左右子树的过程。</li><li>从微观上来看：这是个先找到叶子结点，从下面开始交换左右节点的过程。（函数递归调用栈）</li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>原树仅被遍历一次，所以时间复杂度是 <code>O(n)</code>。</p>]]></content>
    
    
    <summary type="html">[AcWing]38. 二叉树的镜像</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]37. 树的子结构</title>
    <link href="https://blog.phbeats.cn/posts/e7ce670351d7/"/>
    <id>https://blog.phbeats.cn/posts/e7ce670351d7/</id>
    <published>2023-04-11T12:53:20.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-37-树的子结构"><a href="#AcWing-37-树的子结构" class="headerlink" title="[AcWing]37. 树的子结构"></a><a href="https://www.acwing.com/problem/content/description/35/">[AcWing]37. 树的子结构</a></h1><p>输入两棵二叉树 <code>A，B</code>，判断 <code>B</code> 是不是 <code>A</code> 的子结构。</p><p>我们规定空树不是任何树的子结构。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>每棵树的节点数量 <code>[0,1000]</code>。</p><h4 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">    8<br>   / \<br>  8   7<br> / \<br>9   2<br>   / \<br>  4   7<br></code></pre></td></tr></table></figure><p>树 <code>B</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">  8<br> / \<br>9   2<br></code></pre></td></tr></table></figure><p>返回 <strong>true</strong>，因为 <code>B</code> 是 <code>A</code> 的子结构。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>代码分为两个部分：</p><ol><li>遍历树A中的所有非空节点R；</li><li>判断树A中以R为根节点的子树是不是包含和树B一样的结构，且我们从根节点开始匹配；</li></ol><p>对于第一部分，我们直接递归遍历树A即可，遇到非空节点后，就进行第二部分的判断。</p><p>对于第二部分，我们同时从根节点开始遍历两棵子树：</p><ul><li>如果树B中的节点为空，则表示当前分支是匹配的，返回true；</li><li>如果树A中的节点为空，但树B中的节点不为空，则说明不匹配，返回false；</li><li>如果两个节点都不为空，但数值不同，则说明不匹配，返回false；</li><li>否则说明当前这个点是匹配的，然后递归判断左子树和右子树是否分别匹配即可；</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPart</span><span class="hljs-params">(TreeNode* pA,TreeNode* pB)</span></span>&#123;<br>        <span class="hljs-comment">// 匹配成功的情况，B树已经遍历完了</span><br>        <span class="hljs-keyword">if</span>(!pB) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 匹配失败的情况(pB不为空)</span><br>        <span class="hljs-comment">// B树相比A树更枝繁叶茂，或者A树和B树比较的节点值不同，则子结构匹配失败</span><br>        <span class="hljs-keyword">if</span>(!pA || pA -&gt; val != pB -&gt; val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果A树和B树当前节点值相同，则继续匹配左右子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isPart</span>(pA -&gt; left, pB -&gt; left) &amp;&amp; <span class="hljs-built_in">isPart</span>(pA -&gt; right, pB -&gt; right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;<br>        <span class="hljs-comment">//空树不是任何树的子结构。任何树也不是空树的子结构。</span><br>        <span class="hljs-keyword">if</span>(!pRoot1 || !pRoot2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果是真的全匹配了，那么就是子结构</span><br>        <span class="hljs-comment">// 需要区别于 =&gt; return isPart(pRoot1,pRoot2);</span><br>        <span class="hljs-comment">// 上面这行是只要匹配错一个就直接错了，无容错空间。</span><br>        <span class="hljs-comment">// 下面这行是有容错空间的，还可以执行下下行代码</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isPart</span>(pRoot1,pRoot2)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 出现了一个节点不匹配，使得上面的出口未跳出</span><br>        <span class="hljs-comment">// 说明需要进入A树的左右子树，继续进行匹配</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasSubtree</span>(pRoot1 -&gt; left, pRoot2) || <span class="hljs-built_in">hasSubtree</span>(pRoot1 -&gt; right, pRoot2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><wavy>这里有个注意事项：代码注释已经写出，但这里抽出来再次解释</wavy><ol><li>if(isPart(pRoot1,pRoot2)) return true;这行代码需要区别于 =&gt; return isPart(pRoot1,pRoot2);</li><li><wavy>return isPart(pRoot1,pRoot2);这行是只要匹配错一个就直接错了，无容错空间。</wavy></li><li><wavy>if(isPart(pRoot1,pRoot2)) return true;这行是有容错空间的，还可以执行if后面的代码。</wavy></li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>最坏情况下，我们对于树A中的每个节点都要递归判断一遍，每次判断在最坏情况下需要遍历完树B中的所有节点。<br>所以时间复杂度是 <code>O(nm)</code>，其中 <code>n</code> 是树A中的节点数， <code>m</code> 是树B中的节点数。</p>]]></content>
    
    
    <summary type="html">[AcWing]37. 树的子结构</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]19. 二叉树的下一个节点</title>
    <link href="https://blog.phbeats.cn/posts/94e11a4b82e8/"/>
    <id>https://blog.phbeats.cn/posts/94e11a4b82e8/</id>
    <published>2023-04-07T12:34:12.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-19-二叉树的下一个节点"><a href="#AcWing-19-二叉树的下一个节点" class="headerlink" title="[AcWing]19. 二叉树的下一个节点"></a><a href="https://www.acwing.com/problem/content/31/">[AcWing]19. 二叉树的下一个节点</a></h1><p>给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。</p><p><strong>注意：</strong></p><ul><li>如果给定的节点是中序遍历序列的最后一个，则返回空节点;</li><li>二叉树一定不为空，且给定的节点一定不是空节点；</li></ul><!-- --><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量<code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。<br><br>则应返回值等于3的节点。<br><br>解释：该二叉树的结构如下，2的后继节点是3。<br>  2<br> / \<br>1   3<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><wavy>中序遍历：左根右</wavy><p>情况1：有右子树</p><p>情况2：无右子树</p><p><img src="https://bu.dusays.com/2023/04/07/64301d778a9c8.png" alt="image-20230407214109154"></p><p><img src="https://bu.dusays.com/2023/04/07/6430218e1aa8c.png" alt="image-20230407215844606"></p><p><img src="https://bu.dusays.com/2023/04/07/643022e300731.png" alt="image-20230407220425944"></p><p><img src="https://bu.dusays.com/2023/04/07/64302521859e7.png" alt="image-20230407221400823"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode *father;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">inorderSuccessor</span><span class="hljs-params">(TreeNode* p)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果它有右子树，找到右子树下的最左边的节点</span><br>        <span class="hljs-keyword">if</span>(p -&gt; right)&#123;<br>            p = p -&gt; right;<br>            <span class="hljs-keyword">while</span>(p -&gt; left) p = p -&gt; left;<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果它没有右子树，则寻找它的父亲节点，直到满足条件p == p -&gt; father -&gt; left</span><br>        <span class="hljs-comment">// 那么 p -&gt; father 就是 它的中序遍历的下一个节点</span><br>        <span class="hljs-keyword">while</span>(p -&gt; father &amp;&amp; p != p -&gt; father -&gt; left) p = p -&gt; father;<br>        <span class="hljs-keyword">return</span> p -&gt; father;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><wavy>不论往上找还是往下找，总共遍历的节点数都不大于树的高度。所以时间复杂度是`O(h)`，其中 h 是树的高度。</wavy>]]></content>
    
    
    <summary type="html">[AcWing]19. 二叉树的下一个节点</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]18. 重建二叉树</title>
    <link href="https://blog.phbeats.cn/posts/c2f1d45bfc4f/"/>
    <id>https://blog.phbeats.cn/posts/c2f1d45bfc4f/</id>
    <published>2023-04-04T10:47:17.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="18-重建二叉树-AcWing题库"><a href="#18-重建二叉树-AcWing题库" class="headerlink" title="18. 重建二叉树 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/23/">18. 重建二叉树 - AcWing题库</a></h1><p>输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。</p><p><strong>注意:</strong></p><p>二叉树中每个节点的值都互不相同；<br>输入的前序遍历和中序遍历一定合法；</p><p><strong>数据范围</strong><br>树中节点数量范围<code>[0,100]</code>。</p><p><strong>样例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">给定：<br>前序遍历是：[<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>]<br>中序遍历是：[<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7</span>]<br><br>返回：[<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]<br>返回的二叉树如下所示：<br>    <span class="hljs-number">3</span><br>   / \<br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  \<br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p><img src="https://bu.dusays.com/2023/04/04/642c0c5373b5f.png" alt="image-20230404193839718"></p><p><img src="https://bu.dusays.com/2023/04/04/642c1c1de0caf.png" alt="image-20230404204620577"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pos;<br>    <br>    <span class="hljs-function">TreeNode * <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-comment">// 如果区间为空（若 a == b ，比如 9 == 9，此时依旧要创建 根为9 的节点）</span><br>        <span class="hljs-keyword">if</span>(a &gt; b) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// 先构建根节点</span><br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[a]);<br>        <span class="hljs-comment">// 找到中序遍历中根节点的位置</span><br>        <span class="hljs-type">int</span> k = pos[root -&gt; val];<br>        <span class="hljs-comment">// 递归创建左子树和右子树</span><br>        root -&gt; left = <span class="hljs-built_in">build</span>(preorder, inorder, a + <span class="hljs-number">1</span>, k - x + a, x, k - <span class="hljs-number">1</span>);<br>        root -&gt; right = <span class="hljs-built_in">build</span>(preorder, inorder, b - y + k + <span class="hljs-number">1</span>, b, k + <span class="hljs-number">1</span>, y);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 提前记录中序遍历每个元素的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) pos[inorder[i]] = i;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder, inorder, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：O(n)</strong></p>]]></content>
    
    
    <summary type="html">[AcWing]18. 重建二叉树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法-质数</title>
    <link href="https://blog.phbeats.cn/posts/9c8937f58169/"/>
    <id>https://blog.phbeats.cn/posts/9c8937f58169/</id>
    <published>2023-03-31T13:21:14.000Z</published>
    <updated>2023-05-01T07:35:18.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="质数-素数-和合数的定义"><a href="#质数-素数-和合数的定义" class="headerlink" title="质数(素数)和合数的定义"></a>质数(素数)和合数的定义</h3><wavy>大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</wavy><wavy>合数是指在大于1的整数中除了能被1和本身整除外，还能被其他数（0除外）整除的数。</wavy><h3 id="质数的判定：试除法"><a href="#质数的判定：试除法" class="headerlink" title="质数的判定：试除法"></a>质数的判定：试除法</h3><p>此处，给出常规代码写法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">// 如果这个自然数比2小，则一定不是质数</span><br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 试除法</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        <span class="hljs-comment">// 能够被其它自然数整除，不是质数</span><br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>上述代码时间复杂度是O(n)。可是还能优化</p><p>例如：n = 12；i = 2; 那么 (n / i) 一定能整除 n。</p><p>12试除法试到2的时候同时可以知道6也是一个约数。</p><p>所以每次枚举的时候，只需要枚举较小的那个约数就行。</p><p>也就是说，只要 <code>i &lt;= (n / i)</code></p><p>下面给出优化过后的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">// 如果这个自然数比2小，则一定不是质数</span><br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 优化过后的试除法</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++)<br>        <span class="hljs-comment">// 能够被其它自然数整除，不是质数</span><br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码时间复杂度是O(n<sup>1/2</sup>)</p><p>主要修改了for循环里面的判断条件，没有使用<code>sqrt函数</code>，也没有使用<code>i * i &lt;= n</code>，而是使用了<code>i &lt;= n / i</code>。</p><wavy>因为使用sqrt函数慢，i * i 有爆 int 的可能</wavy><h3 id="分解质因数：试除法"><a href="#分解质因数：试除法" class="headerlink" title="分解质因数：试除法"></a>分解质因数：试除法</h3><wavy>合数可以分解质因数，质数不能分解质因数，因为质数只能等于1乘本身这种形式，而1不是质数。</wavy><p><code>算数基本定理</code> 也叫 <code>唯一分解定理</code>，主要的内容为：任何大于 <strong>1</strong> 的正整数都能 唯一 的分解为有限个质数的乘积。根据这一定理任何一个合数都可以被分解成几个质数相乘的形式。</p><p>质因数，给几个例子理解一下。</p><ul><li>1没有质因子。</li><li>5只有1个质因子，5本身。（5是质数）</li><li>6的质因子是2和3。(6 = 2 × 3)</li><li>2、4、8、16等只有1个质因子：2。（2是质数，4 =2²，8 = 2³，如此类推）</li><li>10有2个质因子：2和5。(10 = 2 × 5)</li></ul><h4 id="如何计算质因数：短除法"><a href="#如何计算质因数：短除法" class="headerlink" title="如何计算质因数：短除法"></a>如何计算质因数：短除法</h4><p><img src="https://bu.dusays.com/2023/03/31/6426f34ac5db5.png" alt="image-20230331225037221"></p><p>代码模拟如上操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">// 枚举质因子（i一定是质数，可证明）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++)&#123;<br>        <span class="hljs-comment">// 如果i是质因子</span><br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 进行计数</span><br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>)&#123;<br>                n /= i;<br>                s++;<br>            &#125;<br>            <span class="hljs-comment">// 输出底数和计数结果</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, s);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// n中最多只含有一个大于sqrt(n)的因子(可证明)</span><br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, n, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的点：</p><wavy>假如 i 是一个合数，那么它一定可以分解成多个质因子相乘的形式，这多个质因子同时也是 n 的质因子且比 i 要小，而比 i 小的数在之前的循环过程中一定是被条件除完了的，所以 i 不可能是合数，只可能是质数。</wavy><br /><wavy>n中最多只含有一个大于sqrt(n)的因子，证明通过反证法：如果有两个大于sqrt(n)的因子，那么相乘会大于n，矛盾。</wavy><h3 id="质数筛"><a href="#质数筛" class="headerlink" title="质数筛"></a>质数筛</h3><p>埃氏筛法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-comment">// 埃氏筛法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-comment">// 如果被筛过了</span><br>        <span class="hljs-keyword">if</span>(st[i]) <span class="hljs-keyword">continue</span>;<br>        <br>        <span class="hljs-comment">// 没有被筛过，当前数是质数</span><br>        primes[cnt ++] = i;<br>        <span class="hljs-comment">// 只标记质数的倍数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i)<br>            st[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-built_in">get_primes</span>(n);<br>    <br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><wavy>时间复杂度：O(nlog(logn))</wavy><p>线性筛法（欧拉筛）：</p><p>线性筛法是对朴素筛法的进一步优化，埃式筛法的缺陷在于，对于同一个合数，可能被筛选多次。为了确保每一个合数只被筛选一次，我们用<strong>每个合数的最小质因子</strong>来进行筛选</p><p>之所以被称为线性，是因为：1 ~ n 之内的任何一个合数一定会被筛掉,而且筛的时候只用最小质因子来筛,每一个数都只有一个最小质因子,所以<strong>每个数都只会被筛一次</strong>,因此线性筛法是线性的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-comment">// 欧拉筛</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )&#123;<br>        <span class="hljs-comment">// 如果没被筛过，它是质数</span><br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-comment">// 枚举质数表里面所有的质数(表里面的质数是从小到大存储的)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )&#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-built_in">get_primes</span>(n);<br>    <br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>时间复杂度：O(n)</wavy><br><br /><br>1、因为primes中质数是递增的，所以如果i%primes[j]!=0代表i的最小质因数还没有找到，<strong>即prime[j]小于i的最小质因数。但并不妨碍，primes[j]是primes[j] * i的最小质因数。</strong><br>2、如果当i%prime[j]==0时，代表<strong>i的最小质因数是prime[j]，primes[j]是primes[j] * i的最小质因数。</strong><br>3、综上所述达到了每个数仅筛一次的效果，时间复杂度O ( n ) .</p>]]></content>
    
    
    <summary type="html">算法里面的质数知识</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法-数学知识" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
