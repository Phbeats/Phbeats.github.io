<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phbeats-Blog</title>
  
  <subtitle>记录学习历程和生活感悟</subtitle>
  <link href="https://blog.phbeats.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.phbeats.cn/"/>
  <updated>2024-07-28T13:59:58.386Z</updated>
  <id>https://blog.phbeats.cn/</id>
  
  <author>
    <name>麦高芬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第十八周总结(7/29 - 8/04)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/7e90dc8b978f/"/>
    <id>https://blog.phbeats.cn/posts/7e90dc8b978f/</id>
    <published>2024-07-28T02:24:08.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="85d2f4ff5d2bfba883eb2778560cbb28d001dd46e911a63de0f58aa0c8a849a5">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08145ae0f68963ec2ce0d83a02d02043dac6fc9c53bfa772ae3c283d7a2ace81f49282a3c60187a3e7361ff731d2fc53c4fd2cecf0bdc5a9cedecc3fd189f7818d6c6afe8cf33f400749807b85f57c178b9507718b86ef9ff29fdbccfc439647fc19b50934b60bb3948ddac4ce92353b030f5ee0b4362bc552bd8b75e8c5777eca4bf4647dc6b0e6028d62e82e67fc74b5f6b3801965d7de43155c1d60ae914e47db9a320b0908876452210afad1d90382a22292a296f65d6cf9b9a27f2384d256d606de89631e30d3e6e4e42e55594fde7420476cd4b15527921386c10065233d546d867387a1a50d9eaf29b89eb73d69eec5d04da29b3f52dc75b8f2566271e7407c198533798e02c6c52b2747ba0211e5ab8dfd5eab011550c19cff20a3ad02873edeb1863e4b4297788fd8ccd65c025c4b675a1267b8ea696d2790b525424f847ed4c930111859c31610a0fdc2e855e69e31febae68a29d6d1c096c75c8941559e0cc72747bdcd74cd2432caa3252970a2972eaa327277604b1a6c88bd7ebe6e567c0db5320bff09f9e210718f1cb0c280ff88fab3805157d654bb6593886fac85c72c6e0f102393694ca6954fe84491c5b4d053d4e429404b8b23a413195e08fb6dcc7041f2a4b28cb6c56c0b97737cf3c27a8fca302ec386895be8c90c0d1911d377d5dedde7c7276efa0e251b3701552c544bf11bf82f2cb59abf9fbf57da6b80c2903526f7f61e435322c0f8a148c089caa1b3e6562263eede480d802b9aa0aed92e4e2b70b6430022c0125384b07120c7a12802f79dbda79215fe9ab94ac5ee1ce7ee2e4767b0c2a4f82520a040</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十八周总结(7/29 - 8/04)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>我想回家</title>
    <link href="https://blog.phbeats.cn/posts/f8b1a9df93e6/"/>
    <id>https://blog.phbeats.cn/posts/f8b1a9df93e6/</id>
    <published>2024-07-25T09:10:19.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing3403-我想回家"><a href="#AcWing3403-我想回家" class="headerlink" title="AcWing3403. 我想回家"></a><a href="https://www.acwing.com/problem/content/3406/">AcWing3403. 我想回家</a></h1><p>某国正处于激烈的内战之中，该国的各个城市按照支持领导人的不同分属两个阵营。</p><p>作为一个商人，<code>M</code> 先生并不关心政治，但他能够感受到目前事态的严峻。</p><p>你需要帮助他尽快回家。</p><p>出于安全的考虑，你所提供的回家线路中，最多只能包含一条连接两个不同阵营城市的道路。</p><p>请你计算，<code>M</code> 先生回家所需花费的最短时间。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含多组测试数据。</p><p>每组数据第一行包含整数 <code>N</code>，表示该国家的城市数量。</p><p>第二行包含整数 <code>M</code>，表示该国家的道路数量。</p><p>接下来 <code>M</code> 行，每行包含三个整数 <code>A,B,T</code>，表示城市 <code>A</code> 和城市 <code>B</code> 之间存在一条道路，通过它的时间为 <code>T</code>。</p><p>最后一行包含 <code>N</code> 个整数 <code>1</code> 或 <code>2</code>，其中的第 <code>i</code> 个整数是 <code>1</code>，则表示城市 <code>i</code> 位于阵营 <code>1</code>，否则，表示城市 <code>i</code> 位于阵营 <code>2</code>。</p><p>所有城市编号 <code>1 ~ N</code>。</p><p>为了简化问题，我们假设 <code>M</code> 先生是从城市 <code>1</code> 出发，目的地是城市 <code>2</code>，并且城市 <code>1</code> 一定位于阵营 <code>1</code>，城市 <code>2</code> 一定位于阵营 <code>2</code>。</p><p>注意，所有道路都是双向的，且两个城市之间最多只有一条道路。</p><p>输入 <code>N=0</code> 时，表示输入结束。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每组数据输出一行一个结果，表示最短时间。如果无法到达目的地，则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>每个输入最多包含 <code>10</code> 组数据。<br><code>2 &lt; N &lt; 600</code>,<br><code>0 &lt; M &lt; 10000</code>,<br><code>1 &lt; A,B &lt; N</code>,<br><code>1 &lt; T &lt; 500</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">2<br>1<br>1 2 100<br>1 2<br>3<br>3<br>1 2 100<br>1 3 40<br>2 3 50<br>1 2 1<br>5<br>5<br>3 1 200<br>5 3 150<br>2 5 160<br>4 3 170<br>4 2 170<br>1 2 2 2 1<br>0<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">100<br>90<br>540<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>分析输入：</p><ol><li>第一行：点数<code>n</code></li><li>第二行：边数<code>m</code></li><li>第三行：边<code>add(a,b,c)</code></li><li>最后一行：每个点的阵营<code>team[N]</code></li></ol><p>核心思想：<br><code>A国最短路径 + 连接两国的唯一一条路 + B国最短路径 = 答案</code></p><p><img src="https://bu.dusays.com/2024/07/25/66a21626eaf76.png" alt="QQ_1721898317357"></p><p>难点：</p><ol><li>查表<br>0、1、2、3、4、5、6、7、8、9、……<br>看成：[0, 1]、[1, 2]、[3, 4]、[5, 6]、[7, 8]、[9, 10]、……<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = e[i ^ <span class="hljs-number">1</span>], b = e[i];<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">对于： 0 -&gt; 1<br>a = 0, b= 1; <br><span class="hljs-code">`0 ^ 1 = 1`</span><br><span class="hljs-code">`1 ^ 1 = 0`</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">对于： 2 -&gt; 3<br>a = 2, b= 3; <br><span class="hljs-code">`2 ^ 1 = 3`</span><br><span class="hljs-code">`3 ^ 1 = 2`</span><br></code></pre></td></tr></table></figure></li></ol><p><code>idx</code>一定是这样增长的，所以<code>任取终边一定能找到其反向边</code></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 题目给的边范围[0, 10000]</span><br><span class="hljs-comment">// 由于是无向边，每条边建两次，所以M至少要超过20000</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">610</span>, M = <span class="hljs-number">20010</span>, INF = <span class="hljs-number">0X3F3F3F3F</span>;<br><br><span class="hljs-type">int</span> h[N], e[M], ne[M], w[M], idx;<br><span class="hljs-type">int</span> distA[N], distB[N], team[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 复用型 dijkstra</span><br><span class="hljs-comment">// 起点、起点所属阵营、起点阵营的dist表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> camp, <span class="hljs-type">int</span> dist[])</span></span>&#123;<br>    <span class="hljs-comment">// 因为是复用，所以还要 重置dist和st</span><br>    <span class="hljs-comment">// 细节是 sizeof distA，但是memset执行对象是 dist</span><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> distA);<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <span class="hljs-comment">// 起点距离为0</span><br>    dist[start] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))<br>                t = j;<br>        &#125;<br>        <br>        st[t] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 更新邻接表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = h[t]; ~j; j = ne[j])&#123;<br>            <span class="hljs-comment">// 邻接点</span><br>            <span class="hljs-type">int</span> k = e[j];<br>            <span class="hljs-comment">// 如果不是同一个阵营，则什么也不做</span><br>            <span class="hljs-keyword">if</span>(team[k] != camp) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 是同一个阵营就更新</span><br>            dist[k] = <span class="hljs-built_in">min</span>(dist[k], dist[t] + w[j]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n, n)&#123;<br>        <span class="hljs-comment">// 复用就需要重置图</span><br>        <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>        idx = <span class="hljs-number">0</span>;<br>        <br>        cin &gt;&gt; m;<br>        <span class="hljs-keyword">while</span>(m --)&#123;<br>            <span class="hljs-type">int</span> a, b, c;<br>            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>            <span class="hljs-built_in">add</span>(a, b, c);<br>            <span class="hljs-built_in">add</span>(b, a, c);<br>        &#125;<br>        <span class="hljs-comment">// 阵营输入</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; team[i];<br>        <br>        <span class="hljs-comment">// A国最短路径 + 连接两国的唯一一条路 + B国最短路径 = 答案</span><br>        <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, distA);<br>        <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, distB);<br>        <br>        <span class="hljs-comment">// 查表</span><br>        <span class="hljs-type">int</span> res = INF; <span class="hljs-comment">// 没有答案的话，res还是 INF</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i++)&#123;<br>            <span class="hljs-comment">// [0,1]、[2,3]、...:规律</span><br>            <span class="hljs-comment">// 0^1 = 1</span><br>            <span class="hljs-comment">// 1^1 = 0</span><br>            <span class="hljs-comment">// a -&gt; b</span><br>            <span class="hljs-type">int</span> a = e[i ^ <span class="hljs-number">1</span>], b = e[i];<br>            <span class="hljs-keyword">if</span>(team[a] == <span class="hljs-number">1</span> &amp;&amp; team[b] == <span class="hljs-number">2</span>)&#123;<br>                res = <span class="hljs-built_in">min</span>(res, distA[a] + w[i] + distB[b]);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 无解输出-1，否则输出值</span><br>        <span class="hljs-keyword">if</span>(res == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">我想回家</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>朴素邻接表版Dijkstra求最短路</title>
    <link href="https://blog.phbeats.cn/posts/026d6c6391c3/"/>
    <id>https://blog.phbeats.cn/posts/026d6c6391c3/</id>
    <published>2024-07-25T07:18:13.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-849-Dijkstra求最短路-I"><a href="#AcWing-849-Dijkstra求最短路-I" class="headerlink" title="[AcWing.849. Dijkstra求最短路 I]"></a><a href="https://www.acwing.com/problem/content/851/">[AcWing.849. Dijkstra求最短路 I]</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 <code>1</code> 号点到 <code>n</code> 号点的最短距离，如果无法从 <code>1</code> 号点走到 <code>n</code> 号点，则输出 <code>-1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>n</code> 和 <code>m</code>。</p><p>接下来 <code>m</code> 行每行包含三个整数 <code>x,y,z</code>，表示存在一条从点 <code>x</code> 到点 <code>y</code> 的有向边，边长为 <code>z</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 <code>1</code> 号点到 <code>n</code> 号点的最短距离。</p><p>如果路径不存在，则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 500</code>,<br><code>1 &lt; m &lt; 10^5</code>,<br>图中涉及边长均不超过10000。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 3<br>1 2 2<br>2 3 1<br>1 3 4<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>两个难点：</p><ol><li>邻接表建图</li><li>dijkstra算法 （参考<a href="/posts/6d0f7c8cf39d/">邻接矩阵版本</a>的）</li></ol><p>给出变量名粗略解释：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N];   <span class="hljs-comment">// 顶点 i 的邻接表的首边索引</span><br><span class="hljs-type">int</span> e[M];   <span class="hljs-comment">// 第 i 条边的终点</span><br><span class="hljs-type">int</span> ne[M];  <span class="hljs-comment">// 第 i 条边的下一条边索引</span><br><span class="hljs-type">int</span> w[M];   <span class="hljs-comment">// 第 i 条边的权重</span><br><span class="hljs-type">int</span> idx;    <span class="hljs-comment">// 当前边的索引</span><br></code></pre></td></tr></table></figure></p><p>给出变量名详细解释：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N];   <span class="hljs-comment">// h 数组，存储每个顶点的第一条边的索引。h[i] 表示顶点 i 的第一条边在 e 数组中的索引。</span><br><span class="hljs-type">int</span> e[M];   <span class="hljs-comment">// e 数组，存储每条边的终点。e[i] 表示第 i 条边的终点。</span><br><span class="hljs-type">int</span> ne[M];  <span class="hljs-comment">// ne 数组，存储每条边的下一条边的索引。ne[i] 表示第 i 条边的下一条边在 e 数组中的索引。</span><br><span class="hljs-type">int</span> w[M];   <span class="hljs-comment">// w 数组，存储每条边的权重。w[i] 表示第 i 条边的权重。</span><br><span class="hljs-type">int</span> idx;    <span class="hljs-comment">// idx 变量，记录当前边的数量，同时作为边的索引。</span><br></code></pre></td></tr></table></figure></p><p>容易混淆的点：</p><ol><li><code>e[M]</code>：如果你有一条边从顶点 u 到顶点 v，那么 e 数组的对应位置（例如 e[idx]）就是顶点 v</li><li><code>ne[M]</code>：ne[i] 表示第 i 条边在邻接表中指向的下一条边的索引。这使得我们可以在遍历某个顶点的邻接边时，依次访问所有与该顶点相邻的边。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;      <span class="hljs-comment">// 顶点数量上限</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">100010</span>;   <span class="hljs-comment">// 边数量上限</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3F3F3F3F</span>; <span class="hljs-comment">// 无穷大</span><br><br><span class="hljs-type">int</span> h[N];    <span class="hljs-comment">// 每个顶点的邻接表首条边的索引</span><br><span class="hljs-type">int</span> ne[M];   <span class="hljs-comment">// 每条边的下一条边的索引</span><br><span class="hljs-type">int</span> e[M];    <span class="hljs-comment">// 每条边的终点</span><br><span class="hljs-type">int</span> w[M];    <span class="hljs-comment">// 每条边的权重</span><br><span class="hljs-type">int</span> idx;     <span class="hljs-comment">// 当前边的索引</span><br><br><span class="hljs-comment">// 添加一条边 a -&gt; b，边权为 c</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b;       <span class="hljs-comment">// 设置边的终点为 b</span><br>    w[idx] = c;       <span class="hljs-comment">// 设置边的权重为 c</span><br>    ne[idx] = h[a];   <span class="hljs-comment">// 当前边的下一条边索引</span><br>    h[a] = idx++;     <span class="hljs-comment">// 更新顶点 a 的邻接表首条边为当前边</span><br>&#125;<br><br><span class="hljs-type">int</span> n, m, dist[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-comment">// 使用 Dijkstra 算法计算最短路径</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist); <span class="hljs-comment">// 初始化距离为无穷大</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起点到自身的距离为 0</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 找到未标记顶点中距离起点最小的顶点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t])) &#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <br>        st[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记顶点 t 为已访问</span><br>        <br>        <span class="hljs-comment">// 更新顶点 t 的所有邻接边的最短路径</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = h[t]; ~j; j = ne[j]) &#123;<br>            <span class="hljs-type">int</span> k = e[j]; <span class="hljs-comment">// 邻接点</span><br>            dist[k] = <span class="hljs-built_in">min</span>(dist[k], dist[t] + w[j]); <span class="hljs-comment">// 更新最短距离</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dist[n]; <span class="hljs-comment">// 返回到终点 n 的最短距离</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h); <span class="hljs-comment">// 初始化邻接表，表示每个顶点没有边</span><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-comment">// 读入边的信息并添加到邻接表</span><br>    <span class="hljs-keyword">while</span> (m --) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c); <span class="hljs-comment">// 添加边 a -&gt; b，权重为 c</span><br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">dijkstra</span>(); <span class="hljs-comment">// 执行 Dijkstra 算法</span><br>    <span class="hljs-keyword">if</span> (res == INF) cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 如果无法到达终点，输出 -1</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl; <span class="hljs-comment">// 输出最短距离</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">朴素邻接表版Dijkstra求最短路</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数组中出现次数超过一半的数字</title>
    <link href="https://blog.phbeats.cn/posts/4a6913efcb5c/"/>
    <id>https://blog.phbeats.cn/posts/4a6913efcb5c/</id>
    <published>2024-07-25T05:59:09.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing52-数组中出现次数超过一半的数字"><a href="#AcWing52-数组中出现次数超过一半的数字" class="headerlink" title="AcWing52. 数组中出现次数超过一半的数字"></a><a href="https://www.acwing.com/problem/content/48/">AcWing52. 数组中出现次数超过一半的数字</a></h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>假设数组非空，并且一定存在满足条件的数字。</p><p><strong>思考题</strong>：</p><ul><li>假设要求只能使用 <code>O(n)</code> 的时间和额外 <code>O(1)</code> 的空间，该怎么做呢？</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>数组长度 <code>[1,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,2,1,1,3]</span><br><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>计数器（最受欢迎的选举人票数）：<code>cnt</code></li><li>主元（最受欢迎的选举人）：<code>val</code></li><li>核心思想：<code>新的选举人可以消耗最受欢迎的选举人的票</code></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">moreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, val;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(!cnt) val = nums[i], cnt++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == val) cnt++;<br>            <span class="hljs-keyword">else</span> cnt--;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数组中出现次数超过一半的数字</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="摩尔投票法" scheme="https://blog.phbeats.cn/tags/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第十七周总结(7/22 - 7/28)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/befe218ab6a9/"/>
    <id>https://blog.phbeats.cn/posts/befe218ab6a9/</id>
    <published>2024-07-21T13:01:03.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1527556f03e92baf415aea59ac3c6ca360cf77b71d447e09be70ca470c6405b2">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08143c115436888dede058f21ebd92cb796344c76d7ff429c764db256b1a65412af507dd1cf6ff4dc5282f9de83a47d63ce1c41e73c21db9b25a078c20993d4ba0a88c1077167fa6e25933d4b27f77d1bb8723767a729f0b5f2dfac0463c6004f35ffa3dc7f75bd309015c70ed38ce905dde41d907b32e463f287ea60372dfb702c632afa4311a84b4823a2fcb0ba9e0e39927d01da695dc025ab3962c34f56c2e8dbb3535969906e9674553a38924d7c082fa1a623b917166cf36ae0df460142559f5fe3acda26f8d4bc5567a8f290505c002cabd03c785198b9ebc961350ec5d0a0c18f1be7208332dce2ccd1c2d26690e36d95314560d445e7e95829cde59ec4221bf4189b2d84acca7f241e63c942303c882660cc04bb8cc4feea7618cfb9a76b96d52b55d95063fa4902a214c3e6a69012a676fd5fe12bcde6fe9e821d8fbcd7f1af08c9d5137789ce1750e57f363555dad946d551dda8bf4520da6e3505ada214f27476165a37d074dd0a800d9753503aa265e82fa70583a54f2cda028216a06a4d7674c31bd3191c1e777607bbc6009747f93309dad64c4c1f1b15d8ecafc7b0491dad985b6e5688ab2cdb832320b01f1c636467def02f369b7b53e391666e39bbe19b22c8ad27f689e001a50aff38181cd16a4a794d7e2106e86b1b2e851752e5ce72604769d91dbfe867d642a589ce8cba3f61d64051724e6166a8f096fab40b0b343bd75066a3760a1fe675ac2bb08c39c68f3812bbce779ef1b9c53da7c8a58cfc54912574d5ccaae64977c170d6c18f96ccb678b2a8e819b2cfe976bd55a4ea735554dd754b8c81f86d34d82502e4c1a5e8d8cd7ed316246aa8bd33097c8a08a6c97b34a667093db6976d9f459ad8121f14b4ecbef18be353599219873d8ebc0ae89b850d239049bfa5c008e9c385dff2db22b857a80828b4f7f7669fbe395e0a2d1fc78f43f64a30002f29aa92b670e5709004b92ed4ed43910eb8671b64a0d2ab31c2b27578c244c65c486c34715e90f1aa0fd6ddf54325a12e4b7faa4ae4122e06dbb14af427771023ccb602cbd21dbb67a2bfaa5bea59fefe5b86fb6655c64be269238bd5252b7827d36e1f047ba65afd4cb2ba7ccf3a4943c32433efdd5ee337ae446154cef6a6a25aceee1c6e04612600f176211c7e99b39a701f09b514ee7a18aaebe37d1fefba81a90431864d12849f6b302425861b47ccae7db40d72c7bd4495b8baf22cc8c0443c21ce44f3d82417b957a2f66038f0b305509ce456147b0e99f68eafcfb997fa6b8d73ebfcde780ab093411fbea360f6b389112ceb06a910d2ebcd068daa936e11cfa928b3d8e0ac22a08afa42685cb683d0bf9ae0798e3dde7b8d0e38304516ed2b74a6ee551fa9109bb2f394725e57c445d6e50df7fa070a7309d63f5526c17c47d8a539f11259ac900a5a7bd557fc09e336f8ef587aed77b17882edee6caf9c09e8e532073e7f48c11ac4de20929f9ed4727ff1fa9f2fbd1e054bf5e7ad4e3c507f99e50ae3cd6065f02ce075e2c7a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十七周总结(7/22 - 7/28)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]3786. 二叉排序树</title>
    <link href="https://blog.phbeats.cn/posts/1e9e0dd97bd8/"/>
    <id>https://blog.phbeats.cn/posts/1e9e0dd97bd8/</id>
    <published>2024-07-20T10:02:22.000Z</published>
    <updated>2024-07-28T13:59:58.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3786-二叉排序树"><a href="#AcWing-3786-二叉排序树" class="headerlink" title="[AcWing]3786. 二叉排序树"></a><a href="https://www.acwing.com/problem/content/3789/">[AcWing]3786. 二叉排序树</a></h1><p>你需要写一种数据结构，来维护一些数，其中需要提供以下操作：</p><ol><li>插入数值 <code>x</code>。</li><li>删除数值 <code>x</code>。</li><li>输出数值 <code>x</code> 的前驱(前驱定义为现有所有数中小于 <code>x</code> 的最大的数)。</li><li>输出数值 <code>x</code> 的后继(后继定义为现有所有数中大于 <code>x</code> 的最小的数)。</li></ol><p>题目保证：</p><ul><li>操作 <code>1</code> 插入的数值各不相同。</li><li>操作 <code>2</code> 删除的数值一定存在。</li><li>操作 <code>3</code> 和 <code>4</code> 的结果一定存在。</li></ul><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>n</code>，表示共有 <code>n</code> 个操作命令。</p><p>接下来 <code>n</code> 行，每行包含两个整数 <code>opt</code> 和 <code>x</code>，表示操作序号和操作数值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于操作 <code>3,4</code>，每行输出一个操作结果。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 2000</code>，<br><code>-10000 &lt; x &lt; 10000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">6<br>1 1<br>1 3<br>1 5<br>3 4<br>2 3<br>4 2<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br>5<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>略. 详细看代码注释</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode * left, * right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> _val) : <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 要用引用，需要将改变的结果带回去</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(TreeNode *&amp; root, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">// 此题没有重复的元素插入</span><br>    <span class="hljs-comment">// 遇到空节点直接创建</span><br>    <span class="hljs-keyword">if</span>(!root) root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(x);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; root -&gt; val) <span class="hljs-built_in">insertNode</span>(root -&gt; left, x); <span class="hljs-comment">// 如果插入的值比当前节点的值小，就去左子树找</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">insertNode</span>(root -&gt; right, x); <span class="hljs-comment">// 否则去右子树</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode *&amp; root, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">// 都找遍了都没找到这个结点，那么干脆什么都不做了</span><br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 如果要删除的节点比当前节点小，去左子树找，否则去右子树找</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; root -&gt; val) <span class="hljs-built_in">deleteNode</span>(root -&gt; left, x);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; root -&gt; val) <span class="hljs-built_in">deleteNode</span>(root -&gt; right, x);<br>    <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 找到了</span><br>        <span class="hljs-comment">// 1. 刚好是叶子节点，直接删除</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right) <span class="hljs-keyword">delete</span> root, root = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 2. 只有左子树，只有右子树。让子树接替</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!root -&gt; right) root = root -&gt; left;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!root -&gt; left) root = root -&gt; right;<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 3. 左右子树都存在</span><br>            <span class="hljs-comment">// root的前驱节点顶替root</span><br>            TreeNode * p = root -&gt; left;<br>            <span class="hljs-keyword">while</span>(p -&gt; right) p = p -&gt; right;<br>            root -&gt; val = p -&gt; val;<br>            <span class="hljs-comment">// 去左子树当中删掉它的前驱</span><br>            <span class="hljs-comment">// 在你找到 p 后，简单地删除 p 会破坏树的结构，因为它可能还有子节点。</span><br>            <span class="hljs-built_in">deleteNode</span>(root -&gt; left, p -&gt; val);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 找前驱（小于x的最大数）</span><br><span class="hljs-comment">// 当前值，比x大，应该往左递归，继续找</span><br><span class="hljs-comment">// 当前值，比x小，当前值可能作为答案，当前节点的右子树中也可能存在答案，两者取max即可</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPre</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">// INF是不可能取的值，代表没有找到前驱</span><br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> -INF;<br>    <span class="hljs-keyword">if</span>(root -&gt; val &gt;= x) <span class="hljs-keyword">return</span> <span class="hljs-built_in">findPre</span>(root -&gt; left, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(root -&gt; val, <span class="hljs-built_in">findPre</span>(root -&gt; right, x));<br>&#125;<br><br><span class="hljs-comment">// 找后继（大于x的最小数）</span><br><span class="hljs-comment">// 当前值，比x小，应该往右递归，继续找</span><br><span class="hljs-comment">// 当前值，比x大，当前值可能作为答案，当前节点的左子树中也可能存在答案，两者取min即可</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findSuc</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">// INF是不可能取的值，代表没有找到后继</span><br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">if</span>(root -&gt; val &lt;= x) <span class="hljs-keyword">return</span> <span class="hljs-built_in">findSuc</span>(root -&gt; right, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(root -&gt; val, <span class="hljs-built_in">findSuc</span>(root -&gt; left, x));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    TreeNode * root;  <br>    <br>    <span class="hljs-keyword">while</span>(n --)&#123;<br>        <span class="hljs-type">int</span> op, x; <br>        cin &gt;&gt; op &gt;&gt; x;<br>        <br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 插入</span><br>            <span class="hljs-built_in">insertNode</span>(root, x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-comment">// 删除</span><br>            <span class="hljs-built_in">deleteNode</span>(root, x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-comment">// 前驱</span><br>            cout &lt;&lt; <span class="hljs-built_in">findPre</span>(root, x) &lt;&lt; endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">4</span>)&#123;<br>            <span class="hljs-comment">// 后继</span><br>            cout &lt;&lt; <span class="hljs-built_in">findSuc</span>(root, x) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3786. 二叉排序树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>第十六周总结(7/15 - 7/21)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/d8ab9332a9ff/"/>
    <id>https://blog.phbeats.cn/posts/d8ab9332a9ff/</id>
    <published>2024-07-15T02:29:50.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="72dfd54af341a0b550c720821df82a76f43be123bebe6a9f131a033062f224f2">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08141e080fbd108abc8d8e2db7c6c9ade5629ac04f626c4f0276c17f876e7448ed9bf117b49e46449397bcbbe765be1e079e4cc96be406211456a983dfd1462f01047a6cbb185afbba112cbea7b8c5201a1d2f12ae9f5153b8e68d516b24efee10150a0a53161ff056983387579a0d1b64455585212909931d1cdca470414d96a37e770e99d2b5328ac221d457ce66aaddaa9bf3fc1213797da0a280032d31aa42c1163221ec8e992148ccb183f70a613e319a3344f5b491b58c68588735c2c2b5a51f22cc07c31e7d22007f73b15c1273d4822b1195862c33034255268c911d02ec75a328d472b973e735bb976cc7e1919ba76eaef9a0074b1cedaf3ed232fa980e775097d88cd64df575bd82687b338a5da3db1fd249cd909275ae534f874711b1284d6523bbd0a9c7cf894a3f23aa15e348347e7c764a0cef4b2a9ca53abff20a628dec3a90c04c039500deee12db4fc5ff65f5a3cbdc48a7c241825ec73a781b34cf04e9223847bdcb078a998899f5e19c6567dc7babac008b2217239aa4062af3fa022403dfd5c45982b9b5f7137095ef2883ee715c68cb34ac586a31ca0dc3dd87ed4127442435ca4d261501a3e0d01068fd0d34383ae15edb10c88a57193d73d18139935797abf6fa060d2257bf4aabcb7ec1027cb966f9d552e768192433386466a06413d91b41b553e199ebebd8219e7e007508f4c64811c9dc407074373cbd3e79dfe8d5b199d494e5f14df70bcc793b8152d68e0f4557854a34cdbf6ccaeeda8545c8c3f432a5190ef8eeeaa45da642ec546b60cd9ee35f61e910ab63a134d15ae1782797af5f513adec4476a9189e6e1c54a6bf7905f338dd24134eaacf99cc31b04f777adec6535b0040dabc8fa93fa99391b0b327e70d164b63039d68e7da17eaeb7d3c2d7e9ae545ba898797fc1ef66ebcf993e6e7468202f6920dd45bd7ef3ef2967cd444246e5a6e47bdb62a57ecf60ba5f2d6406811da654877f3f3f97f741f25d7669d909cf1b5000c6eac1fa6e0659cc9c7e28c52a351d0bf0b28880465fe15f0aae897f4cbe5686a8a6a55f3e49e6baa23c9ea006212cd4f3c170c8820fb924f9259cf8354a3c63cfdbf8986c6ceb3445a5e9ba2e9964b8e30dcd5b8d2f14d00bb78c094ff3d49c460d714dda26bc687d863dfc1fdf5b76e5b0995c3c3b88ce85bb3d9ef0a94df5de7566c82f7a53c416f5b4d4d5e720c0ffa15ed4bfa9417f0fed2dabc0b77184c4eb897ee071776c12fdd9d75f2fc17a897611007cc8c153f6b73234e115e78edbc1d7157416c140125c085c0f5ce855cc60a4571c1d33aebaaa1c1fe9271ae0ecdb7b5f782361808e988efb5beb4658558f2e4b03caa7bc20094de0f931f5bd</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十六周总结(7/15 - 7/21)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Floyd求多源最短路径</title>
    <link href="https://blog.phbeats.cn/posts/8ec7c1c49651/"/>
    <id>https://blog.phbeats.cn/posts/8ec7c1c49651/</id>
    <published>2024-07-10T13:33:50.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Acwing-854-Floyd求最短路"><a href="#Acwing-854-Floyd求最短路" class="headerlink" title="[Acwing.854. Floyd求最短路]"></a><a href="https://www.acwing.com/problem/content/856/">[Acwing.854. Floyd求最短路]</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的有向图，图中可能存在重边和自环，边权可能为负数。</p><p>再给定 <code>k</code> 个询问，每个询问包含两个整数 <code>x</code> 和 <code>y</code>，表示查询从点 <code>x</code> 到点 <code>y</code> 的最短距离，如果路径不存在，则输出 <code>impossible</code>。</p><p>数据保证图中不存在负权回路。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 <code>n,m,k</code>。</p><p>接下来 <code>m</code> 行，每行包含三个整数 <code>x,y,z</code>，表示存在一条从点 <code>x</code> 到点 <code>y</code> 的有向边，边长为 <code>z</code>。</p><p>接下来 <code>k</code> 行，每行包含两个整数 <code>x,y</code>，表示询问点 <code>x</code> 到点 <code>y</code> 的最短距离。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 <code>k</code> 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 <code>impossible</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 200</code>,<br><code>1 &lt; k &lt; n^2</code><br><code>1 &lt; m &lt; 20000</code>,<br>图中涉及边长绝对值均不超过 <code>10000</code>。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 3 2<br>1 2 1<br>2 3 2<br>1 3 1<br>2 1<br>1 3<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">impossible</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>Floyd算法</code>可以实现求任意两点的最短距离。有动态规划的思想，纯模板背就行。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span> , INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> n , m , q;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(g , <span class="hljs-number">0x3f</span> , <span class="hljs-keyword">sizeof</span> g);<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br><br>    <span class="hljs-keyword">while</span> (m --)&#123;<br>        <span class="hljs-type">int</span> a , b , c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt;c;<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],c);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 主对角线先置为0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) g[i][i] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 三层for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )&#123;<br>                <span class="hljs-comment">// i -&gt; k -&gt; j</span><br>                g[i][j] = <span class="hljs-built_in">min</span>(g[i][j] , g[i][k] + g[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(q --)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-type">int</span> c = g[a][b];<br>        <br>        <span class="hljs-comment">// 比如只有三个点：1 -&gt; 2 权值是-2</span><br>        <span class="hljs-comment">// 3是孤立点，那么 1 -&gt; 3 的距离是 INF - 2 不是INF但也是无穷大</span><br>        <span class="hljs-comment">// 不妨用 c &gt; INF / 2 表示这种情况</span><br>        <span class="hljs-keyword">if</span>(c &gt; INF / <span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; c &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Floyd求多源最短路径</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Prim求最小生成树</title>
    <link href="https://blog.phbeats.cn/posts/ca375a506a38/"/>
    <id>https://blog.phbeats.cn/posts/ca375a506a38/</id>
    <published>2024-07-08T02:41:45.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-858-Prim算法求最小生成树"><a href="#AcWing-858-Prim算法求最小生成树" class="headerlink" title="[AcWing.858. Prim算法求最小生成树]"></a><a href="https://www.acwing.com/problem/content/860/">[AcWing.858. Prim算法求最小生成树]</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的无向图，图中可能存在重边和自环，边权可能为负数。</p><p>求最小生成树的树边权重之和，如果最小生成树不存在则输出 <code>impossible</code>。</p><p>给定一张边带权的无向图 <code>G=(V, E)</code>，其中 <code>V</code> 表示图中点的集合，<code>E</code> 表示图中边的集合，<code>n=|V|</code>，<code>m=|E|</code>。</p><p>由 <code>V</code> 中的全部 <code>n</code> 个顶点和 <code>E</code> 中 <code>n-1</code> 条边构成的无向连通子图被称为 <code>G</code> 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 <code>G</code> 的最小生成树。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <code>n</code> 和 <code>m</code>。</p><p>接下来 <code>m</code> 行，每行包含三个整数 <code>u,v,w</code>，表示点 <code>u</code> 和点 <code>v</code> 之间存在一条权值为 <code>w</code> 的边。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 <code>impossible</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 500</code>,<br><code>1 &lt; m &lt; 10^5</code>,<br>图中涉及边的边权的绝对值均不超过 <code>10000</code>。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">4 5<br>1 2 1<br>1 3 2<br>1 4 3<br>2 3 2<br>3 4 4<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">6<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>Prim求最小生成树的核心思想：</code></p><ol><li>从源点开始，将源点纳入最小生成树集合中，求出其余点哪个点离它更近，将更近的点纳入最小生成树集合之中（如果最佳点都不连通，意味着其余点距离都是<code>INF</code>，直接返回<code>INF</code>，因为最小生成树要求每个点都连通）</li><li>在这个过程中，始终是<code>最小生成树集合</code>与<code>非最小生成树集合中其余点</code>进行判断。</li><li>Prim算法是一种用于<code>求解加权连通无向图的最小生成树的贪心算法</code>。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-comment">// 使用邻接矩阵建图，dist是最小生成树集合与点的距离</span><br><span class="hljs-type">int</span> g[N][N], dist[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    <span class="hljs-comment">// 集合中初始包含点1，距离是0</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 计算最小生成树的权值（很重要）</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))<br>                t = j;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 与 dijkstra不同的是，这里需要判断集合与当前最佳点是否连通</span><br>        <span class="hljs-comment">// 如果不连通，那么没有最小生成树</span><br>        <span class="hljs-keyword">if</span>(dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br>        <span class="hljs-comment">// 这个点加入最小生成树集合中</span><br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 权值累加</span><br>        res += dist[t];<br>        <br>        <span class="hljs-comment">// 更新最小生成树集合，权值最小的点加入进来，可能会改变其它点的dist值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 返回最小生成树的权值</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-comment">// 双向图 + 重边过滤</span><br>        g[a][b] = g[b][a] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">prim</span>();<br>    <br>    <span class="hljs-keyword">if</span>(res == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Prim求最小生成树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>第十五周总结(7/08 - 7/14)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/3b104892b0c6/"/>
    <id>https://blog.phbeats.cn/posts/3b104892b0c6/</id>
    <published>2024-07-07T04:03:41.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7e10648b205d358a5f6e8e09debbfa2e5ed644646265741eb11e899a4ebf07df">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814d43a7826e9617d25e4bc2882228ab7a9900ba48fe342d13c7b7815ac85e082deee7a0737b1f90c0c64ef436ba2dde457e8d527c17f0d19bc74437607fa8e7643e8887cafce8e4ff32ec0135f85e863fa675f67696b1c244f7634bcea54eb4f3e726dfb17345335be426770b4adeb1ca6322dc6f01b78f17afe89af927983492c443ab47a780e543aa30c0f5f816c4033b6bd2c0d23a42341d1d293faf0fa892eed3963a93602a9fd91ce5309aea1aa6c0ea62bc04585df963aba657d25154f25fb092e7cbc55dfe7717f6b3de04306e23c17e066182b55eade1fc460b2876185f206a0d5e86aefa5c9228c446a3b6816e80e45ef12c83dd7bec3a05d4e337af02af5f4ac01e50ae296a2ae059a0a3c717d63dd91c00ef186305cec23813ddd6e7af53e9623cc1693396e3e1c855d36f6d6f087374b1f5cbbe9bd7f25885d79f472f8d1ea67d01191bff0d8525f903e1acccd08cf82d991d5c04ccc271020b65bd34003d6b78262db9d8eb4a13e52961560d64e7a1225f6c4d41a8ea4eb344636030fe6a9f098e577f4855527738c2afa816114844daefdd9c3bbb88954c17f03c292d0431c855877bc86bef6f5421d2cbd57d4cc94e028f6f256e6e274ac36ca7d86129fbb61ee111be883b57fbcce36659d1780f256cd982edb5638786c868836a780de3b26cf1aa285e88ec72b8ad7004647ac85768e1f26e9305178f20421524efb28b519f41b42f11a758dcd4d5cc5ebeb0c0ff3b22021969e481ea7eeca90f4c34caca169a2297e511796f300df604d27a73c3877881c1f60a89eee7cd7a58e30962769401b114af57a0b1b05cb84591d9b28c08c8579dfceffa217197ccf3a905ebdde225ea7e23019e08806cb30b180a12d141f785733865a78309dbe81ebb05beb9c94744ca2bdef4c6dfec9517d66bf4b5726d35c1ae4361bb5167d9293a7ccf8ec0bb7fad61b2c3657aea625b455f049c6586fddf9a56a3d5f2da71dea0fd4745a9169d854631bf5c85539d76b43a4021406c9f52fd672a750ec4970ea9a4f640ac93192e224c6bee6ff23f41b3dfcc03e567e24a12093d8fb5260dd696c14dfc23f8acd8dfe1c55b8e0bdbbe058a79af6eb2be9d32cf036a084b1b32048635f1565c50529e3ae7ded1c4cef60cdebe3485ec59b246d8b1c687f96c244b2fc61355d71f0b1f2623ae6d95157df6851e9da6714c9bae1f0c476087346c66f63d62db64a9c3862c616c025b3617979653b9e073cb36bb4c89cce3fc71b648556897cae3f3ac0b8df8704c2f0c0a710bf88a946be997a26d25b5b05f16defe348bfe0b28d1dfe637de318cf7e537a780c4fbb4bca653c43e0b9930a9c5df58553419cd64fcb0c25683136aa4533ea11db5cd278b4b41444700baee01b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十五周总结(7/08 - 7/14)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>有向图的拓扑序列</title>
    <link href="https://blog.phbeats.cn/posts/ef6a4cd7f55c/"/>
    <id>https://blog.phbeats.cn/posts/ef6a4cd7f55c/</id>
    <published>2024-07-04T03:16:47.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-848-有向图的拓扑序列"><a href="#AcWing-848-有向图的拓扑序列" class="headerlink" title="[AcWing.848. 有向图的拓扑序列]"></a><a href="https://www.acwing.com/problem/content/850/">[AcWing.848. 有向图的拓扑序列]</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的有向图，点的编号是 <code>1</code> 到 <code>n</code>，图中可能存在重边和自环。</p><p>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 <code>-1</code>。</p><p>若一个由图中所有点构成的序列 <code>A</code> 满足：对于图中的每条边 <code>(x, y)</code>，<code>x</code> 在 <code>A</code> 中都出现在 <code>y</code> 之前，则称 <code>A</code> 是该图的一个拓扑序列。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <code>n</code> 和 <code>m</code>。</p><p>接下来 <code>m</code> 行，每行包含两个整数 <code>x</code> 和 <code>y</code>，表示存在一条从点 <code>x</code> 到点 <code>y</code> 的有向边 <code>(x, y)</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</p><p>否则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n,m &lt; 10^5</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 3<br>1 2<br>2 3<br>1 3<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1 2 3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>首先，存在拓扑序列，必定是<code>有向无环图</code>，如果是<code>有向有环图一定没有拓扑序列</code>，无向图更别说了。</p><p><code>核心思想</code>：</p><ol><li>n个节点，将入度为0的节点全部入队</li><li>删除掉所有入度为0的节点，在这个过程中，被删掉的节点不妨设为<code>t</code></li><li>遍历<code>t</code>节点的邻边节点，让<code>t</code>节点的所有邻边节点<code>入度减1</code>，如果<code>邻边节点入度被减之后恰好为0</code>，则入队</li></ol><p>此题，n的数量达到了10^5。所以需要使用邻接表，当然邻接矩阵算法也写下来，用于借鉴。<br>时间复杂度分别为<code>o(n + m)</code>和<code>o(n^2)</code>。</p><p><code>需要注意的是</code>：<br>邻接矩阵的重边造成的影响需要在加边的时候进行判断，维护入度，不让重边的出现导致入度混乱。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!g[a][b])&#123;<br>    <span class="hljs-comment">// 加边</span><br>&#125;<br></code></pre></td></tr></table></figure><br>或者，在topsort的时候将重边一起删掉，也意味着重边入度也要减少<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(g[t][j]) --g[t][j],--d[j];<br></code></pre></td></tr></table></figure><br><code>使用邻接表</code>就不需要加判断了，因为邻接表在加边的时候，重边不仅加进去了，在<code>topsort</code>的时候<br>它会处理重边，所以入度一直是正确的。</p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 最大节点的数量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-comment">// 节点数，边数</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> id;<br>    Node * next;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _id): <span class="hljs-built_in">id</span>(_id), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<br>&#125; * head[N]; <span class="hljs-comment">// 邻接表</span><br><br><span class="hljs-comment">// 入度，队列</span><br><span class="hljs-type">int</span> d[N], q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 有向图头插法加边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-comment">// 创建b节点</span><br>    Node * p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(b);<br>    <span class="hljs-comment">// b节点的next指向原来节点a指向的next</span><br>    p -&gt; next = head[a];<br>    <span class="hljs-comment">// 节点a指向节点b</span><br>    head[a] = p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 将所有入度为0的节点加入队列之中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span>(!d[i])<br>            q[++tt] = i;<br>            <br>    <span class="hljs-comment">// 删除掉所有入度为0的节点</span><br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh++];<br>        <br>        <span class="hljs-comment">// 遍历t节点的邻边节点</span><br>        <span class="hljs-keyword">for</span>(Node * p = head[t]; p; p = p -&gt; next)&#123;<br>            <span class="hljs-comment">// 周边节点入度-1，如果入度为0，则加入队列</span><br>            <span class="hljs-keyword">if</span>(--d[p -&gt; id] == <span class="hljs-number">0</span>)&#123;<br>                q[++tt] = p -&gt; id;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// n个节点都应该被删掉一次，那么tt达到 n - 1</span><br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-comment">// a -&gt; b</span><br>        <span class="hljs-built_in">add</span>(a, b);<br>        d[b]++; <span class="hljs-comment">// b的入度+1</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果图有环</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">topsort</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 合法拓扑序列恰好是 0 ~ tt，这里写成 &lt; n也无妨，输出那n个节点(0 ~ n - 1)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>; <span class="hljs-comment">// 假设最多有1000个顶点</span><br><br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">// 邻接矩阵表示图</span><br><span class="hljs-type">int</span> d[N]; <span class="hljs-comment">// 入度数组</span><br><span class="hljs-type">int</span> q[N], tt = <span class="hljs-number">-1</span>, hh = <span class="hljs-number">0</span>; <span class="hljs-comment">// 队列及其指针</span><br><span class="hljs-comment">// 节点数、边数</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 遍历所有节点，入度为0的点全部入队</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!d[i]) &#123;<br>            q[++tt] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 装填完毕，删除当前节点，周边节点的入度-1，看是否为0，如果满足它们也入队</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt) &#123;<br>        <span class="hljs-type">int</span> t = q[hh++];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (g[t][j]) &#123; <span class="hljs-comment">// 如果存在边t-&gt;j</span><br>                <span class="hljs-comment">// 由于重边的影响，比如两次 2 -&gt; 3</span><br>                <span class="hljs-comment">// 需要一口气将3的入度-2</span><br>                <span class="hljs-keyword">while</span>(g[t][j]) --g[t][j],--d[j];<br>                <br>                <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">0</span>) &#123;<br>                    q[++tt] = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        g[a][b]++; <span class="hljs-comment">// 边数+1</span><br>        d[b]++; <span class="hljs-comment">// b的入度+1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">topsort</span>()) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n ; i++) &#123;<br>            cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">有向图的拓扑序列</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>朴素邻接矩阵版Dijkstra求最短路</title>
    <link href="https://blog.phbeats.cn/posts/6d0f7c8cf39d/"/>
    <id>https://blog.phbeats.cn/posts/6d0f7c8cf39d/</id>
    <published>2024-07-01T02:49:03.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-849-Dijkstra求最短路-I"><a href="#AcWing-849-Dijkstra求最短路-I" class="headerlink" title="[AcWing.849. Dijkstra求最短路 I]"></a><a href="https://www.acwing.com/problem/content/851/">[AcWing.849. Dijkstra求最短路 I]</a></h1><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 <code>1</code> 号点到 <code>n</code> 号点的最短距离，如果无法从 <code>1</code> 号点走到 <code>n</code> 号点，则输出 <code>-1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>n</code> 和 <code>m</code>。</p><p>接下来 <code>m</code> 行每行包含三个整数 <code>x,y,z</code>，表示存在一条从点 <code>x</code> 到点 <code>y</code> 的有向边，边长为 <code>z</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 <code>1</code> 号点到 <code>n</code> 号点的最短距离。</p><p>如果路径不存在，则输出 <code>-1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 500</code>,<br><code>1 &lt; m &lt; 10^5</code>,<br>图中涉及边长均不超过10000。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 3<br>1 2 2<br>2 3 1<br>1 3 4<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>朴素Dijkstra</code>可以用来求<code>有向图</code>的<code>单源最短路</code>(一个点到其余点的最短距离，一般默认是求起点1到其余点的距离)，<code>无向图</code>可以看作特殊的<code>有向图</code>，只需要建图的时候<code>建两条边</code>即可。</p><p><code>邻接矩阵</code>版，主要变量名解释:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 最大点、边的数组容量、正无穷</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">100010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-comment">// 点、边</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-comment">// 使用邻接矩阵表示图</span><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-comment">// 源点距离其它点的距离</span><br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-comment">// 该点是否已经属于最短路集合中</span><br><span class="hljs-type">bool</span> st[N];<br></code></pre></td></tr></table></figure></p><p><code>易错点：</code></p><ol><li>main函数一开始<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 很重要的一点！一开始就将邻接矩阵的距离都初始化为无穷大</span><br><span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br></code></pre></td></tr></table></figure></li><li>dijkstra函数内一开始<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化源点距离数组为无穷大</span><br><span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br></code></pre></td></tr></table></figure></li><li>dijkstra逻辑细节别都嵌套到for循环里面去了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 枚举所有点（这层循环要求点的编号也能对应上，从1开始）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>    <span class="hljs-comment">// 如果这个点还没有被纳入最短路集合里面</span><br>    <span class="hljs-comment">// t是-1，或者 有点j存在使得 有更短的路径</span><br>    <span class="hljs-comment">// 更新 t</span><br>    <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))&#123;<br>        t = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 确定这个t点是最短路集合里面的点</span><br>st[t] = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 由于t这个点加入，需要更新一下距离</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>    <span class="hljs-comment">// g[t][j]是边权</span><br>    dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 最大点、边的数组容量、正无穷</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">100010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-comment">// 点、边</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-comment">// 使用邻接矩阵表示图</span><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-comment">// 源点距离其它点的距离</span><br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-comment">// 该点是否已经属于最短路集合中</span><br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 初始化源点距离数组为无穷大</span><br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    <span class="hljs-comment">// 源点距离源点它自己的距离为0，源点默认为1</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 枚举所有点（n次），虽然dist[1] = 0，但实际上它还没加入最短路集合中。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-comment">// 保存当前循环，距离最短的点</span><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-comment">// 枚举所有点（这层循环要求点的编号也能对应上，从1开始）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-comment">// 如果这个点还没有被纳入最短路集合里面</span><br>            <span class="hljs-comment">// t是-1，或者 有点j存在使得 有更短的路径</span><br>            <span class="hljs-comment">// 更新 t</span><br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))&#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 确定这个t点是最短路集合里面的点</span><br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 由于t这个点加入，需要更新一下距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-comment">// g[t][j]是边权</span><br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 从源点到终点的距离</span><br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-comment">// 很重要的一点！一开始就将邻接矩阵的距离都初始化为无穷大</span><br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <br>    <span class="hljs-comment">// 建图</span><br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-comment">// 保证没有重边，如果有重边，保留一个最小的边就行</span><br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 求最短路</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">dijkstra</span>();<br>    <br>    <span class="hljs-comment">// 如果结果是正无穷，输出-1，否则输出结果</span><br>    <span class="hljs-keyword">if</span>(res == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">朴素邻接矩阵版Dijkstra求最短路</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="图" scheme="https://blog.phbeats.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>第十四周总结(7/01 - 7/07)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/db40b2dad0b6/"/>
    <id>https://blog.phbeats.cn/posts/db40b2dad0b6/</id>
    <published>2024-06-30T10:40:50.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7bf1d6f55908fd2f89cdf67984e231b00adca3949b48690b1367fee334a2b22d">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08147c59532d54d08f48755ebc43be9739e8ff98267cb1bed9efe9c4b40f47e84b22cf58a8f15cc8c52a2cd7e58f2b15aff58daf2425eedca3f9aed9e40db2d22eb050eea48a82cb726c40209a0a25d470b0002aa3e0ff848b07644019e9ee5f35426ffe3535dd0a39f3aad1bb140b33856c2f85ac3a1587ec10fd7ee7908d14381699f2284632748cc65165c7a2cc916b6f937f088c7e4f8686b9f06f8e488b70e8bc0072b313ae1bfc32f09e648860374c11051d94a934d680e302d8f7863bc15d6b47bcbb45c1dcb8863456c23b47323798f033fcaff831603a4cb12250db1834a15fba84c2ac8529fc8bc841c8e83578182235a9eb8e4cd0f95c840a4cbd8fdbd30bb832e1857c0b4efb36e98d09a53ad9e8a696acf266b7453867064b3f023eca715f0e7ff08bd0a034656044f434362e33e7ebd823400bbc8ce773f798b48b42e98549de22d8f58d901656b5cd09f5d543fb9ffdd339fb98af15654d1ef09c70ce5fa306def10b17c4e44262912e7196a609fad87707df46c3cc834d633b1b78d8a484e726d93ad5fb569b67941d6f38021fa3a9a558df501908f36091b9969848e85cbafc81ce4bb7ab713a229d9fef62ee1f2e6be8f387771a23f172db259db680a615cb65412ba652a8348c8ab17c3fdb556c8f6d20b0aa1540da3090a81271c38c571d5979555d22f95610833428ed6fe6e58e9ac72da9278b7e1a045fac3d13ef349567479537653ea3fa46a7fe8af1fa28259e74a6fcc5021514477ebde2bd1d0ebdcd165b67f25b1ecb767a7737e7b87c0bb4c5cedab011744afb2abe59b5fd6ab7d2cb11ec9587b1d68e68c509dc29a2fa7b9397ef29029cd802f1498dda03169b67b8ac29d49f02fb854e31ac12ce991c3c7e82fd8f9a48fe5e0e766a35f48b8e2bdf15482a527539b44cd59053dfa03c7fdca48ae7e1174ed66eb7c3a05cedefb17ddd7b2459c5763187485bb984bf423b5380fdbd18cffeaae49f5443d46d9787b67f33cc3a34757d8c619f58927ca7e68f56bb77135b77e6b25426d5480e724b017b56f604005228cf0fd2206257b00215d10e9ed296f4d4bb9c56c8d79cba1e1149587c63131161db1a2d2eb78ebf64c48dfdb108bf6729e7be041521967cfef0267be0a8d0a65fec5adb5724e8e9d91c635be1318d244350a514ad719508edbeca5ff3bd856f5a72200833483c526f903c285ea00788dc419408a15b4ae118e66ee4cbc1dc4d2a2d4980d8e0711f872ca7e06dcda71130468d1c9de0ee01e24a0fea280b3c7a58443c6b10f5b8c15ecd45fef9ba119183f292e77e1045e5301e7b7e3dd10052fa478be9f756c14579c87698669712815dba43aa42a3453a6665d9e6d1bdd7508c8930c28f2f6c3ea8b9c6a23dbc544f6f74a2ac0780a46e57f7b496adc99e0a4c5fb72bf7a4cc07f61bd0f4e8276512762335f0f38caa85d35537a68fee727b31515d36bb12f76f12a3fe6c8dfbca6d40a91f58a7492372653721f820fb0a05f9cc522dfe1aed8de3678c60cfeee7dc76c50a3ff12a31fed4650cab94ba8bed03ee23fae1f36f77cfe0567c5428bd24a74757035d9404a0f2f0948149c5349bfd154017e8498b9080fe9cebcf2cc82f1f72</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十四周总结(7/01 - 7/07)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>游戏（约瑟夫）</title>
    <link href="https://blog.phbeats.cn/posts/08d4ec6ea429/"/>
    <id>https://blog.phbeats.cn/posts/08d4ec6ea429/</id>
    <published>2024-06-27T14:27:25.000Z</published>
    <updated>2024-07-28T13:59:58.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing3253-游戏"><a href="#AcWing3253-游戏" class="headerlink" title="[AcWing3253. 游戏]"></a><a href="https://www.acwing.com/problem/content/3256/">[AcWing3253. 游戏]</a></h1><p>有 <code>n</code> 个小朋友围成一圈玩游戏，小朋友从 <code>1</code> 至 <code>n</code> 编号，<code>2</code> 号小朋友坐在 <code>1</code> 号小朋友的顺时针方向，<code>3</code> 号小朋友坐在 <code>2</code> 号小朋友的顺时针方向，……，<code>1</code> 号小朋友坐在 <code>n</code> 号小朋友的顺时针方向。</p><p>游戏开始，从 <code>1</code> 号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加 <code>1</code>。</p><p>若一个小朋友报的数为 <code>k</code> 的倍数或其末位数（即数的个位）为 <code>k</code>，则该小朋友被淘汰出局，不再参加以后的报数。</p><p>当游戏中只剩下一个小朋友时，该小朋友获胜。</p><p>例如，当 <code>n=5, k=2</code> 时：</p><ul><li><code>1</code> 号小朋友报数 <code>1</code>；</li><li><code>2</code> 号小朋友报数 <code>2</code> 淘汰；</li><li><code>3</code> 号小朋友报数 <code>3</code>；</li><li><code>4</code> 号小朋友报数 <code>4</code> 淘汰；</li><li><code>5</code> 号小朋友报数 <code>5</code>；</li><li><code>1</code> 号小朋友报数 <code>6</code> 淘汰；</li><li><code>3</code> 号小朋友报数 <code>7</code>；</li><li><code>5</code> 号小朋友报数 <code>8</code> 淘汰；</li><li><code>3</code> 号小朋友获胜。</li></ul><p>给定 <code>n</code> 和 <code>k</code>，请问最后获胜的小朋友编号为多少？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一行，包括两个整数 <code>n</code> 和 <code>k</code>，意义如题目所述。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行，包含一个整数，表示获胜的小朋友编号。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于所有评测用例，<code>1 ≤ n ≤ 1000</code>，<code>1 ≤ k ≤ 9</code>。</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 2<br></code></pre></td></tr></table></figure><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">7 3<br></code></pre></td></tr></table></figure><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">4<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>这是经典的<code>约瑟夫问题</code>。采用数组模拟，但要注意：没有环，但是怎么实现环的效果呢？<br><code>采用重新入队的方式</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, k;<br>    <br>    <span class="hljs-comment">// n个小朋友，幸运数字k</span><br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-comment">// 小朋友排队等待枪毙</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) q[++tt] = i;<br>    <br>    <span class="hljs-comment">// 编号</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// n个小朋友枪毙 n - 1 个,枪毙的号码是幸运数字的k的倍数或末尾数为k，剩下一个</span><br>    <span class="hljs-comment">// 以小朋友剩下个数为循环跳出条件 tt - hh = 0的情况代表队列还有一个小朋友</span><br>    <span class="hljs-comment">// 可以看成 hh = 0, tt = 0 初始条件，队列中仅有一个元素</span><br>    <span class="hljs-comment">// 写成 tt - hh 也可以。循环条件为：tt - hh &gt; 0</span><br>    <span class="hljs-comment">// 或者：已知 hh &lt;= tt，循环条件为：队列不为空则一直...</span><br>    <span class="hljs-comment">// 那么: hh == tt，代表队列长度为1，hh &lt; tt 队列长度大于1则一直...</span><br>    <span class="hljs-keyword">while</span>(tt - hh &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 如果当前编号的小朋友不该枪毙</span><br>        <span class="hljs-keyword">if</span>(j % k &amp;&amp; j % <span class="hljs-number">10</span> != k)&#123;<br>            <span class="hljs-comment">// 重新排队</span><br>            q[++tt] = q[hh];<br>            ++hh;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ++hh; <span class="hljs-comment">// 该枪毙就枪毙</span><br>        &#125;<br>        j++;<br>    &#125;<br>    <span class="hljs-comment">// 输出剩下的唯一一个在队首的小朋友</span><br>    cout &lt;&lt; q[hh] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">游戏（约瑟夫）</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="队列" scheme="https://blog.phbeats.cn/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>第十三周总结(6/24 - 6/30)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/d5f2e2961333/"/>
    <id>https://blog.phbeats.cn/posts/d5f2e2961333/</id>
    <published>2024-06-26T10:40:59.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="09f894fe7ec59ac6645c91ea07b7a111a7a3798f069806cdac791ec924e6c7a9">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08140bf1b865a9bb93d44a17eb956a683bb8b5bd30e57ee3a4cc89c4a5728505ffc646f33f78a2bc0245e60f7b2c80a47000fbf0a2fef7cd843b851041c54b3d9a0ed35e4abc888a7693654c9a78fc8d65caa651593b2ed8f6668429cde5394266dc4987c4d4da136c446db5babc754301104691ca2447db7b170bec4ca925b9ed716081a4327be6c230823f8f586bd9f0051587645bdb8d8e2161b940ef0ffeaa416e09c6c86d0344a605665336d48a68fcbe82175e5b7b9f569ccc95e8884d87e34ee47ed82180612bd4046015bdb7cb8dfa9f2fb4ea8b313ab3edf1ba4843abbd14d7eb86940a153e86eeec225af50b4630c9138f2a63ce2bec40a8e7caf6be409d60752221b6ae2bc205d081d4a8d3a7bb127ee89b7004f30dce9b66e4beb44e817eb2716a5b71ab6509213225c215906272774dc36363997e7e6a493cd4319a2004d76b7fb082d613f841494c8512cee586c05f9b9eae91adcfcb43375dc3abc9fa4bb0340e6b4e29911b3b510b4463e57bf938d8203b47549a3d9c571a1767719a8ccf294216f952806f0e85c069f5ed7ba87f7d093aff00c254747167f40a4aa498c6e1ac0a5e3248d74352d23a18aac0da098635a081842d8bf634cf629cec3f5cafbcf78d915bd18ef2a7ecbbe55d6d2149cdc0747aa58a9f0baa1fe6b7294f47840f4770a08db905e0f0027561ed7cfcc3f0d0eacaa5607dfc26fd7d2765a9b21d7c615aea9c49a7d16072a504815cc35b012509818c33c68d34cdd708553b9c5c0ef9d9317104a89537f1b757cd491e0867d8ab33a8b08b3b3cb76b70661da9c47e7a4a84445584300d95baf1c23a1da840d0a8a843e2950207e2e3fce87a15c71117d36d663f15f5355133505decd493a28c588f1dee18145fa3434752ec73da7d23f7d9b2fac38a889f938f2d4c90e1626b39e53225f221313839c565368bc988153637a100f751dfcb7791723bce5642bd7437762861a05549cef7a737ebdbce5ff2e4db9be3cadb293a42155aeb0ff5fb6ae20230012fb703a302092f88d4e295200d3baf4a026394a75973e8f84f6ef1ad09ef2c128e6a7114304fdda1f4d3ec7e39377b0a1c8b28553ea76e34437b70d3ca8579002486f725e427364021c6622e99e53716ca11520fee474e65ee163706f353d3e37785627418908ab14eb28de56b42ce3cdd0e330d1aa1f4a954c8cd23a35813dbe6479185ade435557c3a82d957c774c944daf300f5c118c3f99cb916ad2440bf22ea76b2e50521c81b6b6c488d3cc99475c9de363d90ab149fa12fb52026de0eda3d9ffeb7b99721d025fe768e85b4947dfb230c44724accbea69c9cff1af6c6ef28e68fd9c74a63402c23ed84a0e05f857f1f18ff3d9cfd6dad6f13eba54063300ee7200247efce1098b643cc6852d2c1b2f36c4f533a48eb9715a451e953e04cdbe04b77972c36c25f3874f95a402566ff6a9dcc0ef273b547adf98ff43df1f2879b4b3ef410577b9f8eefcbf88bcafb41a9d973f227539218af1534b9b7057971dec016f5c2581903c6f4e420db6a2a0f281bcb76450b0dc975301b6750161dda64a78e6d7ef05bcb5de4a12a059bf3fdc443f054ce4c61928f86e42bad1372bf67a309eb82341114b17ad040ea5b5eeea066cd</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十三周总结(6/24 - 6/30)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口内求最大值和最小值</title>
    <link href="https://blog.phbeats.cn/posts/37333600838e/"/>
    <id>https://blog.phbeats.cn/posts/37333600838e/</id>
    <published>2024-06-17T03:13:21.000Z</published>
    <updated>2024-07-28T13:59:58.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-154-滑动窗口内求最大值和最小值"><a href="#AcWing-154-滑动窗口内求最大值和最小值" class="headerlink" title="[AcWing. 154. 滑动窗口内求最大值和最小值]"></a><a href="https://www.acwing.com/problem/content/156/">[AcWing. 154. 滑动窗口内求最大值和最小值]</a></h1><p>给定一个大小为 <code>n &lt; 10^6</code> 的数组。</p><p>有一个大小为 <code>k</code> 的滑动窗口，它从数组的最左边移动到最右边。</p><p>你只能在窗口中看到 <code>k</code> 个数字。</p><p>每次滑动窗口向右移动一个位置。</p><p>以下是一个例子：</p><p>该数组为 <code>[1 3 -1 -3 5 3 6 7]</code>，<code>k</code> 为 <code>3</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">窗口位置</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th></tr></thead><tbody><tr><td style="text-align:center">[1 3 -1] -3 5 3 6 7</td><td style="text-align:center">-1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1 [3 -1 -3] 5 3 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1 3 [-1 -3 5] 3 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">1 3 -1 [-3 5 3] 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">1 3 -1 -3 [5 3 6] 7</td><td style="text-align:center">3</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">1 3 -1 -3 5 [3 6 7]</td><td style="text-align:center">3</td><td style="text-align:center">7</td></tr></tbody></table></div><p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含两行。</p><p>第一行包含两个整数 <code>n</code> 和 <code>k</code>，分别代表数组长度和滑动窗口的长度。</p><p>第二行有 <code>n</code> 个整数，代表数组的具体数值。</p><p>同行数据之间用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出包含两个。</p><p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p><p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">8 3<br>1 3 -1 -3 5 3 6 7<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1 -3 -3 -3 3 3</span><br>3 3 5 5 6 7<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>滑动窗口，每次滑动一个单位，<code>窗口内求最大最小值</code>。</p><p>借图：</p><p><img src="https://cdn.acwing.com/media/article/image/2022/03/05/55289_0923cf569c-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.PNG" alt="滑动窗口"></p><p><code>题外话</code>：在一个从小到大排列的数列中，若左边的数比右边的数大，就称作逆序数啊，如：1，3，5，4，6 中，5就是逆序数啊，看看5在题目中有没有用，若是没有用，那该题就有单调性。</p><ol><li><p>使用双端单调队列：利用双端单调队列来高效维护滑动窗口的最小值和最大值。</p></li><li><p>维护窗口边界：在每次滑动时，检查队列头部的元素是否已经滑出窗口范围，如果是则移除。</p></li><li><p>保持单调性：<br>对于最小值，保持队列单调递增，移除队列中比当前元素大的元素。<br>对于最大值，保持队列单调递减，移除队列中比当前元素小的元素。<br>插入新元素：将当前元素的索引插入队列。</p></li><li><p>输出结果：当窗口大小达到要求时，队首元素即为当前窗口的最小值或最大值。</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-comment">// 数组和双端单调队列</span><br><span class="hljs-type">int</span> a[N], q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 数组元素个数和滑动窗口的长度</span><br><span class="hljs-type">int</span> n, k;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br><br>    <span class="hljs-comment">// 输入元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br><br>    <span class="hljs-comment">// 求滑动窗口的最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 维护窗口，i - k + 1 是窗口的左边界</span><br>        <span class="hljs-comment">// 如果队首元素的索引已经小于当前窗口的左边界</span><br>        <span class="hljs-comment">// 说明该元素已经滑出窗口，需要将队首指针 hh 向后移动以排除这个元素</span><br>        <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) ++hh;<br>        <br>        <span class="hljs-comment">// 保持队列单调递增，排除不可能的最小值</span><br>        <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) --tt;<br>        <br>        <span class="hljs-comment">// 当前元素入队</span><br>        q[++tt] = i;<br><br>        <span class="hljs-comment">// 输出当前窗口的最小值</span><br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= k) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 重置队列指针</span><br>    hh = <span class="hljs-number">0</span>;<br>    tt = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">// 求滑动窗口的最大值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 维护窗口，i - k + 1 是窗口的左边界</span><br>        <span class="hljs-comment">// 如果队首元素的索引已经小于当前窗口的左边界</span><br>        <span class="hljs-comment">// 说明该元素已经滑出窗口，需要将队首指针 hh 向后移动以排除这个元素</span><br>        <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) ++hh;<br><br>        <span class="hljs-comment">// 保持队列单调递减，排除不可能的最大值</span><br>        <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) --tt;<br><br>        <span class="hljs-comment">// 当前元素入队</span><br>        q[++tt] = i;<br><br>        <span class="hljs-comment">// 输出当前窗口的最大值</span><br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt;= k) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">滑动窗口内求最大值和最小值</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="单调队列" scheme="https://blog.phbeats.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>第十二周总结(6/17 - 6/23)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/a2f37b955b1d/"/>
    <id>https://blog.phbeats.cn/posts/a2f37b955b1d/</id>
    <published>2024-06-16T09:37:30.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ad25a5db3d4c415dbd1b34b8825422846845a22dbb31a514a09e779f110114ef">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08146a9702094cd1a87e411844db555d73d0d99577c1ad9192add1e11493d1c76a7191b633bdc9d9aa5df18e842899784479f8bba74239f5d00921a78e4546707d54def317dd8679f14d5bdf60d3e0bc4ba8cab6453e59c2ebcded5b7ccbd6c117516ff3bf706e19766ce97c4e694461b07d7451a1129e843298860d835d7916d23eccbbad19246234795e44a96eb8e78c9fdc24c03b3052438c34253c3e71064ea8e3ec5d6fa13c84e18496b5ec1e1781b5aa61e9343dc5dc5fa6d4a2164cdc753410f081a5adc3b345c142d25ccf6063800728650b787c54ad0b2df2ac185480f1bfb7125ad8ad7140a5b126a085450379c2f7cb7bb9ebdb91e73cbc514e31bf6e11df2be3b92bd99a29e9145a76ed8e4ea91558c2864bb0a0cb85ead8ec7ceaa1324888d9706276eba597567083868431124639f7daefc373cd48e57eb5c48d373cf081c9ccbfbea848760f4386ecb581fc34aee73a613765befb1187e8f68b103f8720e98b4e6ae3c02de4b49cc8de65547b88daf197dcd76e9fff56e0afd7bad82f68bc02047d1c59068dc2c914d8c05848516da156315099fcdac6a37e5d12e257d43e3ec518743a62a03a516f863d07225e9311edde5f681542e96d709e915b1ac43752c1169dc6da36ed5908ec0e7810383a82d3b8fb80ca74f40e1fcc065de3dd09a4125019897fbfb40279c3bab43a56ab2e861a3a56a2db24b7695af338e08f49a539838d8b9117bc7159e1018ca6ccb5b24c9042e67aa4cc40f352f805bd4f77dfcb45ec693bc895fbc0169eeed7aadf3debd6991f5d5ce798ad253c8380697288c3cb31cc6e80bb3a2b52f8811cd0408840a6b9a5bb4c774f4aee25f4fc0814401afb664efc2dee616ce63ec99a5c455322ae2cf159af06386fd4614d94511b2d252058c8003bcf4e157aa45f5bc4f20178b2285c7d70c5f199231e9e6ba4734662412308dbf2e50e2e36bb63b4ef05c31b79a78d94598e44339c609da9cc0ee0f33821e25b48d73c381e2c46ef645b18c90fd71400d25bf160244da0ff038ea010fa0240edb573a773efaa86b407dea9c5dd1f122389cceb5ac7f0e1422281a5dfabbde836609ba4a407a7bed81f72e7f7fae331082f94043f5264f71b45d14c0c78f8adb6bcbb4d2cf0df42c4a8ca5fe165af913608b6df4bd92996d9f9ea0ee115ddc2b9e96744f8745537337d1978749ce2d9b9fafab574a4f121cdaea092140ac70af03466c15cebcbef12c61e0bc54f870ecd82eea28e904f329c9fdeec726f2d9b0b3d90b136879513b32db196a2333001826d196d065f16a010335d87e8f252e4f41418b66a1f492c2c81512d0778ef2ffbdaaa90897c07a4516b85b9d4ced8a14d6e40d91b4ffdf123762f86e1b22e8d0aff63deba99cc303ec1225d8bcfcfcaf1574d33167f273216f203541de0e9805e9bba5609ccdfe314720bd8c4815a4ecab64157eaa9d5926a3030151fd8a5e3f8af2e37b5481789ec41c9eb84b1d20a8f310f2c7e30f7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十二周总结(6/17 - 6/23)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://blog.phbeats.cn/posts/3be02f72e427/"/>
    <id>https://blog.phbeats.cn/posts/3be02f72e427/</id>
    <published>2024-06-11T12:19:11.000Z</published>
    <updated>2024-07-28T13:59:58.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-20-用两个栈实现队列"><a href="#AcWing-20-用两个栈实现队列" class="headerlink" title="[AcWing. 20. 用两个栈实现队列]"></a><a href="https://www.acwing.com/problem/content/36/">[AcWing. 20. 用两个栈实现队列]</a></h1><p>请用栈实现一个队列，支持如下四种操作：</p><ul><li>push(x) – 将元素x插到队尾；</li><li>pop() – 将队首的元素弹出，并返回该元素；</li><li>peek() – 返回队首元素；</li><li>empty() – 返回队列是否为空；</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用栈的标准操作：<code>push to top</code>，<code>peek/pop from top</code>, <code>size</code> 和 <code>is empty</code>；</li><li>如果你选择的编程语言没有栈的标准库，你可以使用list或者deque等模拟栈的操作；</li><li>输入数据保证合法，例如，在队列为空时，不会进行<code>pop</code>或者<code>peek</code>等操作；</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>每组数据操作命令数量 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyQueue queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyQueue</span>();<br><br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>queue.<span class="hljs-built_in">peek</span>();  <span class="hljs-comment">// returns 1</span><br>queue.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// returns 1</span><br>queue.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// returns false</span><br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2024/06/11/66684222ae1fc.png" alt="image-20240611202459520"></p><p><img src="https://bu.dusays.com/2024/06/11/666842358a6bf.png" alt="image-20240611202525947"></p><p>借助辅助栈，可以让<code>主栈只剩下一个元素</code>，然后拿一个变量保存它后执行<code>pop</code>或者<code>peek</code>逻辑返回它。</p><p>过程中，拿变量保存它之后，需要<code>将辅助栈中的元素们回到主栈中</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> stk[<span class="hljs-number">100010</span>];<br>    <span class="hljs-type">int</span> tmp_stk[<span class="hljs-number">100010</span>];<br>    <span class="hljs-type">int</span> tt;<br>    <span class="hljs-type">int</span> tmp_tt;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br>        tt = <span class="hljs-number">0</span>;<br>        tmp_tt = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 0不用，直接用1</span><br>        stk[++ tt] = x;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// stk只留下1个，其它全部移到辅助栈tmp_stk里去</span><br>        <span class="hljs-keyword">while</span>(tt &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// tmp_stk入栈，stk出栈</span><br>            tmp_stk[++ tmp_tt] = stk[tt --];<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> k = stk[tt --];<br>        <br>        <span class="hljs-comment">// 移回去</span><br>        <span class="hljs-keyword">while</span>(tmp_tt)&#123;<br>            stk[++ tt] = tmp_stk[tmp_tt --];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// stk只留下1个，其它全部移到辅助栈tmp_stk里去</span><br>        <span class="hljs-keyword">while</span>(tt &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// tmp_stk入栈，stk出栈</span><br>            tmp_stk[++ tmp_tt] = stk[tt --];<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> k = stk[tt];<br>        <br>        <span class="hljs-comment">// 移回去</span><br>        <span class="hljs-keyword">while</span>(tmp_tt)&#123;<br>            stk[++ tt] = tmp_stk[tmp_tt --];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !tt;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * bool param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">用两个栈实现队列</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="栈" scheme="https://blog.phbeats.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>第十一周总结(6/10 - 6/16)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/9289cdf65c7c/"/>
    <id>https://blog.phbeats.cn/posts/9289cdf65c7c/</id>
    <published>2024-06-09T14:44:21.000Z</published>
    <updated>2024-07-28T13:59:58.386Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="26acdd6576cffb00f722a00e85d9401b49488f76c3ebac4cf745830086eec53a">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b08147449db493c1f9e603c98a3b5133ce4de802616652d3f205977b31755f193b35ba184f76bc90f80929641f24f6b91e895a765e7d8e4403777988edcec349e04f5571adcf038631137f1f40ff2c1a607071c06052e689aa7fd460c4bf34e06596844db7515db5bd8181668fa6d121bc8800e28aea4c193c09ed8b1d37d89d434178db3f51f67da77b3d69bf02f3a8306fe7a9ff4c1d538c162f56c034c9d5d1dd4c0daba590d9ff30aefa71d02cb4fc38c78b11bf8258fa0730330b547fd5c49dc16e4e0aeccbe1717e50bd63b126b45422fafc40ec9ee96dea81017a543a48baa2244a0bbcdbf09df392328fd9d051ae9e65a479e696875ca13d7b64613b589bfd9efb1d533527efcdc2032746ad305240093b86ccb0c3a74d57ac096ae1b830549d7e0f8e913b331df1e479667022bb2a28a03d7a384f525f0a5083102d6dd3e418d59d1b7edbc0122c4cbcc25bcc053c39058cf2af4e6f813adb027378e46a0deab289cddf2b756a99ec43b6082df3182e3fd92ad4de202a4791cf714ed4b96c2f3763ceb5661fb71a63cc73af4e2bd089ed2e6980311f613354be4961b2ccaff9949b12c8a67368d05b107b8e15256431d561d233d51cd58ddbcb16ed1cf7be6253cca030d4ddd0da13485121a65391f34a9716bd417fed2dadf723d2ba9f7045890679eb1d4bc56626cc7722fa0f1833e001364f1870f111390e6701a639509b7c55883f5e2cf7f63f0c0f27f5b5c7ace70f638b27481dfdf971688162990a1f7c81c70701c04797bffbb9dfd1ceec871f8dfbd71d8cebc394edbb51c04172e8c30d2e31c53d60e737faa9977f662b9272f57646d5896452dafa06c60d09f3b0ed69d56808164be825db84446638cc7851c797c40a0ef597f933110b18773442fa0c02735a7c1e3a6f9591ed975250ec8cb9f2a4eff19a4f7594542c1aa3b902532886354a506090474476c98b5710ea2dbe581e1c48a212296523b95dce1201c9854a77a7213176ab3cb4a78ea01bf628c9465b68d628733c2de4ccdae2ec5304a65112b5de905a0907a3b50e208f6935c90df08d4ae5118dce2f67e9e4d101aac6c0313624aa662049e912f905f88adbaa40fcbe8082781cc99a9b8ac221ed6679b5b7ffdb261c2b42bbb77d307bd04a9df86655d42011060cff589e5d261cb3153f7b80589ade19ae650209a20c77696bb96e1b700d701bc14ba707dc40ac281f810bf18c8309490630e9e205aa05d0f5f9a0bb633a290542a416823d0b82ada65ff48720be4d6cd7877ba9f0b04cb94f9ac542cafc35cc79615a1e265ad70daaebdf96e8ec40d1bd83a908065</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第十一周总结(6/10 - 6/16)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>直方图中最大矩形</title>
    <link href="https://blog.phbeats.cn/posts/410b68f36e34/"/>
    <id>https://blog.phbeats.cn/posts/410b68f36e34/</id>
    <published>2024-06-09T09:27:51.000Z</published>
    <updated>2024-07-28T13:59:58.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-131-直方图中最大的矩形"><a href="#AcWing-131-直方图中最大的矩形" class="headerlink" title="[AcWing]131. 直方图中最大的矩形"></a><a href="https://www.acwing.com/problem/content/description/133/">[AcWing]131. 直方图中最大的矩形</a></h1><p>直方图是由在公共基线处对齐的一系列矩形组成的多边形。</p><p>矩形具有相等的宽度，但可以具有不同的高度。</p><p>例如，图例左侧显示了由高度为 <code>2,1,4,5,1,3,3</code> 的矩形组成的直方图，矩形的宽度都为 <code>1</code>：</p><p><img src="https://cdn.acwing.com/media/article/image/2019/01/14/19_eac6c46017-2559_1.jpg" alt="2559_1.jpg"></p><p>通常，直方图用于表示离散分布，例如，文本中字符的频率。</p><p>现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。</p><p>图例右图显示了所描绘直方图的最大对齐矩形。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含几个测试用例。</p><p>每个测试用例占据一行，用以描述一个直方图，并以整数 <code>n</code> 开始，表示组成直方图的矩形数目。</p><p>然后跟随 <code>n</code> 个整数 <code>h_1，…，h_n</code>。</p><p>这些数字以从左到右的顺序表示直方图的各个矩形的高度。</p><p>每个矩形的宽度为 <code>1</code>。</p><p>同行数字用空格隔开。</p><p>当输入用例为 <code>n=0</code> 时，结束输入，且该用例不用考虑。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。</p><p>每个数据占一行。</p><p>请注意，此矩形必须在公共基线处对齐。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 &lt; n &lt; 100000</code>,<br><code>0 &lt; h_i &lt; 1000000000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">7 2 1 4 5 1 3 3<br>4 1000 1000 1000 1000<br>0<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">8<br>4000<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>对于每个矩阵，基于单调栈的算法，<code>从左往右，从右往左，可以算出各自矩阵的最近且最小的矩阵位置是多少</code>。</p><p><img src="https://bu.dusays.com/2024/06/09/6665b6961d895.png" alt="image-20240609203648376"></p><p><img src="https://bu.dusays.com/2024/06/10/666703e9110d9.png" alt="image-20240610214630320"></p><p>边界预处理在这里的作用主要是为了避免在处理第一个和最后一个矩形时出现特殊情况。具体来说，当你从左到右遍历矩形并尝试找到它们的左边界时，对于第一个矩形（i=1），如果没有额外的预处理，你就没有办法找到一个左侧比它矮的矩形来确定其左边界，因为 h[0] 不存在。同样地，当你从右到左遍历矩形并尝试找到它们的右边界时，对于最后一个矩形（i=n），如果没有额外的预处理，你也没有办法找到一个右侧比它矮的矩形来确定其右边界，因为 h[n+1] 不存在。</p><p>具体来说：</p><p>当从左到右遍历时，对于第一个柱子 h[1]，如果没有 h[0] 作为哨兵，并且 h[1] 是所有柱子中最高的，那么 l[1] 将不会被正确设置（因为没有比它矮的柱子在左侧）。但是，由于我们设置了 h[0] = -1（一个比所有实际柱子都小的值），l[1] 就会被正确地设置为 0（或者说，没有柱子在 h[1] 的左侧）。<br>当从右到左遍历时，对于最后一个柱子 h[n]，如果没有 h[n+1] 作为哨兵，并且 h[n] 是所有柱子中最高的，那么 r[n] 将不会被正确设置（因为没有比它矮的柱子在右侧）。但是，由于我们设置了 h[n+1] = -1，r[n] 就会被正确地设置为 n+1（或者说，没有柱子在 h[n] 的右侧）。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 爆int</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-comment">// h装每个矩形的高，l装每个矩形的左边界，r装每个矩形的右边界</span><br><span class="hljs-comment">// q是双端单调队列</span><br><span class="hljs-type">int</span> h[N], l[N], r[N], q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    <br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n, n)&#123;<br>        <span class="hljs-comment">// 输入每个矩形的高</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; h[i];<br>        <br>        <span class="hljs-comment">// 让h[0]和h[n + 1]值为 -1，这样就不用处理边界问题了（什么边界问题？）</span><br>        h[<span class="hljs-number">0</span>] = h[n + <span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br>        q[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 开始维护单调队列，从左往右</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-comment">// 维护</span><br>            <span class="hljs-keyword">while</span>(tt &amp;&amp; h[i] &lt;= h[q[tt]]) tt--;<br>            <span class="hljs-comment">// 左边界</span><br>            l[i] = q[tt];<br>            q[++tt] = i;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 准备维护单调队列，从右往左</span><br>        tt = <span class="hljs-number">0</span>;<br>        q[<span class="hljs-number">0</span>] = n + <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i ; i--)&#123;<br>            <span class="hljs-comment">// 维护</span><br>            <span class="hljs-keyword">while</span>(tt &amp;&amp; h[i] &lt;= h[q[tt]]) tt--;<br>            <span class="hljs-comment">// 右边界</span><br>            r[i] = q[tt];<br>            q[++tt] = i;<br>        &#125;<br>        <br>        ll res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, (ll)h[i] * (r[i] - l[i] - <span class="hljs-number">1</span>));<br>        &#125;<br>        <br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">直方图中最大矩形</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="单调队列" scheme="https://blog.phbeats.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="单调栈" scheme="https://blog.phbeats.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
</feed>
