<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phbeats-Blog</title>
  
  <subtitle>记录学习历程和生活感悟</subtitle>
  <link href="https://blog.phbeats.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.phbeats.cn/"/>
  <updated>2024-04-07T14:31:17.306Z</updated>
  <id>https://blog.phbeats.cn/</id>
  
  <author>
    <name>Phbeats</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[AcWing]3765. 表达式树</title>
    <link href="https://blog.phbeats.cn/posts/4d1178f3e0bb/"/>
    <id>https://blog.phbeats.cn/posts/4d1178f3e0bb/</id>
    <published>2024-04-04T11:41:18.000Z</published>
    <updated>2024-04-07T14:31:17.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3765-表达式树"><a href="#AcWing-3765-表达式树" class="headerlink" title="[AcWing]3765. 表达式树"></a><a href="https://www.acwing.com/problem/content/3768/">[AcWing]3765. 表达式树</a></h1><p>请设计一个算法，将给定的表达式树(二叉树)转换为等价的中缀表达式(通过括号反映操作符的计算次序)并输出。</p><p>例如，当下列两棵表达式树作为算法的输入时：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c3f2bab7.png" alt="QQ截图20210708095213.png"></p><p>输出的等价中缀表达式分别为 <code>(a+b)*(c*(-d))</code> 和 <code>(a*b)+(-(c-d))</code>。</p><p><strong>注意</strong>：</p><ul><li>树中至少包含一个运算符。</li><li>当运算符是负号时，左儿子为空，右儿子为需要取反的表达式。</li><li>树中所有叶节点的值均为非负整数。</li></ul><h4 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">输入：二叉树[+, <span class="hljs-number">12</span>, *, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]如下图所示：<br>    +<br>   / \<br>  <span class="hljs-number">12</span>  *<br>     / \<br>    <span class="hljs-number">6</span>   <span class="hljs-number">4</span><br><br>输出：<span class="hljs-number">12</span>+(<span class="hljs-number">6</span>*<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>给定二叉树的非空结点数量保证不超过 <code>1000</code>。</p><p>给定二叉树保证能够转化为合法的中缀表达式。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>很容易想到这是基于树的<code>中序遍历</code>的算法，难点在于加括号的时机。</p><p>通过观察发现，除了根节点，每棵子树都一直在重复做的事情：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c45e6e6b.png" alt="image-20240404195438756"></p><p>那么就会有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">ans += <span class="hljs-string">&quot;(&quot;</span>;<br><span class="hljs-built_in">dfs</span>(root -&gt; left);<br>ans += root -&gt; val;<br><span class="hljs-built_in">dfs</span>(root -&gt; right);<br>ans += <span class="hljs-string">&quot;)&quot;</span>;<br></code></pre></td></tr></table></figure><p>在中序遍历之前需要加上括号。</p><p>可是，有特殊情况：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c5cd7fef.png" alt="image-20240404201019068"></p><p>那么就需要特殊处理。</p><p>当碰到叶子结点的时候就不需要加括号了，直接输出结点值就行。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     string val；</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string ans;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 遇到叶子结点</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;<br>            ans += root -&gt; val;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 非叶子结点</span><br>            ans += <span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>            ans += root -&gt; val;<br>            <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>            ans += <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">expressionTree</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理根节点的特殊情况，直接处理左右子树</span><br>        <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>        ans += root -&gt; val;<br>        <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3765. 表达式树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>第一周总结(4/1 - 4/7)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/216a02683518/"/>
    <id>https://blog.phbeats.cn/posts/216a02683518/</id>
    <published>2024-04-01T13:19:14.000Z</published>
    <updated>2024-04-07T14:31:17.302Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="337146a722e28ed6afe67aba183c8b0160991c22a05c46188abd0cd404e35175">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814870b88c966fecb0cc2e967028af3411eee7300cb80bbf274f423dd19658f7505c530642711d548c2dc40e28f93eae2df7482b8d7f287346b0700bc0a6340105e6ea3aede3f037af485f18b8b3bed1367387e302de213c7661d9311e5de8feb9732ca67c4573b20edc8ef5bc3525464e85c21b047d751374412e1463cf3a1916e8dc86e753f6a76827c450ce814391ede13b13708368897ddf751d3ad12d75ab7133e419f45a4daba29d4481590da59f287b85f357d28fca03170453ea227274644608fd462f2583ae33283f8743e5b57ebae9650ba1c2c522a73c49277e7f818b4431fbe5ff793fea52c249e7afcef85a308419edb0fefad03f15809f45519fe8c7a8708c35d74100c7086b7ad28972b1e75ca4016ebebf8ddae22c333e262e490409525fb7934949c1986f5bf59394f88d55a073260d2e9b32bad061280a3c3f7547da3daf47cc63cb300bee14abb49bcd0f7bd1f45058ce82fd0046ac77c135f286d65eaf6d5ed12ed7924e83ad033f13b2385c6fb254d67f5bb56f986d6920740ed912071ee156e64bdc2b418fe3a02f1d35744e03b1643bac3e1f27329e2b2c087e123e026353bf929e9e6606b5f7dbf9dac23db4275a990b4f63f422a32d1c82c115b6f038cf05bdb7d0b63e1af02405c17e5b5afcbdcbe549229ee0dfd451cf3a4da25d9f9b857eab388167c95d0396598c5e8da793e6889421792e10ee2a97328e78910dc679a18fd4ee0caca158b028754a4a0eae729875bffa3313f6f74dc7f3ac84d2dd6a1dddeadd6254eff498178e35afc40bbb0ed400aba75744d10837c389dfbb2313239650c73edaa70eb81b48c2929d57e7cb58888ee62da4a49d54745011b231d6913f20f4b4aad9755bc5ffe1322783604e37930b4125a7b12d0a397946f687a57cbee171764684ea69c1d0f7f1ac89d2929449466af2c2a90ee603de2c8547af4249ce635ce40ab3f9a509e5ca2cdfbabfb6f486f17f5033203745892373a04bb569a30b14e2d4bd5d5cbe2d53bd24edd801a51b06bbd28189e8c41ef9b2ec399a8fab257c23bbe98ec4d70f688b1d59c40eb229ac8aaeabdd02733ae8e083a1ff7b1dc9e58dbb4d9dcca755c95b39d01e057f06e24faabcb8fed7ab3758adc9013dfb9c1c8b9a4f28fae3dca392cfd84f7eb96a2d5849295e77c2d2f5b0a042d88dbb9db9e1d9d6376f8fe4775e1feb304dc9cd17672d9b90660b3936554039277744e40d248b436296ee908fecc9a2399d97e31d0318488deb60437a0ac1f1cf87d716c2df7fb79138188ea830dc4190da8139ef770a591f99bb8c4101872f9cb49de48b7470d64e17509d117a02420badf97e2a6785abb3433ebe1516912c02bc897956f2bf9a582534892ff7ad14bc4b8a936f36a60bd0f3cbf29118f4354127c00d1a1e9112f1e062551e3adcea9cb59e17349194e2f6a5467260be116b37a19ff20fddd3488f3231ef37859c69eddef5444225941eca15cce22dfd117a18d4cfa0d916584169a7602ce347edda5a803d76c2cb9ff7ff9b407a6c89d04227d896dd0694e676540ffc43d99606c194bc843c3283205f188834040d1b8f67f118fc7a53fbd1a92d62af6de5725cf3cca1942a2233e595be09e68d43afe709f1ac6c4c782c27f1c338f8cb1d91e354986a867def22dbd2cb6cf362609fabc464e6210a579abeccad63874985184b19ef62703957ab2eb0f20957c6bf1d489b0d2e0b2704bd958c46606e0beb0279cb9c571225a46bd7c1504e878f1822224e394362546d8fdd8ee76f68bd7e75c37ec7e488e25919244030f7cdf67f7bbcb40c6f2828e1967bf9b125d403619a3887af06751dcb3f1860425db9eaad334b330d2cf3674cb7e0e791d50f2e019a7484321be621f9add7aea8c74a90d81405771b067764f85cf874647a419b4957e3411ba824fe80be6fac4591b2ff31d6089edcc32c16d9d682255cf8026a5c3b4d97668b2411ea145e1ba346e8bc442895fb218a970da23c87fed093c33131d21600aca663bdf2f5e95620b857aa13d9d110bd76ed824f3b74d96a495568ff6fbd97d9938656f7b1b99ca3e1f764d228cb603b1ddb83de65353a13b51a118e0cdfbabcba5845577af9d7ff5919b4677afcc898aede7d585f616688a671b594af7afad2918e3b08df08ff2add06b3a23bcd6a7460a49d591905f3ac6dc609c749293025a2aeb20b06757667e2abfc8146cde114763f43c4287c495a4246f48a50c0853ab049bece83cdaed9e536ebb76ae18afb400ab539ad95a81f89f56092e19e9bc77a0bb9fdabf2ec2e949d40d6774deab16cd1ba93293993d4b73e8d4d53ffa347040ba62af15621da3b26f0949e5630e8f7eb58983e681f8774bea20f17e85e6870dd1a16227babe00ae8dc9a6fa4e03ebb07d4affd666b1eae87c79707445102ce2a5f631be9a634ebd95d8fda953feb569fbac61dc05e0fbf54a3624a390170fca78a148a9d01ad3fc3a743e2f4ea1173a9f28b3db4752690517f78e99bf2ac444d10ae0e71f9ec54bf9bce0a5654d0770dcf81f7175e9a7f1d8e9fdf5ba9fefe32f83aa8eaebf056061011b26b59a0e5d6437cae171f8c9febcd1ab79ebcb77329f0689ece6f4c87aba14548466c1f44b6afffa34e94bb1c30fdb7121937840b23ac0e42c2d1ee867821e1a5de98875b60e16b28aad7912e5e088b12ebf6e6c4c3a9d074dc4f3bf96ac79979051a514bd266b7fe07d050380d82d7d0c4355254dbd2569144e8629ac7fe6913db449d28af15846ebfad03b923edb4ec6adcd925f333cbb5a1a42f258e19e0f1f9c0377d75b469daaef5e7e368698aaa0bf5f27711a78684a8b51be1485fb48fbc5bae67682562d43f85dfc56d19e3dd96c926f19a7ab4c5d963b37f1af5bc0d4bce17c09125c6fd6d1336aaed5f02acd1c4b6b5d5dde44f3d01bf806b473661368664fb054cfae7b1552194c3c2335209b5857ff0fe4e8c77e0b655e4fad1b15b0234ddf4a11907af50dd17d7ef9a02e0607bf3c033ca34cc28be0eb849cfb64342ac0728c61562194506803a3082371253e304f4f00da52fb8d1105b13092e9261108446f9ec1f35fa43b49fa138ddc7ad8a3280aa499c9f61c572f8826392061bbc4372174fb6d6f2f6f77adf947fe27634bfa5f16562b78b0bb958f145ef012131f41bba37c1fecda639ccabaf074e890c8c1e6263fae5ae453783fecc511a4f170887fb48ca0eaf3e75205d868a3c788629b8b6000740d98f67a7aa0b550826c06430afbbd6f35877367d3e74ce95397ff6ddf1ed65cee771d9b22a2fe17f97e00fb9d4279657d01cc33cc1331c6c001777cc7892b855d3b14003e1e9df3c65d491ea8c4b58956b2d3b0f4cb6315a3c0cef2a83cbf81c3eb3e5c1ed8a02addbb74d337d9fa40387cdd215e342591eee13c8689e265c38d73c9039bd6267a06fcf8867f038780eb53a04ff743e8433c47f3e4178d2baa5f884e32d0475643e311c08056e820169305c52304db20ee34a1f41d8a8e1edead8eddceef5bf8fc1fb6f850c62605749c32d428925839cbd398b183cf22cf0bea285b8bcc524b2aee6c5c9daca2e82fc306accdbb8bd41c2c9e3841a99b7fda56ca282cb7863df41153c95d55e19dcc9397681945bf44d34809b8a10ad5f4a956758847b26453558ba1503e180be88c70adc465690d3fc9268db6f324cceef38a4e4de46fadcd687680956171035015b5283adfbc70563eb42fc38317ed2f588c56f39ee21bc2c54b3188cbd4cdb12e3cc59995d2677353ff823b1f3319f232e740c3de89f0cafc44e62b48865154184cb9a8caff8966363574771bc5fab949a82afcc066ea464ed8d95e0ed4449f4ec5f73512d55957f046354567785c240087fcba0190b06bb68a7fa344d38e06604a4124c84cd0cfd61548b8d8d0c82c168e6fb95de70c1f1d1d7872d4d5283672158fd76f41306e031dc5823bbbd652c9ed255265bf042d38e9c0518aceacfd654a5e3253cf7d10d03081bcd480f240efebe46c2c6b30b6874e8e26b56ef46b3b50aacf9f85cb0f86a7eec0c1623c30eaab4d94e1fe050d5586851ca1a19cd824210968740e215792ee0b27877b11e0603d1116eaf4fe4dad1be2a159d8c87e8fd6dd38aad9dbd554536898f40b8db20434d45933a60e37a1c43aa79de1bea38a78fed7b5c642a188d22e14590549da647355e1288709a282728338913fbc55eda6479dfa3086fcef818231b2637620dd96f936d4928a7c6730a3cb0100025910a80aadc0022b6d14d760287b6cd4b46f3ae84d8da4f61d0c4367f1d18d5c88ede33a89b04e2a606f01b323ace0a3e94e37f8e8860b9917bc42585045c120ec75cf0e2c2823673d4106c78378b7e4718072913459a0054758249864021562783fa6417d0b640521ebb7436126fa3a97e6c2ef8e04ae3b25e408a98a4ced2c9c0cd6dad172906d2346cf176c0e5611d76f00dd4a71c6fce52e0c4304197d8385bd1888e41dda08d69100076b4a2681e000a742d0c0957780627e960dc40f3e2ba6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第一周总结(4/1 - 4/7)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>美好的每一天～不连续存在～</title>
    <link href="https://blog.phbeats.cn/posts/ca2f7778875d/"/>
    <id>https://blog.phbeats.cn/posts/ca2f7778875d/</id>
    <published>2024-03-19T14:53:45.000Z</published>
    <updated>2024-04-07T14:31:17.302Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="2f2605a4bcf628ca678776e8cb7f18e903846f26e2c49c31b58574e5e14c1923">e673c8ca06aefc9fd566f76e908c7073bf122394db4047bcd924ce9ea37328240a38cdea58412a376dfb2c4084c8672e19e7fec2a499cc6cfafe0f544c575fc22968d157ace4fc995bc36c6fc521fa9124d0e79762ed71cfa3cbcfcd4f2370559b60818db7bb6248fa9ec9043fefa6dd542fad9625b40ee414f98f8b4d4229f43045d6de6524382334aa4bed97a16c7bc05e200ebf0b391e85dd57d31d13a06bce177e062841c4bb1b41ab134bc77b3f70b96877878da8e45570bc5c4ee08c33ad15d85aee225e68d757cf0aac34fe97b285f3215fbf412a760af5f6f3691597d84ad90fda5219954d39ea8b1e3644a3240473aaf12cd8cf5aed44a9fe285f0c4207a2772aa01f08ef95291a83d3b0eabe0f6ad0e1ae7a23e6ef964e46f8eb8ed46a8e5c2ae3a3c780cc8ab09d94cf1cb6195cbc0489e14bd2f9ee4863ff555244fda4fe3a65be8fd19f23892a7fe1c8ecb04b6348ba842687d71ddd21456506718cb68994c50b19946737e56a1d0489649d5b15fe3f02639a4bfdb432b111bc7cf3593ac49ab49886c252d62d4d2f54a19cb18bd9a0b28fb89a9891b679cdd2693f8e8c129a53eb5ec1b9f2d33f2c8824f4e9cd870abe7ca2aac942d1118ee7ce0c27f79c5b3629cf0ab9219a52fa209b52ba4aad6af95aac24d6f56fd33ed14b04453498d782395ff5b2b93ba5f45a1e32398aeffeeffbd03fbabd58b079fe1d1ccb6be2dd3cb2590438d42256c6e4fb4a558a72582cc0f05253116d6b494b98bc165fe6dbae9212bc1401d0229d4e9d0ca4610c2fd6acaad1de300846d215bfc72ce50c8228081235ba8b3a3bc70bda5b380c0bdd728c3e1e9325c6699354524eeca4bf58819b11f200d98f183411dc236030cbc2404ae0d1dc99eb3d559cb6f10818f7b5939cb0ca8984afc5cfa8c0d76b10ba53898ca567f69d6ae36ff666d0ef2e4f0712c4f35f212e5169804774a618d6d703150f7fe46dce77b67aa6fbc7d211ca34476e8417e2f475dc04d18af0c4e956522b8e1d3849ae0f61c2fd586d6de11cdba44563f40ac8f5d672f433664526571bebfbbfec29cc15ce3d99732dbaf3c7c9ad582e1ccbd5fcd4f56782f6fa7ce9b27f4278168615fa9deb18c695db7a811d540163ba1ac95dc5ac6b295484b9b36db403764f9d3da60eeb897cc34a382a951861a5f332942e154c7cc6aeeab1aabbaa844492ba828f41846f7473accab0ede2ec57fe4671abcea4af076abdb200673ce23fdc53eae1badf7181490e19bfe80b61fc96eb72a44c2a5c242b17d6f9bf7d18e6b3eade8b2dba36411ec5b1b53fe6527013a26055e6debb33cc623454471bf55ea73a58e02ef1ee0bdeda0627a009a7c0793c8c601de92d8164d884df5257037c1758bd3dd7af875db2f1e0f2b6b893d1312da0617bcaca088ee3066f40deec20a2bfd0615fe7c020b49957b7e1c19f21228d0ea4805163a4263962f0a5c1808582e88aa2225d0bdf4c32eb23b9c3fe7cc62bb457820bdbcadc59808d9f4330fa3c0d162ddd17e56263512de4ae83de03c405bee19d23cf746140c286f8487c7128e47a6da914e56ccc320f2a6f0a91dc3e59ba9000afd25b8ef0b068f5e0ee2b1428217d84ca8f7ec80c306bd2101f58d26f5257ac202bb41f29f17f793dcf24cad481bf832eb526fd5fc52070193fab29bbd7598107288781f1c7f99efc66fe41c93166589380b8eafc01fea33f4e5fc4bf6b451d610ae7f428b089461b707dab20967ab009c8ee146d82304091c304950b937b023f426a83b3a571e9f1cea15dfce4d759f9a0760c1f17f3d58b56312d83a42ece10ee4fb23e47e968c1c91bcb8c0bfc13d80afc928d81860df2b4c2d7cc707e9aec836e67b9ef843c2b4798424e5511fe693f14a3c35748a1c66287d9e178bf075627b97c7667e44333bc166630720694835bd801d3c49ee4638ead95e882ddaf8bf53842dd98ae9cd6b33410d394205529ae76345eb1ebc250b400faae5095b84d0309bfd77efd0035631e16297030d82aab47d8518a26fb23a676a56d2ded1bedc745eb40fbe7c2519084ba9d00b161d027a435a8b2e2b166b3721fd54f717f7d865c69bba5619edd74326a81ae06afbd3bc0f15844c52e6a8b7eb778a229d2b6f94fda580e0168144bc1c969a95c7c9f796dcaa5530bb14fd033bc6f13329f93c489b9609cbeec967cbc90a9b144a4f7d7f694daafc18a80215528bd1acf9f507ace00a21ccad7a56493610d6f3ec8a14c64c642f759d448789b6b8e6ac67071749bb6f88379e1066d5f8130c73f52e48356e49bacfb7505408545b8f2e9660d61f3fbbe195cfb12839e6ff136d84fd09d36be050b3c8455131e877807e5217a133bdee12b39a326759227542ebc0240913fa20cc23a48f335748f863f916ea253183ced3ae84068976330e95430f8f5ca7f3dde01875c6e2ca1481356c713db8ef633fc6f875bde045431a653904d57e3b5b2b1cb519d883554515f1178b89048fb99c85f8a28d2ff84029505cf47ad3d222c3b8e474e498421f01f6dba043419411429dde8d032993cbb266a87569ee3bdc35d3194157e7f2921c5ab2993f9901cc46e126232ae15edeec2ec1acab3a727e459525131a33f5975b307b67298e5c2214e259450339a065988adc3437ecb529d7964fa0d4b94313693944406422876143f68899ccf492021406172742ff5c476f3cf288318017e1b63322b93e9299f015109c873fd54ede705160f30074720ce9db22de289a000582dd02517165477926e5d43e5f1f70b5efa9887b56ba7fe4189d0495601d62b4c4990ba00e4688f2952fbd1dc95b9b8bc736b2bd923a87f2aea9b5286667933b0b3281c4fe2408208ed1d6c089535d524c5cdb890541e4b94d674657770bc80fbbfef071a63aa1ed80947cc7e2b18832b3a87c27e56f1dc43b717a17bfd85835601ff46b236d53fe25e22bbcc8f962ef15a09b1e25b812d4ddb258de49ad22212e1148515068d64272925aacbdda388e470963a12a6c893aca328e75518810bcea52aabdceaa0be3de7ca50d3fecfccccb10e92c8c7ab5c1c363db000181075504f323b2fccab63549e22e8224551d79ee74f24a9d6f54635799712051707529f98e2527fe61e5f503f4445a3654070e6616b5ce654691761ffcc13157c9db5c2fb2e891bc370f33c39d78c7ec7f4f88c7fde41082f41995a33f7476c042baed56e1475544b3659ae9856071ec54c8af8827bbb8a9b9d9c68b6e9f7e0fca00790268499c30e2d88376a9c5940decca1f8b106326302f99131549bdf4e4abcc8a2a182aaa80adb92e12df5e205e6c143cea8be921742e711002a10a0c5baa321a2cff7f6e0c32ae216259a62ddc2593d14d39538fd99c2baa6fc31dbeafed2625e716b2ddacbc673ec2c011004f331cd023d6eea571e2a6867470c4754f344fdd733ea15460dae6f35bc169f14903327b400ff817eac220c480beed9548f00fbd36009395a9eac5589b373da906b0cef40d1bf254db51b734d16a539069940f4f04980439404880cdee2c6d7403e0316906e29abd30ee3b60402c6f83885a14b0a851b007a9401d61d1ae7e490d53244ad1d5e8349bc9243fc278a7e15f3f798bf84e5ef2d89a4eb9b45188319eb1b360e8b6ad5258017f632021356079b170dbedba062078a14861343b87f28cd4edc51035ece6c55080edd02674b0dee8bfa8719a2f77be8c533ddbaea2e9227b8851d1ea2e905d0f9b9c2fbce913fbdfd30554e65fb8f5ec3639ae3683ee38d33404517ba5bf5d2da8e20daa5536372efef1028e8eff07397055d293e2ca674fe66ab73544e11b19f3b991df5913d28c9bd046302576037d65730ef6edeadd452e82a4ed92a44549e3aa020558d1c7b66ba7cec2d35b6a31fdc797a8c5c3de4195382a35afd259aa350f87977669b09d08c2e9e88feb63713491d071bfa2f34290493b3a02bcf2053bc1489fd9130dbdc768da45473fe379e25b4a3b869bbb97aa8dead2a63632c59c466b864e547c97f2e42c663dd3c1fa5af2322a267d9b79f1403c206f247730cd13bc0db2107a5bce777f18172a43a8a4e5afc471ccb0f7439b210d51fe10381c808decbcfefc8dd9fba7fc3a039e002e2180632ea852b660448739ae3060aea1d967a7e0e7c85c64696fb3220a2e14851f32b6c78b8e0d4f50bd545d259e3fe89e2ede30adb84e1b13de133bdc53caac6b6a4aa87def8ac537c46decc9c1c6bf5cc573a7f9840b00151f46dbc5c263ead4ad3859e4a330fd11041affd849c0a43bd86af2bde514d4191ed328991bf2f78352b1b27766fc577a636dbb23f0f994f622d6f3b85a27be08157b02fc5632ae8042be936cd302bca7a1febf89d9aa14deca45efed75cd727b06395ef7fac1f2f157030ffd8dd25b563ec76780f1c79dcd06cc39ab1f8f9f6cc1fd8e6bb2cd4b1283ec441146d28757e31026b6f37c9681a45f1fa6a64dc15f6b655c90b4c61e73d7e2472094a7f02c1f1bb87cefed29c9df71a9e7f44b95e92fb11f31942837bca24723b13880e9b58a2053c5bc46fe605faa30425cb73337be798ad4ebab542a5ddc8b8067f4f3aee76d7cc814e786502647f58cd6f459546261e90eadcb2c630f654b6eefc4ba20bd68ea1430dd5c85e79dc47a1127845d81da592ac712be13c260ab47e76ceac8b44493eda126061f7f4c420799053ea944ff5ac9358adb17c5e8c8c62567269eff4e0272bd59c2e6371b907a1e7d9e15638fe04729dd6cbf8c8b6205a6e688a7fcf59c719c9cfbb7aad945fb92f1ef47415f26f3888abc4dada80cb9135d01fc6d247231ccdb5d8ff7f7288e5507b1b44e3817d8205e2e15d7bae3a32ac9df996e3c80db81a6738aae3d575788a697660b28bc338a192a8e7e1e35d02a4d0758805746d993bd67a57c540318fd175a8bdc3df6b4c78861d7b492b3147cc5fd181ecea9a07c1fc020f6678b81ace25092f4238be20a50d7a5f0fc9d25246f0afecd4ee52c0f1cfbba57b3ca3c9615cffa243e2d160706021084d42b1e46f09048f090de4f01d6e94015fbcfbc0d73045a61dc771bc770cf904443638bcdcec92fe40d644690b212375786b8758c9056a8a86cefb9b18aa25959c91208f456c7c855c60ba27e6ff1e908b3a87df9e1ab0fe1d5aee879e2cb176c96c26c247ef61e11591ab93e1b712a48f8137626cd27c67d06147e00dc543c59217d0a872867175ee61d1dbfdc0072fe5ef934d8071d5faa28f7f3e7c748a61f5897268f770953288a71d51d6ccb9a26056a9b68ab5e3431127cc8377ab9ea88cae078b0d578c7b58397134cd122bd7652b3d4029aae7396f79e3280d5b25e93673e2d83d8e8f1d972793c7830401711c9d49568b2b9cd5d52066ca0c8b9807530725d2c5f65ac4ddb8a6c9403255ca442f8a530e96c2342809617d0a06c608b45777aedb5015030773e196bdb2dd9266d742a99d029a7bd6e42a3d2984774b29323d0e8bf5670ad6bb91eb2c69df59a425b8ad08edddfd0008fb1b854873b884fb9be4ee4ad683a381959ad8d166708241e629e6ca84a71430fe9b5e4c1b85437ce54a9b91e8afd4d761c83584254060b1e5909e66da4d6bb26fbf47a40d7e435a26284cb6a128d7e224337e014719a13688457b8eef57eb9b2aa33d2c1af6ee21b1818f81ef4700f36eb17ea9cbccc15360f8fe90eb6c17373eac2305ad7f32c9ef3a6cf492abaf2ad24819ddd0aa8f5e279947651d352991a4ee647f85790f775b68b16caebd8ce08fd7a58678f9a7863a396cf241356cbf8fafce10caf417a30af11e6ceae77303b3d606758a3b45baf1fee8d6cffb21d35ac6ffecb713380c4188d3aec7fcf85b063d973cbf91729f1cc14e2a327e4a68a87434987700b7386a42bb7c8769931a3f0165bc8f6515653164fb178a397a884b661fcc81f8a60d80eb0bc9d14c001a88037130feaa6782894d08478fcaeaf70dbc5e09968ca2b539167d943e19e53123e1e9ac15d44fb083196cd9267eeb876e981e9abc4dc879ab2f8b5afd954030a21a18d497809b579de22b1fc9fee4c162e242b24d7f528f55aa9a4ae885e9ba364599b1431bda5c0bb47a8079ec6be25786f8b858c6215aae74d4ff0bf1350e2d9e999ad83652bdb5d3ba2b78bbc6c7d43253697723e823cdd24438668a1ae389ab46ccb5632a51b7cd5e9701c4f39f3a07ad64d9f2067122b8d92d1f8537a002a154ce1f9865d659297af7967a840158df05ca4752031bd64864b3190b99449f75c574aff6f877977919ec8033212a0f54238aba6bddf976a2bcb57eeeeaac3328356a0bc5d3e926b00c8b1edef2eeaf1d40d31442cfb21f35c9aa15d549b4ea2b7b22a6c591f6d43d8b38b64487b8746dec6bfc21e4682ad9bf261e7876fdc6ca9b2be31cbae666245f5b6e31072fc07793eb88d6bfdfd55f71d7fa092adf5f4ded0b63bdf5978392bb6333a07b608693a274c38219f6d864af0fc876167c2f36ab58254f047006c551c0503a0a53e8d0feb4eb9bf1dfae1db28f233f327330b3462882015300c84d2cb10f5ffe29fa5bc4cd383381d6a3c00d4b1ddb149ed68c46a34531e52b6bbc50b4be3fa6e49ec0a3f8e4277b73ebccfcf0ebc6b722a4a92d5ad11590512d734834ec17f66ba6480f47ee4e89cdec032465cebac69cc8d96ad9baac12b791e66321fe297c46e2daa0d31f5b8db3b3df7067d6b572b96b6cf2f28871f3536af1484148a0409869dbc9308865ea69a86e94a38aec7ce76b58ad9a0db325753dcc03b697f75486c4deacf0fe1c3af57f042365d9674ff81ed64c35fcc694ed67cc42a4873980cd46a615f7022305a9c7011067b019f9dd29430563d60267047dbe8a9a2936c048cf91f41797890418fa779fac477a2a94e9e86c5ac96fa56b7f695748ccadeb1a32cd8e1da5dc9436f216c6d699d3f42a1b27c11b5f2c6f6d4426a494abdfc76a0e32c731d4ba0f58b6d5c05ebeb659337f216096532c0759d63c003c30cbfcd966abd6ef05dc3c8cc94e3f2f9269ce9c7c965fdaf1ab568560f0d1c5f54b2240ae56048608888520f40a120feca275c4e8065f472c1018570cea88834da41c04e910e2d0c97df60adf96a59ae32fedaf8b9b96265a6553644f31b06bfb0098ff3f98c79662032a66dcab22e054c458c121fc436c9038c750d23a8c119e22234e9891dde0f5a261e4e7e0f492fdd3307ccf66fd9fe99c099ceae2329661c0683c9ada82177a1eb3f452443b8bcb4e45f06a2de4ddf04e7dd1e6f711902e8f0d2dd0cc2d93b4a14e1c146bbc52bf4e452396a0979e81771511cd0244b4ad3b347bbcd1ae1b55ee229c728066e43d3c5083db20399f4c10af90ee48caf82caeea119713fc210ec68822cc85162ed2e529eba2299e61ee07a40c950ba18967fd97cb5f023bc7100da3a4db74bd2836cc3cd569bc2b21dd2774d4a755d5e90dc3beefc107a9fe01d7dfbd1f1afc31156b538121958e35d2dd7d83d2731e7c27093f2d03ae4ef3d1b72d0997d75417d2387d179e59912d9d21dc48268f940f21ca9f91950c62be56365cb52e1f7ea82944d062e444a361965ea9077073858dde862922bc5fa4b95e4935c5c0205be0a2f390fc3147147d97b5a6f9c4540272159f72f989052e89dddb8c934092f03fd82d5d49c9e26e55f5436412fed77dc969e764b248329aebec9f103a32e97294778702d40393130daadbb531fc03555e790a3ac269ae430a431bf5112550f0ecee263310be6064046339850ef74896290332af8fd63dd56936954f41e6e60e69ebdb4d7dc0499cfe3a45f94757bd1f1bdb605e4e2570e40aa009f303ec8994c873a30eeaa8e1a2147f3ceaa2993b11cf886f8ae82bbbe784595e2faec1d5d7bc321612e88ec0053ddab7c4d824ef139dedce8f8370427656224e020f32c7d9a96fa011e2034a762d7fc14228de2747b4ffae0034daa5dfa80c9d6802138be86c1b069c72762b32bb38ac57efb353585ac2dd89c6ffc8b25c5b89f719d61c143179fc2fbeb529511800a9cc52d0ebc144ebf36208ed19496b61f3bcc5778520c9dbb8bb5867522ae2cd0ff732f93bff8e664b7d4cb5622bf487fd1bc45c8259175fb7c9d92bfc3c8c94e43b7ffc819214fe504c47b07e2cd2fac69bb8992ad8f162f13429acb6049aedbe8ea7c6f3fe7c05b5e97cdd876ad4d4c28a29530af2bc8076124e941fff56855542b61d501f59ffcf173984fa80a548baa9db59a7bcc5baf73e7ae900499968100366209f6e64e0e538ebace7d7d07c7d8dfefbfaf461f28cc3db23ade958b138012e4772a783e003a306436abc7696e2ac3d329d66f7573a08fe22450aaa44d16d022400749b0a442878cfe7b724349fd58663fa9230ff0ac64d529f8fa20dd5a5433b3905d17ba84e9ed5f63a0dc31bcd443babf2d70c2e69af843a18fb8daac9e5cd8958cefd42bc9f71877c9369d15deb7c97082005bccc3942908d8f88a6d471800c539368eee992a53e294de6a37e2e4ea451be1e3e34e5d102492e7b41d6c5a297a59b2a5d3c0579ce2082cf6507723fbf1857df4591a77d055aba5c720036e76effef02d4a4e788d07dc626926564b2437b30ec4e8c2577db17f6a2bc1e222955034d497353ab5e094d90d8715b0d2140e4bfd509da57cfabe5cd56d2bbe57b1132d9e40df038d9f46dd5d012cd488ee8d8ceb1d4f04d7d4d565f34024a773666b4f99c4bc7fbf5130810c86585646ea4f2576455181d2d6d2cbf10655f1e4a10062f38e00f3f391543cb3b5d46beb406001be1091a5199c08a1a727a41e2fecb00d0c4c1a6734ea63a276a82fbb47934ef960c84a3c81b3ee42b5100ed50b602d2085e8f577b9220f7f46bcd2a01d46b2c9bd0efef75979b1119ff94d566bf42aa98a37bbae67049beabb7eec3f144dba0c643d1797cb30919cc93790cc2eef4be8861067dc715dd8888d09f12d69e70722224c0f821d023ab89c560a291b28df23d968fe223836d013f19d2bfe11754198e1ff9e77487cc9151ffd1fd1d7fa1869916c2742fb24abc4bf7269d372996fe790c3e30b8f36bc44aa5c1f17571b533b370fac85fa83600b6815414b167f735865b27ce10c7524d7ba3c2de91cd768431e0200279a2f22e0d69dfa08f0db6297c002113780bdfeeb97468234266c434bce16989b2a2b7d1c23a2278083624a88209c5415b35a1593f189153ae62371cf834bce07667b4e0858596768f71c69f0e500b52344c247f7166e776f9bbf2fb0a87803192bd4c992194d1fd1bf12e36e0054770add643241762c60dfed4d8ba2b780bc49c69e146a86f075e2d9e0dc3164cb2286961b9f49544737728fdcaa5630555f37b85778cae93238280757c8c6deabc87f0e23d1f9cd1e48d408d37cc583d0b23d71d889802f8dc0d29f2d58234402d11a8348586cdb0cbdf0ef3a5d823b3c291e3b430f0c3ec0b9b075ebc08815401e7a4340cc580109366a70d2f16395311dcabff58993b0cfa73c1a90a3732c55bd612e39be649dfc5ca9ca1fe82d3ca0826b1aed36b5d40abee6960d1838c52d9f7fb3e4b9882140c778d62fa353108a2e64cb5e485337a7c16d4f04025c3dded4c2d2d08bdb9954826e78dac47e7a7f0f0143bcb8d7e08f5eb55276c219693d5cfc7d5073cab9b6e30a5970d33d1fa193e89b0637e7576f8216010ded7d3edc1585924147eaf61099b25cc98a539dfccf1fab020919ad67754b1a590a707bfbb310e8171efdb9762a44d1d8bc368a36aec8d61f2e05867aa886577f6b854cc05fe088d95362abc1a835e0bcd42eda6d6937b32f00781b9901ea25daad03166ed40e691ad06d2ccd74a29df4fb0c04e5dae402e785923b84848911bcd9fce58a381bd4e691db130f64af7734421eedb10586d0d1736d8c78364fe491c7b5390b5f704f4e2b2d41764d0c08cf61beaf2d184ee79182195991a148a38ed72405053105d969b48434bd912ca396b9c0e8db16d6fd29601e65a2e7264b01e9567efbe19c3a8b7407e3785c0490dc83652a44ed9dbd6e210ce7ad5dbbd0ddb75009cc5c5931840575873db35aab08827a3a8a5badceb7c8af009f2078e393c9ae5fdf3e91f77ef5f9fb09131dbd4c8d2366e67da2d5e86e77859c6c0dfdeea2873c4ba69a2ea6cf2033a0601aeee9fd56aa6cd4cd0341d4d36041e280803f68d364770be028f029f9e6082db6be0fd841b02b9096815abc02646821df087fe26bcc6f65036599bbed00db238c890a35ea874ae71f65d06e1fc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">美好的每一天～不连续存在～</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>周志汇总</title>
    <link href="https://blog.phbeats.cn/posts/acdb8d5c9b7b/"/>
    <id>https://blog.phbeats.cn/posts/acdb8d5c9b7b/</id>
    <published>2024-03-19T14:37:12.000Z</published>
    <updated>2024-04-07T14:31:17.306Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="62e7bb2dbb712f05aba0c50b3049bb5d5c3f814d08a379ccf3aa17a76d727900">e673c8ca06aefc9fd566f76e908c7073bf122394db4047bcd924ce9ea3732824180a4f1db344e311487ba241f1b16c4587f75b861f83fe634c4c300b5ce9c13f6ab2dc51be3173e872c5b9303aab66b98f2d10c9186f542c60bdf6e9e018902100efec3c9b0d9e25eb662a6738083cac0144094eaf56dff4f3d0dac07a1d8fde55b12b81cafe45e830d294450db7709fb63d8646cd7dbfc68602c1aa7bd817e8af19f77f37b3a9914120c5cb5b0f50da53c2241e20617cb37b4d39a1119beb3e073a03515b4a5930f95ae2a3fcf3e482c62a96ff08658ef5f572c32442201c12f96576e6b29cddc71ec72e7ca496a5ed9674904c3ddfb4040e37bd0457a3a51e7b885dc33f80ae91af49c6cfe9ad3576d9cd6d90c341d4b1473f006a8219a96cb109b928364ee5ea8a84eb1df1aa43f86f1a449ac8807a6cd5d14028ff1a150b0647f7bd953905b24c4ac42666bb5aaad8ae433312519d1d56cbb4be4d33d47f2b8d78626e4ff5b2718b48f105341926a755ecd794ec9be2add66b6d55b256ae426d7119f48550892431893b8fcae2604b2564b58ec667e3e4b72c42eef25bfd9dc36471fe6138d81d728f753f473859</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">周志汇总</summary>
    
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/tags/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>图-基于邻接表实现</title>
    <link href="https://blog.phbeats.cn/posts/de48a254d011/"/>
    <id>https://blog.phbeats.cn/posts/de48a254d011/</id>
    <published>2023-10-28T06:30:33.000Z</published>
    <updated>2024-04-07T14:31:17.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>使用<code>邻接表</code>作为我的<code>图论算法</code>的基本模板。</p><p><code>图论算法</code>可以使用<code>邻接表</code>和<code>邻接矩阵</code>来作为地基。<br>我选择王道书上的邻接表作为我的模板原因有：</p><ol><li>若要使用<code>邻接矩阵</code>，我有 y 总 的模板。并且也契合，因为可以使用一个<code>二维数组</code>来简化类似邻接矩阵</li><li>我如果是出题人，要指定数据类型，我会选择邻接表，因为考生肯定会优先选择二维数组。</li></ol><h3 id="邻接表的类型描述"><a href="#邻接表的类型描述" class="headerlink" title="邻接表的类型描述"></a>邻接表的类型描述</h3><wavy>我似乎理解错《数据结构》这门考试科目的含义了。它应该重视的是理论，而不是代码的实现，我花费了大量的时间在代码上，这是错误的！因此我打算停更...</wavy>]]></content>
    
    
    <summary type="html">图-基于邻接表实现</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://blog.phbeats.cn/posts/00977ebe8687/"/>
    <id>https://blog.phbeats.cn/posts/00977ebe8687/</id>
    <published>2023-10-27T09:10:02.000Z</published>
    <updated>2024-04-07T14:31:17.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>使用<code>链式存储</code>。</p><p>因为书上的大题使用的都是<code>链式存储</code>。所以我也采取这样的方式，作为我的算法模板。</p><h3 id="二叉树的类型描述"><a href="#二叉树的类型描述" class="headerlink" title="二叉树的类型描述"></a>二叉树的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br><span class="hljs-type">int</span> data; <span class="hljs-comment">// 数据域</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> * lchild, * rchild; <span class="hljs-comment">// 左、右孩子指针</span><br>&#125;BiTNode, * BiTree;<br></code></pre></td></tr></table></figure><h3 id="先序递归建树"><a href="#先序递归建树" class="headerlink" title="先序递归建树"></a>先序递归建树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序递归建树</span><br><span class="hljs-function">BiTree <span class="hljs-title">CreateBiTree</span><span class="hljs-params">()</span></span>&#123;<br>BiTNode * root = (BiTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br><span class="hljs-type">int</span> ch;<br>cin &gt;&gt; ch;<br><br><span class="hljs-keyword">if</span>(ch == <span class="hljs-number">-1</span>)&#123;<br>root = <span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>root -&gt; data = ch;<br>root -&gt; lchild = <span class="hljs-built_in">CreateBiTree</span>();<br>root -&gt; rchild = <span class="hljs-built_in">CreateBiTree</span>();<br>&#125;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">PreOrder</span>(root -&gt; lchild);<br><span class="hljs-built_in">PreOrder</span>(root -&gt; rchild);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br><span class="hljs-built_in">InOrder</span>(root -&gt; lchild);<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">InOrder</span>(root -&gt; rchild);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br><span class="hljs-built_in">PostOrder</span>(root -&gt; lchild);<br><span class="hljs-built_in">PostOrder</span>(root -&gt; rchild);<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先序遍历的非递归算法"><a href="#先序遍历的非递归算法" class="headerlink" title="先序遍历的非递归算法"></a>先序遍历的非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">// 一路向左</span><br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 出栈，并转向出栈结点的右子树</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>p = p -&gt; rchild;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于先序遍历的非递归算法：<wavy></p><ol><li><code>根左右</code>，先根的性质，决定了在<code>一路向左</code>的过程，是可以<code>边输出边入栈</code>的。</li><li>模拟递归回溯，也就是<code>else</code>部分，此时已经完成了<code>根左</code>。现就只要出栈，并转向出栈结点的右子树。</li></ol><h3 id="中序遍历的非递归算法"><a href="#中序遍历的非递归算法" class="headerlink" title="中序遍历的非递归算法"></a>中序遍历的非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 中序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">// 一路向左</span><br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 出栈，并转向出栈结点的右子树</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br>p = p -&gt; rchild;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于中序遍历的非递归算法：<wavy></p><ol><li>与<code>先序遍历的非递归算法</code>类似，不同的是<code>什么时候访问结点</code>。</li><li><code>左根右</code>，决定了必须要找到最左边的结点再回溯。</li><li><code>else</code>部分，也就是模拟递归回溯过程，必须要先<code>出栈</code>再拿着那个结点的值访问。</li></ol><h3 id="后序遍历非递归算法"><a href="#后序遍历非递归算法" class="headerlink" title="后序遍历非递归算法"></a>后序遍历非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 后序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><span class="hljs-comment">// 还需要借助一个指针r，记录最近访问过的结点</span><br><span class="hljs-comment">// 因为回溯的过程中，可能是从左边回溯，也可能是从右边回溯</span><br><span class="hljs-comment">// 从左边回溯，那么根结点就没被访问过。</span><br><span class="hljs-comment">// 从右边回溯，那么根结点被访问过。</span><br>BiTNode * r = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123; <span class="hljs-comment">// 一路向左</span><br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 转右</span><br><span class="hljs-built_in">GetTop</span>(s, p);<br><span class="hljs-comment">// 右子树存在，且右子树还没被访问过</span><br><span class="hljs-keyword">if</span>(p -&gt; rchild &amp;&amp; p -&gt; rchild != r)&#123;<br>p = p -&gt; rchild;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 否则出栈</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br>r = p; <span class="hljs-comment">// 标记为最近访问过的结点</span><br>p = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 重置p，这样下次循环会直接弹出栈顶元素。</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于后序遍历的非递归算法：<wavy></p><ol><li>指针<code>r</code>：回溯的过程中，可能是从左边回溯，也可能是从右边回溯。<code>∴</code> 从左边回溯，那么根结点就没被访问过。从右边回溯，那么根结点被访问过。根结点被访问过，说明该直接从栈顶弹出一个元素。</li></ol><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 层序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 辅助队列</span><br>SqQueue q; <span class="hljs-built_in">InitQueue</span>(q);<br><br><span class="hljs-built_in">EnQueue</span>(q, root);<br><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">EmptyQueue</span>(q))&#123;<br>BiTNode * t; <span class="hljs-built_in">DeQueue</span>(q, t);<br>cout &lt;&lt; t -&gt; data &lt;&lt; endl;<br><br><span class="hljs-keyword">if</span>(t -&gt; lchild) <span class="hljs-built_in">EnQueue</span>(q, t -&gt; lchild);<br><span class="hljs-keyword">if</span>(t -&gt; rchild) <span class="hljs-built_in">EnQueue</span>(q, t -&gt; rchild);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">二叉树</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>顺序队列</title>
    <link href="https://blog.phbeats.cn/posts/54e3f3a21b91/"/>
    <id>https://blog.phbeats.cn/posts/54e3f3a21b91/</id>
    <published>2023-10-27T08:33:53.000Z</published>
    <updated>2024-04-07T14:31:17.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>顺序队列，以<code>循环队列</code>为主。</p><p>因为好写，所以采取它作为我的模板。</p><h3 id="顺序队列的类型描述"><a href="#顺序队列的类型描述" class="headerlink" title="顺序队列的类型描述"></a>顺序队列的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>ElemType data[MaxSize]; <span class="hljs-comment">// 存放队列元素</span><br><span class="hljs-type">int</span> front, rear; <span class="hljs-comment">// 队头、队尾指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化队列 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp; q)</span></span>&#123;<br>q.front = q.rear = <span class="hljs-number">0</span>; <span class="hljs-comment">//初始化队头、队尾指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EmptyQueue</span><span class="hljs-params">(SqQueue q)</span></span>&#123;<br><span class="hljs-keyword">if</span>(q.front == q.rear) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 入队</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp; q, ElemType x)</span></span>&#123;<br><span class="hljs-comment">// 队满,报错</span><br><span class="hljs-keyword">if</span>((q.rear + <span class="hljs-number">1</span>) % MaxSize == q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 入队</span><br>q.data[q.rear] = x;<br>q.rear = (q.rear + <span class="hljs-number">1</span>) % MaxSize;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 出队</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp; q, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 队空, 报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">EmptyQueue</span>(q)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 出队</span><br>x = q.data[q.front];<br>q.front = (q.front + <span class="hljs-number">1</span>) % MaxSize;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获得队头元素"><a href="#获得队头元素" class="headerlink" title="获得队头元素"></a>获得队头元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获得队头元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue q, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 队空，报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">EmptyQueue</span>(q)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 获得队头元素</span><br>x = q.data[q.front];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">静态分配的顺序队列</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>顺序栈</title>
    <link href="https://blog.phbeats.cn/posts/15d79a1a4b3e/"/>
    <id>https://blog.phbeats.cn/posts/15d79a1a4b3e/</id>
    <published>2023-10-27T08:04:26.000Z</published>
    <updated>2024-04-07T14:31:17.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><wavy>顺序栈比较好写,因此我使用它作为我的算法模板</wavy><h3 id="顺序栈的类型描述"><a href="#顺序栈的类型描述" class="headerlink" title="顺序栈的类型描述"></a>顺序栈的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>ElemType data[MaxSize]; <span class="hljs-comment">// 存放栈中元素</span><br><span class="hljs-type">int</span> top; <span class="hljs-comment">// 栈顶指针</span><br>&#125; SqStack;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp; s)</span></span>&#123;<br>s.top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化栈顶指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断栈空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack s)</span></span>&#123; <br><span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 入栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp; s, ElemType x)</span></span>&#123;<br><span class="hljs-comment">// 看栈是否已满,报错</span><br><span class="hljs-keyword">if</span>(s.top == MaxSize - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 入栈</span><br>s.data[++s.top] = x;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 成功</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 出栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp; s, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">StackEmpty</span>(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 先出栈，再减</span><br>x = s.data[s.top--];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获得栈顶元素"><a href="#获得栈顶元素" class="headerlink" title="获得栈顶元素"></a>获得栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获得栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack s, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 空栈，报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">StackEmpty</span>(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 获取栈顶元素</span><br>x = s.data[s.top];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">静态分配的顺序栈</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师沃卡74110耶加雪菲手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/89001a5236dd/"/>
    <id>https://blog.phbeats.cn/posts/89001a5236dd/</id>
    <published>2023-09-11T14:06:31.000Z</published>
    <updated>2024-04-07T14:31:17.302Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近又买了两款<code>治光师</code>的咖啡豆。</p><p><img src="https://bu.dusays.com/2023/09/11/64ff1c3e0aee9.webp" alt="Screenshot_20230911_214426_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/09/11/64ff1c53bc299.webp" alt="IMG_20230904_174607"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/09/11/64ff1cbb12663.jpg" alt="IMG_20230910_035340"></p><p><img src="https://bu.dusays.com/2023/09/11/64ff1d1fb1cfc.webp" alt="IMG_20230910_035309"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>冲好后，是红茶和柑橘香味。<br>高温表现为：酸质明亮，甜感十足，但还是酸更为突出。</p><p>温度低一点，甜感增强许多。</p><p>低温时，轻微泛苦，甜感更强，但失去香味，茶感还未失去，有点像吃了烂果子的甜感。</p><p>总体评价：中高温很好喝，让人想一直喝。</p>]]></content>
    
    
    <summary type="html">浅尝治光师沃卡74110耶加雪菲手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝辛鹿号码系列手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/9d745f9baaa9/"/>
    <id>https://blog.phbeats.cn/posts/9d745f9baaa9/</id>
    <published>2023-08-08T08:12:00.000Z</published>
    <updated>2024-04-07T14:31:17.302Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前买了<code>辛鹿SOE耶加雪菲</code>，然后我去评论了它的风味描述，店家看到了找我售后，表示他们很抱歉。作为顾客，我觉得辛鹿的这个价格，本身我对他家的豆子就不报有很大期望，我基本上是将<code>辛鹿</code>作为行业性价比龙头来看待的，因为学生党时代，我买过辛鹿的咖啡豆，因为便宜，但是味道也就不多提了。</p><p>店家这次给我补偿了一些豆子希望我尝尝，然后表示歉意，所以我还是写一篇评测。</p><p><img src="https://bu.dusays.com/2023/08/08/64d1fa8d9e1e8.png" alt="image-20230808161911377"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p>首先上场的是：<code>辛鹿02意式拼配</code>。</p><p>闻起来就知道是深烘系列了，一如既往的焦味，能喝出些许酸味，整体风味均衡。</p><p>应该算是经典老咖啡风味了。</p><p>总体评价：老咖啡、性价比高。</p><p>然后是：<code>辛鹿04精品罗布斯塔</code>。</p><p>闻起来有种不一样的味道，不是纯烟熏味，更多的是大麦茶的味道，而且气泡超多。</p><p><img src="https://bu.dusays.com/2023/08/08/64d22c610c730.webp" alt="IMG_20230808_194509"></p><p><img src="https://bu.dusays.com/2023/08/08/64d22c60a1944.webp" alt="IMG_20230808_194519"></p><p>喝起来绝了！这尼玛纯纯<code>大麦茶</code>！喝一口，剩下的就不喝了。</p><p>总体评价：大麦茶，不推荐！</p><p>在喝完大麦茶之后，现在是：<code>辛鹿05精选蓝山风味</code>。</p><p>第一口下去纯苦，多喝几口，有浅烘的些许热带水果风味。总体挺均衡，风味不突出。</p><p>总体评价：均衡，均衡得想笑。</p><p>最后，是：<code>辛鹿06精品庄园圆豆</code>。</p><p>闻起来好像是浅烘，呜呜呜，连续喝了那么多深烘，人要死啦。尝尝这个豆子怎么样吧。</p><p>额，喝起来是中烘，风味其实感觉像<code>中烘的耶加雪菲</code>，个人感觉比<code>05</code>好喝，起码这个有风味。</p><p>总体评价：中烘耶加雪菲？性价比高，还行。</p>]]></content>
    
    
    <summary type="html">浅尝辛鹿号码系列手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝四人咖啡粉红佳人手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/b8bb6e256940/"/>
    <id>https://blog.phbeats.cn/posts/b8bb6e256940/</id>
    <published>2023-08-08T07:08:36.000Z</published>
    <updated>2024-04-07T14:31:17.302Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这次事件挺有意思的，起因是我给了<code>四人咖啡果丁丁</code>一个中评，然后客服来问我要不要售后，退货也行，我表示不需要，并且表示下次要购买他家的<code>粉红佳人</code>，他说给我先送点喝喝，我起初以为给我补发<code>30 g</code>豆子尝尝鲜，谁知道他家诚意满满，发了<code>100 g</code>。</p><p>不过喝了之后，我表示很不错，他家也是发了一个修改评价，我也是改成了好评+空评价。</p><p><img src="https://bu.dusays.com/2023/08/08/64d1ed5b9ac47.webp" alt="Screenshot_20230808_151607_com.taobao.taobao"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/08/64d1edc1c17af.webp" alt="Screenshot_20230808_151830_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/08/64d1ede675129.webp" alt="IMG_20230808_145826"></p><p><img src="https://bu.dusays.com/2023/08/08/64d1edd1322eb.webp" alt="IMG_20230808_145904"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>你知道什么是<code>花香</code>吗？你知道什么是<code>蜜桃</code>吗？我小啜第一口，全是<code>蜜桃和花香</code>，而不是<code>酸或甜</code>。我怀疑店家给我的是<code>A1</code>品质的豆子，几乎喝不出什么负面的味道。</p><p>中高温，蜜桃风味明显，随后才是酸和甜的草莓风味。低温，酸味开始突出，但是蜜桃风味不减，甜感增强。</p><p>继治光师伊迪朵水洗耶加雪菲之后，又一让我眼前一亮的豆子，很惊艳。</p><p>总体评价：蜜桃、草莓、高品质、性价比高、推荐。</p>]]></content>
    
    
    <summary type="html">浅尝四人咖啡粉红佳人手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师野草莓手冲咖啡(整活)</title>
    <link href="https://blog.phbeats.cn/posts/0e42f4daeb32/"/>
    <id>https://blog.phbeats.cn/posts/0e42f4daeb32/</id>
    <published>2023-08-03T03:50:57.000Z</published>
    <updated>2024-04-07T14:31:17.302Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>买了<code>治光师</code>的另一款咖啡豆，这款咖啡豆是意式拼配，中深烘焙的。之前喝的差不多都是浅烘，不知道这下风味转变能不能接受了呢，应该问题不大，毕竟以前黑咖我都是不加糖的，主打一个不怕苦。</p><p><code>治光师</code>店铺也九周年了，送了一些小玩意，虽然没啥用，姑且也算送了？</p><p><img src="https://bu.dusays.com/2023/08/03/64cb3337d9470.webp" alt="IMG_20230801_181148"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/03/64cb32d81bb8a.webp" alt="Screenshot_20230803_114348_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/03/64cb33549edd7.webp" alt="IMG_20230803_114019"></p><p><img src="https://bu.dusays.com/2023/08/03/64cb335dd702a.webp" alt="IMG_20230803_113927"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>豆子看起来棕亮的，冲好之后闻了一下，一股烟熏味，感觉梦回高中了。</p><p>果然，一口下去就知道<code>老咖啡</code>了。整体喝起来十分不错，不对我口味的是那烟熏味！即使是手冲也能感觉到它油脂丰富（别和我说没压就出不来油脂，我说有就有），它入口绵滑，虽然带有烟熏味，但并没有带其它奇奇怪怪的味道，比如<code>焦炭</code>这种。回味能够感受到<code>柑橘</code>风味。草莓酱我倒是没感觉到，不过毕竟是手冲吧。</p><p>这算整活了吧，因为这豆子要用<code>咖啡机</code>来制作，然而我是手冲！因为我现在还没咖啡机，仅仅是手冲爱好者，但是<code>治光师野草莓</code>又十分有名，我抱着试试看的心态买了这款豆子，尝尝鲜。</p><p>总体评价：中深烘焙、油脂丰富、均衡、性价比高。</p>]]></content>
    
    
    <summary type="html">浅尝治光师野草莓手冲咖啡(整活)</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝四人咖啡果丁丁耶加雪菲手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/9c71bc76a9ad/"/>
    <id>https://blog.phbeats.cn/posts/9c71bc76a9ad/</id>
    <published>2023-07-31T22:53:21.000Z</published>
    <updated>2024-04-07T14:31:17.302Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>四人咖啡送了我一些小玩意，还送了我一包<code>花海</code>，之后我再喝。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/01/64c83b62d354b.jpg" alt="Screenshot_20230801_065234_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b71273d0.webp" alt="IMG_20230801_062901"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b8391dae.webp" alt="IMG_20230801_063010"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b951ee47.webp" alt="IMG_20230801_063637"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b9ea4a2d.webp" alt="IMG_20230801_064028"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>偏高温时，第一口居然是莫名其妙的味道，第二口继续确认，出来的是<code>茶感</code>，随后品<code>茶感</code>的时候容易品出<code>木质</code>和<code>涩味</code>，随后感觉像咬到了一颗焦炭豆子一样，口腔开始发苦。</p><p>温度稍微下来，酸味明亮，茶感明显。但后半段伴随着不好的味道，比如：木质、涩味、烟熏、焦炭。</p><p>其中不好的味道比较突出的是：木质、涩味、焦炭。还是那个问题，喝到瑕疵豆了！</p><p>到了中温才能更好喝出它的风味，耶加雪菲的感觉。不过风味变成：柑橘、焦糖了。</p><p>不过它确实能喝出来，水蜜桃的风味，很神奇哦，不过我是在偏中低温情况喝出来的。高温的表现并不好，因为不好的味道突出太明显了。咖啡豆还真就和运气沾点边，我这批次的豆子应该属于不太理想。去除那些瑕疵风味，我想<code>果丁丁</code>一定非常好喝。</p><p>总体评价：耶加雪菲、些许木质、涩、烟熏焦炭、性价比一般。</p>]]></content>
    
    
    <summary type="html">浅尝四人咖啡果丁丁耶加雪菲手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>王道数据结构链表习题</title>
    <link href="https://blog.phbeats.cn/posts/78005f2f1e1c/"/>
    <id>https://blog.phbeats.cn/posts/78005f2f1e1c/</id>
    <published>2023-07-31T05:32:29.000Z</published>
    <updated>2024-04-07T14:31:17.302Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表经典大题"><a href="#链表经典大题" class="headerlink" title="链表经典大题"></a>链表经典大题</h3><h4 id="递归删除不带头结点的单链表中所有值为-x-的结点"><a href="#递归删除不带头结点的单链表中所有值为-x-的结点" class="headerlink" title="递归删除不带头结点的单链表中所有值为 x 的结点"></a>递归删除不带头结点的单链表中所有值为 x 的结点</h4><p><img src="https://bu.dusays.com/2023/07/31/64c75c76e2b3a.png" alt="image-20230731150204492"></p><p>题目说了是 L 哦。但是我代码写得是 list。偷懒了。</p><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p>板子</p><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归删除不带头结点单链表中 x 的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del_x</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 出口</span><br><span class="hljs-keyword">if</span>(!list) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list -&gt; data == x)&#123;<br><span class="hljs-comment">// 如果当前递归中的结点是应该被删除的结点</span><br>LNode * p = list;<br>list = list -&gt; next; <span class="hljs-comment">// 指向下一个结点</span><br><span class="hljs-built_in">free</span>(p);<br><span class="hljs-comment">// 继续寻找</span><br><span class="hljs-built_in">Del_x</span>(list, x);<br><br><span class="hljs-comment">// 下面这三行代码是绝对不能写！！！死循环</span><br><span class="hljs-comment">// LNode * p = list -&gt; next;</span><br><span class="hljs-comment">// free(list);</span><br><span class="hljs-comment">// Del_x(p, x);</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是应该被删除的结点</span><br><span class="hljs-built_in">Del_x</span>(list -&gt; next, x);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="附赠无头结点的尾插法代码"><a href="#附赠无头结点的尾插法代码" class="headerlink" title="附赠无头结点的尾插法代码"></a>附赠无头结点的尾插法代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 无头结点尾插法建立单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TailInsert</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-built_in">InitList</span>(list);<br><br>LNode * r;<br><br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">9999</span>)&#123;<br>LNode * s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>s -&gt; data = x;<br>s -&gt; next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">// 是第一个结点</span><br><span class="hljs-keyword">if</span>(!list) list = s;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 平常的尾插</span><br>s -&gt; next = r -&gt; next;<br>r -&gt; next = s;<br>&#125;<br>r = s;<br>cin &gt;&gt; x;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除带头结点的单链表中所有值为-x-的结点"><a href="#删除带头结点的单链表中所有值为-x-的结点" class="headerlink" title="删除带头结点的单链表中所有值为 x 的结点"></a>删除带头结点的单链表中所有值为 x 的结点</h4><p><img src="https://bu.dusays.com/2023/07/31/64c76dedf2ece.png" alt="image-20230731161643650"></p><h5 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h5><p>板子</p><h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除带头结点单链表中 x 的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del_x</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br>LNode * pre = list, * cur = list -&gt; next;<br><br><span class="hljs-keyword">while</span>(cur)&#123;<br><span class="hljs-comment">// 当前结点是应该被删除的结点</span><br><span class="hljs-keyword">if</span>(cur -&gt; data == x)&#123;<br>LNode * q = cur;<br>cur = cur -&gt; next;<br>pre -&gt; next = cur;<br><span class="hljs-built_in">free</span>(q);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 当前结点不是应该被删除的结点</span><br>pre = cur;<br>cur = cur -&gt; next;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="从尾到头反向输出带头结点单链表中每个结点的值"><a href="#从尾到头反向输出带头结点单链表中每个结点的值" class="headerlink" title="从尾到头反向输出带头结点单链表中每个结点的值"></a>从尾到头反向输出带头结点单链表中每个结点的值</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb446b8fd07.png" alt="image-20230803135630640"></p><h5 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h5><p>利用栈的思想</p><h5 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 反向输出链表中每个结点的值</span><br><span class="hljs-comment">// 0.在 main 函数中，调用要注意！</span><br><span class="hljs-comment">// 1.Reverse_Print（list -&gt; next); 带头结点</span><br><span class="hljs-comment">// 2.Reverse_Print（list); 不带头结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reverse_Print</span><span class="hljs-params">(LinkList list)</span></span>&#123;<br><span class="hljs-comment">// 出口</span><br><span class="hljs-keyword">if</span>(!list) <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">// 入栈</span><br><span class="hljs-built_in">Reverse_Print</span>(list -&gt; next);<br><br><span class="hljs-comment">// 出栈</span><br>cout &lt;&lt; list -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除带头结点单链表中的唯一最小值"><a href="#删除带头结点单链表中的唯一最小值" class="headerlink" title="删除带头结点单链表中的唯一最小值"></a>删除带头结点单链表中的唯一最小值</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb4502a04bb.png" alt="image-20230803141117604"></p><h5 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>利用 <code>min_pre</code>、<code>cur</code> 两个指针</li><li>利用线性表寻找最小值算法思想</li><li><code>min_pre</code>用来更新保存，目前已知最小值结点的前一个结点</li></ol><h5 id="核心代码-3"><a href="#核心代码-3" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除单链表中唯一最小值结点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_Min</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 如果是空表或只有头节点</span><br><span class="hljs-keyword">if</span>(!list || !list -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 经典前后指针</span><br>LNode * pre = list, * cur = list -&gt; next;<br>    <span class="hljs-comment">// 保存最小值结点的前一个结点</span><br>LNode * min_pre = list;<br><br><span class="hljs-comment">// 假设最小值是第一个节点</span><br>LNode * t = cur;<br><span class="hljs-comment">// 打擂台</span><br><span class="hljs-keyword">while</span>(cur)&#123;<br><span class="hljs-comment">// 如果发现比最小值还要小的</span><br>         <span class="hljs-comment">// 打赢了，新的当 t</span><br><span class="hljs-keyword">if</span>(cur -&gt; data &lt; t -&gt; data)&#123;<br>t = cur;<br>             <span class="hljs-comment">// pre 作为 新的min_pre</span><br>min_pre = pre;<br>&#125;<br><span class="hljs-comment">// 俩指针后移</span><br>pre = cur;<br>cur = cur -&gt; next;<br>&#125;<br><br><span class="hljs-comment">// 删除擂主</span><br>min_pre -&gt; next = t -&gt; next;<br><span class="hljs-built_in">free</span>(t);<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="带头结点的单链表逆置"><a href="#带头结点的单链表逆置" class="headerlink" title="带头结点的单链表逆置"></a>带头结点的单链表逆置</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb637357a20.png" alt="image-20230803162110380"></p><h5 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h5><p>准备<code>pre</code>、<code>cur</code>、<code>r</code> 3个指针，<code>cur</code>指向<code>pre</code>。</p><h5 id="核心代码-4"><a href="#核心代码-4" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表就地逆置</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reverse_LinkList</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 空表或者只有头结点或者只有一个元素</span><br><span class="hljs-keyword">if</span>(!list || !list -&gt; next || !list -&gt; next -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>LNode * pre = list , * cur = list -&gt; next;<br>LNode * r = cur -&gt; next;<br><span class="hljs-comment">// NULL &lt;- cur &lt;- r</span><br>cur -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">while</span>(r)&#123;<br>pre = cur;<br>cur = r;<br>r = r -&gt; next;<br>cur -&gt; next = pre;<br>&#125;<br><br><span class="hljs-comment">// cur才是真正的主元素，r只是拿来判断的边界条件</span><br>list -&gt; next = cur;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单链表的插入排序"><a href="#单链表的插入排序" class="headerlink" title="单链表的插入排序"></a>单链表的插入排序</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32c0724c39.png" alt="image-20230809140236810"></p><h5 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h5><p><a href="/posts/f7271c1a5982/">跳转链接</a></p><h5 id="核心代码-5"><a href="#核心代码-5" class="headerlink" title="核心代码"></a>核心代码</h5><p><a href="/posts/f7271c1a5982/">跳转链接</a></p><h4 id="两个单链表的公共结点"><a href="#两个单链表的公共结点" class="headerlink" title="两个单链表的公共结点"></a>两个单链表的公共结点</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32d21a0968.png" alt="image-20230809140728686"></p><h5 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h5><p>假设有两个单链表<code>A</code>和<code>B</code>。</p><p>单链表<code>A</code>长度为：a</p><p>单链表<code>B</code>长度为：b</p><p>无非两种情况：<code>相交</code>和<code>不相交</code></p><p><img src="https://bu.dusays.com/2023/08/09/64d32ff3099be.png" alt="image-20230809141931085"></p><p>可以利用<code>a + c + b</code> ＝ <code>b + c + a</code>。求出交点。</p><p>这是<code>不相交</code>的情况。</p><p><img src="https://bu.dusays.com/2023/08/09/64d330de84da4.png" alt="image-20230809142327260"></p><p><code>a + b</code> ＝ <code>b + a</code>。</p><p>相遇为<code>NULL</code>，返回<code>NULL</code>。</p><p><code>公式恒成立</code>。</p><h5 id="核心代码-6"><a href="#核心代码-6" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LNode * <span class="hljs-title">findFirstCommonNode</span><span class="hljs-params">(LinkList headA, LinkList headB)</span> </span>&#123;<br>    LNode * p = headA , * q = headB;<br>    <br>    <span class="hljs-keyword">while</span>(p != q)&#123;<br>        p = p ? p -&gt; next : headB;<br>        q = q ? q -&gt; next : headA;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将原单链表A分裂为：奇A表和偶B表"><a href="#将原单链表A分裂为：奇A表和偶B表" class="headerlink" title="将原单链表A分裂为：奇A表和偶B表"></a>将原单链表A分裂为：<code>奇A表</code>和<code>偶B表</code></h4><p><img src="https://bu.dusays.com/2023/08/09/64d33587565fd.png" alt="image-20230809144319763"></p><h5 id="核心思想-7"><a href="#核心思想-7" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>奇偶序号计数<code>i</code>。</li><li><code>ra</code>和<code>rb</code>尾指针。</li><li>将<code>A</code>的<code>next</code>先<code>置空</code>，后面会通过<code>ra</code>来增加结点。</li><li>根据<code>i</code>的奇偶，在<code>ra</code>或者<code>rb</code>后面增加结点<code>p</code>，再更新<code>ra</code>或<code>rb</code>。</li><li><code>ra</code>和<code>rb</code>的<code>next</code>需要<code>置空</code>。</li></ol><h5 id="核心代码-7"><a href="#核心代码-7" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将原单链表A分裂为：`奇A表`和`偶B表`</span><br><span class="hljs-function">LinkList <span class="hljs-title">Re_Create</span><span class="hljs-params">(LinkList &amp; A)</span></span>&#123;<br><span class="hljs-comment">// 准备B表</span><br>LinkList B = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>B -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 准备工作</span><br>LNode * ra = A , * rb = B; <span class="hljs-comment">// A 和 B 的尾指针</span><br>LNode * p = A -&gt; next; <span class="hljs-comment">// 遍历准备工作</span><br><br><span class="hljs-comment">// A 表断开</span><br>A -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 奇偶序列计数</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p)&#123;<br>i++;<br><span class="hljs-comment">// 奇</span><br><span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span>)&#123;<br>ra -&gt; next = p;<br>ra = p;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 偶</span><br>rb -&gt; next = p;<br>rb = p;<br>&#125;<br>p = p -&gt; next;<br>&#125;<br><span class="hljs-comment">// 尾指针置空</span><br>ra -&gt; next = <span class="hljs-literal">NULL</span>;<br>rb -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> B;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="递增有序的单链表，去除相同的元素"><a href="#递增有序的单链表，去除相同的元素" class="headerlink" title="递增有序的单链表，去除相同的元素"></a>递增有序的单链表，去除相同的元素</h4><p><img src="https://bu.dusays.com/2023/08/09/64d33acd8d1ba.png" alt="image-20230809150548410"></p><h5 id="核心思想-8"><a href="#核心思想-8" class="headerlink" title="核心思想"></a>核心思想</h5><p><a href="448d550da686">跳转链接</a></p><h5 id="核心代码-8"><a href="#核心代码-8" class="headerlink" title="核心代码"></a>核心代码</h5><p><a href="448d550da686">跳转链接</a></p><h4 id="带头结点的循环双链表是否对称"><a href="#带头结点的循环双链表是否对称" class="headerlink" title="带头结点的循环双链表是否对称"></a>带头结点的循环双链表是否对称</h4><p><img src="https://bu.dusays.com/2023/08/09/64d33f2db78aa.png" alt="image-20230809152429784"></p><h5 id="核心思想-9"><a href="#核心思想-9" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>设置两个指针<code>p</code>和<code>q</code>。往两个不同的方向走</li><li>结点数是奇数和偶数，是难点。<code>2n + 1</code>和<code>2n</code>。</li></ol><h5 id="核心代码-9"><a href="#核心代码-9" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Symmetry</span><span class="hljs-params">(DLinkList list)</span></span>&#123;<br>    DNode * p = list -&gt; next , * q = list -&gt; prior;<br>    <span class="hljs-comment">// 第二个条件容易写成 p -&gt; next != q;</span><br>    <span class="hljs-keyword">while</span>(p != q &amp;&amp; q -&gt; next != p)&#123;<br>        <span class="hljs-keyword">if</span>(p -&gt; data == q -&gt; data)&#123;<br>            p = p -&gt; next;<br>            q = q -&gt; prior;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单链表判断是否有环"><a href="#单链表判断是否有环" class="headerlink" title="单链表判断是否有环"></a>单链表判断是否有环</h4><p><img src="https://bu.dusays.com/2023/08/09/64d34b2220fb7.png" alt="image-20230809161529567"></p><h5 id="核心思想-10"><a href="#核心思想-10" class="headerlink" title="核心思想"></a>核心思想</h5><ul><li>慢指针一步一步走，快指针两步两步走</li><li>无环：快指针必定会先到达终点（NULL）</li><li>有环：俩指针会相遇，相遇之后，让慢指针回到起点，再让快慢指针同步速度，一步一步走</li><li>当再次相遇的时候，那个点就是环的入口</li></ul><h5 id="核心代码-10"><a href="#核心代码-10" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">entryNodeOfLoop</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode * slow = head , * fast = head;<br><br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-comment">// 有环，相遇了</span><br>            <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果fast是空，那么代表无环，否则代表有环，并且slow == fast成立</span><br>        <span class="hljs-comment">// 而且，如果while循环条件一开始就没满足，那么代表head是空节点亦或者长度为1</span><br>        <span class="hljs-keyword">if</span>(!fast || !fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// slow == fast ， 有环</span><br>        <span class="hljs-comment">// 让slow回去，fast和slow以同样的速度走，再次相遇就是环的入口结点</span><br>        slow = head;<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            slow = slow -&gt; next;<br>            fast = fast -&gt; next;<br>        &#125;<br>        <span class="hljs-comment">// 再次相遇了</span><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br><br>作者：麦高芬<br>链接：https:<span class="hljs-comment">//www.acwing.com/solution/content/153752/</span><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="单链表倒数第-k-个值"><a href="#单链表倒数第-k-个值" class="headerlink" title="单链表倒数第 k 个值"></a>单链表倒数第 k 个值</h4><p><img src="https://bu.dusays.com/2023/08/09/64d34d9156593.png" alt="image-20230809162553225"></p><h5 id="核心思想-11"><a href="#核心思想-11" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>两个指针<code>p</code>和<code>q</code></li><li>先让它们两个相距<code>k</code></li><li>当<code>q</code>遍历完的时候，<code>p</code>就是倒数第<code>k</code>个节点</li></ol><h5 id="核心代码-11"><a href="#核心代码-11" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_K</span><span class="hljs-params">(LinkList list, <span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-comment">// 计数</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>LNode * p = list -&gt; next, * q = list -&gt; next;<br><br><span class="hljs-keyword">while</span>(q)&#123;<br><span class="hljs-comment">// 先让q走 k 步</span><br><span class="hljs-keyword">if</span>(count &lt; k)&#123;<br>count++;<br>q = q -&gt; next;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>p = p -&gt; next;<br>q = q -&gt; next;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 查找失败</span><br><span class="hljs-keyword">if</span>(count &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h4><p><img src="https://bu.dusays.com/2023/08/09/64d35190e4e8b.png" alt="image-20230809164257287"></p><h5 id="核心思想-12"><a href="#核心思想-12" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>先遍历一遍链表，获取链表的长度。</li><li>根据获取到的链表长度，获取链表中间的结点。(向上取整)</li><li>反转后半段链表。</li><li>合并前半段链表和反转后的后半段链表。</li></ol><h5 id="核心代码-12"><a href="#核心代码-12" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rearrangedList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head-&gt;next) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 获取链表的长度</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = head ; p ; p = p -&gt; next) len++;<br>    <br>        <span class="hljs-comment">// 链表中间的结点</span><br>        <span class="hljs-type">int</span> left = (len + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">auto</span> a = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; left - <span class="hljs-number">1</span> ; i++) a = a -&gt; next;<br>    <span class="hljs-comment">// 反转后半段链表，b在前，c在后  </span><br>        <span class="hljs-keyword">auto</span> b = a -&gt; next , c = b -&gt; next;<br>    <span class="hljs-comment">// a-&gt;next 是为了从中间将链表截断；b-&gt;next 是因为此时的 b 是反转后链表的结尾元素</span><br>        a -&gt; next = b -&gt; next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-keyword">while</span>(c)&#123;<br>            <span class="hljs-keyword">auto</span> p = c -&gt; next;<br>            c -&gt; next = b;<br>            b = c; c = p;<br>        &#125;<br>    <br>        <span class="hljs-comment">// 合并链表，注意此时 b 指向反转链表头部</span><br>        <span class="hljs-keyword">auto</span> p = head;<br>        <span class="hljs-keyword">auto</span> q = b;<br>        <span class="hljs-comment">// o -&gt; o -&gt; o -&gt; NULL (p)</span><br>        <span class="hljs-comment">// o -&gt; o -&gt; o -&gt; NULL (q)</span><br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            <span class="hljs-keyword">auto</span> o = q -&gt; next;<br>            q -&gt; next = p -&gt; next;<br>            p -&gt; next = q;<br>            p = q -&gt; next;<br>            q = o;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">王道数据结构链表习题</summary>
    
    
    
    <category term="王道数据结构习题" scheme="https://blog.phbeats.cn/categories/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    
    
    <category term="王道数据结构习题" scheme="https://blog.phbeats.cn/tags/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师肯尼亚圆豆手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/bb95ebed2e97/"/>
    <id>https://blog.phbeats.cn/posts/bb95ebed2e97/</id>
    <published>2023-07-29T22:45:30.000Z</published>
    <updated>2024-04-07T14:31:17.302Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是治光师会员限购9.9包邮的，肯尼亚FCS合作社顶级圆豆批次，水洗处理的浅烘豆子。</p><p>9.9元30g，不妨让我来试试水。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/30/64c5986ae14d5.webp" alt="Screenshot_20230730_064146_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/07/30/64c5987b1a642.webp" alt="IMG_20230730_063602"></p><p><img src="https://bu.dusays.com/2023/07/31/64c74e7532b67.webp" alt="IMG_20230730_063624"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>一到货熟豆闻起来和之前买的<code>菠萝成子危地马拉瑰夏</code>味道差不多。先养养豆。</p><p>第一口下去是它的酸度和甜度，比较突出，酸度明显高于<code>治光师耶加雪菲</code>，最大的亮点是它真的<code>很甜</code>。喝完后回甘有很久很久，感觉喝了蜂蜜一样，不过对于我这种不太喜欢甜的咖啡的人来说，有点偏齁甜了。它的<code>热带水果风味</code>实在太足了，十分好喝，有轻微涩味，不过太能接受了！</p><p>总体评价：烟熏、涩、果酸和甜感突出、性价比高、推荐。</p>]]></content>
    
    
    <summary type="html">浅尝治光师肯尼亚圆豆手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师伊迪朵耶加雪菲手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/32f6f1e29b78/"/>
    <id>https://blog.phbeats.cn/posts/32f6f1e29b78/</id>
    <published>2023-07-23T00:00:02.000Z</published>
    <updated>2024-04-07T14:31:17.302Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这款<code>治光师伊迪朵耶加雪菲</code>是群友推荐的，直接无脑买了。<br>写这篇文章，已经过了好些日子了，这是第二次喝的时候写的评价。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/13/64af5071a51a7.webp" alt="Screenshot_20230713_085908_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf456c60.webp" alt="IMG_20230723_064938"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf52e837.webp" alt="IMG_20230723_065210"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf44e11f.webp" alt="IMG_20230714_081733"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>首先，从豆子品控来看，是十分优秀的。</p><p>高温下，酸很<code>明亮</code>，基本无涩感，值得一提的是<code>茶感</code>很明显，有些许回甘，带<code>清香的甜</code>。</p><p>低温下，酸更加明显，有<code>SeeSaw 甜橙子</code>那味了。<code>茶感</code>更上一层楼。</p><p>目前喝过<code>最棒的耶加雪菲</code>。</p><p>缺点可能就是100g需要45元，喝几次就无了吧。真的，它就是优秀，挑不出什么刺。非要说的话，喝完后还是有些许烟熏感，不过能够接受。</p><p>不过我觉得这种价格配得上这种品质。</p><p>总体评价：浅烘、水果清香、茶感浓郁、性价比适中、推荐回购。</p>]]></content>
    
    
    <summary type="html">浅尝治光师伊迪朵耶加雪菲手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝菠萝成子危地马拉瑰夏手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/fcab5f014e92/"/>
    <id>https://blog.phbeats.cn/posts/fcab5f014e92/</id>
    <published>2023-07-21T23:18:45.000Z</published>
    <updated>2024-04-07T14:31:17.302Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>瑰夏！瑰夏！瑰夏！</p><p>啊，我终于也能喝上瑰夏了，不过这款瑰夏不是出自<code>巴拿马的翡翠庄园</code>的瑰夏。</p><p>而是出自<code>危地马拉的庄园</code>。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/22/64bb06f93ff84.jpg" alt="Screenshot_20230722_062419_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/07/22/64bb0705f2398.jpg" alt="IMG_20230713_190844"></p><p><img src="https://bu.dusays.com/2023/07/22/64bb070c95363.jpg" alt="IMG_20230713_200015"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>根据<code>菠萝成子</code>介绍，入手了这款瑰夏，他说这款瑰夏一定是真的瑰夏。</p><p>这款瑰夏是中烘的，开包后香味给我的感觉是没有之前的豆子香，我层怀疑是不是豆子不新鲜了，密封罐好像很容易就打开了，是否起到了密封效果？嚼了两粒，确定一下，是<code>大麦茶</code>的味道，香香脆脆的。</p><p><code>瑰夏</code>为什么是瑰夏呢？不仅是指品种，还有风味。</p><p>即使是中烘，苦味一点儿也不明显，突出的更多是水果风味，属于那种真的很清香的，带草莓的酸的感觉，有焦糖味，有一点红茶茶感，喝完后给我的感觉是很均衡，<code>为什么感觉刚刚喝的是水？</code>。喝完后，还是能够感觉到明显的烘焙味，喉咙还是有点不太舒服，也许这也就是之前口嚼大麦茶味的缘由吧。</p><p>真的！这尼玛就是水吧，尝试了各种不同的水粉比，果然是水…</p><p>和闻起来一样，喝起来也是如此清淡，好喝倒是一言难尽，不过我不喜欢那种喝完后那种喉咙被烟熏的感觉。</p><p>总体评价：中烘、清淡、烟熏、性价比低。</p>]]></content>
    
    
    <summary type="html">浅尝菠萝成子危地马拉瑰夏手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>王道数据结构算法设计大题汇总</title>
    <link href="https://blog.phbeats.cn/posts/ba547e211266/"/>
    <id>https://blog.phbeats.cn/posts/ba547e211266/</id>
    <published>2023-07-18T08:53:20.000Z</published>
    <updated>2024-04-07T14:31:17.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章-线性表"><a href="#第一章-线性表" class="headerlink" title="第一章 线性表"></a>第一章 线性表</h3><ol><li><a href="/posts/f57f98d1b5f4">顺序表</a></li><li><a href="/posts/78005f2f1e1c">链表</a></li></ol>]]></content>
    
    
    <summary type="html">王道数据结构算法设计大题汇总</summary>
    
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/tags/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>王道数据结构顺序表习题</title>
    <link href="https://blog.phbeats.cn/posts/f57f98d1b5f4/"/>
    <id>https://blog.phbeats.cn/posts/f57f98d1b5f4/</id>
    <published>2023-07-18T08:53:00.000Z</published>
    <updated>2024-04-07T14:31:17.302Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序表经典大题"><a href="#顺序表经典大题" class="headerlink" title="顺序表经典大题"></a>顺序表经典大题</h3><h4 id="删除顺序表中的最小值"><a href="#删除顺序表中的最小值" class="headerlink" title="删除顺序表中的最小值"></a>删除顺序表中的最小值</h4><p><img src="https://bu.dusays.com/2023/07/18/64b6140d7eb70.png" alt="image-20230718122418457"></p><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p>遍历表，查找最小值，并记住位置 </p><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_Min</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> &amp; value)</span></span>&#123;<br><span class="hljs-comment">// 表空</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 假定最小值是第1个元素</span><br>value = list.data[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 遍历表，尝试找到更小的元素（从第2个元素开始找起）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; list.length; i++)&#123;<br><span class="hljs-keyword">if</span>(list.data[i] &lt; value)&#123;<br>value = list.data[i];<br>pos = i;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 题目要求：空出的位置由最后一个元素顶替</span><br>list.data[pos] = list.data[list.length - <span class="hljs-number">1</span>];<br><br>list.length--; <span class="hljs-comment">// 这一步是最最最容易忘记的！！！</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="逆置顺序表"><a href="#逆置顺序表" class="headerlink" title="逆置顺序表"></a>逆置顺序表</h4><p><img src="https://bu.dusays.com/2023/07/18/64b619073eeab.png" alt="image-20230718124559870"></p><h5 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h5><p>算法板子…</p><h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 输入非法</span><br>    <span class="hljs-keyword">if</span>(from &gt;= to) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 向上取整</span><br><span class="hljs-type">int</span> mid = (to - from + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mid; i++)&#123;<br><span class="hljs-type">int</span> temp = list.data[from + i];<br>list.data[from + i] = list.data[to - i];<br>list.data[to - i] = temp;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表批量删除指定值-x-元素"><a href="#顺序表批量删除指定值-x-元素" class="headerlink" title="顺序表批量删除指定值 x 元素"></a>顺序表批量删除指定值 x 元素</h4><p><img src="https://bu.dusays.com/2023/07/18/64b61b50f028c.png" alt="image-20230718125544632"></p><h5 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h5><p>利用变量<code>k</code>，从0开始，遍历表，只保留<code>非 x</code> 元素</p><h5 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_x</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-keyword">if</span>(list.data[i] != x)<br>list.data[k++] = list.data[i];<br><br><span class="hljs-comment">// k 才是有效表长</span><br>list.length = k;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表在某条件下的批量删除"><a href="#顺序表在某条件下的批量删除" class="headerlink" title="顺序表在某条件下的批量删除"></a>顺序表在某条件下的批量删除</h4><p><img src="https://bu.dusays.com/2023/07/18/64b626805f0ac.png" alt="image-20230718134328974"></p><h5 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h5><p>算法板子…</p><p><img src="https://bu.dusays.com/2023/07/18/64b629de5c63b.png" alt="image-20230718135751532"></p><h5 id="核心代码-3"><a href="#核心代码-3" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_range</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 题目要求，非法输入判定</span><br><span class="hljs-keyword">if</span>(s &gt;= t) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(i &lt; list.length)&#123;<br><span class="hljs-comment">// 值在[s,t]这个范围内 k++</span><br><span class="hljs-keyword">if</span>(list.data[i] &gt;= s &amp;&amp; list.data[i] &lt;= t) k++;<br><span class="hljs-keyword">else</span> list.data[i - k] = list.data[i]; <span class="hljs-comment">// 不在这个范围则直接位移</span><br>i++;<br>&#125;<br><br><span class="hljs-comment">// 更新表长，删除了 k 个</span><br>list.length -= k;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除顺序表中重复元素"><a href="#删除顺序表中重复元素" class="headerlink" title="删除顺序表中重复元素"></a>删除顺序表中重复元素</h4><p><img src="https://bu.dusays.com/2023/07/18/64b62c656f8fc.png" alt="image-20230718140838298"></p><h5 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h5><p>经典的双指针算法。</p><h5 id="核心代码-4"><a href="#核心代码-4" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_repeat</span><span class="hljs-params">(SqList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">int</span> i,j;<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>; j &lt; list.length; j++)<br><span class="hljs-comment">// 出现不同元素</span><br><span class="hljs-keyword">if</span>(list.data[i] != list.data[j])<br><span class="hljs-comment">// 前移 不能写 i++ 必须要写 ++i ！！！！</span><br>             <span class="hljs-comment">// 不同的元素要放在 i 的下一个位置(保证)</span><br>list.data[++i] = list.data[j];<br><br><br>list.length = i + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线性表的-AB-gt-BA-问题"><a href="#线性表的-AB-gt-BA-问题" class="headerlink" title="线性表的 AB =&gt; BA 问题"></a>线性表的 AB =&gt; BA 问题</h4><p><img src="https://bu.dusays.com/2023/07/18/64b631f37d5fe.png" alt="image-20230718143153144"></p><h5 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h5><p><img src="https://bu.dusays.com/2023/07/18/64b6372246520.png" alt="image-20230718145427110"></p><h5 id="核心代码-5"><a href="#核心代码-5" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span></span>&#123;<br><span class="hljs-comment">// 空表</span><br><span class="hljs-keyword">if</span>(list.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 输入非法</span><br><span class="hljs-keyword">if</span>(from &gt;= to) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 向上取整</span><br><span class="hljs-type">int</span> mid = (to - from + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mid; i++)&#123;<br><span class="hljs-type">int</span> temp = list.data[from + i];<br>list.data[from + i] = list.data[to - i];<br>list.data[to - i] = temp;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Converse</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-built_in">Reverse</span>(list, <span class="hljs-number">0</span>, m + n - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">Reverse</span>(list, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">Reverse</span>(list, n, m + n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表的二分查找"><a href="#顺序表的二分查找" class="headerlink" title="顺序表的二分查找"></a>顺序表的二分查找</h4><p><img src="https://bu.dusays.com/2023/07/18/64b6380c82626.png" alt="image-20230718145821268"></p><h5 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h5><p>使用<code>折半查找</code>。</p><h5 id="核心代码-6"><a href="#核心代码-6" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SearchExchangeInsert</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 二分</span><br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = list.length - <span class="hljs-number">1</span>, mid;<br><br><span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br><span class="hljs-comment">// 防溢出</span><br>mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span>(list.data[mid] == x) <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list.data[mid] &lt; x) left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 找到了，与它后面那个元素进行交换（要有的话）</span><br><span class="hljs-keyword">if</span>(list.data[mid] == x &amp;&amp; mid != list.length - <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">swap</span>(list.data[mid],list.data[mid + <span class="hljs-number">1</span>]); <span class="hljs-comment">// 偷懒了</span><br>&#125;<br><br><span class="hljs-comment">// 没找到</span><br><span class="hljs-keyword">if</span>(left &gt; right)&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i = list.length - <span class="hljs-number">1</span>; i &gt; right; i--)&#123;<br>list.data[i + <span class="hljs-number">1</span>] = list.data[i];<br>&#125;<br>list.data[i + <span class="hljs-number">1</span>] = x;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表的主元（摩尔投票法）"><a href="#顺序表的主元（摩尔投票法）" class="headerlink" title="顺序表的主元（摩尔投票法）"></a>顺序表的主元（摩尔投票法）</h4><p>题目太长了，就不给了。</p><p>大概意思是<code>主元的数量大于总数量的一半</code></p><h5 id="核心思想-7"><a href="#核心思想-7" class="headerlink" title="核心思想"></a>核心思想</h5><p>算法板子…</p><h5 id="核心代码-7"><a href="#核心代码-7" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(SqList list)</span></span>&#123;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> val;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++)&#123;<br><span class="hljs-keyword">if</span>(!cnt) val = list.data[i], cnt++;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val == list.data[i]) cnt++;<br><span class="hljs-keyword">else</span> cnt--;<br>&#125;<br><br><span class="hljs-comment">// 如果有主元。统计出主元实际出现次数</span><br><span class="hljs-keyword">if</span>(cnt &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = cnt = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-keyword">if</span>(list.data[i] == val) cnt++;<br>&#125;<br><br><span class="hljs-comment">// 主元超过总元素长度的一半</span><br><span class="hljs-keyword">if</span>(cnt &gt; list.length / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> val;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 不存在主元</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="顺序表中未出现的最小正整数"><a href="#顺序表中未出现的最小正整数" class="headerlink" title="顺序表中未出现的最小正整数"></a>顺序表中未出现的最小正整数</h4><p><img src="https://bu.dusays.com/2023/07/18/64b64e770a249.png" alt="image-20230718163359493"></p><h5 id="核心思想-8"><a href="#核心思想-8" class="headerlink" title="核心思想"></a>核心思想</h5><p>桶计数</p><h5 id="核心代码-8"><a href="#核心代码-8" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindMissMin</span><span class="hljs-params">(SqList list)</span></span>&#123;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-type">int</span> * B; <span class="hljs-comment">// 桶</span><br>B = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * list.length);<br><span class="hljs-built_in">memset</span>(B, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * list.length); <span class="hljs-comment">// 赋初始值为0</span><br><br><span class="hljs-comment">// 计数</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-comment">// 合法的范围</span><br><span class="hljs-keyword">if</span>(list.data[i] &gt; <span class="hljs-number">0</span> &amp;&amp; list.data[i] &lt;= list.length)<br>B[list.data[i] - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记出现过</span><br><span class="hljs-comment">// 从桶里面找最小整数</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; list.length; i++)<br><span class="hljs-keyword">if</span>(!B[i]) <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">王道数据结构顺序表习题</summary>
    
    
    
    <category term="王道数据结构习题" scheme="https://blog.phbeats.cn/categories/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    
    
    <category term="王道数据结构习题" scheme="https://blog.phbeats.cn/tags/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>浅尝手冲咖啡汇总</title>
    <link href="https://blog.phbeats.cn/posts/7da784530acd/"/>
    <id>https://blog.phbeats.cn/posts/7da784530acd/</id>
    <published>2023-07-18T03:52:53.000Z</published>
    <updated>2024-04-07T14:31:17.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浅尝手冲咖啡汇总"><a href="#浅尝手冲咖啡汇总" class="headerlink" title="浅尝手冲咖啡汇总"></a>浅尝手冲咖啡汇总</h3><ol><li><a href="/posts/8635f45e7775">SeeSaw 甜橙子</a></li><li><a href="/posts/cb40af96710f">八平方 晴天娃娃</a></li><li><a href="/posts/c19e2a8a5f1a">辛鹿 SOE 耶加雪菲</a></li><li><a href="/posts/fcab5f014e92">菠萝成子 危地马拉 瑰夏</a></li><li><a href="/posts/32f6f1e29b78">治光师 伊迪朵 耶加雪菲</a></li><li><a href="/posts/bb95ebed2e97">治光师 肯尼亚圆豆</a></li><li><a href="/posts/9c71bc76a9ad">四人咖啡 果丁丁</a></li><li><a href="/posts/0e42f4daeb32">治光师 野草莓意式拼配咖啡</a></li><li><a href="/posts/b8bb6e256940">四人咖啡 粉红佳人</a></li><li><a href="/posts/9d745f9baaa9">辛鹿 号码系列</a></li><li><a href="/posts/89001a5236dd">治光师 沃卡74110 耶加雪菲</a></li></ol><div class="tip home"><p>最近很忙，暂时停更…</p></div>]]></content>
    
    
    <summary type="html">浅尝手冲咖啡汇总</summary>
    
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/tags/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
</feed>
