<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phbeats-Blog</title>
  
  <subtitle>记录学习历程和生活感悟</subtitle>
  <link href="https://blog.phbeats.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.phbeats.cn/"/>
  <updated>2023-04-20T16:33:16.066Z</updated>
  <id>https://blog.phbeats.cn/</id>
  
  <author>
    <name>Phbeats</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[AcWing]46. 二叉搜索树的后序遍历序列</title>
    <link href="https://blog.phbeats.cn/posts/d46bd558c265/"/>
    <id>https://blog.phbeats.cn/posts/d46bd558c265/</id>
    <published>2023-04-19T09:58:27.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-46-二叉搜索树的后序遍历序列"><a href="#AcWing-46-二叉搜索树的后序遍历序列" class="headerlink" title="[AcWing]46. 二叉搜索树的后序遍历序列"></a><a href="https://www.acwing.com/problem/content/44/">[AcWing]46. 二叉搜索树的后序遍历序列</a></h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。</p><p>如果是则返回true，否则返回false。</p><p>假设输入的数组的任意两个数字都互不相同。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>数组长度 <code>[0,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：[4, 8, 6, 12, 16, 14, 10]<br><br>输出：true<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/04/20/64415023411af.png" alt="image-20230420220541552"></p><p><wavy>初始划分阶段</wavy>：</p><ol><li>数组最后一个元素一定是根元素，然后<code>从左往右</code>找到<code>第一个比根元素大</code>的下标，记为<code>k</code>。</li><li>左区间就是<code>[0, k - 1]</code>，右区间是<code>[k, n - 1]</code>。（n为数组长度)</li><li>然后对子区间做同样的划分。</li></ol><p><wavy>注意事项<wavy>：</p><ol><li>区间长度为0，则后续遍历序列合法。</li><li>只有包含<code>k</code>的右区间可能会出现小于根节点的情况，因为左边已经在找<code>k</code>的过程中排除了非法情况（左区间中有比根节点大的元素）。</li></ol><p><img src="https://bu.dusays.com/2023/04/20/644150271b857.png" alt="image-20230420224540132"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;<span class="hljs-type">int</span>&gt; &amp; seq)</span></span>&#123;<br>        <span class="hljs-comment">// 如果区间长度为0，说明一切合法</span><br>        <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 找到根节点</span><br>        <span class="hljs-type">int</span> root = seq[r];<br>        <br>        <span class="hljs-comment">// 从左往右找到第一个比根大的元素下标</span><br>        <span class="hljs-type">int</span> k = l;<br>        <span class="hljs-keyword">while</span>(k &lt; r &amp;&amp; seq[k] &lt; root) k++;<br>  <br>        <span class="hljs-comment">// 如果右区间有比根元素小的元素，一定不合法</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k; i &lt; r; i++)<br>            <span class="hljs-keyword">if</span>(seq[i] &lt; root)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-comment">// 左区间和右区间同时划分</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(l, k - <span class="hljs-number">1</span>, seq) &amp;&amp; <span class="hljs-built_in">dfs</span>(k, r - <span class="hljs-number">1</span>, seq);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verifySequenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; sequence)</span> </span>&#123;<br>        <span class="hljs-comment">// 整个区间长度[0, n - 1]。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, sequence.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, sequence);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度O(n<sup>2</sup>)：<code>dfs</code>中有一个while循环，最坏情况会循环O(n)次，一共执行O(n)次<code>dfs</code>，所以时间复杂度是O(n<sup>2</sup>)。其实也就是退化成单链表了。</li><li>空间复杂度O(n)：退化成单链表空间占用O(n)。</li></ul>]]></content>
    
    
    <summary type="html">[AcWing]46. 二叉搜索树的后序遍历序列</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]47. 二叉树中和为某一值的路径</title>
    <link href="https://blog.phbeats.cn/posts/e407ed0acd1f/"/>
    <id>https://blog.phbeats.cn/posts/e407ed0acd1f/</id>
    <published>2023-04-19T09:58:27.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-47-二叉树中和为某一值的路径"><a href="#AcWing-47-二叉树中和为某一值的路径" class="headerlink" title="[AcWing]47. 二叉树中和为某一值的路径"></a><a href="https://www.acwing.com/problem/content/45/">[AcWing]47. 二叉树中和为某一值的路径</a></h1><p>输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。</p><p>从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><p>保证树中结点值均不小于 $0$。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中结点的数量 $[0,1000]$。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">给出二叉树如下所示，并给出num=22。<br>      5<br>     / \<br>    4   6<br>   /   / \<br>  12  13  6<br> /  \    / \<br>9    1  5   1<br><br>输出：[[5,4,12,1],[5,6,6,5]]<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>DFS的过程中，在遇到叶子节点的时候进行累加求和，并且提交<code>path</code>作为<code>ans</code>之一。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <br>    <span class="hljs-comment">// 节点，当前累计的值，目标值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> target)</span></span>&#123;<br>        <span class="hljs-comment">// 遇到叶子节点下面的空节点，或者是棵空树，什么也不做，反正返回的是ans</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 将当前遇到节点加入路径集合</span><br>        path.<span class="hljs-built_in">push_back</span>(root -&gt; val);<br>        <span class="hljs-comment">// 进行累加计算</span><br>        sum += root -&gt; val;<br>        <br>        <span class="hljs-comment">// 有左子树就开始递归左子树</span><br>        <span class="hljs-keyword">if</span>(root -&gt; left) <span class="hljs-built_in">dfs</span>(root -&gt; left, sum, target);<br>        <span class="hljs-comment">// 有右子树就开始递归右子树</span><br>        <span class="hljs-keyword">if</span>(root -&gt; right) <span class="hljs-built_in">dfs</span>(root -&gt; right, sum, target);<br>        <span class="hljs-comment">// 剩下的情况就是，左子树和右子树都没有，说明是当前节点是叶子节点</span><br>        <span class="hljs-comment">// 订正：不一定是左子树和右子树都没有，或许它是只有一个子树，因此不能无脑开始计算并且提交答案</span><br>        <span class="hljs-comment">// 确定是叶子节点才能计算并且提交答案</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;<br>            <span class="hljs-keyword">if</span>(sum == target) ans.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 不成功也不管了，反正最终会提交一个ans</span><br>        <br>        <span class="hljs-comment">// 每次dfs都需要恢复现场</span><br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findPath</span>(TreeNode* root, <span class="hljs-type">int</span> sum) &#123;<br>        <span class="hljs-comment">// 从根节点找到每个分支的叶子节点</span><br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>, sum);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><wavy>注意事项</wavy>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">path.<span class="hljs-built_in">push_back</span>(root -&gt; val);<br><br>path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 恢复现场</span><br></code></pre></td></tr></table></figure><p>在DFS过程中，上面这两行到底怎么理解？</p><p>DFS的过程中，可以用函数调用栈来表示。如果调用四次DFS，则有四个DFS压入栈中，<code>path</code>也会有四个节点的值。在DFS出栈的过程中，如果不恢复现场，则会出现<code>函数调用栈空了，但path的里面值依旧没有减少</code>。</p><p>归根结底，四次DFS，<code>path</code>会加入四个节点的值，通过<code>path.pop_back()</code>会清除掉这四个节点的值。这样能够保证DFS在结束一个分支，再次开启新的分支的时候<code>path</code>是干净的。</p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul><li>最坏时间复杂度O(n<sup>2</sup>)：在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶子节点的路径都符合题目要求。路径的数目为 O(n)，并且每一条路径的节点个数也为 O(n)。要想将n个路径的所有节点都统计起来，需要的时间复杂度是O(n<sup>2</sup>)。</li><li>平均时间复杂度O(n)：由于每个节点最多只会被访问一次，所以时间复杂度是O(n)。</li></ul><p>但是注意：在大多数情况下，二叉树不会退化成链表，因此大部分情况下的时间复杂度都是线性的。</p><p>我认为时间复杂度还是能看做O(n)。</p>]]></content>
    
    
    <summary type="html">[AcWing]47. 二叉树中和为某一值的路径</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]45. 之字形打印二叉树</title>
    <link href="https://blog.phbeats.cn/posts/de0ff6a9d060/"/>
    <id>https://blog.phbeats.cn/posts/de0ff6a9d060/</id>
    <published>2023-04-19T09:35:14.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-45-之字形打印二叉树"><a href="#AcWing-45-之字形打印二叉树" class="headerlink" title="[AcWing]45. 之字形打印二叉树"></a><a href="https://www.acwing.com/problem/content/description/43/">[AcWing]45. 之字形打印二叉树</a></h1><p>请实现一个函数按照之字形顺序从上向下打印二叉树。</p><p>即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点的数量 <code>[0,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入如下图所示二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]<br>    8<br>   / \<br>  12  2<br>     / \<br>    6   4<br>输出：[[8], [2, 12], [6, 4]]<br></code></pre></td></tr></table></figure><h3 id="算法思路1、2"><a href="#算法思路1、2" class="headerlink" title="算法思路1、2"></a>算法思路1、2</h3><p>在之前的题的基础上，添加了条件判断</p><p>详情参考<a href="/6929c8c24cea">分行从上往下打印二叉树</a></p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">printFromTopToBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 空树，返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        <br>        <span class="hljs-comment">// 基于BFS的分行操作</span><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 从根节点开始BFS</span><br>        <br>        <span class="hljs-comment">// 当前层是否需要逆置</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">// 下一层的节点数量</span><br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 保存每层的值</span><br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-comment">// 一口气将当前层的节点，全放入队列</span><br>            <span class="hljs-keyword">while</span>(len --)&#123;<br>                TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <br>                level.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>                <br>                <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>                <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>            &#125;<br>            <span class="hljs-comment">// 逆置判断</span><br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                <span class="hljs-built_in">reverse</span>(level.<span class="hljs-built_in">begin</span>(), level.<span class="hljs-built_in">end</span>());<br>            &#125;<br>                <br>            <span class="hljs-comment">// 下一层必定与当前层BFS的顺序相反</span><br>            flag = !flag;<br>            <span class="hljs-comment">// 提交当前层</span><br>            ans.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">printFromTopToBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 空树，返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        <br>        <span class="hljs-comment">// 基于BFS的分行操作</span><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 从根节点开始BFS</span><br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 代表这层结束</span><br>        <br>        <span class="hljs-comment">// 存储每层的节点值</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; level;<br>        <br>        <span class="hljs-comment">// 表示是否需要将 level 集合逆置(从右到左)</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <br>            <span class="hljs-comment">// 如果当前层结束了</span><br>            <span class="hljs-keyword">if</span>(!t)&#123;<br>                <span class="hljs-comment">// 如果下一层没有节点了</span><br>                <span class="hljs-comment">// 比如：4 NULL，while循环拿出4，放入level之后，取出NULL，进入这个if条件里面</span><br>                <span class="hljs-comment">// level不是空，因此提交 level 到 ans 里面</span><br>                <span class="hljs-comment">// 队列里面剩下的是 NULL，再拿出来，此时判断level，为空，break掉</span><br>                <span class="hljs-comment">// 这也就是下一层没有节点的情况</span><br>                <span class="hljs-keyword">if</span>(level.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 当前层结束了，下一行还有节点，根据类型提交level，再给下一层增加结束标识符</span><br>                <span class="hljs-comment">// 如果需要逆置</span><br>                <span class="hljs-keyword">if</span>(flag)&#123;<br>                    <span class="hljs-built_in">reverse</span>(level.<span class="hljs-built_in">begin</span>(), level.<span class="hljs-built_in">end</span>());<br>                &#125;<br>                ans.<span class="hljs-built_in">push_back</span>(level);<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>                <span class="hljs-comment">// 为了下一次，level容器是空的，还需要还原空状态</span><br>                level.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-comment">// 下一层必定与当前层BFS的顺序相反</span><br>                flag = !flag;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 当前层没结束,正常BFS</span><br>            level.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>            <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>            <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>由于树中每个节点仅会进队出队一次，所以时间复杂度是<code>O(n)</code></p>]]></content>
    
    
    <summary type="html">[AcWing]45. 之字形打印二叉树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]44. 分行从上往下打印二叉树</title>
    <link href="https://blog.phbeats.cn/posts/6929c8c24cea/"/>
    <id>https://blog.phbeats.cn/posts/6929c8c24cea/</id>
    <published>2023-04-15T11:31:13.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-44-分行从上往下打印二叉树"><a href="#AcWing-44-分行从上往下打印二叉树" class="headerlink" title="[AcWing]44. 分行从上往下打印二叉树"></a><a href="https://www.acwing.com/problem/content/42/">[AcWing]44. 分行从上往下打印二叉树</a></h1><p>从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点的数量 <code>[0,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null]<br>    8<br>   / \<br>  12  2<br>     /<br>    6<br>   /<br>  4<br><br>输出：[[8], [12, 2], [6], [4]]<br></code></pre></td></tr></table></figure><h3 id="算法思想1"><a href="#算法思想1" class="headerlink" title="算法思想1"></a>算法思想1</h3><p>已知不分行的做法是使用<code>BFS</code>层序遍历这棵树。</p><p>在此基础上，做出一些改变，即可得到不分行的做法。</p><p>问：<wavy>在BFS的过程中，能否知道当前队列中有多少节点？</wavy></p><p>答：可以。<wavy>队列的容量就是当前层的节点数量</wavy></p><p>那么，在第1层，只有根节点，队列容量是1，当前层节点数量是1。</p><p>在第2层，有2个节点，队列容量是2，当前层节点数量是2。</p><p>原<code>BFS</code>每次只能弹出一个节点，如果我们一次性弹出<code>当前层数</code>的节点呢？然后将它放入小集合。</p><p>这样一轮结束，将小集合放入大集合。</p><h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">printFromTopToBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 如果是空树返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        <br>        <span class="hljs-comment">// BFS</span><br>        queue&lt;TreeNode *&gt; q;<br>        <span class="hljs-comment">// 从根节点开始扩展</span><br>        q.<span class="hljs-built_in">push</span>(root);<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">// 当前层的元素个数</span><br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <br>            <span class="hljs-comment">// 用来保存当前层的值的集合</span><br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <br>            <span class="hljs-comment">// 一次性将当前层的所有节点弹出</span><br>            <span class="hljs-keyword">while</span>(len --)&#123;<br>                <span class="hljs-comment">// 从队头开始弹出</span><br>                TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 记录这层值的元素</span><br>                level.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>                <br>                <span class="hljs-comment">// 为一次性弹出下层节点做准备</span><br>                <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>                <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>            &#125;<br>            <span class="hljs-comment">// 将小集合放入大集合</span><br>            ans.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="算法思想2"><a href="#算法思想2" class="headerlink" title="算法思想2"></a>算法思想2</h3><p><img src="https://bu.dusays.com/2023/04/19/643fb3cee443e.png" alt="image-20230419172627366"></p><p>代码实现2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">printFromTopToBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 空树，返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        <br>        <span class="hljs-comment">// 基于BFS的分行操作</span><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 从根节点开始BFS</span><br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 代表这层结束</span><br>        <br>        <span class="hljs-comment">// 存储每层的节点值</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; level;<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <br>            <span class="hljs-comment">// 如果当前层结束了</span><br>            <span class="hljs-keyword">if</span>(!t)&#123;<br>                <span class="hljs-comment">// 如果下一层没有节点了</span><br>                <span class="hljs-comment">// 比如：4 NULL，while循环拿出4，放入level之后，取出NULL，进入这个if条件里面</span><br>                <span class="hljs-comment">// level不是空，因此提交 level 到 ans 里面</span><br>                <span class="hljs-comment">// 队列里面剩下的是 NULL，再拿出来，此时判断level，为空，break掉</span><br>                <span class="hljs-comment">// 这也就是下一层没有节点的情况</span><br>                <span class="hljs-keyword">if</span>(level.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 当前层结束了，下一行还有节点，先提交level，再给下一层增加结束标识符</span><br>                ans.<span class="hljs-built_in">push_back</span>(level);<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>                <span class="hljs-comment">// 为了下一次，level容器是空的，还需要还原空状态</span><br>                level.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 当前层没结束,正常BFS</span><br>            level.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>            <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>            <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>由于树中每个节点仅会进队出队一次，所以时间复杂度是<code>O(n)</code></p>]]></content>
    
    
    <summary type="html">[AcWing]44. 分行从上往下打印二叉树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]43. 不分行从上往下打印二叉树</title>
    <link href="https://blog.phbeats.cn/posts/b0ff145d2003/"/>
    <id>https://blog.phbeats.cn/posts/b0ff145d2003/</id>
    <published>2023-04-15T10:40:31.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-43-不分行从上往下打印二叉树"><a href="#AcWing-43-不分行从上往下打印二叉树" class="headerlink" title="[AcWing]43. 不分行从上往下打印二叉树"></a><a href="https://www.acwing.com/problem/content/41/">[AcWing]43. 不分行从上往下打印二叉树</a></h1><p>从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点的数量 <code>[0,1000]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null]<br>    8<br>   / \<br>  12  2<br>     /<br>    6<br>   /<br>  4<br><br>输出：[8, 12, 2, 6, 4]<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>显然，这是二叉树的层序遍历，使用 <code>BFS</code>就行。</p><p>我们从根节点开始按宽度优先的顺序遍历整棵树，每次先扩展左儿子，再扩展右儿子。</p><p>这样我们会：</p><ol><li>先扩展根节点；</li><li>再依次扩展根节点的左右儿子，也就是从左到右扩展第二层节点；</li><li>再依次从左到右扩展第三层节点；</li><li>依次类推</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <br>        <span class="hljs-comment">// 如果是空树，则返回空集合</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>        <br>        <span class="hljs-comment">// 开始BFS</span><br>        queue&lt;TreeNode *&gt; q;<br>        <span class="hljs-comment">// 从根节点开始扩展</span><br>        q.<span class="hljs-built_in">push</span>(root);<br>        <br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">// 取出队头元素</span><br>            TreeNode * t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <br>            <span class="hljs-comment">//题目要求输出序列，需要将它放入集合中</span><br>            res.<span class="hljs-built_in">push_back</span>(t -&gt; val);<br>            <br>            <span class="hljs-comment">// 拓展根节点的左右节点（如果存在的话）</span><br>            <span class="hljs-keyword">if</span>(t -&gt; left) q.<span class="hljs-built_in">push</span>(t -&gt; left);<br>            <span class="hljs-keyword">if</span>(t -&gt; right) q.<span class="hljs-built_in">push</span>(t -&gt; right);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>BFS时每个节点仅被遍历一次，所以时间复杂度是 <code>O(n)</code>。</p>]]></content>
    
    
    <summary type="html">[AcWing]43. 不分行从上往下打印二叉树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]39. 对称的二叉树</title>
    <link href="https://blog.phbeats.cn/posts/49a255ffe500/"/>
    <id>https://blog.phbeats.cn/posts/49a255ffe500/</id>
    <published>2023-04-14T13:33:45.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-39-对称的二叉树"><a href="#AcWing-39-对称的二叉树" class="headerlink" title="[AcWing]39. 对称的二叉树"></a><a href="https://www.acwing.com/problem/content/38/">[AcWing]39. 对称的二叉树</a></h1><p>请实现一个函数，用来判断一棵二叉树是不是对称的。</p><p>如果一棵二叉树和它的镜像一样，那么它是对称的。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">如下图所示二叉树[1,2,2,3,4,4,3,null,null,null,null,null,null,null,null]为对称二叉树：<br>    1<br>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br><br>如下图所示二叉树[1,2,2,null,4,4,3,null,null,null,null,null,null]不是对称二叉树：<br>    1<br>   / \<br>  2   2<br>   \ / \<br>   4 4  3<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p><img src="https://bu.dusays.com/2023/04/14/6439692818a87.png" alt="image-20230414225426092"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* pA, TreeNode* pB)</span></span>&#123;<br>        <span class="hljs-comment">// 如果左根节点和右根节点有一个为空，那么只有它两都为空的时候才是true，否则是false</span><br>        <span class="hljs-keyword">if</span>(!pA || !pB) <span class="hljs-keyword">return</span> !pA &amp;&amp; !pB;<br>        <span class="hljs-comment">// 左右根节点都存在的情况</span><br>        <span class="hljs-comment">// 左右节点根节点值不同，则不对称</span><br>        <span class="hljs-keyword">if</span>(pA -&gt; val != pB -&gt; val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 左右根节点都存在，且值相同，比较他们的子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(pA -&gt; left, pB -&gt; right) &amp;&amp; <span class="hljs-built_in">dfs</span>(pA -&gt; right, pB -&gt; left);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果根节点是空的那么一定是对称的（规定如此）</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 判断左右子树是不是镜像的</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root -&gt; left, root -&gt; right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>从上到下每个节点仅被遍历一遍，所以时间复杂度是 <code>O(n)</code>。</p>]]></content>
    
    
    <summary type="html">[AcWing]39. 对称的二叉树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]38. 二叉树的镜像</title>
    <link href="https://blog.phbeats.cn/posts/f218078c7891/"/>
    <id>https://blog.phbeats.cn/posts/f218078c7891/</id>
    <published>2023-04-11T12:53:20.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-38-二叉树的镜像"><a href="#AcWing-38-二叉树的镜像" class="headerlink" title="[AcWing]38. 二叉树的镜像"></a><a href="https://www.acwing.com/problem/content/description/37/">[AcWing]38. 二叉树的镜像</a></h1><p>输入一个二叉树，将它变换为它的镜像。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量 <code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入树：<br>      8<br>     / \<br>    6  10<br>   / \ / \<br>  5  7 9 11<br><br> [8,6,10,5,7,9,11,null,null,null,null,null,null,null,null] <br>输出树：<br>      8<br>     / \<br>    10  6<br>   / \ / \<br>  11 9 7  5<br><br> [8,10,6,11,9,7,5,null,null,null,null,null,null,null,null]<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>仔细观察发现，镜像就是：<wavy>交换左右子树，对于子树中的左右子节点也进行交换。</wavy><br>利用这个性质，抽象一下就是：递归遍历这个树，交换其<code>左右子树</code>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mirror</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归到空的节点，就跳出，什么也不做</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 交换左右子树</span><br>        <span class="hljs-built_in">mirror</span>(root -&gt; left);<br>        <span class="hljs-built_in">mirror</span>(root -&gt; right);<br>        <span class="hljs-built_in">swap</span>(root -&gt; left, root -&gt; right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的代码虽然简单，但还是可以分析一下。</p><ol><li>从宏观上来看：这是个交换左右子树的过程。</li><li>从微观上来看：这是个先找到叶子结点，从下面开始交换左右节点的过程。（函数递归调用栈）</li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>原树仅被遍历一次，所以时间复杂度是 <code>O(n)</code>。</p>]]></content>
    
    
    <summary type="html">[AcWing]38. 二叉树的镜像</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]37. 树的子结构</title>
    <link href="https://blog.phbeats.cn/posts/e7ce670351d7/"/>
    <id>https://blog.phbeats.cn/posts/e7ce670351d7/</id>
    <published>2023-04-11T12:53:20.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-37-树的子结构"><a href="#AcWing-37-树的子结构" class="headerlink" title="[AcWing]37. 树的子结构"></a><a href="https://www.acwing.com/problem/content/description/35/">[AcWing]37. 树的子结构</a></h1><p>输入两棵二叉树 <code>A，B</code>，判断 <code>B</code> 是不是 <code>A</code> 的子结构。</p><p>我们规定空树不是任何树的子结构。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>每棵树的节点数量 <code>[0,1000]</code>。</p><h4 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">    8<br>   / \<br>  8   7<br> / \<br>9   2<br>   / \<br>  4   7<br></code></pre></td></tr></table></figure><p>树 <code>B</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">  8<br> / \<br>9   2<br></code></pre></td></tr></table></figure><p>返回 <strong>true</strong>，因为 <code>B</code> 是 <code>A</code> 的子结构。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>代码分为两个部分：</p><ol><li>遍历树A中的所有非空节点R；</li><li>判断树A中以R为根节点的子树是不是包含和树B一样的结构，且我们从根节点开始匹配；</li></ol><p>对于第一部分，我们直接递归遍历树A即可，遇到非空节点后，就进行第二部分的判断。</p><p>对于第二部分，我们同时从根节点开始遍历两棵子树：</p><ul><li>如果树B中的节点为空，则表示当前分支是匹配的，返回true；</li><li>如果树A中的节点为空，但树B中的节点不为空，则说明不匹配，返回false；</li><li>如果两个节点都不为空，但数值不同，则说明不匹配，返回false；</li><li>否则说明当前这个点是匹配的，然后递归判断左子树和右子树是否分别匹配即可；</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPart</span><span class="hljs-params">(TreeNode* pA,TreeNode* pB)</span></span>&#123;<br>        <span class="hljs-comment">// 匹配成功的情况，B树已经遍历完了</span><br>        <span class="hljs-keyword">if</span>(!pB) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 匹配失败的情况(pB不为空)</span><br>        <span class="hljs-comment">// B树相比A树更枝繁叶茂，或者A树和B树比较的节点值不同，则子结构匹配失败</span><br>        <span class="hljs-keyword">if</span>(!pA || pA -&gt; val != pB -&gt; val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果A树和B树当前节点值相同，则继续匹配左右子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isPart</span>(pA -&gt; left, pB -&gt; left) &amp;&amp; <span class="hljs-built_in">isPart</span>(pA -&gt; right, pB -&gt; right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;<br>        <span class="hljs-comment">//空树不是任何树的子结构。任何树也不是空树的子结构。</span><br>        <span class="hljs-keyword">if</span>(!pRoot1 || !pRoot2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果是真的全匹配了，那么就是子结构</span><br>        <span class="hljs-comment">// 需要区别于 =&gt; return isPart(pRoot1,pRoot2);</span><br>        <span class="hljs-comment">// 上面这行是只要匹配错一个就直接错了，无容错空间。</span><br>        <span class="hljs-comment">// 下面这行是有容错空间的，还可以执行下下行代码</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isPart</span>(pRoot1,pRoot2)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 出现了一个节点不匹配，使得上面的出口未跳出</span><br>        <span class="hljs-comment">// 说明需要进入A树的左右子树，继续进行匹配</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasSubtree</span>(pRoot1 -&gt; left, pRoot2) || <span class="hljs-built_in">hasSubtree</span>(pRoot1 -&gt; right, pRoot2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><wavy>这里有个注意事项：代码注释已经写出，但这里抽出来再次解释</wavy><ol><li>if(isPart(pRoot1,pRoot2)) return true;这行代码需要区别于 =&gt; return isPart(pRoot1,pRoot2);</li><li><wavy>return isPart(pRoot1,pRoot2);这行是只要匹配错一个就直接错了，无容错空间。</wavy></li><li><wavy>if(isPart(pRoot1,pRoot2)) return true;这行是有容错空间的，还可以执行if后面的代码。</wavy></li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>最坏情况下，我们对于树A中的每个节点都要递归判断一遍，每次判断在最坏情况下需要遍历完树B中的所有节点。<br>所以时间复杂度是 <code>O(nm)</code>，其中 <code>n</code> 是树A中的节点数， <code>m</code> 是树B中的节点数。</p>]]></content>
    
    
    <summary type="html">[AcWing]37. 树的子结构</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]19. 二叉树的下一个节点</title>
    <link href="https://blog.phbeats.cn/posts/94e11a4b82e8/"/>
    <id>https://blog.phbeats.cn/posts/94e11a4b82e8/</id>
    <published>2023-04-07T12:34:12.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-19-二叉树的下一个节点"><a href="#AcWing-19-二叉树的下一个节点" class="headerlink" title="[AcWing]19. 二叉树的下一个节点"></a><a href="https://www.acwing.com/problem/content/31/">[AcWing]19. 二叉树的下一个节点</a></h1><p>给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。</p><p><strong>注意：</strong></p><ul><li>如果给定的节点是中序遍历序列的最后一个，则返回空节点;</li><li>二叉树一定不为空，且给定的节点一定不是空节点；</li></ul><!-- --><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量<code>[0,100]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。<br><br>则应返回值等于3的节点。<br><br>解释：该二叉树的结构如下，2的后继节点是3。<br>  2<br> / \<br>1   3<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><wavy>中序遍历：左根右</wavy><p>情况1：有右子树</p><p>情况2：无右子树</p><p><img src="https://bu.dusays.com/2023/04/07/64301d778a9c8.png" alt="image-20230407214109154"></p><p><img src="https://bu.dusays.com/2023/04/07/6430218e1aa8c.png" alt="image-20230407215844606"></p><p><img src="https://bu.dusays.com/2023/04/07/643022e300731.png" alt="image-20230407220425944"></p><p><img src="https://bu.dusays.com/2023/04/07/64302521859e7.png" alt="image-20230407221400823"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode *father;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">inorderSuccessor</span><span class="hljs-params">(TreeNode* p)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果它有右子树，找到右子树下的最左边的节点</span><br>        <span class="hljs-keyword">if</span>(p -&gt; right)&#123;<br>            p = p -&gt; right;<br>            <span class="hljs-keyword">while</span>(p -&gt; left) p = p -&gt; left;<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果它没有右子树，则寻找它的父亲节点，直到满足条件p == p -&gt; father -&gt; left</span><br>        <span class="hljs-comment">// 那么 p -&gt; father 就是 它的中序遍历的下一个节点</span><br>        <span class="hljs-keyword">while</span>(p -&gt; father &amp;&amp; p != p -&gt; father -&gt; left) p = p -&gt; father;<br>        <span class="hljs-keyword">return</span> p -&gt; father;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><wavy>不论往上找还是往下找，总共遍历的节点数都不大于树的高度。所以时间复杂度是`O(h)`，其中 h 是树的高度。</wavy>]]></content>
    
    
    <summary type="html">[AcWing]19. 二叉树的下一个节点</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]18. 重建二叉树</title>
    <link href="https://blog.phbeats.cn/posts/c2f1d45bfc4f/"/>
    <id>https://blog.phbeats.cn/posts/c2f1d45bfc4f/</id>
    <published>2023-04-04T10:47:17.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="18-重建二叉树-AcWing题库"><a href="#18-重建二叉树-AcWing题库" class="headerlink" title="18. 重建二叉树 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/23/">18. 重建二叉树 - AcWing题库</a></h1><p>输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。</p><p><strong>注意:</strong></p><p>二叉树中每个节点的值都互不相同；<br>输入的前序遍历和中序遍历一定合法；</p><p><strong>数据范围</strong><br>树中节点数量范围<code>[0,100]</code>。</p><p><strong>样例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">给定：<br>前序遍历是：[<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>]<br>中序遍历是：[<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7</span>]<br><br>返回：[<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]<br>返回的二叉树如下所示：<br>    <span class="hljs-number">3</span><br>   / \<br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  \<br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p><img src="https://bu.dusays.com/2023/04/04/642c0c5373b5f.png" alt="image-20230404193839718"></p><p><img src="https://bu.dusays.com/2023/04/04/642c1c1de0caf.png" alt="image-20230404204620577"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pos;<br>    <br>    <span class="hljs-function">TreeNode * <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-comment">// 如果区间为空（若 a == b ，比如 9 == 9，此时依旧要创建 根为9 的节点）</span><br>        <span class="hljs-keyword">if</span>(a &gt; b) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// 先构建根节点</span><br>        TreeNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[a]);<br>        <span class="hljs-comment">// 找到中序遍历中根节点的位置</span><br>        <span class="hljs-type">int</span> k = pos[root -&gt; val];<br>        <span class="hljs-comment">// 递归创建左子树和右子树</span><br>        root -&gt; left = <span class="hljs-built_in">build</span>(preorder, inorder, a + <span class="hljs-number">1</span>, k - x + a, x, k - <span class="hljs-number">1</span>);<br>        root -&gt; right = <span class="hljs-built_in">build</span>(preorder, inorder, b - y + k + <span class="hljs-number">1</span>, b, k + <span class="hljs-number">1</span>, y);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 提前记录中序遍历每个元素的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) pos[inorder[i]] = i;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder, inorder, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：O(n)</strong></p>]]></content>
    
    
    <summary type="html">[AcWing]18. 重建二叉树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法-质数</title>
    <link href="https://blog.phbeats.cn/posts/9c8937f58169/"/>
    <id>https://blog.phbeats.cn/posts/9c8937f58169/</id>
    <published>2023-03-31T13:21:14.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="质数-素数-和合数的定义"><a href="#质数-素数-和合数的定义" class="headerlink" title="质数(素数)和合数的定义"></a>质数(素数)和合数的定义</h3><wavy>大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</wavy><wavy>合数是指在大于1的整数中除了能被1和本身整除外，还能被其他数（0除外）整除的数。</wavy><h3 id="质数的判定：试除法"><a href="#质数的判定：试除法" class="headerlink" title="质数的判定：试除法"></a>质数的判定：试除法</h3><p>此处，给出常规代码写法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">// 如果这个自然数比2小，则一定不是质数</span><br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 试除法</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        <span class="hljs-comment">// 能够被其它自然数整除，不是质数</span><br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>上述代码时间复杂度是O(n)。可是还能优化</p><p>例如：n = 12；i = 2; 那么 (n / i) 一定能整除 n。</p><p>12试除法试到2的时候同时可以知道6也是一个约数。</p><p>所以每次枚举的时候，只需要枚举较小的那个约数就行。</p><p>也就是说，只要 <code>i &lt;= (n / i)</code></p><p>下面给出优化过后的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">// 如果这个自然数比2小，则一定不是质数</span><br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 优化过后的试除法</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++)<br>        <span class="hljs-comment">// 能够被其它自然数整除，不是质数</span><br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码时间复杂度是O(n<sup>1/2</sup>)</p><p>主要修改了for循环里面的判断条件，没有使用<code>sqrt函数</code>，也没有使用<code>i * i &lt;= n</code>，而是使用了<code>i &lt;= n / i</code>。</p><wavy>因为使用sqrt函数慢，i * i 有爆 int 的可能</wavy><h3 id="分解质因数：试除法"><a href="#分解质因数：试除法" class="headerlink" title="分解质因数：试除法"></a>分解质因数：试除法</h3><wavy>合数可以分解质因数，质数不能分解质因数，因为质数只能等于1乘本身这种形式，而1不是质数。</wavy><p><code>算数基本定理</code> 也叫 <code>唯一分解定理</code>，主要的内容为：任何大于 <strong>1</strong> 的正整数都能 唯一 的分解为有限个质数的乘积。根据这一定理任何一个合数都可以被分解成几个质数相乘的形式。</p><p>质因数，给几个例子理解一下。</p><ul><li>1没有质因子。</li><li>5只有1个质因子，5本身。（5是质数）</li><li>6的质因子是2和3。(6 = 2 × 3)</li><li>2、4、8、16等只有1个质因子：2。（2是质数，4 =2²，8 = 2³，如此类推）</li><li>10有2个质因子：2和5。(10 = 2 × 5)</li></ul><h4 id="如何计算质因数：短除法"><a href="#如何计算质因数：短除法" class="headerlink" title="如何计算质因数：短除法"></a>如何计算质因数：短除法</h4><p><img src="https://bu.dusays.com/2023/03/31/6426f34ac5db5.png" alt="image-20230331225037221"></p><p>代码模拟如上操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">// 枚举质因子（i一定是质数，可证明）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++)&#123;<br>        <span class="hljs-comment">// 如果i是质因子</span><br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 进行计数</span><br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>)&#123;<br>                n /= i;<br>                s++;<br>            &#125;<br>            <span class="hljs-comment">// 输出底数和计数结果</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, s);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// n中最多只含有一个大于sqrt(n)的因子(可证明)</span><br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, n, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的点：</p><wavy>假如 i 是一个合数，那么它一定可以分解成多个质因子相乘的形式，这多个质因子同时也是 n 的质因子且比 i 要小，而比 i 小的数在之前的循环过程中一定是被条件除完了的，所以 i 不可能是合数，只可能是质数。</wavy><br /><wavy>n中最多只含有一个大于sqrt(n)的因子，证明通过反证法：如果有两个大于sqrt(n)的因子，那么相乘会大于n，矛盾。</wavy><h3 id="质数筛"><a href="#质数筛" class="headerlink" title="质数筛"></a>质数筛</h3><p>埃氏筛法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-comment">// 埃氏筛法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-comment">// 如果被筛过了</span><br>        <span class="hljs-keyword">if</span>(st[i]) <span class="hljs-keyword">continue</span>;<br>        <br>        <span class="hljs-comment">// 没有被筛过，当前数是质数</span><br>        primes[cnt ++] = i;<br>        <span class="hljs-comment">// 只标记质数的倍数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i)<br>            st[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-built_in">get_primes</span>(n);<br>    <br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><wavy>时间复杂度：O(nlog(logn))</wavy><p>线性筛法（欧拉筛）：</p><p>线性筛法是对朴素筛法的进一步优化，埃式筛法的缺陷在于，对于同一个合数，可能被筛选多次。为了确保每一个合数只被筛选一次，我们用<strong>每个合数的最小质因子</strong>来进行筛选</p><p>之所以被称为线性，是因为：1 ~ n 之内的任何一个合数一定会被筛掉,而且筛的时候只用最小质因子来筛,每一个数都只有一个最小质因子,所以<strong>每个数都只会被筛一次</strong>,因此线性筛法是线性的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-comment">// 欧拉筛</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )&#123;<br>        <span class="hljs-comment">// 如果没被筛过，它是质数</span><br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-comment">// 枚举质数表里面所有的质数(表里面的质数是从小到大存储的)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )&#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-built_in">get_primes</span>(n);<br>    <br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>时间复杂度：O(n)</wavy><br><br /><br>1、因为primes中质数是递增的，所以如果i%primes[j]!=0代表i的最小质因数还没有找到，<strong>即prime[j]小于i的最小质因数。但并不妨碍，primes[j]是primes[j] * i的最小质因数。</strong><br>2、如果当i%prime[j]==0时，代表<strong>i的最小质因数是prime[j]，primes[j]是primes[j] * i的最小质因数。</strong><br>3、综上所述达到了每个数仅筛一次的效果，时间复杂度O ( n ) .</p>]]></content>
    
    
    <summary type="html">算法里面的质数知识</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法-数学知识" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>微分算子法</title>
    <link href="https://blog.phbeats.cn/posts/08501a9a6eaf/"/>
    <id>https://blog.phbeats.cn/posts/08501a9a6eaf/</id>
    <published>2023-03-15T04:12:55.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微分算子法"><a href="#微分算子法" class="headerlink" title="微分算子法"></a>微分算子法</h2><div class="note success simple"><p>求二阶常系数线性非齐次微分方程 特解 的一种手段</p></div><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p><kbd>D</kbd>代表<code>求导</code></p><p><kbd>1/D</kbd>代表<code>积分</code></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><img src="https://bu.dusays.com/2023/03/15/6411577cb91ba.png" alt="image-20230315132826225"></p><p><img src="https://bu.dusays.com/2023/03/15/64115d332b4d6.png" alt="image-20230315135248183"></p><p><img src="https://bu.dusays.com/2023/03/15/641167aa9967a.png" alt="image-20230315143649705"></p><p><img src="https://bu.dusays.com/2023/03/15/64116ffacdbae.png" alt="image-20230315150023917"></p><p><img src="https://bu.dusays.com/2023/03/15/64117c205f71d.png" alt="image-20230315155844496"></p>]]></content>
    
    
    <summary type="html">求二阶常系数线性非齐次微分方程特解的一种手段</summary>
    
    
    
    <category term="高等数学" scheme="https://blog.phbeats.cn/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="高等数学" scheme="https://blog.phbeats.cn/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
    <category term="高等数学技巧" scheme="https://blog.phbeats.cn/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]788.逆序对的数量</title>
    <link href="https://blog.phbeats.cn/posts/da4ee60f29fd/"/>
    <id>https://blog.phbeats.cn/posts/da4ee60f29fd/</id>
    <published>2023-02-06T15:43:57.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-788-逆序对的数量"><a href="#AcWing-788-逆序对的数量" class="headerlink" title="AcWing 788. 逆序对的数量"></a><a href="https://www.acwing.com/problem/content/790/">AcWing 788. 逆序对的数量</a></h1><p>给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。</p><p>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。</p><p><strong>输入格式</strong><br>第一行包含整数 n，表示数列的长度。</p><p>第二行包含 n 个整数，表示整个数列。</p><p><strong>输出格式</strong><br>输出一个整数，表示逆序对的个数。</p><p><strong>数据范围</strong><br>1 ≤ n ≤ 100000，<br>数列中的元素的取值范围 [1,109]。</p><p><strong>输入样例：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">6<br>2 3 4 5 6 1<br></code></pre></td></tr></table></figure><br><strong>输出样例：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5<br></code></pre></td></tr></table></figure></p><h3 id="暴力解法思想"><a href="#暴力解法思想" class="headerlink" title="暴力解法思想"></a>暴力解法思想</h3><p>模仿人类的肉眼观察法，从左往右进行两个for循环的迭代。</p><h3 id="暴力解法代码"><a href="#暴力解法代码" class="headerlink" title="暴力解法代码"></a>暴力解法代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-comment">// 暴力解法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n; cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; q[i];<br>    <br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)<br>            <span class="hljs-keyword">if</span>(q[i] &gt; q[j])<br>                cnt++;<br>                <br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用暴力解法，结果是TLE，因此暴力解法不可行。</p><h3 id="较优的方案：使用归并排序进行求解"><a href="#较优的方案：使用归并排序进行求解" class="headerlink" title="较优的方案：使用归并排序进行求解"></a>较优的方案：使用归并排序进行求解</h3><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><a href="/posts/e413468c3db1/">二路归并排序</a></p><p>在归并排序的过程中进行统计</p><p><strong>简单图示</strong></p><p><img src="https://bu.dusays.com/2023/02/16/63eda74378d04.png" alt="2023-02-16_114608"></p><h3 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h3><p>逆序对最多的情况：即倒序序列</p><p>此时有：</p><p><img src="https://bu.dusays.com/2023/02/16/63eda93ceccf5.png" alt="image-20230216115540983"></p><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> q[N], temp[N];<br><br><span class="hljs-function">LL <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <br>    LL res = <span class="hljs-built_in">merge_sort</span>(l, mid) + <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<span class="hljs-comment">// 核心代码1</span><br>    <br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j]) temp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span> &#123;<br>            temp[k++] = q[j++];<br>            res += mid - i + <span class="hljs-number">1</span>;<span class="hljs-comment">// 核心代码2</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= mid) temp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) temp[k++] = q[j++];<br>    <br>    <span class="hljs-keyword">for</span>(i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++,j++) q[i] = temp[j];<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n; cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; q[i];<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://blog.csdn.net/u014339447/article/details/109055298">C++ 基本数据类型中int、long等整数类型取值范围及原理看这一篇就够了_猿六凯的博客-CSDN博客_c++ int long</a></p>]]></content>
    
    
    <summary type="html">[AcWing]788.逆序对的数量</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://blog.phbeats.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>二路归并排序</title>
    <link href="https://blog.phbeats.cn/posts/e413468c3db1/"/>
    <id>https://blog.phbeats.cn/posts/e413468c3db1/</id>
    <published>2023-02-06T15:43:57.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h2><div class="note success simple"><p>本文将用图例介绍二路归并排序的过程，和经典的板子</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>归并排序和快速排序类似，是基于分治的算法，具有两个主要阶段「划分」和「合并」。</p><ol><li><wavy>划分阶段</wavy>：通过递归不断 <strong>将数组从中点位置划分开</strong>，将长数组的排序问题转化为短数组的排序问题；</li><li><wavy>合并阶段</wavy>：划分到子数组长度为 1 时，开始向上合并，不断将 <strong>左、右两个短有序数组</strong> 合并为 <strong>一个长有序数组</strong>，直至合并至原数组时完成排序；</li></ol><p>一个简单的例子：</p><p><img src="https://bu.dusays.com/2023/02/13/63ea3c2b1a3c7.png" alt="2023-02-13_213202"></p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><ul><li><p><wavy>时间复杂度</wavy>：「划分」阶段形成的递归树花费的时间为O(logn)，每层合并的总操作花费的时间为O(n)。因此总体时间复杂度为O(nlogn)</p></li><li><p><wavy>空间复杂度</wavy>：它需要临时存储原始数据的副本，因此使用了 O(n) 的额外空间，排序过程需要借助一个额外的辅助数组O(n)大小，因此空间复杂度为O(n)。</p></li><li><p><emp>提问：为什么归并排序的空间复杂度和递归深度无关？</emp><wavy>答：因为归并排序只需要复制原始数据的一份副本，而不需要将原始数据进行划分，这样就避免了递归深度的影响。</wavy></p></li><li><p><wavy>稳定性</wavy>：稳定</p></li></ul><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N] , w[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l , <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-comment">// 区间长度为1 则停止继续划分</span><br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 分割中点</span><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 递归划分</span><br>    <span class="hljs-built_in">merge_sort</span>(l , mid) ; <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span> , r);<br><span class="hljs-comment">// 排序合并</span><br>    <span class="hljs-type">int</span> i = l , j = mid + <span class="hljs-number">1</span> , k = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 在区间[l,mid]和[mid + 1, r]内</span><br>    <span class="hljs-comment">// 排序合并一部分</span><br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j]) w[k++] = q[i++];<br>        <span class="hljs-keyword">else</span> w[k++] = q[j++];<br>    &#125;<br>    <span class="hljs-comment">// 剩下的有序数组直接填入辅助数组内</span><br>    <span class="hljs-keyword">while</span>(i &lt;= mid) w[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) w[k++] = q[j++];<br><br>    <span class="hljs-comment">// 将辅助数组的值 覆盖原数组</span><br>    <span class="hljs-keyword">for</span>(i = l , j = <span class="hljs-number">0</span> ; j &lt; k ; i++ , j++)<br>        q[i] = w[j];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://www.hello-algo.com/chapter_sorting/merge_sort/">hello-algo</a></p><p><a href="https://www.bilibili.com/video/BV1Rt411H7UJ/">B站视频</a></p><p><a href="https://www.bilibili.com/video/BV16L411c7fn/">手写归并排序讲解视频</a></p><p><a href="https://www.acwing.com/activity/content/code/content/4550243/">我</a></p>]]></content>
    
    
    <summary type="html">二路归并排序图解</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://blog.phbeats.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]786.第K个数</title>
    <link href="https://blog.phbeats.cn/posts/1e599f9c3b25/"/>
    <id>https://blog.phbeats.cn/posts/1e599f9c3b25/</id>
    <published>2023-02-06T14:45:25.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-786-第K个数"><a href="#AcWing-786-第K个数" class="headerlink" title="AcWing 786.第K个数"></a><a href="https://www.acwing.com/problem/content/788/">AcWing 786.第K个数</a></h1><p>给定一个长度为 n 的整数数列，以及一个整数 k，请求出数列从小到大排序后的第 k 个数。</p><p><strong>输入格式</strong></p><p>输入共两行，第一行包含整数 n 。</p><p>第二行包含 n 个整数（所有整数均在 1∼10<sup>9</sup> 范围内），表示整个数列。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示数列的第 k 小数。</p><p><strong>数据范围</strong></p><p>1 ≤ n ≤ 100000</p><p>1 ≤ k ≤ n</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 3<br>2 4 1 5 3<br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>由题可知，元素是基于数组存储的，于是考虑用快速排序，将元素有序化，输出对应位置的数即可。</p><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><a href="/posts/15ae1352a338">快速排序</a></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l , <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-comment">// 区间大小为1，跳出循环</span><br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 一开始 左边是 -1 右边是 length, pivot不取第一个元素是避免出现极端情况退化成单链表</span><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span> , j = r + <span class="hljs-number">1</span> , pivot = q[(l + r) &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; pivot);<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; pivot);<br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(q[i],q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(l,j);<br>    <span class="hljs-built_in">quick_sort</span>(j+<span class="hljs-number">1</span>,r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n , k;<br>    <br>    cin &gt;&gt; n &gt;&gt; k;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; q[i];<br>    <br>    <span class="hljs-built_in">quick_sort</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <br>    cout &lt;&lt; q[k - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="[AcWing 785. 快速排序 - AcWing](https://www.acwing.com/activity/content/code/content/4550243/">我</a></p>]]></content>
    
    
    <summary type="html">[AcWing]786.第K个数</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://blog.phbeats.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>单链表的直接插入排序</title>
    <link href="https://blog.phbeats.cn/posts/f7271c1a5982/"/>
    <id>https://blog.phbeats.cn/posts/f7271c1a5982/</id>
    <published>2023-02-06T14:22:44.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单链表的直接插入排序"><a href="#单链表的直接插入排序" class="headerlink" title="单链表的直接插入排序"></a>单链表的直接插入排序</h2><div class="note success simple"><p>本文将图解LeetCode上面的一道基于单链表的直接插入排序的题</p></div><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><p><a href="/posts/a1dd46ab1c25/">基于数组的直接插入排序</a></p><h3 id="来自LeetCode的一道题对链表进行直接插入排序"><a href="#来自LeetCode的一道题对链表进行直接插入排序" class="headerlink" title="来自LeetCode的一道题对链表进行直接插入排序"></a>来自LeetCode的一道题<a href="https://leetcode.cn/problems/insertion-sort-list/">对链表进行直接插入排序</a></h3><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><ul><li>列表中的节点数在 <code>[1, 5000]</code>范围内</li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><h4 id="输入样例和输出结果"><a href="#输入样例和输出结果" class="headerlink" title="输入样例和输出结果"></a>输入样例和输出结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: head = [4,2,1,3]<br>输出: [1,2,3,4]<br></code></pre></td></tr></table></figure><p>以上面这个输入为例子，下面是表示图：<br><span style="color:green">绿色</span>：代表<strong>已经排序好的有序序列的元素</strong></p><p><span style="color:brown">褐色</span>：代表<code>base</code>即待插入的元素</p><p><span style="color:red">红色</span>：代表变量关系<br><img src="https://bu.dusays.com/2023/01/14/63c2a6500414f.png" alt="image-20230114205541206"></p><h4 id="算法思路图示-表述如下："><a href="#算法思路图示-表述如下：" class="headerlink" title="算法思路图示 + 表述如下："></a>算法思路图示 + 表述如下：</h4><p><img src="https://bu.dusays.com/2023/01/14/63c2a6c171e50.png" alt="image-20230114205746805"></p><wavy>顺序情况很容易理解，因为直接插入排序就是维护一个有序序列的过程。</wavy><p>我们来分析<wavy>逆序情况</wavy>：</p><p><img src="https://bu.dusays.com/2023/01/14/63c2a6f3ce4d3.png" alt="image-20230114205837275"></p><p>画五角星的这轮，实际上是最容易提取出 task 步骤的，请关注这一轮操作。</p><p>转换成<wavy>部分代码</wavy>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(sortedTail -&gt; val &lt;= base -&gt; val)&#123;<br>    <span class="hljs-comment">// 顺序</span><br>    sortedTail = sortedTail -&gt; next; <span class="hljs-comment">// sortedTail 后移一位    </span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// 逆序 （此处也是关注重点）</span><br>    <span class="hljs-comment">// pre处 是插入点（后插），需要循环找出来，因此 dummy 的重要性就体现出来了</span><br>    <span class="hljs-comment">// 毕竟在这个过程有一个极小的数，需要放在第一个位置，你怎么插？</span><br>    ListNode * pre = dummy;<br>    <span class="hljs-comment">// 过滤掉比base小的，使用 pre -&gt; next -&gt; val 的值来过滤，这样就能求出 插入点</span><br>    <span class="hljs-keyword">while</span>(pre -&gt; next -&gt; val &lt;= base -&gt; val) pre = pre -&gt; next;<br>    <span class="hljs-comment">// 现在 pre 处就是插入点了（后插）</span><br>    <span class="hljs-comment">// 插入三部曲，图示很清楚</span><br>    sortedTail -&gt; next = base -&gt; next;<br>    base -&gt; next = pre -&gt; next;<br>    pre -&gt; next = base;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们实现了<code>step 1</code> 和 <code>step 2</code> 了。</p><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果头结点为空或者只有一个结点，则直接返回头结点</span><br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">// 虚拟头结点，方便操作</span><br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <br>        <span class="hljs-comment">// 直接插入排序：① 默认第1个元素有序。② 第2个元素是 base</span><br>        <span class="hljs-comment">// sortedTail: 有序序列中的 最后一个结点, 在这也是元素中第1个结点</span><br>        <span class="hljs-comment">// base：第2个元素，也是待插入元素</span><br>        ListNode * sortedTail = head, * base = head -&gt; next;<br><br>        <span class="hljs-comment">// 当base不为空，则一直是排序状态</span><br>        <span class="hljs-keyword">while</span>(base)&#123;<br>            <span class="hljs-comment">// base 与 sortedTail比较</span><br>            <span class="hljs-comment">// 产生两种情况 (1. 顺序 2. 逆序)</span><br><br>            <br>            <span class="hljs-keyword">if</span>(sortedTail -&gt; val &lt;= base -&gt; val)&#123;<br>                <span class="hljs-comment">// 顺序</span><br>                sortedTail = sortedTail -&gt; next; <span class="hljs-comment">// sortedTail 后移一位    </span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 逆序，执行 task 步骤</span><br>                ListNode * pre = dummy;<br>                <span class="hljs-comment">// 过滤掉比 base 小的值，pre就是插入的位置</span><br>                <span class="hljs-keyword">while</span>(pre -&gt; next -&gt; val &lt;= base -&gt; val) pre = pre -&gt; next;<br><br>                <span class="hljs-comment">// 插入三部曲</span><br>                sortedTail -&gt; next = base -&gt; next;<br>                base -&gt; next = pre -&gt; next;<br>                pre -&gt; next = base;<br>            &#125;<br>            <span class="hljs-comment">// 注意：base总是 sortedTail的next，不能写成 base = base -&gt; next</span><br>            base = sortedTail -&gt; next;<br>        &#125;<br>        <span class="hljs-comment">// 去掉dummy，返回排序后的链表</span><br>        <span class="hljs-keyword">return</span> dummy -&gt; next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ol><li><p>时间复杂度：<br>对于链表而言，插入元素时只要更新相邻节点的指针即可，不需要像数组一样将插入位置后面的元素往后移动，因此插入操作的<strong>时间复杂度</strong>是<strong>O(1)</strong>，但是找到插入位置需要遍历链表中的节点，<strong>时间复杂度是O(n)</strong>，因此链表直接插入排序的总<strong>时间复杂度</strong>仍然是<strong>O(n<sup>2</sup>)</strong>。</p></li><li><p>空间复杂度：<br>整个排序过程中需要的额外辅助空间为 <code>dummy</code>，<code>sortedTail</code>，<code>base</code>，<code>pre</code>。<br>使用常数大小的额外空间，<strong>空间复杂度为O（1）</strong></p></li></ol><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://leetcode.cn/problems/insertion-sort-list/solution/dui-lian-biao-jin-xing-cha-ru-pai-xu-by-leetcode-s/">LeetCode官方解答</a></p>]]></content>
    
    
    <summary type="html">图解单链表的直接插入排序</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://blog.phbeats.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://blog.phbeats.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="https://blog.phbeats.cn/posts/9ec0dc442f72/"/>
    <id>https://blog.phbeats.cn/posts/9ec0dc442f72/</id>
    <published>2023-02-01T04:39:54.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><div class="note success simple"><p>本文将介绍数据结构堆，以及堆排序</p></div><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一种<wavy>完全二叉树</wavy>，分为<wavy>小根堆</wavy>和<wavy>大根堆</wavy>；以大根堆为例：根≥儿子。<br>通常堆是通过<strong>一维数组</strong>来实现的。</p><p><wavy>堆的存储方式</wavy>：顺序存储（因为要支持随机索引）</p><p><emp>在数组起始下标为0的情况下</emp>：</p><p>如果根节点的编号是 x 的话，它的左儿子编号是 2x + 1，右儿子编号是 2x + 2。</p><p>一个子节点是 p 的话，它的父节点是 ⌊ (p - 1) / 2 ⌋。</p><p><emp>在数组起始下标为1的情况下</emp>：</p><p>如果根节点的编号是 x 的话，它的左儿子编号是 2x，右儿子编号是 2x + 1。</p><p>一个子节点是 p 的话，它的父节点是 ⌊ p / 2 ⌋。</p><div class="tip blue"><p>在数组起始下标为1的情况下</p></div><p><wavy>大根堆的创建</wavy>：</p><p><img src="https://bu.dusays.com/2023/02/01/63da191470816.png" alt="image-20230201135015855"></p><p><img src="https://bu.dusays.com/2023/02/01/63da1cc17a06d.png" alt="image-20230201160315416"></p><p><wavy>大根堆的删除（堆顶）</wavy>：</p><p>将堆的最后一个元素覆盖堆顶元素，堆的大小减1。（最后一个元素很好删）</p><p>然后，从堆顶开始 down 一遍。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用大根堆，基于大根堆的操作基础；堆顶元素总是最大值，每次将堆顶元素与堆中最后一个元素互换，将堆的大小减1，然后 <code>down(1)</code>维护大根堆。反复如此，直到 n 个元素，执行 n - 1 次这样的操作，排序完成。</p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p><wavy>时间复杂度</wavy>：初始化建堆时间是O(n)，更改堆元素后重建堆时间是O(nlogn)，但一般认为全部情况都是O(nlogn)</p><p><wavy>空间复杂度</wavy>：O(1)</p><p><wavy>稳定性</wavy>：不稳定</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><p>需要注意的是，需要维护一个变量 <code>sz</code>，它代表堆的容量</p><p><emp>在数组起始下标为1的情况下</emp>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 维护以 u 为根的堆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> &lt;= sz &amp;&amp; q[u * <span class="hljs-number">2</span>] &gt; q[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= sz &amp;&amp; q[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &gt; q[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 如果 t 和 u 不相等，说明有 儿子比父亲大，应该进行交换，然后进行维护之前儿子在的位置</span><br>    <span class="hljs-keyword">if</span>(u != t)&#123;<br>        <span class="hljs-built_in">swap</span>(q[t],q[u]);<br>        <span class="hljs-comment">// 如果是上层发生改变，可能会牵涉到下层，因此需要递归down下去</span><br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">()</span></span>&#123;<br>    sz = n;<br>    <span class="hljs-comment">// 从有分支的结点开始down</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> ; i ; i--) <span class="hljs-built_in">down</span>(i);<br><br>    <span class="hljs-comment">// down完之后堆顶是最大的元素, 利用大根堆性质，进行n - 1次与数组最后一个元素交换可以进行排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n - <span class="hljs-number">1</span> ; i++)&#123;<br>        <span class="hljs-built_in">swap</span>(q[<span class="hljs-number">1</span>],q[sz]);<br>        sz--;<br>        <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://oi-wiki.org/basic/heap-sort/">Wiki</a><br><a href="https://www.acwing.com/activity/content/code/content/4550243/">我</a></p>]]></content>
    
    
    <summary type="html">堆排序图解</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://blog.phbeats.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://blog.phbeats.cn/posts/15ae1352a338/"/>
    <id>https://blog.phbeats.cn/posts/15ae1352a338/</id>
    <published>2023-01-24T05:29:31.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><div class="note success simple"><p>本文将介绍王道书上的快排模板和一种不同于老教材的快排模板，图示是根据考研书上画的</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>快速排序的核心操作为「哨兵划分」，其目标为：<wavy>选取数组某个元素为基准数，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边</wavy>。「哨兵划分」执行完毕后，原数组被划分成两个部分，即 <wavy>左子数组</wavy> 和 <wavy>右子数组</wavy>，且满足 <wavy>左子数组任意元素 ＜ 基准数 ＜ 右子数组任意元素</wavy>。因此，接下来我们只需要排序两个子数组即可，再将两个子数组执行「哨兵划分」……；直至子数组长度为1时<wavy>终止递归</wavy>。</p><p>一个简单的例子：</p><p><img src="https://bu.dusays.com/2023/01/24/63cf7ee962723.png" alt="image-20230124144637959"></p><p>以上是快速排序第一轮的模拟。</p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p><wavy>时间复杂度</wavy>：</p><ul><li>快速排序的<wavy>平均情况下的运行时间与其最佳情况下的运行时间很接近都是O(nlogn)</wavy></li><li>快速排序的运行时间与划分是否对称有关，<wavy>快速排序的最坏情况发生在两个区域分别包含 n - 1 个元素和 0 个元素时</wavy>，这种最大限度的不对称若发生在每层递归上，本应是二叉树的递归树退化成一叉树（单链表），<wavy>即对应于初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度O(<sup>2</sup>)</wavy>。</li></ul><wavy>空间复杂度</wavy>：由于快速排序是递归的，<wavy>需要借助一个递归工作栈</wavy><ul><li>最好情况：O(logn) （二叉树）</li><li>平均情况：O(logn) （二叉树）</li><li>最坏情况：由于要进行 n - 1 次递归调用，所以栈的深度为O(n)</li></ul><wavy>稳定性</wavy>：不稳定<br><br><div class="tip "><p>在快速排序算法中，每趟排序后会将枢轴（基准）元素放到其最终位置上。（考研写法） </p></div><h3 id="快速排序为什么快？"><a href="#快速排序为什么快？" class="headerlink" title="快速排序为什么快？"></a>快速排序为什么快？</h3><p>从命名能够看出，快速排序在效率方面一定“有两把刷子”。快速排序的平均时间复杂度虽然与「归并排序」和「堆排序」一致，但实际 <strong>效率更高</strong>，这是因为：</p><ul><li><strong>出现最差情况的概率很低</strong>：虽然快速排序的最差时间复杂度为 O(n<sup>2</sup>) ，不如归并排序，但绝大部分情况下，快速排序可以达到 O(nlogn) 的复杂度。</li><li><strong>缓存使用效率高</strong>：哨兵划分操作时，将整个子数组加载入缓存中，访问元素效率很高。而诸如「堆排序」需要跳跃式访问元素，因此不具有此特性。</li><li><strong>复杂度的常数系数低</strong>：在提及的三种算法中，快速排序的 <strong>比较</strong>、<strong>赋值</strong>、<strong>交换</strong> 三种操作的总体数量最少（类似于「插入排序」快于「冒泡排序」的原因）。</li></ul><h3 id="算法模板1（背诵适合面试）"><a href="#算法模板1（背诵适合面试）" class="headerlink" title="算法模板1（背诵适合面试）"></a>算法模板1（背诵适合面试）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l , <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-comment">// 区间大小为1，跳出循环</span><br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 一开始 左边是 -1 右边是 length, pivot不取第一个元素是避免出现极端情况退化成单链表</span><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span> , j = r + <span class="hljs-number">1</span> , pivot = q[(l + r) &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; pivot);<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; pivot);<br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(q[i],q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(l,j);<br>    <span class="hljs-built_in">quick_sort</span>(j+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法模板2（考研版本）"><a href="#算法模板2（考研版本）" class="headerlink" title="算法模板2（考研版本）"></a>算法模板2（考研版本）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-type">int</span> pivot = q[i];<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; q[j] &gt;= pivot) --j;<br>        q[i] = q[j];<br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; q[i] &lt;= pivot) ++i;<br>        q[j] = q[i];<br>    &#125;<br>    q[i] = pivot;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt; r)&#123;<br>        <span class="hljs-type">int</span> pivot_pos = <span class="hljs-built_in">partition</span>(l,r);<br>        <span class="hljs-built_in">quick_sort</span>(l, pivot_pos - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quick_sort</span>(pivot_pos + <span class="hljs-number">1</span>, r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上两种模板，各有缺点：</p><ul><li><wavy>第一种模板的pivot最终不一定是在分界点上，而教材上的pivot最终一定是在分界点上的</wavy>    </li><li><wavy>第二种模板的分界点取每个区间的第一个元素作为pivot，若被卡数据，比如：顺序或逆序，让二叉树退化成一叉链表。这样就会TLE(Time Limit Exceeded)</wavy></li></ul><p>第一种适合算法模板（短），第二种适合考研写法。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><a href="/posts/1e599f9c3b25">第k个数</a></p><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://www.hello-algo.com/chapter_sorting/quick_sort/">hello-algo</a></p><p><a href="https://www.acwing.com/activity/content/code/content/4550243/">我</a></p>]]></content>
    
    
    <summary type="html">快速排序图解</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://blog.phbeats.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="https://blog.phbeats.cn/posts/0f47dab8531e/"/>
    <id>https://blog.phbeats.cn/posts/0f47dab8531e/</id>
    <published>2023-01-24T02:40:20.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><div class="note success simple"><p>本文将用图例介绍希尔排序的过程，和经典的优化板子</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>对 n 个序列进行分组，每组内的下标是等差数列，其公差就是增量，每一组的等差数列的公差相等，然后对每组序列进行<wavy>直接插入排序</wavy>，然后将增量缩小（例如：n/2、n/4、n/8,…）<wavy>直至每组元素只有1个</wavy>，然后再进行一次直接插入排序。</p><div class="tip "><p>直接插入排序对于部分有序的序列效率很高</p></div><p>一个简单的例子：</p><p><img src="https://bu.dusays.com/2023/01/24/63cf49a9cd35d.png" alt="image-20230124105921140"></p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p><wavy>时间复杂度</wavy>：希尔排序的平均时间复杂度和最坏时间复杂度与间距序列的选取（就是间距如何减小到 1）有关，比如「间距每次除以 3」的希尔排序的时间复杂度是O(n<sup>3/2</sup>)</p><p><wavy>空间复杂度</wavy>：O（1）</p><p><wavy>稳定性</wavy>：不稳定</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 分组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d = n / <span class="hljs-number">3</span> ; d ; d = d == <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : d / <span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-comment">// start是每组的第一个元素的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> start = <span class="hljs-number">0</span> ; start &lt; d ; start++)&#123;<br>            <span class="hljs-comment">// 直接插入排序(找到组内第二个元素)</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start + d ; i &lt; n ; i += d)&#123;<br>                <span class="hljs-type">int</span> base = q[i] , j = i;<br><br>                <span class="hljs-keyword">while</span>(j &gt; start &amp;&amp; q[j - d] &gt; base)&#123;<br>                    q[j] = q[j - d];<br>                    j -= d;<br>                &#125;<br>                q[j] = base;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://www.acwing.com/activity/content/code/content/4550243/">我</a></p><p><a href="https://oi-wiki.org/basic/shell-sort/">Wiki</a></p>]]></content>
    
    
    <summary type="html">希尔排序图解</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://blog.phbeats.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>简单选择排序</title>
    <link href="https://blog.phbeats.cn/posts/1421240f22ac/"/>
    <id>https://blog.phbeats.cn/posts/1421240f22ac/</id>
    <published>2023-01-22T07:34:03.000Z</published>
    <updated>2023-04-20T16:33:16.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><div class="note success simple"><p>本文将用图例介绍冒泡排序的过程，和经典的优化板子</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>每一趟（如第 i 趟）在后面 n - i + 1（i从1开始）个待排序元素中选取最小的元素，作为有序子序列的第 i 个元素，直到 n - 1 趟做完，只剩最后一个元素时，就不需要再选了。</p><p>一个简单的例子：</p><p><img src="https://bu.dusays.com/2023/01/22/63cd4bd4ee6e5.png" alt="image-20230122222342741"></p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p><wavy>时间复杂度</wavy>：雷打不动O(n<sup>2</sup>)，堪称经典内排序里面最弱的</p><p><wavy>空间复杂度</wavy>：O(1)</p><p><wavy>稳定性</wavy>：不稳定</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">select_sort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// n个元素，比 n - 1 趟</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n - <span class="hljs-number">1</span> ; i++)&#123;<br>        <span class="hljs-type">int</span> k = i; <span class="hljs-comment">// 记录最小的那个元素下标，一开始默认第一个</span><br>        <br>        <span class="hljs-comment">// 从第二个开始找，找到最后，与记录的最小值一一比较</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span> ; j &lt; n ; j++)&#123;<br>            <span class="hljs-comment">// 如果出现更小的就替换给 k</span><br>            <span class="hljs-keyword">if</span>(q[j] &lt; q[k])<br>                k = j;<br>        &#125;<br>        <span class="hljs-comment">// 最小的元素和下标为i的元素交换</span><br>        <span class="hljs-built_in">swap</span>(q[i],q[k]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://www.acwing.com/activity/content/code/content/4550243/">我</a></p>]]></content>
    
    
    <summary type="html">简单选择排序图解</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://blog.phbeats.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
</feed>
