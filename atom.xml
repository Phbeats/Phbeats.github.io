<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phbeats-Blog</title>
  
  <subtitle>记录学习历程和生活感悟</subtitle>
  <link href="https://blog.phbeats.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.phbeats.cn/"/>
  <updated>2023-07-13T01:35:23.446Z</updated>
  <id>https://blog.phbeats.cn/</id>
  
  <author>
    <name>Phbeats</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅尝辛鹿SOE耶加雪菲手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/c19e2a8a5f1a/"/>
    <id>https://blog.phbeats.cn/posts/c19e2a8a5f1a/</id>
    <published>2023-07-13T01:10:02.000Z</published>
    <updated>2023-07-13T01:35:23.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不同品牌的不同耶加雪菲差别是不是很大呢？性价比之王的<code>辛鹿</code>和其它品牌的耶加雪菲差别是不是巨大呢？</p><p>这篇是<code>辛鹿SOE耶加雪菲</code>的评测，这篇只写主观评价，作为以后我是否会回购的依据。</p><p>其它品牌，这里选择了口碑不错的<code>治光师</code>。</p><p><img src="https://bu.dusays.com/2023/07/13/64af5071a51a7.webp" alt="Screenshot_20230713_085908_com.taobao.taobao"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/13/64af50880a611.webp" alt="IMG_20230713_081516"></p><p><img src="https://bu.dusays.com/2023/07/13/64af5091cfebd.webp" alt="IMG_20230713_081713"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>香味依旧是那股辛鹿味。</p><p><code>辛鹿耶加雪菲</code>喝起来让我十分不舒服，仅仅是啜一口，回味充满了烟熏味，不久这种感觉就能占领你的口腔，喝的整个过程令我喉咙十分不舒服。</p><p>说起口味，就像吃了烤焦的橙子一样，有橙子的风味，耶加雪菲特有的水果风味应该是没有骗我，入口除了烟熏味，还能感觉到明显涩味，不过放冷之后，整体风味变得比一开始好喝多了（可能是烟熏味已经麻痹了我，已经开始变习惯）。</p><p>作为浅中烘焙的咖啡豆，喝出了深烘的感觉，耶加雪菲的水果风味被烟熏味覆盖，个人不喜欢这款<code>辛鹿耶加雪菲</code>。</p><p>总体评价：浅中烘焙、耶加雪菲、烟熏、涩、性价比高、但不推荐。</p>]]></content>
    
    
    <summary type="html">浅尝辛鹿SOE耶加雪菲手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝八平方晴天娃娃手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/cb40af96710f/"/>
    <id>https://blog.phbeats.cn/posts/cb40af96710f/</id>
    <published>2023-07-09T06:20:32.000Z</published>
    <updated>2023-07-13T01:35:23.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是我的第二篇关于咖啡的主观评测。</p><p>这篇文章的意义主要是作为以后我是否会回购的依据。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/09/64aa52eceb0b8.webp" alt="IMG_20230709_135823"></p><p><img src="https://bu.dusays.com/2023/07/09/64aa52f922f15.webp" alt="IMG_20230709_140302"></p><p><img src="https://bu.dusays.com/2023/07/09/64aa53037427f.webp" alt="IMG_20230709_140331"></p><p><img src="https://bu.dusays.com/2023/07/09/64aa530a5b14d.webp" alt="IMG_20230709_140918"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>这次一打开包装，猛吸一口，瞬间是很舒服的咖啡香味，随后带给我的感觉有点刺鼻（吸得太猛了），还有除咖啡豆味其它的味道，是独特的香味。</p><p><code>八平方晴天娃娃</code>的处理法是<code>厌氧日晒</code>处理，第一次喝厌氧日晒处理法的手冲咖啡。</p><p><code>八平方晴天娃娃</code>相比<code>SeeSaw甜橙子</code>，它的酸味并没有那么突出，酸味和苦味是比较均衡的。让我感觉：<code>哦，这款咖啡一定是浅烘的</code>。能明显感受到甜味，不愧是厌氧处理的。</p><p><code>八平方晴天娃娃</code>的缺点也很明显（瑕疵豆有点多，希望是我倒霉吧），喝下去我能明显感受到它的<code>木质感</code>，<code>烟熏味</code>，<code>涩味</code>。因为个人不是很喜欢<code>烟熏味</code>太重的咖啡。</p><p>这次应该翻车了吧，豆子品控不太好，瑕疵豆很影响口感。<code>倘若筛掉瑕疵豆，应该会很好喝</code>。</p><p>总体评价：浅烘、酸质均衡、水果风味、烟熏、性价比低，不推荐。</p>]]></content>
    
    
    <summary type="html">浅尝八平方晴天娃娃手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="https://blog.phbeats.cn/posts/634af820198d/"/>
    <id>https://blog.phbeats.cn/posts/634af820198d/</id>
    <published>2023-07-05T18:52:44.000Z</published>
    <updated>2023-07-13T01:35:23.450Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单链表的实现方式"><a href="#单链表的实现方式" class="headerlink" title="单链表的实现方式"></a>单链表的实现方式</h3><p>实现方式：<code>不带头结点</code>和<code>带头结点</code></p><p>为了写代码方便，使用<code>带头结点</code>的策略作为我的算法模板</p><h3 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp; list)</span><span class="hljs-comment">// 初始化</span></span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">(LinkList list)</span><span class="hljs-comment">// 判空</span></span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InsertNextNode</span><span class="hljs-params">(LNode *p, <span class="hljs-type">int</span> e)</span><span class="hljs-comment">// 后插操作：在p结点之后插入元素e</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeadInsert</span><span class="hljs-params">(LinkList &amp; list)</span><span class="hljs-comment">// 头插法建立单链表</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TailInsert</span><span class="hljs-params">(LinkList &amp; list)</span><span class="hljs-comment">// 尾插法建立单链表</span></span><br><span class="hljs-function">LNode * <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList list, <span class="hljs-type">int</span> i)</span> <span class="hljs-comment">// 按位查找</span></span><br><span class="hljs-function">LNode * <span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList list, <span class="hljs-type">int</span> e)</span><span class="hljs-comment">// 按值查找（太简单省略）</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x)</span><span class="hljs-comment">// 将x插入到单链表的第i个位置上</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> i)</span><span class="hljs-comment">// 将单链表中的第i个结点删除</span></span><br><span class="hljs-function">省略Length，Print.......</span><br></code></pre></td></tr></table></figure><h3 id="单链表的类型描述"><a href="#单链表的类型描述" class="headerlink" title="单链表的类型描述"></a>单链表的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> * next;<br>&#125;LNode, * LinkList;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 1. 给头结点分配内存</span><br>list = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br><span class="hljs-comment">// 2. 头结点指向的下一个结点地址为NULL</span><br>list -&gt; next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">(LinkList list)</span></span>&#123;<br><span class="hljs-comment">// 如果头结点下一个结点指向NULL，则为空</span><br><span class="hljs-keyword">if</span>(!list -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后插操作"><a href="#后插操作" class="headerlink" title="后插操作"></a>后插操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在p结点之后插入元素e</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InsertNextNode</span><span class="hljs-params">(LNode *p, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-comment">// 1.不能在NULL后面插入元素</span><br><span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 2.创建新节点承载元素e</span><br>LNode * s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>s -&gt; data = e;<br><span class="hljs-comment">// 3.后插</span><br>s -&gt; next = p -&gt; next;<br>p -&gt; next = s;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="头插法建立单链表"><a href="#头插法建立单链表" class="headerlink" title="头插法建立单链表"></a>头插法建立单链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeadInsert</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 初始化单链表</span><br><span class="hljs-built_in">InitList</span>(list);<br><span class="hljs-comment">// 批量插入</span><br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">9999</span>)&#123;<br><span class="hljs-built_in">InsertNextNode</span>(list, x);<br>cin &gt;&gt; x;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="尾插法建立单链表"><a href="#尾插法建立单链表" class="headerlink" title="尾插法建立单链表"></a>尾插法建立单链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 尾插法建立单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TailInsert</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 初始化单链表</span><br><span class="hljs-built_in">InitList</span>(list);<br><span class="hljs-comment">// 需要一个尾指针指向当前单链表的最后一个有效节点</span><br>LNode * r = list; <span class="hljs-comment">// 最初是头结点</span><br><span class="hljs-comment">// 批量输入</span><br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">9999</span>)&#123;<br>LNode * s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>s -&gt; data = x;<br><span class="hljs-comment">// 在尾指针指向的节点后面插入新元素</span><br>s -&gt; next = r -&gt; next;<br>r -&gt; next = s;<br>r = s; <span class="hljs-comment">// 更新尾指针</span><br>cin &gt;&gt; x;<br>&#125;<br><span class="hljs-comment">// 非常重要！！！！</span><br>r -&gt; next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 尾指针指向的节点的next置空</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 按位查找</span><br><span class="hljs-function">LNode * <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList list, <span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">// 1. 位置判断(0:取出头结点)</span><br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> list;<br><span class="hljs-comment">// 无效非法的位置i</span><br><span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 2. 查找</span><br><span class="hljs-comment">// 计数器</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 第一个元素（可能为空）</span><br>LNode * p = list -&gt; next;<br><br><span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i)&#123; <span class="hljs-comment">// 循环次数为：相距 i - 1 次(从第1位置找到第4位置需要移动3个单位）</span><br>j++;<br>p = p -&gt; next;<br>&#125;<br><br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将x插入到单链表list的第i个位置上</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 插入操作需要先找到第 i - 1 个位置的节点，再插入</span><br>LNode *p = <span class="hljs-built_in">GetElem</span>(list,i<span class="hljs-number">-1</span>);<br><span class="hljs-comment">// 在 p 节点后面插入元素x</span><br><span class="hljs-built_in">InsertNextNode</span>(p, x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将单链表中的第i个结点删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i &gt; <span class="hljs-built_in">Length</span>(list))&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;delete failed: index is wrong.&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 找到第 i - 1 个节点</span><br>LNode *p = <span class="hljs-built_in">GetElem</span>(list,i<span class="hljs-number">-1</span>);<br><span class="hljs-comment">// 删除</span><br>LNode *q = p-&gt;next;<br>p-&gt;next = q-&gt;next;<br><span class="hljs-built_in">free</span>(q);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="另外：前插操作"><a href="#另外：前插操作" class="headerlink" title="另外：前插操作"></a>另外：前插操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前插操作：在p结点之前插入元素e</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InsertPriorNode</span><span class="hljs-params">(LNode *p, <span class="hljs-type">int</span> e)</span></span>&#123;<br>    <span class="hljs-comment">// 不能在NULL之前插入元素</span><br>    <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 前插</span><br>    <span class="hljs-comment">// 创建新节点，在p节点后插</span><br>    LNode *s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next = s;<br>    <span class="hljs-comment">// p给s，e给p</span><br>    s-&gt;data = p-&gt;data;<br>    p-&gt;data = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> * next;<br>&#125;LNode, * LinkList;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 1. 给头结点分配内存</span><br>list = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br><span class="hljs-comment">// 2. 头结点指向的下一个结点地址为NULL</span><br>list -&gt; next = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 判空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">(LinkList list)</span></span>&#123;<br><span class="hljs-comment">// 如果头结点下一个结点指向NULL，则为空</span><br><span class="hljs-keyword">if</span>(!list -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 在p结点之后插入元素e</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InsertNextNode</span><span class="hljs-params">(LNode *p, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-comment">// 1.不能在NULL后面插入元素</span><br><span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 2.创建新节点承载元素e</span><br>LNode * s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>s -&gt; data = e;<br><span class="hljs-comment">// 3.后插</span><br>s -&gt; next = p -&gt; next;<br>p -&gt; next = s;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 头插法建立单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeadInsert</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 初始化单链表</span><br><span class="hljs-built_in">InitList</span>(list);<br><span class="hljs-comment">// 批量插入</span><br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">9999</span>)&#123;<br><span class="hljs-built_in">InsertNextNode</span>(list, x);<br>cin &gt;&gt; x;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 尾插法建立单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TailInsert</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 初始化单链表</span><br><span class="hljs-built_in">InitList</span>(list);<br><span class="hljs-comment">// 需要一个尾指针指向当前单链表的最后一个有效节点</span><br>LNode * r = list; <span class="hljs-comment">// 最初是头结点</span><br><span class="hljs-comment">// 批量输入</span><br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">9999</span>)&#123;<br>LNode * s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>s -&gt; data = x;<br><span class="hljs-comment">// 在尾指针指向的节点后面插入新元素</span><br>s -&gt; next = r -&gt; next;<br>r -&gt; next = s;<br>r = s; <span class="hljs-comment">// 更新尾指针</span><br>cin &gt;&gt; x;<br>&#125;<br><span class="hljs-comment">// 非常重要！！！！</span><br>r -&gt; next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 尾指针指向的节点的next置空</span><br>&#125;<br><br><span class="hljs-comment">// 按位查找</span><br><span class="hljs-function">LNode * <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList list, <span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-comment">// 1. 位置判断(0:取出头结点)</span><br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> list;<br><span class="hljs-comment">// 无效非法的位置i</span><br><span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 2. 查找</span><br><span class="hljs-comment">// 计数器</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 第一个元素（可能为空）</span><br>LNode * p = list -&gt; next;<br><br><span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i)&#123; <span class="hljs-comment">// 循环次数为：相距 i - 1 次(从第1位置找到第4位置需要移动3个单位）</span><br>j++;<br>p = p -&gt; next;<br>&#125;<br><br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//将x插入到单链表list的第i个位置上</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 插入操作需要先找到第 i - 1 个位置的节点，再插入</span><br>LNode *p = <span class="hljs-built_in">GetElem</span>(list,i<span class="hljs-number">-1</span>);<br><span class="hljs-comment">// 在 p 节点后面插入元素x</span><br><span class="hljs-built_in">InsertNextNode</span>(p, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Length</span><span class="hljs-params">(LinkList list)</span></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>LNode * p = list -&gt; next;<br><br><span class="hljs-keyword">while</span>(p)&#123;<br>i++;<br>p = p -&gt; next;<br>&#125;<br><br><span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-comment">// 将单链表中的第i个结点删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i &gt; <span class="hljs-built_in">Length</span>(list))&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;delete failed: index is wrong.&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 找到第 i - 1 个节点</span><br>LNode *p = <span class="hljs-built_in">GetElem</span>(list,i<span class="hljs-number">-1</span>);<br><span class="hljs-comment">// 删除</span><br>LNode *q = p-&gt;next;<br>p-&gt;next = q-&gt;next;<br><span class="hljs-built_in">free</span>(q);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(LinkList list)</span></span>&#123;<br><span class="hljs-comment">//头结点指向第一个元素（可能为空）</span><br>LNode * p = list -&gt; next;<br><span class="hljs-keyword">while</span>(p)&#123;<br>cout &lt;&lt; p -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>p = p -&gt; next;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>LinkList list;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-built_in">InitList</span>(list);<br><br><span class="hljs-comment">// 判空</span><br>cout &lt;&lt; <span class="hljs-string">&quot;此时单链表是否为空？(1代表是，0代表不是)&quot;</span> &lt;&lt; endl &lt;&lt; <span class="hljs-built_in">Empty</span>(list) &lt;&lt; endl;<br><br><span class="hljs-built_in">InsertNextNode</span>(list, <span class="hljs-number">1</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;成功在头结点之后插入元素1&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">InsertNextNode</span>(list, <span class="hljs-number">2</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;成功在头结点之后插入元素2&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">// 遍历</span><br>cout &lt;&lt; <span class="hljs-string">&quot;当前单链表元素：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">PrintList</span>(list);<br>cout &lt;&lt; <span class="hljs-string">&quot;==========================================&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;熟悉以上几个操作，下面介绍头插法创建单链表:&quot;</span> &lt;&lt; endl;<br><br>LinkList head_list;<br><br><span class="hljs-comment">// 使用头插法创建单链表</span><br><span class="hljs-built_in">HeadInsert</span>(head_list); <span class="hljs-comment">// 假如输入：3 2 1</span><br><span class="hljs-comment">// 遍历</span><br>cout &lt;&lt; <span class="hljs-string">&quot;当前单链表元素：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">PrintList</span>(head_list); <span class="hljs-comment">// 输出：1 2 3</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;==========================================&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;再介绍一种尾插法创建单链表:&quot;</span> &lt;&lt; endl;<br><br>LinkList tail_list;<br><br><span class="hljs-comment">// 使用尾插法创建单链表</span><br><span class="hljs-built_in">TailInsert</span>(tail_list);<span class="hljs-comment">// 假如输入：1 2 3</span><br><span class="hljs-comment">// 遍历</span><br>cout &lt;&lt; <span class="hljs-string">&quot;当前单链表元素：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">PrintList</span>(tail_list); <span class="hljs-comment">// 输出：1 2 3</span><br><br>LNode * p1 = <span class="hljs-built_in">GetElem</span>(tail_list, <span class="hljs-number">3</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;第3个位置的元素是：&quot;</span> &lt;&lt; p1 -&gt; data &lt;&lt; endl;<br><br><span class="hljs-comment">// 在第4个位置上插入元素4</span><br><span class="hljs-built_in">Insert</span>(tail_list, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;在第4个位置上插入元素4&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前单链表元素：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">PrintList</span>(tail_list); <span class="hljs-comment">// 输出：1 2 3 4</span><br><br><span class="hljs-comment">// 删除第4个位置上的元素</span><br><span class="hljs-built_in">Delete</span>(tail_list, <span class="hljs-number">4</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;删除单链表中第4个位置的元素&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前单链表元素：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">PrintList</span>(tail_list); <span class="hljs-comment">// 输出：1 2 3</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">此时单链表是否为空？(1代表是，0代表不是)<br>1<br>成功在头结点之后插入元素1<br>成功在头结点之后插入元素2<br>当前单链表元素：<br>2 1<br>==========================================<br>熟悉以上几个操作，下面介绍头插法创建单链表:<br>3 2 1 9999<br>当前单链表元素：<br>1 2 3<br>==========================================<br>再介绍一种尾插法创建单链表:<br>1 2 3 9999<br>当前单链表元素：<br>1 2 3<br>第3个位置的元素是：3<br>在第4个位置上插入元素4<br>当前单链表元素：<br>1 2 3 4<br>删除单链表中第4个位置的元素<br>当前单链表元素：<br>1 2 3<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">带头结点的单链表</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>顺序表</title>
    <link href="https://blog.phbeats.cn/posts/b854574263bd/"/>
    <id>https://blog.phbeats.cn/posts/b854574263bd/</id>
    <published>2023-07-05T17:35:17.000Z</published>
    <updated>2023-07-13T01:35:23.450Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序表的实现方式"><a href="#顺序表的实现方式" class="headerlink" title="顺序表的实现方式"></a>顺序表的实现方式</h3><p>实现方式：<code>静态分配</code>和<code>动态分配</code></p><wavy>根据观察，包括王道书上的算法设计题，绝大部分使用的是静态分配的顺序表，因此我使用同样的策略作为我的算法模板</wavy><h3 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp; list)</span><span class="hljs-comment">// 初始化顺序表</span></span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span><span class="hljs-comment">// 在顺序表的第i个(位序)上插入值e</span></span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp; e)</span><span class="hljs-comment">// 删除顺序表中第i个元素并返回其元素值e</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList list, <span class="hljs-type">int</span> i)</span><span class="hljs-comment">// 按位查找</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList list, <span class="hljs-type">int</span> e)</span><span class="hljs-comment">// 按值查找</span></span><br></code></pre></td></tr></table></figure><h3 id="顺序表的类型描述"><a href="#顺序表的类型描述" class="headerlink" title="顺序表的类型描述"></a>顺序表的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10; <span class="hljs-comment">//定义最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> data[MaxSize];       <span class="hljs-comment">//“静态”的数组存数据，存int数据</span><br>    <span class="hljs-type">int</span> length;              <span class="hljs-comment">//顺序表的当前长度</span><br>&#125;SqList;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化顺序表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 1.将表中所有元素赋值为0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++)&#123;<br>list.data[i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 2.将表的当前长度赋值为0</span><br>list.length = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在顺序表的第i个(位序)上插入值e</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-comment">// 1.判断插入位置合法性</span><br><span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; list.length + <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 2.判断表是否已经满了</span><br><span class="hljs-keyword">if</span>(list.length &gt;= MaxSize)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 3.合法插入</span><br><span class="hljs-comment">// 3.1 由于传入的是位序，因此插入时是在下标为 i - 1 的地方插入元素</span><br><span class="hljs-comment">// 3.2 将未插入前的表中，从 i - 1 开始，所有元素后移，给新元素腾出位置</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = list.length; j &gt;=i; j--)&#123;<br>list.data[j] = list.data[j - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">// 3.3 此时 i - 1 位置是空的，可以直接插入了</span><br>list.data[i - <span class="hljs-number">1</span>] = e;<br><span class="hljs-comment">// 插入成功，表长+1</span><br>list.length++;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除顺序表中第i个元素并返回其元素值e</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp; e)</span></span>&#123;<br><span class="hljs-comment">// 1.判断删除位置合法性，同时可以判断掉空表可能性</span><br><span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; list.length)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 2.记录删除元素</span><br>e = list.data[i - <span class="hljs-number">1</span>];<br><span class="hljs-comment">// 3.覆盖</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; list.length; j++)&#123;<br>list.data[j - <span class="hljs-number">1</span>] = list.data[j];<br>&#125;<br><span class="hljs-comment">// 4.删除成功</span><br>list.length--;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 按位查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList list, <span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-keyword">return</span> list.data[i - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 按值查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList list, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-comment">// 1.遍历全表，找到该元素为止</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++)&#123;<br><span class="hljs-keyword">if</span>(list.data[i] == e)<br><span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<span class="hljs-comment">// 返回的注意是位序哦！！！！</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 查找失败！</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10</span><br><br><span class="hljs-comment">// 静态分配的顺序表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br><span class="hljs-type">int</span> data[MaxSize];<br><span class="hljs-type">int</span> length; <span class="hljs-comment">// 顺序表当前长度</span><br>&#125;SqList;<br><br><span class="hljs-comment">// 初始化顺序表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 1.将表中所有元素赋值为0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++)&#123;<br>list.data[i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 2.将表的当前长度赋值为0</span><br>list.length = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在顺序表的第i个(位序)上插入值e</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-comment">// 1.判断插入位置合法性</span><br><span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; list.length + <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 2.判断表是否已经满了</span><br><span class="hljs-keyword">if</span>(list.length &gt;= MaxSize)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 3.合法插入</span><br><span class="hljs-comment">// 3.1 由于传入的是位序，因此插入时是在下标为 i - 1 的地方插入元素</span><br><span class="hljs-comment">// 3.2 将未插入前的表中，从 i - 1 开始，所有元素后移，给新元素腾出位置</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = list.length; j &gt;=i; j--)&#123;<br>list.data[j] = list.data[j - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">// 3.3 此时 i - 1 位置是空的，可以直接插入了</span><br>list.data[i - <span class="hljs-number">1</span>] = e;<br><span class="hljs-comment">// 插入成功，表长+1</span><br>list.length++;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 删除顺序表中第i个元素并返回其元素值e</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp; e)</span></span>&#123;<br><span class="hljs-comment">// 1.判断删除位置合法性，同时可以判断掉空表可能性</span><br><span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; list.length)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 2.记录删除元素</span><br>e = list.data[i - <span class="hljs-number">1</span>];<br><span class="hljs-comment">// 3.覆盖</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; list.length; j++)&#123;<br>list.data[j - <span class="hljs-number">1</span>] = list.data[j];<br>&#125;<br><span class="hljs-comment">// 4.删除成功</span><br>list.length--;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 按位查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList list, <span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-keyword">return</span> list.data[i - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">// 按值查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList list, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-comment">// 1.遍历全表，找到该元素为止</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++)&#123;<br><span class="hljs-keyword">if</span>(list.data[i] == e)<br><span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<span class="hljs-comment">// 返回的注意是位序哦！！！！</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 查找失败！</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(SqList list)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) cout &lt;&lt; list.data[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>SqList list;<br><br><span class="hljs-comment">// 初始化顺序表</span><br><span class="hljs-built_in">InitList</span>(list);<br><br><span class="hljs-comment">// 将元素插入顺序表中（将1这个元素插入顺序表中第一个位置）</span><br><span class="hljs-built_in">ListInsert</span>(list, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">ListInsert</span>(list, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">ListInsert</span>(list, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">ListInsert</span>(list, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;插入元素过后的顺序表中的元素有：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">PrintList</span>(list);<br><br><span class="hljs-comment">// 删除指定位序的元素，并返回被删除元素（删除第1个位置的元素）</span><br><span class="hljs-type">int</span> deletedElem;<br><span class="hljs-built_in">ListDelete</span>(list, <span class="hljs-number">1</span>, deletedElem);<br>cout &lt;&lt; <span class="hljs-string">&quot;被删除的元素是：&quot;</span> &lt;&lt; deletedElem &lt;&lt; endl;<br><br><span class="hljs-comment">// 按位查找</span><br>cout &lt;&lt; <span class="hljs-string">&quot;现在第一个元素是：&quot;</span>&lt;&lt; <span class="hljs-built_in">GetElem</span>(list, <span class="hljs-number">1</span>) &lt;&lt; endl;<br><br><span class="hljs-comment">// 按值查找</span><br>cout &lt;&lt; <span class="hljs-string">&quot;现在4这个元素在第 &quot;</span> &lt;&lt; <span class="hljs-built_in">LocateElem</span>(list, <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-string">&quot; 个位置上&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">// 打印顺序表</span><br><span class="hljs-built_in">PrintList</span>(list);<br>    <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">插入元素过后的顺序表中的元素有：<br>1 2 3 4<br>被删除的元素是：1<br>现在第一个元素是：2<br>现在4这个元素在第 3 个位置上<br>2 3 4<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">静态分配的顺序表</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>浅尝SeeSaw甜橙子手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/8635f45e7775/"/>
    <id>https://blog.phbeats.cn/posts/8635f45e7775/</id>
    <published>2023-06-27T06:18:50.000Z</published>
    <updated>2023-07-13T01:35:23.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>毕业季，最近比较忙，总算回家了。手冲器具都在家里，在学校搞不了手冲咖啡。</p><p>所以一回来，我就马上就买了两款咖啡豆，看咖啡评测似乎不错，但是自己不试试是不知道的。</p><p>这篇是<code>SeeSaw甜橙子</code>的评测，这篇只写主观评价，作为以后我是否会回购的依据。</p><p><img src="https://bu.dusays.com/2023/06/27/649a8529c469f.webp" alt="Screenshot_20230627_134637_com.taobao.taobao_edit"></p><p><img src="https://bu.dusays.com/2023/06/27/649a855845dd9.webp" alt="IMG_20230626_182450"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/06/27/649a8696b728d.webp" alt="IMG_20230627_135220"></p><p><img src="https://bu.dusays.com/2023/06/27/649a869c2ac12.webp" alt="IMG_20230627_135128"></p><p><img src="https://bu.dusays.com/2023/06/27/649a86a3a3585.webp" alt="IMG_20230627_135250"></p><p><img src="https://bu.dusays.com/2023/06/27/649a86e515e15.webp" alt="IMG_20230627_140635"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>香味十分浓郁，包装一打开我就猛一吸，我开心地笑了，因为很久没闻咖啡豆了（真该死，在学校带了豆子没带器具）。</p><p><code>SeeSaw甜橙子</code>给我的感觉，它的酸味很明显，喝了它不禁让我感觉<code>这是啥，这是水果咖啡吗？</code></p><p>它的酸味十分突出，仔细品会有细微柑橘的苦味（至于包装说的乌龙茶我倒是没感觉到），在强烈的酸味刺激下，会有回甘。<code>SeeSaw甜橙子喝的时候涩味不是很明显</code>入口很顺滑(如果加水过滤太多次，涩味还是会明显起来的)，我只过滤了两次。全部喝完，还是能感觉到微微涩味，但还是在能够接受的范围内。</p><p><code>SeeSaw甜橙子</code>作为一款浅烘焙的咖啡豆，我个人觉得还是太有个性了，让我怀疑它真的不是极浅烘焙咖啡豆？这也太酸了吧，<code>甜橙子</code>的<code>甜</code>是极酸作用产生的甜味，这种<code>个性</code>是把双刃剑。咖啡能够品出酸味，我会觉得很开心，每次都会让我觉得<code>咖啡果然是水果啊</code>。<code>SeeSaw甜橙子</code>一定说不上难喝，它很有趣，给我的味觉冲击很大，至于它好不好喝，我目前还无法给出明确评价，但它足以吊打以前我喝过的绝大部分百元内咖啡豆。</p><p>有意思的是瑕疵豆带来的口感影响我还能接受。</p><p><code>SeeSaw甜橙子</code>总体评价：极浅烘，过酸，好在我能够接受，性价比比较低。</p>]]></content>
    
    
    <summary type="html">浅尝SeeSaw甜橙子手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]34. 链表中环的入口结点</title>
    <link href="https://blog.phbeats.cn/posts/35d2359e9b06/"/>
    <id>https://blog.phbeats.cn/posts/35d2359e9b06/</id>
    <published>2023-06-06T14:07:19.000Z</published>
    <updated>2023-07-13T01:35:23.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-34-链表中环的入口结点"><a href="#AcWing-34-链表中环的入口结点" class="headerlink" title="[AcWing]34. 链表中环的入口结点"></a><a href="https://www.acwing.com/problem/content/86/">[AcWing]34. 链表中环的入口结点</a></h1><p>给定一个链表，若其中包含环，则输出环的入口节点。</p><p>若其中不包含环，则输出<code>null</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>节点 val 值取值范围 <code>[1,1000]</code>。<br>节点 val 值各不相同。<br>链表长度 <code>[0,500]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p><a href="https://www.acwing.com/media/article/image/2018/12/02/19_69ba6d14f5-QQ%E6%88%AA%E5%9B%BE20181202023846.png">!QQ截图20181202023846.png</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">给定如上所示的链表：<br>[1, 2, 3, 4, 5, 6]<br>2<br>注意，这里的2表示编号是2的节点，节点编号从0开始。所以编号是2的节点就是val等于3的节点。<br><br>则输出环的入口节点3.<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>y总讲这个题，听得我云里雾里，最终我放弃思考了，直接记住结论，开始写代码。</p><ol><li><code>慢指针一步一步走，快指针两步两步走</code></li><li><code>无环：快指针必定会先到达终点（NULL）</code></li><li><code>有环：俩指针会相遇，相遇之后，让慢指针回到起点，再让快慢指针同步速度，一步一步走</code></li><li><code>当再次相遇的时候，那个点就是环的入口</code></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">entryNodeOfLoop</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode * slow = head , * fast = head;<br>        <br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-comment">// 有环，相遇了</span><br>            <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果fast是空，那么代表无环，否则代表有环，并且slow == fast成立</span><br>        <span class="hljs-comment">// 而且，如果while循环条件一开始就没满足，那么代表head是空节点亦或者长度为1</span><br>        <span class="hljs-keyword">if</span>(!fast || !fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// slow == fast ， 有环</span><br>        <span class="hljs-comment">// 让slow回去，fast和slow以同样的速度走，再次相遇就是环的入口结点</span><br>        slow = head;<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            slow = slow -&gt; next;<br>            fast = fast -&gt; next;<br>        &#125;<br>        <span class="hljs-comment">// 再次相遇了</span><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]34. 链表中环的入口结点</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]29. 删除链表中重复的节点</title>
    <link href="https://blog.phbeats.cn/posts/448d550da686/"/>
    <id>https://blog.phbeats.cn/posts/448d550da686/</id>
    <published>2023-05-12T13:27:09.000Z</published>
    <updated>2023-07-13T01:35:23.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-29-删除链表中重复的节点"><a href="#AcWing-29-删除链表中重复的节点" class="headerlink" title="[AcWing]29. 删除链表中重复的节点"></a><a href="https://www.acwing.com/problem/content/27/">[AcWing]29. 删除链表中重复的节点</a></h1><p>在一个排序的链表中，存在重复的节点，请删除该链表中重复的节点，重复的节点不保留。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>链表中节点 val 值取值范围 <code>[0,100]</code>。<br>链表长度 <code>[0,100]</code>。</p><h4 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br><br>输出：1-&gt;2-&gt;5<br></code></pre></td></tr></table></figure><h4 id="样例2"><a href="#样例2" class="headerlink" title="样例2"></a>样例2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;1-&gt;1-&gt;2-&gt;3<br><br>输出：2-&gt;3<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/12/645e40746c07e.png" alt="image-20230512213440430"></p><p><img src="https://bu.dusays.com/2023/05/12/645e412839dba.png" alt="image-20230512213751300"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy -&gt; next = head;<br>        <br>        ListNode * p = dummy;<br>        <br>        <span class="hljs-comment">// 保证节点都不为空</span><br>        <span class="hljs-keyword">while</span>(p -&gt; next)&#123;<br>            <span class="hljs-comment">// 被检查的节点</span><br>            ListNode * q = p -&gt; next;<br>            <span class="hljs-comment">// 由于这是一个已被排序的链表，因此可以通过while循环筛掉一连串的节点</span><br>            <span class="hljs-comment">// 循环跳出的时候 q -&gt; next 就是新的需要被检查的元素，与 q 的值不同</span><br>            <span class="hljs-keyword">while</span>(q -&gt; next &amp;&amp; q -&gt; val == q -&gt; next -&gt; val) q = q -&gt; next;<br>            <span class="hljs-comment">// 如果没有重复的元素，while循环体不会执行，会出现下面这种情况</span><br>            <span class="hljs-comment">// 那么 q 元素是没有重复元素的，就让 p 前进</span><br>            <span class="hljs-comment">// 否则，被筛选了，p 直接跳跃至 q -&gt; next 这个新的需要被筛选元素</span><br>            <span class="hljs-keyword">if</span>(p -&gt; next == q) p = p -&gt; next;<br>            <span class="hljs-keyword">else</span> p -&gt; next = q -&gt; next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dummy -&gt; next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]29. 删除链表中重复的节点</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]28. 在O(1)时间删除链表结点</title>
    <link href="https://blog.phbeats.cn/posts/766b1c104395/"/>
    <id>https://blog.phbeats.cn/posts/766b1c104395/</id>
    <published>2023-05-11T13:28:58.000Z</published>
    <updated>2023-07-13T01:35:23.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-28-在O-1-时间删除链表结点"><a href="#AcWing-28-在O-1-时间删除链表结点" class="headerlink" title="[AcWing]28. 在O(1)时间删除链表结点"></a><a href="https://www.acwing.com/problem/content/85/">[AcWing]28. 在O(1)时间删除链表结点</a></h1><p>给定单向链表的一个节点指针，定义一个函数在O(1)时间删除该结点。</p><p>假设链表一定存在，并且该节点一定不是尾节点。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>链表长度 <code>[1,500]</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：链表 1-&gt;4-&gt;6-&gt;8<br>      删掉节点：第2个节点即6（头节点为第0个节点）<br><br>输出：新链表 1-&gt;4-&gt;8<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/11/645cf4ee045e4.png" alt="image-20230511213718985"></p><p><img src="https://bu.dusays.com/2023/05/11/645cf4f1ea571.png" alt="image-20230511214024756"></p><p><img src="https://bu.dusays.com/2023/05/11/645cf4e63b40d.png" alt="image-20230511214110079"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>        ListNode * q = node -&gt; next;<br>        ListNode * p = q -&gt; next;<br>        <br>        node -&gt; val = q -&gt; val;<br>        node -&gt; next = p;<br>        <span class="hljs-keyword">delete</span> q;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]28. 在O(1)时间删除链表结点</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]17. 从尾到头打印链表</title>
    <link href="https://blog.phbeats.cn/posts/7cd2155b1ef6/"/>
    <id>https://blog.phbeats.cn/posts/7cd2155b1ef6/</id>
    <published>2023-05-11T12:18:01.000Z</published>
    <updated>2023-07-13T01:35:23.450Z</updated>
    
    <content type="html"><![CDATA[<div class="note success simple"><p>你凭什么让别人相信你？</p></div><h1 id="AcWing-17-从尾到头打印链表"><a href="#AcWing-17-从尾到头打印链表" class="headerlink" title="[AcWing]17. 从尾到头打印链表"></a><a href="https://www.acwing.com/problem/content/18/">[AcWing]17. 从尾到头打印链表</a></h1><p>输入一个链表的头结点，按照 <strong>从尾到头</strong> 的顺序返回节点的值。</p><p>返回的结果用数组存储。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>0 ≤</code> 链表长度 <code>≤ 1000</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：[2, 3, 5]<br>返回：[5, 3, 2]<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>最简单的方法就是，直接遍历链表，然后存入<code>vector</code>，再利用库函数将其反转输出。<br>所以此处只写一下，递归函数法。<br>还是利用递归栈，出栈的时候将节点值塞入<code>vector</code>，这样就是逆序的了。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ListNode * head)</span></span>&#123;<br>        <span class="hljs-comment">// 出口</span><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 找到尾</span><br>        <span class="hljs-built_in">dfs</span>(head -&gt; next);<br>        <span class="hljs-comment">// 从尾到头放入res</span><br>        res.<span class="hljs-built_in">push_back</span>(head -&gt; val);<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printListReversingly</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(head);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]17. 从尾到头打印链表</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="链表" scheme="https://blog.phbeats.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>判断子序列</title>
    <link href="https://blog.phbeats.cn/posts/8dc10c9dd9e8/"/>
    <id>https://blog.phbeats.cn/posts/8dc10c9dd9e8/</id>
    <published>2023-05-05T12:08:34.000Z</published>
    <updated>2023-07-13T01:35:23.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2816-判断子序列"><a href="#2816-判断子序列" class="headerlink" title="2816. 判断子序列"></a><a href="https://www.acwing.com/problem/content/2818/">2816. 判断子序列</a></h1><p>给定一个长度为 <code>n</code> 的整数序列 <code>a1,a2,…,an</code> 以及一个长度为 <code>m</code> 的整数序列 <code>b1,b2,…,bm</code>。</p><p>请你判断 <code>a</code> 序列是否为 <code>b</code> 序列的子序列。</p><p>子序列指序列的一部分项按<strong>原有次序排列</strong>而得的序列，例如序列 <code>&#123;a1,a3,a5&#125;</code> 是序列 <code>&#123;a1,a2,a3,a4,a5&#125;</code> 的一个子序列。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <code>n,m</code>。</p><p>第二行包含 <code>n</code> 个整数，表示 <code>a1,a2,…,an</code>。</p><p>第三行包含 <code>m</code> 个整数，表示 <code>b1,b2,…,bm</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>如果 <code>a</code> 序列是 <code>b</code> 序列的子序列，输出一行 <code>Yes</code>。</p><p>否则，输出 <code>No</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ n ≤ m ≤ 10^5</code>,<br><code>-10^9 ≤ ai,bi ≤ 10^9</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 5<br>1 3 5<br>1 2 3 4 5<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Yes<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>a</code>序列和<code>b</code>序列同时进行遍历，直到某一个序列遍历完毕。</p><p>在这个过程中，如果<code>a</code>序列游标<code>i</code>和它长度相等，说明全部匹配，<code>a</code>序列是<code>b</code>的子序列</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[N], b[N], s[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) cin &gt;&gt; b[i];<br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; j &lt; m)&#123;<br>        <span class="hljs-keyword">if</span>(a[i] == b[j]) i++;<br>        <span class="hljs-comment">// 不敢怎样，j都要往后走，保证</span><br>        j++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(i == n) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">判断子序列</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="双指针" scheme="https://blog.phbeats.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>数组元素的目标和</title>
    <link href="https://blog.phbeats.cn/posts/d268782dc5be/"/>
    <id>https://blog.phbeats.cn/posts/d268782dc5be/</id>
    <published>2023-05-05T11:35:05.000Z</published>
    <updated>2023-07-13T01:35:23.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="800-数组元素的目标和"><a href="#800-数组元素的目标和" class="headerlink" title="800. 数组元素的目标和"></a><a href="https://www.acwing.com/problem/content/802/">800. 数组元素的目标和</a></h1><p>给定两个升序排序的有序数组 <code>A</code> 和 <code>B</code>，以及一个目标值 <code>x</code>。</p><p>数组下标从 <code>0</code> 开始。</p><p>请你求出满足 <code>A[i] + B[j] = x</code> 的数对 <code>(i, j)</code>。</p><p>数据保证有唯一解。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 <code>n,m,x</code>，分别表示 <code>A</code> 的长度，<code>B</code> 的长度以及目标值 <code>x</code>。</p><p>第二行包含 <code>n</code> 个整数，表示数组 <code>A</code>。</p><p>第三行包含 <code>m</code> 个整数，表示数组 <code>B</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含两个整数 <code>i</code> 和 <code>j</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>数组长度不超过 <code>10^5</code>。<br>同一数组内元素各不相同。<br><code>1 ≤ 数组元素 ≤ 10^9</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">4 5 6<br>1 2 4 7<br>3 4 6 8 9<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1 1<br></code></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>双指针算法，首先应该先想出暴力解法，然后根据单调性求解。（本文暴力不分析）</p><p>由于题中给出，两个升序序列<code>A</code>和<code>B</code>，且存在唯一解。我们可以得到如下性质：</p><p><img src="https://bu.dusays.com/2023/05/05/6454ed463355d.png" alt="image-20230505194642740"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> A[N], B[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, m, x;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; A[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) cin &gt;&gt; B[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = m - <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; A[i] + B[j] &gt; x) j--;<br>        <span class="hljs-keyword">if</span>(A[i] + B[j] == x) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数组元素的目标和</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="双指针" scheme="https://blog.phbeats.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>最长连续不重复子序列</title>
    <link href="https://blog.phbeats.cn/posts/471596286a1c/"/>
    <id>https://blog.phbeats.cn/posts/471596286a1c/</id>
    <published>2023-05-04T12:39:49.000Z</published>
    <updated>2023-07-13T01:35:23.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="双指针算法核心思想"><a href="#双指针算法核心思想" class="headerlink" title="双指针算法核心思想"></a>双指针算法核心思想</h3><p>原本两个指针是有 n<sup>2</sup> 种组合，因此时间复杂度是 O(n<sup>2</sup>) 。<br>而双指针算法就是运用单调性使得指针只能单向移动，因此总的时间复杂度只有 O(2n) ，也就是O(n)。</p><p>之所以双指针可以实现 O(n) 的时间复杂度是因为指针只能单向移动，没有指针的回溯，而且每一步都会有指针移动。</p><p>而朴素的 O(n<sup>2</sup>) 算法的问题就在于指针经常<strong>回溯到之前的位置</strong>。</p><p>双指针算法的模板一般都可以写成下面的形式(模板)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>    <span class="hljs-comment">// check是满足某种性质</span><br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j++;<br><br>    <span class="hljs-comment">// 每道题目的具体逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="799-最长连续不重复子序列"><a href="#799-最长连续不重复子序列" class="headerlink" title="799. 最长连续不重复子序列"></a><a href="https://www.acwing.com/problem/content/801/">799. 最长连续不重复子序列</a></h1><p>给定一个长度为 <code>n</code> 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>n</code>。</p><p>第二行包含 <code>n</code> 个整数（均在 <code>0 ~ 10^5</code> 范围内），表示整数序列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ n ≤ 10^5</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5<br>1 2 2 3 5<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><ol><li>无脑暴力求解（不作解释）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> l , <span class="hljs-type">int</span> r )</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l ; i &lt;= r ; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = l ; j &lt; i ; j++)&#123;<br>            <span class="hljs-keyword">if</span>(q[i] == q[j]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; i ; j++)&#123;<br>            <span class="hljs-comment">// 判断区间 [j,i] 是否有重复元素,没有重复元素就返回结果 check代表成功</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(j,i) == <span class="hljs-number">1</span>) res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这种会TLE。</p><h3 id="双指针算法思想"><a href="#双指针算法思想" class="headerlink" title="双指针算法思想"></a>双指针算法思想</h3><p>可以考虑，使用<code>i</code>作为终点，<code>j</code>作为起点，让<code>j</code>去追赶<code>i</code>。</p><p><code>j</code>与<code>i</code>在这个过程，如果是不同序列，那么就让<code>i</code>一直走。</p><p>如果遇到了重复序列，就让<code>j</code>去追赶<code>i</code>，直到这个重复序列结束，然后计算<code>i - j + 1</code>就是<code>最长连续，但不重复的子序列长度</code>。</p><p><strong>代码实现提示：对每个整数进行桶计数。</strong></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> a[N], s[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br>    <span class="hljs-comment">// i和j下标最远距离</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> , j = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-comment">// 对 a[i] 进行桶计数</span><br>        s[a[i]]++;<br><br>        <span class="hljs-comment">// 跳过重复序列，s[a[i]]≥2的时候才可能触发，也就是进入了重复序列片段</span><br>        <span class="hljs-keyword">while</span>(s[a[i]] &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// a[j]如果等于a[i]自然也就是剔除重复序列</span><br>            s[a[j]]--;<br>            j++;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 只保留 i 和 j 相隔最远的距离。</span><br>        <span class="hljs-comment">// 即，最长连续，但不重复的子序列长度。</span><br>        res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">最长连续不重复子序列</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="双指针" scheme="https://blog.phbeats.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>[差分]差分矩阵</title>
    <link href="https://blog.phbeats.cn/posts/255d64b2bba3/"/>
    <id>https://blog.phbeats.cn/posts/255d64b2bba3/</id>
    <published>2023-05-03T13:38:18.000Z</published>
    <updated>2023-07-13T01:35:23.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的值加上<code>c</code>,是否也可以达到<code>O(1)</code>的时间复杂度。答案是可以的，考虑二维差分。<br><code>a[][]</code>数组是<code>b[][]</code>数组的前缀和数组，那么<code>b[][]</code>是<code>a[][]</code>的差分数组</p><p>原数组： <code>a[i][j]</code></p><p>我们去构造差分数组： <code>b[i][j]</code></p><p>使得<code>a</code>数组中<code>a[i][j]</code>是<code>b</code>数组左上角<code>(1,1)</code>到右下角<code>(i,j)</code>所包围矩形元素的和。</p><p><img src="https://bu.dusays.com/2023/05/03/64527be20518e.png" alt="image-20230503232104902"></p><h1 id="798-差分矩阵"><a href="#798-差分矩阵" class="headerlink" title="798. 差分矩阵"></a><a href="https://www.acwing.com/problem/content/description/800/">798. 差分矩阵</a></h1><p>输入一个 <code>n</code> 行 <code>m</code> 列的整数矩阵，再输入 <code>q</code> 个操作，每个操作包含五个整数 <code>x1, y1, x2, y2, c</code>，其中 <code>(x1, y1)</code> 和 <code>(x2, y2)</code> 表示一个子矩阵的左上角坐标和右下角坐标。</p><p>每个操作都要将选中的子矩阵中的每个元素的值加上 <code>c</code>。</p><p>请你将进行完所有操作后的矩阵输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 <code>n,m,q</code>。</p><p>接下来 <code>n</code> 行，每行包含 <code>m</code> 个整数，表示整数矩阵。</p><p>接下来 <code>q</code> 行，每行包含 <code>5</code> 个整数 <code>x1, y1, x2, y2, c</code>，表示一个操作。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 <code>n</code> 行，每行 <code>m</code> 个整数，表示所有操作进行完毕后的最终矩阵。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ n,m ≤ 1000</code>,<br><code>1 ≤ q ≤ 100000</code>,<br><code>1 ≤ x1 ≤ x2 ≤ n</code>,<br><code>1 ≤ y1 ≤ y2 ≤ m</code>,<br><code>-1000 ≤ c ≤ 1000</code>,<br><code>-1000 ≤ 矩阵内元素的值 ≤ 1000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 4 3<br>1 2 2 1<br>3 2 2 1<br>1 1 1 1<br>1 1 2 2 1<br>1 3 2 3 2<br>3 1 3 4 1<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">2 3 4 1<br>4 3 4 1<br>2 2 2 2<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> a[N][N], b[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, m, q;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            cin &gt;&gt; a[i][j];<br>            <br>    <span class="hljs-comment">// 求差分数组，类比一维数组求差分</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            b[i][j] = a[i][j] - a[i - <span class="hljs-number">1</span>][j] - a[i][j - <span class="hljs-number">1</span>] + a[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <br>    <span class="hljs-keyword">while</span>(q --)&#123;<br>        <span class="hljs-type">int</span> x1, y1, x2, y2, c;<br>        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;<br>        b[x1][y1] += c;<br>        b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>        b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>        b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 求差分数组的前缀和，并且输出</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>            b[i][j] += b[i - <span class="hljs-number">1</span>][j] + b[i][j - <span class="hljs-number">1</span>] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], cout &lt;&lt; b[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p><a href="https://www.acwing.com/solution/content/27325/">林小鹿</a></p>]]></content>
    
    
    <summary type="html">[差分]差分矩阵</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="差分" scheme="https://blog.phbeats.cn/tags/%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>差分</title>
    <link href="https://blog.phbeats.cn/posts/254738f560c0/"/>
    <id>https://blog.phbeats.cn/posts/254738f560c0/</id>
    <published>2023-05-03T13:38:18.000Z</published>
    <updated>2023-07-13T01:35:23.446Z</updated>
    
    <content type="html"><![CDATA[<div class="note success simple"><p>你必须坚持，因为你已经做出了选择了，不是吗？</p></div><h3 id="差分应用场景"><a href="#差分应用场景" class="headerlink" title="差分应用场景"></a>差分应用场景</h3><p>对区间内频繁地对数组中某个区间进行同一操作。例如将序列中[l, r]之间的每个数加上c这一操作，可能执行n次，每次的c不同，如果对原数组进行操作，每次操作都会花费O(n)的时间复杂度。如果使用该数组的差分数组进行操作，每次操作为O(1)。<br>然后求差分数组的前缀和即为所求结果。</p><h3 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h3><p>首先给定一个原数组<code>a[]</code>：a[1], a[2], a[3], … , a[n];</p><p>然后我们构造一个数组<code>b[]</code>： b[1] ,b[2] , b[3], … , b[i];</p><p>使得 <code>a[i] = b[1] + b[2 ]+ b[3] +,..., + b[i]</code></p><p>也就是说，<code>a</code>数组是<code>b</code>数组的前缀和数组，反过来我们把<code>b</code>数组叫做<code>a</code>数组的差分数组。换句话说，每一个<code>a[i]</code>都是<code>b</code>数组中从头开始的一段区间和。</p><p>考虑如何构造差分<code>b</code>数组？</p><p>最为直接的方法</p><p><code>a[0]= 0;</code></p><p><code>b[1] = a[1] - a[0];</code></p><p><code>b[2] = a[2] - a[1];</code></p><p><code>b[3] =a [3] - a[2];</code></p><p><code>........</code></p><p><code>b[n] = a[n] - a[n-1];</code></p><h3 id="差分数组的使用？"><a href="#差分数组的使用？" class="headerlink" title="差分数组的使用？"></a>差分数组的使用？</h3><p>给定区间<code>[l ,r ]</code>，让我们把<code>a</code>数组中的<code>[ l, r]</code>区间中的每一个数都加上<code>c</code>。</p><p>由于<code>a</code>数组是<code>b</code>数组的<code>前缀和</code>，所以有这样的一个性质：</p><p><img src="https://bu.dusays.com/2023/05/03/6452681e9318d.png" alt="image-20230503215308523"></p><p>抽象的来说：</p><p><img src="https://bu.dusays.com/2023/05/03/645268225b877.png" alt="image-20230503215648039"></p><h1 id="797-差分"><a href="#797-差分" class="headerlink" title="797. 差分"></a><a href="https://www.acwing.com/problem/content/799/">797. 差分</a></h1><p>输入一个长度为 <code>n</code> 的整数序列。</p><p>接下来输入 <code>m</code> 个操作，每个操作包含三个整数 <code>l, r, c</code>，表示将序列中 <code>[l, r]</code> 之间的每个数加上 <code>c</code>。</p><p>请你输出进行完所有操作后的序列。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <code>n</code> 和 <code>m</code>。</p><p>第二行包含 <code>n</code> 个整数，表示整数序列。</p><p>接下来 <code>m</code> 行，每行包含三个整数 <code>l，r，c</code>，表示一个操作。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 <code>n</code> 个整数，表示最终序列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ n,m ≤ 100000</code>,<br><code>1 ≤ l ≤ r ≤ n</code>,<br><code>-1000 ≤ c ≤ 1000</code>,<br><code>-1000 ≤ 整数序列中元素的值 ≤ 1000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">6 3<br>1 2 2 1 2 1<br>1 3 1<br>3 5 1<br>1 6 1<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 4 5 3 4 2<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-comment">// 求差分数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) b[i] = a[i] - a[i - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> l, r, c;<br>        cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;<br>        <span class="hljs-comment">// 在[l, r]区间的元素都 + c</span><br>        b[l] += c;<br>        b[r + <span class="hljs-number">1</span>] -= c;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 求一遍前缀和输出</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) b[i] += b[i - <span class="hljs-number">1</span>], cout &lt;&lt; b[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p><a href="https://www.acwing.com/solution/content/26588/">林小鹿</a></p>]]></content>
    
    
    <summary type="html">差分</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="差分" scheme="https://blog.phbeats.cn/tags/%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>[前缀和]子矩阵的和</title>
    <link href="https://blog.phbeats.cn/posts/0607b1e0bdb9/"/>
    <id>https://blog.phbeats.cn/posts/0607b1e0bdb9/</id>
    <published>2023-05-03T13:00:21.000Z</published>
    <updated>2023-07-13T01:35:23.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="796-子矩阵的和"><a href="#796-子矩阵的和" class="headerlink" title="796. 子矩阵的和"></a><a href="https://www.acwing.com/problem/content/798/">796. 子矩阵的和</a></h1><p>输入一个 <code>n</code> 行 <code>m</code> 列的整数矩阵，再输入 <code>q</code> 个询问，每个询问包含四个整数 <code>x1, y1, x2, y2</code>，表示一个子矩阵的左上角坐标和右下角坐标。</p><p>对于每个询问输出子矩阵中所有数的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 <code>n，m，q</code>。</p><p>接下来 <code>n</code> 行，每行包含 <code>m</code> 个整数，表示整数矩阵。</p><p>接下来 <code>q</code> 行，每行包含四个整数 <code>x1, y1, x2, y2</code>，表示一组询问。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 <code>q</code> 行，每行输出一个询问的结果。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ n,m ≤ 1000</code>,<br><code>1 ≤ q ≤ 200000</code>,<br><code>1 ≤ x1 ≤ x2 ≤ n</code>,<br><code>1 ≤ y1 ≤ y2 ≤ m</code>,<br><code>-1000 ≤ 矩阵内元素的值 ≤ 1000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 4 3<br>1 7 2 4<br>3 6 2 8<br>2 1 2 3<br>1 1 2 2<br>2 1 3 4<br>1 3 3 4<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">17<br>27<br>21<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/03/64526352163b6.png" alt="image-20230503211519377"></p><p><img src="https://bu.dusays.com/2023/05/03/645263574b964.png" alt="image-20230503213325665"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n , m , q , s[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j++)<br>            cin &gt;&gt; s[i][j];<br>    <span class="hljs-comment">// 计算前缀和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j++)<br>            s[i][j] += s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <br>    <span class="hljs-keyword">while</span>(q --)&#123;<br>        <span class="hljs-type">int</span> x1, y1 , x2 , y2;<br>        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;<br>        <span class="hljs-comment">// 输出区间和</span><br>        cout &lt;&lt; s[x2][y2] - s[x2][y1 - <span class="hljs-number">1</span>] - s[x1 - <span class="hljs-number">1</span>][y2] + s[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[前缀和]子矩阵的和</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="前缀和" scheme="https://blog.phbeats.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>前缀和</title>
    <link href="https://blog.phbeats.cn/posts/4c155c76f2b7/"/>
    <id>https://blog.phbeats.cn/posts/4c155c76f2b7/</id>
    <published>2023-05-03T03:33:21.000Z</published>
    <updated>2023-07-13T01:35:23.446Z</updated>
    
    <content type="html"><![CDATA[<div class="note success simple"><p>我知道你很累了，但是再坚持一下好吗？</p></div><h3 id="前缀和有什么用？"><a href="#前缀和有什么用？" class="headerlink" title="前缀和有什么用？"></a>前缀和有什么用？</h3><p>前缀和是一种预处理，用于降低查询时的时间复杂度。 举个例子：给定 n 个整数，然后进行 m 次询问，每次询问求一个区间内值的和。</p><p>如果用暴力写法，那每次询问都需要从区间左端点循环到区间右端点求和，时间复杂度较大。</p><p>但是如果使用前缀和就可以将它降到<code>O(n + m)</code>。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/03/645257b375e96.png" alt="image-20230503115839749"></p><h1 id="795-前缀和"><a href="#795-前缀和" class="headerlink" title="795. 前缀和"></a><a href="https://www.acwing.com/problem/content/797/">795. 前缀和</a></h1><p>输入一个长度为 <code>n</code> 的整数序列。</p><p>接下来再输入 <code>m</code> 个询问，每个询问输入一对 <code>l, r</code>。</p><p>对于每个询问，输出原序列中从第 <code>l</code> 个数到第 <code>r</code> 个数的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <code>n</code> 和 <code>m</code>。</p><p>第二行包含 <code>n</code> 个整数，表示整数数列。</p><p>接下来 <code>m</code> 行，每行包含两个整数 <code>l</code> 和 <code>r</code>，表示一个询问的区间范围。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 <code>m</code> 行，每行输出一个询问的结果。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ l ≤ r ≤ n</code>,<br><code>1 ≤ n,m ≤ 100000</code>,<br><code>-1000 ≤ 数列中元素的值 ≤ 1000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 3<br>2 1 3 6 4<br>1 2<br>1 3<br>2 4<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br>6<br>10<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[N], s[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-comment">// 计算前缀和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br>    <br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> l , r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        cout &lt;&lt; s[r] - s[l - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前缀和</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="前缀和" scheme="https://blog.phbeats.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>高精度除法</title>
    <link href="https://blog.phbeats.cn/posts/ca4465c5974d/"/>
    <id>https://blog.phbeats.cn/posts/ca4465c5974d/</id>
    <published>2023-04-28T14:41:04.000Z</published>
    <updated>2023-07-13T01:35:23.450Z</updated>
    
    <content type="html"><![CDATA[<div class="note success simple"><p>再学完这个知识点，我再休息</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/01/644f6b6cb6fda.png" alt="image-20230428224911582"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp; r)</span></span>&#123;<br>    <span class="hljs-comment">// 默认A大于b</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 除法是从最高位开始 &lt;-</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 保存的时候是从高到低，需要反转一下</span><br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    <span class="hljs-type">int</span> r; <span class="hljs-comment">// 余数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">div</span>(A, b, r);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>    <br>    cout &lt;&lt; endl &lt;&lt; r;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">高精度除法</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="高精度算法" scheme="https://blog.phbeats.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>高精度乘法</title>
    <link href="https://blog.phbeats.cn/posts/d222ff48c8bc/"/>
    <id>https://blog.phbeats.cn/posts/d222ff48c8bc/</id>
    <published>2023-04-28T13:39:39.000Z</published>
    <updated>2023-07-13T01:35:23.450Z</updated>
    
    <content type="html"><![CDATA[<div class="note success simple"><p>学累了就出去走走吧</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/01/644f6b65b32ba.png" alt="image-20230428221023505"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-comment">// 默认A 大于 b</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果t很大可能会留有剩余</span><br>    <span class="hljs-keyword">while</span>(t)&#123;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 去除前导0</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">mul</span>(A, b);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">高精度乘法</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="高精度算法" scheme="https://blog.phbeats.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>高精度减法</title>
    <link href="https://blog.phbeats.cn/posts/c87c248906c2/"/>
    <id>https://blog.phbeats.cn/posts/c87c248906c2/</id>
    <published>2023-04-28T13:02:27.000Z</published>
    <updated>2023-07-13T01:35:23.450Z</updated>
    
    <content type="html"><![CDATA[<div class="note success simple"><p>不要有强迫症，面对眼前的难题，可以跳过，回头再处理。</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><img src="https://bu.dusays.com/2023/05/01/644f6b58d3634.png" alt="image-20230428213513607"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b5d16368.png" alt="image-20230428213521595"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 比较两个数谁大谁小，如果A大于B返回true，反之</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span>&#123;<br>    <span class="hljs-comment">// 如果两个数字位数不同</span><br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 如果两个数字位数相同，直接从最高位开始比较 方向提示：&lt;-</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span>(B[i] != A[i])<br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>            <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span>&#123;<br>    <span class="hljs-comment">// A一定是大于B的</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <br>    <span class="hljs-comment">// 进位</span><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 去除高位0，同时要保证结果长度大于1，不能1 - 1 = 0把答案0也给消了</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    string a, b;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-comment">// 如果A比B大</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A, B))&#123;<br>        C = <span class="hljs-built_in">sub</span>(A, B);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>        <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 如果A比B小</span><br>        C = <span class="hljs-built_in">sub</span>(B, A);<br>        <span class="hljs-comment">// 还需要输出减号</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">高精度减法</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="高精度算法" scheme="https://blog.phbeats.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>高精度加法</title>
    <link href="https://blog.phbeats.cn/posts/759ae4655658/"/>
    <id>https://blog.phbeats.cn/posts/759ae4655658/</id>
    <published>2023-04-27T12:13:25.000Z</published>
    <updated>2023-07-13T01:35:23.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><div class="note success simple"><p>你有下大雨去网吧的勇气，却没有下小雨去图书馆的勇气吗</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用数组模拟平常我们的竖式计算。例如：</p><p><img src="https://bu.dusays.com/2023/05/01/644f6b0aa04aa.png" alt="image-20230427202700060"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b12b49a4.png" alt="image-20230428202609403"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b186bf4d.png" alt="image-20230428203007184"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b1e05ea1.png" alt="image-20230428203255775"></p><p><img src="https://bu.dusays.com/2023/05/01/644f6b2160933.png" alt="image-20230428203857482"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span>&#123;<br>    <span class="hljs-comment">// 为了方便计算，让A中保存较长的数字， B中保存较短的数字</span><br>    <span class="hljs-keyword">if</span>(B.<span class="hljs-built_in">size</span>() &gt; A.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br>    <br>    <span class="hljs-comment">// 保存最终的结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <br>    <span class="hljs-comment">// 以 A 为基准，开始按位计算</span><br>    <span class="hljs-comment">// 每位的进位</span><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        t += A[i];<br>        <span class="hljs-comment">// 如果B位置还没遍历完</span><br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        <span class="hljs-comment">// 9 + 9 = 18, 1 + 2 = 3。取余即可，进位交给 t /= 10 做</span><br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 如果是18, 那么下次t初始值会变成1</span><br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">// 最终，还需要判断进位上是否还有数</span><br>    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 字符串形式读取两个数</span><br>    string a, b;<br>    <br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-comment">// 用来保存两个数字</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>    <span class="hljs-comment">// 倒序保存，记得转数字</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">add</span>(A, B);<br>    <br>    <span class="hljs-comment">// 输出计算之后的结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; C[i];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">高精度加法</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="高精度算法" scheme="https://blog.phbeats.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
