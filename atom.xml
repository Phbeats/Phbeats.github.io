<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phbeats-Blog</title>
  
  <subtitle>记录学习历程和生活感悟</subtitle>
  <link href="https://blog.phbeats.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.phbeats.cn/"/>
  <updated>2024-04-20T13:06:17.226Z</updated>
  <id>https://blog.phbeats.cn/</id>
  
  <author>
    <name>Phbeats</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[AcWing]842. 全排列数字</title>
    <link href="https://blog.phbeats.cn/posts/2eede509a240/"/>
    <id>https://blog.phbeats.cn/posts/2eede509a240/</id>
    <published>2024-04-19T11:55:28.000Z</published>
    <updated>2024-04-20T13:06:17.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-842-全排列数字"><a href="#AcWing-842-全排列数字" class="headerlink" title="[AcWing]842. 全排列数字"></a><a href="https://www.acwing.com/problem/content/844/">[AcWing]842. 全排列数字</a></h1><p>给定一个整数 <code>n</code>，将数字 <code>1 ~ n</code> 排成一排，将会有很多种排列方法。</p><p>现在，请你按照字典序将所有的排列方法输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个整数 <code>n</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>按字典序输出所有排列方案，每个方案占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 \le n \le 7</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>此题，适合用来理解<code>DFS</code>。<code>DFS</code>可以用<code>树</code>模型来理解。</p><p><img src="https://bu.dusays.com/2024/04/19/6622634b9d95a.png" alt="image-20240419202755100"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n; <span class="hljs-comment">// 多少位数字</span><br><span class="hljs-type">int</span> path[N]; <span class="hljs-comment">// 装数字</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 在DFS的过程中，数字是否已经被用过了</span><br><br><span class="hljs-comment">// 参数:当前递归是确定第 u 位（从左往右看）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-comment">// 从图看出来的。</span><br>    <span class="hljs-comment">// 第一层确定第 1 位数字，第n层确定第 n 层的数字。</span><br>    <span class="hljs-keyword">if</span>(u == n)&#123;<br>        <span class="hljs-comment">// 确定完毕，输出</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            cout &lt;&lt; path[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// u &lt; n 的情况，在递归中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-comment">// 这个数字，没有被用过</span><br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            <span class="hljs-comment">// 用一下，这个数字已经用过了，并且放入path里面展示</span><br>            st[i] = <span class="hljs-literal">true</span>;<br>            path[u] = i;<br>            <span class="hljs-comment">// 递归下一位</span><br>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 回溯的时候，恢复现场</span><br>            <span class="hljs-comment">// 因为有数字回退，回溯完，下一次递归需要使用新的path和st。</span><br>            <span class="hljs-comment">// path[i] = 0; 可以写，也可以不写，严格来说要写。</span><br>            st[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 全排列数字n</span><br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-comment">// 从第 0 位开始（从左往右）</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]842. 全排列数字</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="DFS" scheme="https://blog.phbeats.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]3766. 二叉树的带权路径长度</title>
    <link href="https://blog.phbeats.cn/posts/6049e4bb40ad/"/>
    <id>https://blog.phbeats.cn/posts/6049e4bb40ad/</id>
    <published>2024-04-17T12:17:11.000Z</published>
    <updated>2024-04-20T13:06:17.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3766-二叉树的带权路径长度"><a href="#AcWing-3766-二叉树的带权路径长度" class="headerlink" title="[AcWing]3766. 二叉树的带权路径长度"></a><a href="https://www.acwing.com/problem/content/3769/">[AcWing]3766. 二叉树的带权路径长度</a></h1><p>二叉树的带权路径长度(WPL)是二叉树中所有叶结点的带权路径长度之和，也就是每个叶结点的深度与权值之积的总和。</p><p>给定一棵二叉树 <code>T</code>，请你计算并输出它的 WPL。</p><p>注意，根节点的深度为 <code>0</code>。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">输入：二叉树[<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]如下图所示：<br>    <span class="hljs-number">8</span><br>   / \<br>  <span class="hljs-number">12</span>  <span class="hljs-number">2</span><br>     / \<br>    <span class="hljs-number">6</span>   <span class="hljs-number">4</span><br><br>输出：<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>二叉树结点数量不超过 <code>1000</code>。<br>每个结点的权值均为不超过 <code>100</code> 的非负整数。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><code>从根结点到各叶结点的路径长度</code> * <code>相应叶节点权值</code> 之和。</p><p><img src="https://bu.dusays.com/2024/04/17/661fc561aba08.png" alt="image-20240417204932311"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 只结算叶子结点的</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right) <span class="hljs-keyword">return</span> depth * root -&gt; val;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root -&gt; left, depth + <span class="hljs-number">1</span>) + <span class="hljs-built_in">dfs</span>(root -&gt; right, depth + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3766. 二叉树的带权路径长度</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>第三周总结(4/15 - 4/21)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/e3b1009c0e89/"/>
    <id>https://blog.phbeats.cn/posts/e3b1009c0e89/</id>
    <published>2024-04-14T13:45:42.000Z</published>
    <updated>2024-04-20T13:06:17.222Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="02aca811f56ebe63d47b708eda0b8b61f898f4c1c44464cbbf3ed28aa7c5d3bd">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814d2b442d5d57a8a1951978d9635e2a48b4ded424e00212e73fc5a3d8aba0ecae59698a3711542c20c3ddcab60165cfc56be82b5c60b0812e64082439dc1fdd18fe5db88e3baba417f4a1537df105e8702028de40e40817343b03654b548d7079c96160c52d602c9e2bdafeeb15e69919d159096053356a84a17c8833b394fa79d06932aa0d4979f14e1a11ce96fe9f29d398054b676644f7b3105e64a9ef1153818f9eb19cad9deabad3579d8cf2cda24525d34fbf4132c2195bdfa591a786f06cd4883b750a10e1e75b3107d92ebe01cccce7b36e2f6d7de0b2d6fef14b49b4a352373cea646ec8b7c5bcf94228a261f24fb036e4c25db5758d72924878ce91e1930a454ee0ef97c926dbf965e1ded2bffd86de66984127894ca8ebc7576fbf6fc1a13af54d3bd1fbcff9e4dbb51be0a6ccc189b08f6566e7ada89682b2006e300f7fc661e9a2cdae977c0ce163f8832c52405b82aa98bad124ad852b619364c5af4d34a1da58caf436ab5156a60e46518ef07e49f265f7fe822326d692d3c4e1b3b9cf3bbfaf912ab50eaa5b422f163bb3cad0192f44122dd37246a8b5326f0fa6a682a875fb461e72809b8777f2a5c76c75957f032338edeb590626dd02e63128536f6cc847e62cb7356c92ff3c9b74a6ae26d8f7dd6d2905a325c7afab5a9f2aa412f81d88dcbbe350129360f101c76ad4192453224987161f718151a0a4f77dd4b7a6331966b45707daec6f243aced6c6acd7ea5e15823b3b7ad56ec90dd5cafae95be2e4515956ff180775c5f347aa38ace25fd8139b8b034d26d1e953fe2c18bfd22321f6eda1ea552608564745cd925f3bdf1c7dc11f909e5bfec206519383f2733b81ba9e73a8723a5eda47ffca8b28e80af63e71c5fb4514a05cab3af59c5d0bb09ded30c8880b8920968f6e88c5d95c255ebefce94c004b45cf26de4ab9e5f6ba0cc4cd73f8d871813adba8453861b2b57b0d16652b1bf17ce746b42c2fcae5c46264d12f372ba09ba6cbbbaa8b0da6693cd33690077bcacf422bfba373059e7ae4ecda11f89cdd91fef4120220c146e0f08a6b20c43fdc8974b55dcf78cd9da62292ca580d78b2040bad806c5632df977ad429695ccfe6cb18f17e168cfb0125635aa74a9e504423ab785af10eef64ae66af9642e796547dfa8225dd89c46d254e4b2acd9a34c5c1d224c3c1a33b3142162f76ec0b4565bde5d1c39dcc2b2b8a092cf0569585f06018c078173d24f124f1f848e20f880182b798bdbcf2d4b3e542c61d185a593a82cff700f06338eb0572dbe5621e9ade3e845d1634c38edc587a4cdb23299d7ddc1acd3e54ab20f52f4d764515abd6ab6188e1c7cecfe95d873788646703f146749b3af53d841ee412121c4504a8d0e97131d4b5ba10c0b9a0390376fc6a34d570e8a69c00fafe4fb350def1a59f8d42bbcfbc10cd1b16b52252ab57a3abc8df35664394d4bad27a6ccedceb870e9700644bc7c273281a65428f69a4b072ec059c7fc02fc5b5e365d8bb854767300c7bcbc378cc46d8d0e1705e8ff0cff1eb212d4a2577f0751c5fa00fbd47aaddbea91b81ffbf0ecafb306eb3e56ba8185709d2766a7904ca52fbf4d54db3e3f5add66f22660246f9325256ee425665112ec1e4fe818988420e4d5866e5efb03817ecc6dbc24562ceaf176097912fd10cf318312660974b9175aab597094361f045dd0391cf2fd711bbd440077d5b72a9eeb3a53dabc74f15796f5fcee22c21dac85946cd0e7578f51d30b5b5951fb67b674eefc6fd82280ac27abf57654820d484b3715ce06282c6eb9edef2e070264a690041b56954ad288e2855254d4f341316d4dbd0f95f2d5f05455c622293b671ff547b355d6994fa88ae5929b15ce3caac8423b3147b26c21a2793a3a240e57d632b6b17c33f63fe467bb89fe7bbf5d10fc4649a5ed741d92e13901b0280b3606fa6df2f7b9b1a813f700ed35161209b24a337b0c256d41a65a27eb97b7b393cf86b0fdb3359756c72ba8fbcde59b4edf87c17c1e739809e02c901d537669891029d3c51c558716fa1477bb3734258273b99555e1be953d7adfa997b44e90e918f6276fe0977157f127d8dd9525fb7ab893d3cef0de16b5ccec925890289f47e9f0de18898021c016e15877a172c67506dbda3b6877618b73d7f4ce8af368ed3d1b4d6b63be64ca3a6c18a9e6fdc31e731e5fa8fa9cab246645bb992fd3c686d67a9cf461dd3b664eb3b3bd20fe4d6ade9b917163ba12db2b451113c47c79b1f22614a0271f7daaa580d2b44c3ebdc3afc1f8c1732aebff6c7428c5e46f198543a93b89255fcfd052b506a7ae20082e429cff04fe0d4c45072d11b958c6fc8bf5630cb84f46daee349cfb66cee25f1fde197a003f9d20e5b0bfa168536f8b636f6ca70cb04e4ab86327cf2a49e065c331d70dff0cafbcc486edcb904867c692644ff833bda6879419980003dfae4092f8a2c7dc79399b15e9df8f4fa532e486ea60b6862674d40db26c9de697bd30701b895dd4bfdf4e549b25cbd11fa0317ba42abe4fdd09a864a9a58ea2d9413dd854490a4559c85156fc8811944014cb41308e903b679421d470071c8488a0d1848128c294c61bfe8af89784f1b0aa7ca14a12418ea1da1335935a0c4c79439967b1bd285d5e5ab683dd5cd5c0e35343b0f5959149acbf4826cebf1ebd7719607bba41f2a7a5b87458a1f5d331a8fee40d7ec52d1e7a95e5a3091e4c3a41e2246c5670e6f6d2d32f809002362d805ba3e4863863156c3ec195ff094eb40fd8639356544aef7cc9085f764dcec723550e53acf8b54c3e25ff08e37443fac032627de7bc8afd8e98a233340349806faf7804038034e303339ebd357830827d9eea41f7a55611d82064b9184525e8d145ad5a59f714cc4eed8e3e4b41b0724ee4918db870d8e47d7ba9d53cc3b0be9dfd576e93ad58e77ea0379aa1b97bf3baf2f8a464417b5aea5324171b48121e3d0de7068a91329a837b2711e35bd93c7976fb62dce90093d100eafca7f0de191ad3c28d4bdeab4e358ac93770c617e4b5f045775f4a03a8e6b9dd881af94127cc02ae5a219f0fb857d9cb36488a6d513f65ddb2c41d8cb1658364d31e13dbe1ae824888ad9222768f0868853ffc1ee90585f366ddd036331e019cc290954092ba04ca107c32e84e015b9999e0fead98bedb064cf72c3ae1b4861966bc23d713f61e4d9488473ee44f4f0f045ce14348ee3b48d8318fa18be4e9f03df7fb2a72f9ea32010854b6297d8e441969f0902e02cc6be9db826b9f21961468fef51ca49f6081090f02fbb22113d48877084e8f575483daa40cb885148b953115c67bdecd517f31105715334d49f342d03567bbe1fce9320454c651fbceb1b21eb7224f37bbfbafcb808272a48e8bb517245dc76ad16a8bf87f25357307e40f56f78777912d278892c0b02c74032e7bd4d8d347f2058f930bd05fe95441abe368223b47842c04a695760b4428051e0123f8f9e56379af4226dbd80c648d762cba8a9140a7ec535ebbd003107097bbd5c9ea8030245cb0232e27b6a76590ab10023752f6e757c2a040209c58507c676978f75f48835aee64850030d3e067e1418862eeff5f0369c290e5d3838d833c93a78e5829efdfa642e611430a839403fcde912eb90bf99fc894b3277f1e77e73b8fa3ef6b1b4abde64f3900cd2430cddb7843e92ae2ef5b31d6b1089054feaadf5d21bf0c31c85b012e924d93acc9231e13d6bc053a6688333044adcceb4cb4ebb6306e0a029599be4264ed690f9af461b4612163ea42a8be1df9bb38adce318f0c9d144a443a0c6fa8287c85d83d8d9f2bc0324ce72f7fbb50561a47b784e7c1a0ad59df37f38b6a2942719e1d29d2672dc64ff3ef38c9e5101f8b987ab345af6beb67a5f25a82768ccf100adfe7e239449479f61d4eff1d8929f2b37cd07ee40d06a3ebc4a100af4e645e7ca5ac14bf0537f09347a97afd4cd9ccb5c8124d8f9f9d83391797a44fa4aafd065084</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第三周总结(4/15 - 4/21)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>第二周总结(4/1 - 4/14)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/132dfe66ee9d/"/>
    <id>https://blog.phbeats.cn/posts/132dfe66ee9d/</id>
    <published>2024-04-07T23:27:47.000Z</published>
    <updated>2024-04-20T13:06:17.222Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="c166cfc54e96a5c6351a9782c6c44e36d5171bdb4ee8bab4e26d0955062cfae0">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b081440615059111ca942f2f251783284cea249d270ca95f89bf8323aad5db0cab858837333983672a3b5f6924d143b2935aa9c9dc602f6964d6b05ff384e693f798de866fbacc0124cb9146bd60feb01a529c920e69af76f2e2980e8d6b98ed10e5465d89980a1ada0cef63c07ec3a6c743e9ce962932f52e5026cd71e34d4336cdd6ba4bcbb540d789a4dd7e8c6040a41e2a42328f362d0e084b9528ab36687b9cad183aec318fa0af431691097562f1df5f9447042b374e2bb9501f8aedec0852b281cd1f3b9cd852ee7b02f9c83c267f9d8661dab750a18e6192207056fbb478d3f8541b548b34d4daac73119c60860e280ee479615feefb478413c5b948fbd3b07c1419da04f143c95e234401ca140b39f94ce684f0dc83483ac271358414a9e2e830fbfa36cc4d9492edaf87f5baf59a82f57cba80a8fc9e8052dd87bd50639144fb4ec3a958539f82a3f3ae281005f1016ba914cabb5f92e1400daf81e80c8c883ce6b0955b627a852d7c75744d8f79af24bc4b274132d782b0a6b736463c0ac5044dc8eb9f6b46f52754ab46cd1ee06dd4e61cbbd096096e57a8450b7218ec18c379bc61514e9d3f9b81a08b4892f32fa13b20a7d60a981e2197300de1a4f216d4066d1414ec11bdaf204e24b63c8d4f0a0394ec4b3b473fdd1ea52d8ecb528a0080e8fc731c193b5a9f59bf00fde12f30e003970331fe65588f23ac0c214e7b4febf9f13134893bce86ff84e454ab8733a90394f20cffb5d09e78c3eed7cf40df4764fb60f486a38e78c56f40bff66a3d699d105dd5bd5e49adacd002b50cd9e2cd09adae0580c10e48f2999a660b271f4513ca3b5514433b2a55accb743680f1c8c1bdfd7ee31c7219003420098aeebdad930d7ca9452ef7ff1a105b11f71fa20fddb2e830167f5c04d36cb768258261797e4601b292f3d342bc96290645e3570893365381b887d443da03c8379158d1684fd164e249782c7cb9fbb2c8dc281ccabc0e6e348f0fc391e36e8945150ef3010eaee82ea9ddffdd6c4aaef58eb4e06c8de2f86609c619a70dc35d4399e197e48c4a41e39ec3130f711d759046da2edc85ce71caa190551e28d00c638c5dd1b8c4270a93f5c2197be14fb6f705dde972d33580f1da4caa7a852df33b209eaf70fa641568c2c8aff1dce71490509f74d20c6f23839318f72a3064a52ed1603bc59e72311c425bf64098d846e3312955a36d470e07b7b47a1c5543ab0be57174876c764a4952dc8fd6940cfab9830936f59b8efd3d2dbe5ffc5c5fc756c553c53b985c9b36a3f932464cbacfe544a609790df364c090e041d1972450e172bfba53a0f60d5ae6ef9434f13d09264c0f3e5e9e8b55a01a2897c0392ff2708481f2535fb53c50a4afbb23de427278f87de5a96453abfb5394612c6f64c981f3401ccde56cd6586a4997a19943828fdf0f6169f6cd68cdbc2c082ac83bde864f9c7eb37613f6e8013027f5f33acc7e58612f57163f2c5fe8e0cd5b658b9e4b7d3e11f529aa971ae7cd40596836b09c71bcf72823dabb83b8b18196e501d832b4073439c29f1a99e9ac202d728fb3db5c08bf1dde1ae44bc7688e4f661be06ff82cd299a69a766f2d7f1515ae9d9f8d605181afb5a8ee7bcc303126caafc7bb095ade8d5ac05dd2c7aceb5b921a88dfdc8bcb15c61b2af8420e5fa587667c2123e3ccfc2339e463284bed368594c9dbd4879ff44b6538eb241407f6ecc636235dbeb853454d73b97f9b785ba2ee65b344e3000f6b6e7ca1586cab5d0a21360084d49c48b9005d7ce336fc52bc7bd13e7213a5423ff236201fdc364e5ab9a68413e8acb0664d9a38e697fc9564549fc0f060b3f9985a9fdbbe0c53a84e5b8f528ea86e54913fff46ff8d1def268a66fc58c3245cf308b782aa8824a75c382a54a4fd0699b94bdbe0d74fef001fc6a80c5e00f6244f98f9ded9fbc3a15dc9a711b8c5ef096938ffb8cf7a64e453c58b7414f23ec7d2836ec9ea93a585af8d4424f163ee5a8ca71a62f8d6a89177ca4ccdaeea86c4c395a37a5beb3d5892b118428bba2212d66f03eb63601291dfad49c20fcaf668a78952298bfef580d11b3f02069bfe3804f487d02794659722bf8ae557bceb78d538dceaf9f347a188907e8a3d857e0c0baabdd0033849604e1e822b958c381a729be7e671aac98fc061b7dae8b4f24df53ee734f17baf9113e0b4d60c3ab5a4f17f67ecb19033a956ac8b3ed2363ab6b29b06f9615b08c5fae6f320880cffe039fe13fa1a9c1b75b0f4c2e882918e78713ac3c729420a9c33222298cbc58a4b2a3fbef28473901365a15b9f1a5cd35a09e7a358c6d11c46305ddd665138ca5298e0d1a1c4848e4f4cc76e5afa9f8711c7025b41dabb9e6cea7f38fe13e7f73c7d47b57036d6a6dc6c494ee072ed974c36426c375b14009450941656843937b936de8523ccf2d0bb1626687eae7ee49c7016fb49822a4c2f14a62cc6af9beb88adccbc70a32fef17e3c57cd10232a01824366667ab4b88ab8b47111f25ee5487f5ae41f23efe95f58f7c0cba6f23ac48831d85e423a65c587e0764014bc82d696680727db1e2a6365414c3682a7401214d55a8f8cdfdaee26d70e66ef5bc82174fbe16642057a7a0b9d8df88042ce6511c065d8fbb0c52c3c7cfdedb45eccc205da325dee7795826aab7984c750a2a77fc7094bb73d841f63a44b45827fd43b31cc669d04a18090535c385ee692f3eee9e415b4a38c6323b654d00f0aba2bd729ae7a76c06ce9c51bb7651a86f3ab9d48acb2e952a1b95aa39e9574a7e9dfbd3116d939467b77b5b941d8c18d0a070d3ae852f7943046ad5d61e66df4ef3be02ddb14a69b9171134fdb34951d3721229603d40537d1ae1fd25ac6d57e3ff3bf47a444fd4e293f04928a9d916dfe40cd54dce000d757a03affa9d7e10f84116be70a9f1928f023a1852932479369913a37c1bb7fe86371885f27e02b8ed42417c6afe29e0910154b5e4c7e265e2c76ebc15374092afa09d484e3ec82ec74a9d0a17e7adc9cb12cb9ae4651584b3ae3f21c1339b2f83b7700f65cbeb43e7ffc6f265a2eebbb24993dc6288973be7e4b357277ca7791383f8ae8ce7115ac239887f4c545fc348f7357e65335dcfd2fd3cfdba5e95b063211d8ff2e5f4c5d0384b37a5a178593f7704c8f4a17904fb67e7dda994a67b16a211ec97f42d2039dfaa519f6177d9f58abe1b0049ef8b3a36b98b9e3b53c77b8cce1c2672fb6051e46724ac47fdbe7db57f5645e627e8278c5d4e4d719bce02ac57c12f60d9868739ac66fded2cf490d7549a39fdcd14c099a8db4ec9f5feb391de6326c5d24a286c3555f0e41693806decbeecf38fdbe5ee96ff2443e9298a16939435e7e33f95f2a5881f71d9b6643cae6c95e3edc070e57471f11c38ec637833be07362bfeb8fbb6ffcc14e12f68bb1eb627303e5835163ca962e0af31691cdac5d90f168c45649231c128b96370ac2d6e72a01c85ea536ae780f33e3cfe86f62a29c28061505fbfc978d61c2fa11db357f973a0fa670777a1a2cf2c69c07e2a76bfa83b43d8e1c8f2aea0cbf703d85142171a56f370722d022d7880bed363852d5750138caa0c40531beb077e5e9cc8796694b64dcfd73d2ccb74423f228f16e878eaab57b0dec5eca85ff03c9f42841a7f9ecd91e4f1770787233016c76117446cfd559043bda1a5566a10cc3904e83f0c83ffef42d5537dda3a1ca54105d6a5fdbf8d9c0c276e0f2a9c6978a9c8ae98353e81b87560f2400caed90ebf786a62bfb2bb12923628cbb602a1b19f94cabd1879b788dd36fa9a8bcfc27e2992e1172f4edb3eb65c7187ef7f8d3f0f97a770939ecac3f010bd79a2ce9259f5678b4416ae9a950875ac7b619b5f27588ac69c28cff338cb5fca976b0830c74a1a2fa6fd864c4b5a8fa31041ef5f2c09ae20f3474946848b21380781ac605cf952396a9feb61e788780bd5d7d9cb4eb7a3089bb4daa7dab492c22d25391706f40f822c976efe5b548e018af9bb1f6265a4d4a8c2a66da77004ddbdea547cd46f15bc00d6b94672df3111675f156bf28acf9816551578e3ef145735fba0ad0c1e7303aac337941cf584b46ba27e6e75b32c951e167ce89629c64bb00b0132cac9732f76c5a0fd445269304b61ec8264a684b64d09413d6f2999183b2f07c47c1a5c9231a77c32a6107ea0a3a628d1476c02bc8f73ad020eb2af7e19de928542f83b487b3deffccd4474569a2146d893b049b562cab4d12f3cc7999513b3f62cd7a7705048b228267b380de83b48c8ee8d575f71f879de2d93d58ff41496ccdfaa95c0a6e30626a8c46491b9491103141e45908780c5c4dfda20ee0afe9137f47fb920596a247d2a2c06156271f9c5308e996c6ebb76bee62912be8f0bcf58b7259db7f1391a44f86679b8dc8fe157985a66b651128fe4f579fdd03d5ed771fd264f0e0a2fc907514e6829c13012094b8965e0bba19c241bc958f7edf7ff8c7cffaa59f792319d60a0cd34bf0c2e9a6a5237036e9c1ceb106af04d43c1ae8a9292c486f2281e8ff1d9d635f54f1fe60dad15924e12e8ce4a097d0a6260af3a5364235a444d04ed65ebb459593117226ed3c00a2c56e59f5b5bd216f497359a2e867452c965981eabc8647a98bb1c1354eeb2c3f73402be51b7a5481f670d1193e0ac20323881aa986f2aa6773768d5f09cb854483ea784f0d208f65cec46721a307e6872be46cc63ed03bc19509037d19d7bd3eb808590ccefa0746bcc79eb7fb71f9ddf8833d695260ae508be124d64030e75a13b313735f2a59cce7360e9b7a3bfcebfadba845994ce1065f24998127fef0b94a2dbd0553a6ced0c4573b217585fa37e7c748fb1512c0174935edee17f5ffe36e8b97049c78683e387011dbf42b3a85ba79a66b4da4a1f484504dded5bd3b727dd5a0985022bdefa3aef8a5acbfc870c39aef59105d08e89bfdb1870ab7030234d410de6485e6129ad2ecac618a46376f7e7a8b279a0f90688ed58298d1b2d964eba5f459ca5603f620f005e959311711e97d63943af9a9cd31394b7e57a419b8afd6898d8d6fd7d6ce51f7a506414ad7589aa14ed7c5da23e7e351471e0adf2e166a9284a14dc0d066976271d7d0e5a900c407030a15ba1e91d9bbccb656b7bae143bda0447f6e56d95b01e706a7c38e492faea2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第二周总结(4/1 - 4/14)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>[AcWing]3765. 表达式树</title>
    <link href="https://blog.phbeats.cn/posts/4d1178f3e0bb/"/>
    <id>https://blog.phbeats.cn/posts/4d1178f3e0bb/</id>
    <published>2024-04-04T11:41:18.000Z</published>
    <updated>2024-04-20T13:06:17.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-3765-表达式树"><a href="#AcWing-3765-表达式树" class="headerlink" title="[AcWing]3765. 表达式树"></a><a href="https://www.acwing.com/problem/content/3768/">[AcWing]3765. 表达式树</a></h1><p>请设计一个算法，将给定的表达式树(二叉树)转换为等价的中缀表达式(通过括号反映操作符的计算次序)并输出。</p><p>例如，当下列两棵表达式树作为算法的输入时：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c3f2bab7.png" alt="QQ截图20210708095213.png"></p><p>输出的等价中缀表达式分别为 <code>(a+b)*(c*(-d))</code> 和 <code>(a*b)+(-(c-d))</code>。</p><p><strong>注意</strong>：</p><ul><li>树中至少包含一个运算符。</li><li>当运算符是负号时，左儿子为空，右儿子为需要取反的表达式。</li><li>树中所有叶节点的值均为非负整数。</li></ul><h4 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">输入：二叉树[+, <span class="hljs-number">12</span>, *, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]如下图所示：<br>    +<br>   / \<br>  <span class="hljs-number">12</span>  *<br>     / \<br>    <span class="hljs-number">6</span>   <span class="hljs-number">4</span><br><br>输出：<span class="hljs-number">12</span>+(<span class="hljs-number">6</span>*<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>给定二叉树的非空结点数量保证不超过 <code>1000</code>。</p><p>给定二叉树保证能够转化为合法的中缀表达式。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>很容易想到这是基于树的<code>中序遍历</code>的算法，难点在于加括号的时机。</p><p>通过观察发现，除了根节点，每棵子树都一直在重复做的事情：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c45e6e6b.png" alt="image-20240404195438756"></p><p>那么就会有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">ans += <span class="hljs-string">&quot;(&quot;</span>;<br><span class="hljs-built_in">dfs</span>(root -&gt; left);<br>ans += root -&gt; val;<br><span class="hljs-built_in">dfs</span>(root -&gt; right);<br>ans += <span class="hljs-string">&quot;)&quot;</span>;<br></code></pre></td></tr></table></figure><p>在中序遍历之前需要加上括号。</p><p>可是，有特殊情况：</p><p><img src="https://bu.dusays.com/2024/04/04/660e9c5cd7fef.png" alt="image-20240404201019068"></p><p>那么就需要特殊处理。</p><p>当碰到叶子结点的时候就不需要加括号了，直接输出结点值就行。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     string val；</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string ans;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 遇到叶子结点</span><br>        <span class="hljs-keyword">if</span>(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;<br>            ans += root -&gt; val;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 非叶子结点</span><br>            ans += <span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>            ans += root -&gt; val;<br>            <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>            ans += <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">expressionTree</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理根节点的特殊情况，直接处理左右子树</span><br>        <span class="hljs-built_in">dfs</span>(root -&gt; left);<br>        ans += root -&gt; val;<br>        <span class="hljs-built_in">dfs</span>(root -&gt; right);<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">[AcWing]3765. 表达式树</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
    <category term="二叉树" scheme="https://blog.phbeats.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>第一周总结(4/1 - 4/7)与下周规划</title>
    <link href="https://blog.phbeats.cn/posts/216a02683518/"/>
    <id>https://blog.phbeats.cn/posts/216a02683518/</id>
    <published>2024-04-01T13:19:14.000Z</published>
    <updated>2024-04-20T13:06:17.222Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0e0c679d7feafcc9d0c2aa66f93997a13d827a30477d5d0f72ff0812234a3cb6">e673c8ca06aefc9fd566f76e908c707310684ae5b1521629cc5fde21209b0814870b88c966fecb0cc2e967028af3411eee7300cb80bbf274f423dd19658f7505c530642711d548c2dc40e28f93eae2df7482b8d7f287346b0700bc0a6340105e6ea3aede3f037af485f18b8b3bed1367387e302de213c7661d9311e5de8feb9732ca67c4573b20edc8ef5bc3525464e85c21b047d751374412e1463cf3a1916e8dc86e753f6a76827c450ce814391ede13b13708368897ddf751d3ad12d75ab7133e419f45a4daba29d4481590da59f287b85f357d28fca03170453ea227274644608fd462f2583ae33283f8743e5b57ebae9650ba1c2c522a73c49277e7f818b4431fbe5ff793fea52c249e7afcef85a308419edb0fefad03f15809f45519fe8c7a8708c35d74100c7086b7ad28972b1e75ca4016ebebf8ddae22c333e262e490409525fb7934949c1986f5bf59394f88d55a073260d2e9b32bad061280a3c3f7547da3daf47cc63cb300bee14abb49bcd0f7bd1f45058ce82fd0046ac77c135f286d65eaf6d5ed12ed7924e83ad033f13b2385c6fb254d67f5bb56f986d6920740ed912071ee156e64bdc2b418fe3a02f1d35744e03b1643bac3e1f27329e2b2c087e123e026353bf929e9e6606b5f7dbf9dac23db4275a990b4f63f422a32d1c82c115b6f038cf05bdb7d0b63e1af02405c17e5b5afcbdcbe549229ee0dfd451cf3a4da25d9f9b857eab388167c95d0396598c5e8da793e6889421792e10ee2a97328e78910dc679a18fd4ee0caca158b028754a4a0eae729875bffa3313f6f74dc7f3ac84d2dd6a1dddeadd6254eff498178e35afc40bbb0ed400aba75744d10837c389dfbb2313239650c73edaa70eb81b48c2929d57e7cb58888ee62da4a49d54745011b231d6913f20f4b4aad9755bc5ffe1322783604e37930b4125a7b12d0a397946f687a57cbee171764684ea69c1d0f7f1ac89d2929449466af2c2a90ee603de2c8547af4249ce635ce40ab3f9a509e5ca2cdfbabfb6f486f17f5033203745892373a04bb569a30b14e2d4bd5d5cbe2d53bd24edd801a51b06bbd28189e8c41ef9b2ec399a8fab257c23bbe98ec4d70f688b1d59c40eb229ac8aaeabdd02733ae8e083a1ff7b1dc9e58dbb4d9dcca755c95b39d01e057f06e24faabcb8fed7ab3758adc9013dfb9c1c8b9a4f28fae3dca392cfd84f7eb96a2d5849295e77c2d2f5b0a042d88dbb9db9e1d9d6376f8fe4775e1feb304dc9cd17672d9b90660b3936554039277744e40d248b436296ee908fecc9a2399d97e31d0318488deb60437a0ac1f1cf87d716c2df7fb79138188ea830dc4190da8139ef770a591f99bb8c4101872f9cb49de48b7470d64e17509d117a02420badf97e2a6785abb3433ebe1516912c02bc897956f2bf9a582534892ff7ad14bc4b8a936f36a60bd0f3cbf29118f4354127c00d1a1e9112f1e062551e3adcea9cb59e17349194e2f6a5467260be116b37a19ff20fddd3488f3231ef37859c69eddef5444225941eca15cce22dfd117a18d4cfa0d916584169a7602ce347edda5a803d76c2cb9ff7ff9b407a6c89d04227d896dd0694e676540ffc43d99606c194bc843c3283205f188834040d1b8f67f118fc7a53fbd1a92d62af6de5725cf3cca1942a2233e595be09e68d43afe709f1ac6c4c782c27f1c338f8cb1d91e354986a867def22dbd2cb6cf362609fabc464e6210a579abeccad63874985184b19ef62703957ab2eb0f20957c6bf1d489b0d2e0b2704bd958c46606e0beb0279cb9c571225a46bd7c1504e878f1822224e394362546d8fdd8ee76f68bd7e75c37ec7e488e25919244030f7cdf67f7bbcb40c6f2828e1967bf9b125d403619a3887af06751dcb3f1860425db9eaad334b330d2cf3674cb7e0e791d50f2e019a7484321be621f9add7aea8c74a90d81405771b067764f85cf874647a419b4957e3411ba824fe80be6fac4591b2ff31d6089edcc32c16d9d682255cf8026a5c3b4d97668b2411ea145e1ba346e8bc442895fb218a970da23c87fed093c33131d21600aca663bdf2f5e95620b857aa13d9d110bd76ed824f3b74d96a495568ff6fbd97d9938656f7b1b99ca3e1f764d228cb603b1ddb83de65353a13b51a118e0cdfbabcba5845577af9d7ff5919b4677afcc898aede7d585f616688a671b594af7afad2918e3b08df08ff2add06b3a23bcd6a7460a49d591905f3ac6dc609c749293025a2aeb20b06757667e2abfc8146cde114763f43c4287c495a4246f48a50c0853ab049bece83cdaed9e536ebb76ae18afb400ab539ad95a81f89f56092e19e9bc77a0bb9fdabf2ec2e949d40d6774deab16cd1ba93293993d4b73e8d4d53ffa347040ba62af15621da3b26f0949e5630e8f7eb58983e681f8774bea20f17e85e6870dd1a16227babe00ae8dc9a6fa4e03ebb07d4affd666b1eae87c79707445102ce2a5f631be9a634ebd95d8fda953feb569fbac61dc05e0fbf54a3624a390170fca78a148a9d01ad3fc3a743e2f4ea1173a9f28b3db4752690517f78e99bf2ac444d10ae0e71f9ec54bf9bce0a5654d0770dcf81f7175e9a7f1d8e9fdf5ba9fefe32f83aa8eaebf056061011b26b59a0e5d6437cae171f8c9febcd1ab79ebcb77329f0689ece6f4c87aba14548466c1f44b6afffa34e94bb1c30fdb7121937840b23ac0e42c2d1ee867821e1a5de98875b60e16b28aad7912e5e088b12ebf6e6c4c3a9d074dc4f3bf96ac79979051a514bd266b7fe07d050380d82d7d0c4355254dbd2569144e8629ac7fe6913db449d28af15846ebfad03b923edb4ec6adcd925f333cbb5a1a42f258e19e0f1f9c0377d75b469daaef5e7e368698aaa0bf5f27711a78684a8b51be1485fb48fbc5bae67682562d43f85dfc56d19e3dd96c926f19a7ab4c5d963b37f1af5bc0d4bce17c09125c6fd6d1336aaed5f02acd1c4b6b5d5dde44f3d01bf806b473661368664fb054cfae7b1552194c3c2335209b5857ff0fe4e8c77e0b655e4fad1b15b0234ddf4a11907af50dd17d7ef9a02e0607bf3c033ca34cc28be0eb849cfb64342ac0728c61562194506803a3082371253e304f4f00da52fb8d1105b13092e9261108446f9ec1f35fa43b49fa138ddc7ad8a3280aa499c9f61c572f8826392061bbc4372174fb6d6f2f6f77adf947fe27634bfa5f16562b78b0bb958f145ef012131f41bba37c1fecda639ccabaf074e890c8c1e6263fae5ae453783fecc511a4f170887fb48ca0eaf3e75205d868a3c788629b8b6000740d98f67a7aa0b550826c06430afbbd6f35877367d3e74ce95397ff6ddf1ed65cee771d9b22a2fe17f97e00fb9d4279657d01cc33cc1331c6c001777cc7892b855d3b14003e1e9df3c65d491ea8c4b58956b2d3b0f4cb6315a3c0cef2a83cbf81c3eb3e5c1ed8a02addbb74d337d9fa40387cdd215e342591eee13c8689e265c38d73c9039bd6267a06fcf8867f038780eb53a04ff743e8433c47f3e4178d2baa5f884e32d0475643e311c08056e820169305c52304db20ee34a1f41d8a8e1edead8eddceef5bf8fc1fb6f850c62605749c32d428925839cbd398b183cf22cf0bea285b8bcc524b2aee6c5c9daca2e82fc306accdbb8bd41c2c9e3841a99b7fda56ca282cb7863df41153c95d55e19dcc9397681945bf44d34809b8a10ad5f4a956758847b26453558ba1503e180be88c70adc465690d3fc9268db6f324cceef38a4e4de46fadcd687680956171035015b5283adfbc70563eb42fc38317ed2f588c56f39ee21bc2c54b3188cbd4cdb12e3cc59995d2677353ff823b1f3319f232e740c3de89f0cafc44e62b48865154188c7143a952d83f858408506600d648c9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">第一周总结(4/1 - 4/7)与下周规划</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>美好的每一天～不连续存在～</title>
    <link href="https://blog.phbeats.cn/posts/ca2f7778875d/"/>
    <id>https://blog.phbeats.cn/posts/ca2f7778875d/</id>
    <published>2024-03-19T14:53:45.000Z</published>
    <updated>2024-04-20T13:06:17.222Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="77da9c6f3a7d2e0c538f3d06df8a4709d682ecd0f44b0a12878680d5ab8ed25d">e673c8ca06aefc9fd566f76e908c7073bf122394db4047bcd924ce9ea37328240a38cdea58412a376dfb2c4084c8672e19e7fec2a499cc6cfafe0f544c575fc22968d157ace4fc995bc36c6fc521fa9124d0e79762ed71cfa3cbcfcd4f2370559b60818db7bb6248fa9ec9043fefa6ddd9daae6953ba901f3b971678481dcee1f13ad850e842de09a7c3163f96bfe109ca867b2dc83bcc21ac84d0a70d21b8084f6fc776f65dda5936baf3f89ed826708fa0111450ebbd723630f4858f9b52d4dd1aa605d1fe5ea68f715459a4654df40881da453aa694a3fb0de34b8a3ec0c8dce4495c591ac913f37de8ba201526361352d7c161af77bb1058e56adc7ce2a7bffbfce3dcde47bf495993af096840be3bc84addc5ff934878ba7ded3174baa97d74a6c200dbd8350fcdd0563c0fb71f0779028acf0b6987c59f5be9d8b40d78e1f83910af085d290f461c002d47cb650291f0b0838af5457877960f94bbb7d37e684d9a957cf73ff2a8131baf0860e594c83df1e20b554be188ad14e685bca8f18fc7a5ea63c98c078873d9ff1996cc9f6b694313d4d34a3936c46b8e987cf350381c26d5bba90e8f188819843872c38321f463a0af6c26f162228b995481d97218ab7c70c1802e49d9ffb2fc3a99a0f4d94412cfae73501e3036a9de2d19512724defc1c5be6fc89a489dd340453362a4e734d7c4ae050b7f3af45009146e67fc807bddb5742e1a15f4aff8c8c866aa4f6b0aaf2de85faa9fc4c0704bb125b768fb1688758ad898db8c2244459186ca8c8a7a6a620738a5eda2e3f46c642a4fb7d5215a2577d00d4d72d33cbbdb0c8b30e9887cc7a7af67655c510c5ad6d1bb94af0d9df7bb6ec27afd8280256786afddd48ac242bc24d5412b874251fa2c25ec61e705b506a9063e60f8d7a71c160d55a6ac8c896facf3c97b991bcb3cb16491e68eccc48cc52908ae6da136d3ab140c5061e1649b453c59ed4bde8bbfd50632dcd00bf40283cf1500720caa7c4b9417cc4e01e0547423488339da47078070d3778982e5735f2cba06162c4b2159e5f80d58fb3ce96a376d6067470d78d57f353acbbdd95f28cb6516a4dc7de7494ecabb6701e670d2681a6b5799c4657c07eb0d2076e83ee9b574f73d62b8a1a422fee27e2c098e8567f9490b2d233091ac07f893ff14bd86f9f785bfa3ff50c0c1bc117a1c1a0c14ba45a7c05c06eda901de9e73771fb2267f5a57d3d427d7bb430b2c45ad758569f05a5920ff6eae253f181575b94585f6df99320dda002ba81a8c9314accd896ce5ed31f291fb45b0132b94b2706ea550d4f0b6993f4d81c9a55f57e5e27370dad1086ef1bdea0b31cbcfed1cecfc746b8e227601b7f4f4fbb208c2030da66da3628ced6c1941166bb86ba58b85ec98d851f5c48e157f5749798638b6e3ef5a5b7923944825fe95fee854904bc3eba9c1f21f63393322295624502147c85f1b9444bf716d145eed242817be2d945e5edf6cd90871605f45f9dfed2d391a38e5bbe62083ef3aaa94470b77857e42064fbcdb32d489faf13fb37adcb03e60ef3cadca6296f582325729275969b8a1e6bcb773e7eea43ae81aefb7cfb1f1209f988b1bdc6033c8c960c5fb0d2db6d1b72fdb3d07083a7cc62d8ea75eaf4c2b82cd60f71a7c49ffb390c32f1dd73cc62392fddb0c40f905c7ea1688ca0c935cffd388f6ef06e32e5c6edf95410d776468acd15df477b27bba5923dd5c7329fc2fd79cba8764862794c468a1bf5e94e4d6f4b489eb0052a61aa3040077cbd24bfdff4dda5f58a2e45505fb63ef59df751d7447a304c28d6718fd04e5cca9b7ed3bf7ffd20c761cd37c2818f383ce2190decf57d1d5ec350d933b9b7f2e4a027d1602cfa2ab41a6a0303ec68c3f3848576a11b56d481045436336b8161577dca49418ed2f47be7441263991e06297499c1c0e7211777d2d1aea7db8e81dead6935d397590b917695a857dc059fd2b51ee9eb6148bca9f78e88adbda89f776e2d339627983354ff206f171e95bf5142a584e0c17541f9be0eb9e1721a45013a7d35c2a4f7c7e5e4b520c9e25dc0fce02369bfec9b7fe02eaf0fd5beac2d7513eb1ec6e34dc0e806118e625b960e73fdc7520b16a7475f6855e36767e4fd9fdcd932a5864d48ee4e74d741fefe7b7944c8c42c17b744d9b0fd917236f51a892c04a263a5e6f22c260cb65eab989e5957d25a86ba336af238eb032e2369ab4bd0d8f6431b16bde1af3ff658c4a1a936a53a227b4082d718e58169fded573e42edaf0f2ec9d367c0f29f9e179d7010ae942c9535dbe080f011a4e684803a7670fe562df277ad331da882a97a71d0ecbb4a7836616bf4f2004cea9fc6ad545adbfa8a704136a6dfee75a4fdd77bbde1b1e4c4f054d7047b6a9e40e2f96992c588faa3061878877211bf4a84f876faf0788be05d9b81a5725b5fa18de68dbab51ada39279977294c475a13c9814546f098e8053c753980006d8729ffa5abced131be42af896a1eec9c181b11f8b188a4fbaa29444050138d15b6c3729463019926d9c25de25845b25fe8d1fc96cc184e2fc9ea8624a5102adb214a146408cf574c653eaec739912358cc3adac71a2c354440ce7807f2aec235867b7eecd573d82f49b6b78b985483cb0086940f1bcfd0cb4ea40f902a6468cdd7483915b3041ea939e165952f9d240bd69973af597421ed330aaa836406f404e39b48114f11975a003da37b20f56be9b5352cd4b7195b885511d27c09ed60111b5fe3f3f28f8566302a50d8d9f283d30a2f086430f1ffaec560831c568a5e22596156ee14814898b3f2cc3adf25baebdb949658c35fed882c2340eee44c46fa60d5367a851e09c2cb75e4c4298253b96608089865dbbb4c74d5bd0c292c3487ac278c7370eb9dbe5fb9799b3346f16fac64c7acce8963f3b60f05298560ae7fc3a21e86c338911a2bd9205d121af359ca5e411f1de9a4ac9a0db47cdd64d76084cc5c003a5d6c4b75cd21672778ceb276b3d44ecde1f41bf9277738bf77da506b52c83b9b8ef3277b42a20071756d9def8edcfa1226b56b4e6a557a67e21ab82674f70cda70c0abaf4b12ee5f2cd21a1a06f68c78a62697fb94863d293eda5de31d69850b9dc45e512efc7b152e9926797358e6065ad592e3244d544fd44bb1f37da463fa81a27a387644e3bc483f4771870fb364125269aa502051ec3bff27e5298f07ac0f8e9789ec6bfd356764a43b81da9f990b7a94de4a299621c11197565493a6ec1d20a13e8b78967aac3d469bfd87d4b2bff4a0f533e5b9858e8fa61edff786966e1b82b5a98c20cb8a10ff4276fd415950aff18e5c02704c30f0413f57893a3a87fe2d7a00b0f8bbac3e3235a32dc7541315282aea42bf7445a5f7e0765ae2ff0a5cc5e832314283af39377548dbed44e6240570a4acb9084ab09ca3d24210ad06709e892d241a0cef27514a54c9e0cacfdd243d47c0244e547cfc643b56b62a99eb403e69701a85454a5a1e35b2066b57d623e9061e0a9f86bd54e528f0466ecdc61bbeab7ae7ac2b227125eb1518207dabba68e01b17f8a9112864dedd7587ceb38b7ee9c1592c25324682265637ed23b1c1cc867f6cdd05d1ceb6bca80892596b2322e8697e30ba5efc6405d7f386eff8a457fd9fac3d533e4c45de2e692ec567debcd4506badfd472e650eee4b95c5afa29532ace0fdd4be0a61ce65245d9f6816010d61b600f13ac92cc308feaffcd9cb4fdc0e13ea931432e486af64cb01c3fe7f7d1e5daa29e8248c1071921c54953b380dd4994d07927002e552383a29049f47179c45a1d4ab7ca9c921e4960b39562cdb9934c426f0d7afa113e11b14b1addfdce36c35b52d767e815bc7f3365df43bfa3da8d69594c20092859c2e67e81221fb61ebf9597d2f2db292b641d3eab1ff76b79049883216bc9a0b063b72961daad292f203899f8b270fa30f82ea98bb28016a6e3fc03aaf8e2e31f401d342eca2b03ff5bdf160ff73b8ab9da5d97ec2298f4183e355e8ae1a8250174931c5511ef1e2b059207bb2ceb38110fbed69a24f86d17defaa4ae6ab94d4963a357685acd97ef183a54e17cc8908aa75aeb3b1322a222d5c2a72369316dd20976a80f57b34d1b2eedba0c7338bb7ed4f02e58653f184733f09b0a61d8b018ed926c372e723523a5245d814652befc24a2bf3cb1e70a807780cf7feec44d5524388727034d1438ec9397f7b8475105126494a048c9214815199609c8550824344544c09e833a641f2e5462a39959de0aa2c704993f714cd94bb69979e1ce17b3ab395a70cbea8f924c8afa21d601490be3a70fa7947ee1ae98fe68dbd69aa3275c90b4e87e94f40d16e8dbf7563d660dcd2ae7d12aa35b826d7acd68ecd1b61aa304c366bc32c3dc6f6f20ac04e406afbae20785ae85e89c4c1fd42d6a828e9927c5a1929e07c982706d684de0eeb1f9fa21404a33e5b6f4e9f39cfb314c6eb5973678250fe7f7d99369ea9f52227a5ac74bdb6e3719add9b3d7cffa58025b3cb73e38bf5025577b696f6012d22a21bd67ad3c200bf02057f4ca6ab139d117660987153dfc7cc70c62c273cf354afda434e68bd02f83a2054dc70402f5b7409a64d461bf45b747c14458cc16ebc824f8e09e555776a50c030b5a47a42494464ffcac96205603aed1dbc5974715956150e98f7b3c2aed2828a315955dfd9095fdafd9d092b9b51f4eb97e472c37452338b99e402728025eec407dbc44cbce0f4589e5ab2f664af7ef6513c64e04e94f922459bc621cf429a98b2812723d920d7f3c3f732eca99616882829816a4d93ce58d8b5e4c15b98ae8dedc09f4e88ef02a7fcdb447858a0b94cf56b77ca6c82b5c1026f47d3b9608996117329c3ee53aec63713850a092f90c6f4f96f75512a73d9833324bc15ee504b0ab93a862354db36c3dcf88782a159c77ac083b7958f73e34022fb8ca3b78464d3f2d2d2c2a09b227f739a5834df88689a44228171f978d98c9d0e3f444bf8de433bd737e7a9d325b80be0297f59b922e202116759df911d6974ed75e5006d5900c629512c6bccd4fd0bb86d242a1e1fac47e110a70a645d8cd51d8094d4979aa3ec3d157ecf015def2bc3e25268ddba587e369ce009dc2074dc5471d8f9b3d655bb5824a790252efccde02173c2e59f5042ed199546a65fe38c9e36933f7b300d3c093a95ea95df443ddf70beddd03368e2f195bee68abaa9f51f75c5552cfb2f2838cb2e47ce129d81823ed42d9a69e856f8be295b2cf97fe5e8355b3e0432cc665001661c938abeb511f8366becc88982d438e13c55bee5a4c4c904c9bef0968dd89beea313394d4f06582e1aa4fabb4ba97c49a9644b54d09ef12c1afc6f1d5efd356f0567b7d9656c2527c5814123f0b75a2b10b9ad09f6bfbe3488c0e6813d82b41061dd2cb462feae975e2729efc441841ee87a5b4e3c8754187b8ca6ac3660eaa1f5d15b7f7934b53665fdc2fc318007e457505898df2a4929515c52b9673084f09d96c687248e5c536edc38423de39878df1c81fc61e25a2a9503e840a37a4089f94b18fc3a53ccb1b8723231e2a6f1ab9712bd32caf4f36d2abbc18f6437abaf1ff311351f55cfcb1c74fb5339dcc8637df11b6a5b8bc01ad4564edba2f13af7b4c9ae8d8f4c8c1bf4a0319f884f1d2b5031a9999e8257d997e5b937f1271a72225854e45e794dba43d16f0b36ac9249387e029fd098326114844548408aa6eaaad977b6a4b48369b6fd78a7dd5bc287b42e81d544ce156d9100dce6c6c3ac874392beb9552469b6de4b2d5b09051d621a148af4e115789e967a37383ecc457b06a593dbc0febc47b6e3190ee08c16620cba0a78e260ee023a2aa8d2e73bb6ab81ef73bc7b04e48cd84e97a6927c3493b5ff8bb9e90599a42d073f4e3046ad61bcae7e614fd40c041044bc4329fd6770b0fa6f249c8e886833ce4aec7656032fcb5205971e8ad3cc27627b15d81d135dabbfbc776293433d6fcf3a1157217f344fc288d4c2af9caee8f531be9a9657a9cc1c73498ddfe23be88e886051e7d425bf759895ec06bd5837cc5b045de0b7756ec9050e9d4e1bc6dbfe93de48c777bf75fe1221c0861a24329c1d686e91e79203a742d47eea53a6b33861ec1b835a48d42b2fd2e0d381f26408ee42c462c66ad706990cef92766456e3d29a69ab1e6da8950d9dddb455c72fc6773e6cbc8911464557ffc2b3a4f9408abd605d0d0166ef63c1b8e0363ccde5f7da389d322a2877b6a561ced6dfe95820e29e5a9c2e408075547b2889117db049596720df9b76b941413685bb3a80898ca902d271c31be55152c6ca6c259507068018eb796d5fb32d66a6e84eea38dcd9968ca0e810a3ff9dcd5ae1383a6e72babd0cd051f7943723426ba30ddd967d36fcd5b0ff2dcd69d8cbe1334135d6887a89982acc993c82ba580a6d04caff2dd75254af585e8306a720daa661dbb8e88f68f620b18cb61e7cba1ee22c4218adeeeb69e7b7e4c633ccc1adb79199208622a2b609e772e42d605a6feaeddc5acb497f0a6b968ffec9d945a0cc739be22c3bce0b3cb9fe74a5f5a1988b33c3d6aa964bf2663142be0f244d4c2a4f90a06e26413e40cae8dbb4cf06feae7b89ad769fee01f7fe12741c51ec3526f4caf98f1837dd371162983b76f0cac33a3cc8c350040a65e181782ee91d1df02d8fdd00d598c61a6ea668417cede1363fc8ea185c196d910d4c1a95e379b3d30a461723f5aefe19ff693b5b0c0efbe025f335d28b3d0e18ee41886afd96a17d48c794c85007686288e278bb1de439f210c0942bf42ddd26328c2d28bdf43e200a1756e905a45471ad65763f7ed3a31edd81e42121c19ca4bd976d978bcdcf95c2fd0818fdd066bb2e8bb53c9b3b2cb893c440413d3dabf08df73d2e09b83ec7bbd270293373c86c7cfdd22d2d1554c750e5a366578d7d9077ba30a09153d2c28c79d0d281a8a47b0b57575df4cc6e9e699d335d91f04d69193fb9b1fad49ebc024291972db0a7bb04c2f5565820af2b81e8c64f25c9aef13dd2bec3b4f97870ddbc61a0d9ee05f2727fecdc8418d0244715045a7ea98252114771acce4c14de905bdbc9dff5ca0de40189a21841cbb36ee170d1ed2fc7d8a640b5bd23c7b53ced87a4ff8fa295c8acfc1c7eec7837c946445c60c291415c577994ffb185d936bf2cd0d21573aca51737b82ebc10b267e6d85ffd1523e34e8e8a60d2bdee2369b5a6793c4b78a90de2e2ea14652c7f34e8b9df6a836f45a64cb816400615a5b08599b4a3c96070d13be676189d60b91a7e956c69dc3f47aa8c713aac6982b68f3e74fdf3b1a99e5cadbba51cc201bdfb3593d468b969e669b693d2aa9f3901b1a396531e30b127542406cfe6a7be342572b5bf456f6b9dca7b7692e7ffda68dc0ba7a0337bf61ed983843982c62a3731b4057ae4f150d1b08dacb3dbf9fd76130782b0f4ba6e499d15aba917be60263e374a8b0eee2cdfd89a46cb2eb0152050d153e7b59c93cdf153e1efb68039b24743eceb8c25bbab7c986f2542524f60f494558e1ec1c7950f728acca32737dac6da5ecbf08efce4a88e2680cdf4c30890e633f395b4f3d7df5143af636c52505f4ca071e22dae606b8e346f9d98fafa44582d568f6cde829fc0247bbd5518701ee692e1ba06d2b681ea170b08056e566407557952fe5e01b83599db8d5aada03276adb2d350cb83980b24bd0eb553b1ec894a8da8bb3754e5c333bf8f6a8d36fd15bfc9914bd33295400350c98b6a2549c73f84a796eb4dc545414ad947ef37a0207c92954d30d47e62a50daf4a7d71bebd17b3cb0118333d054a413f68069d5f6a8196134eaf0cf88cf83b9e8d9efcd376b9612070d2d7085f08e712498a57c5abf880bd57fa58c3a2dd06c9567fd9559e76d8092b22162e582c2e565d766723ebca61d98f77b786b106e6993c0022602e33cca91689297ea0c63878c03491a6f734cfbc7ca61d61cfe02c9cb75b1dcd2e7d64688f43f39d37b3b5fa6e53941a1162f7089cccf61cc175d5d4d2f9653485867ee82a8f3fbb85628c25d5baa9832d9565c73aed7c148a80161638db484a9bca9f4adf5bba0050aa873aa33642f7df2542e81291553980a80647cd66d6a709271d0d3dd684fc6b93c9ba8ffae268a15ece7f769acb4867170d95872461ee9beaa49f6cafc909ee10b48d8d189e109b30dba0b898fb0d09a677de83b721c9995eb0b671a64acba057513667f2a369bc0d1cf18bc049de28c7509c30b2e7d79bf8de8fb69c643683c3a1cf7f7a9812999cfae998fe6f1a4e27a27ebc706b1bbf2b59d248c48eb183ed1780f080027e34f4d926acbed00253fe2d6cb7f05a6c16a854ab1b146607b0c088c2e800c9f5adfb3fe9f12d228c39faa165de21eb65ae75d0eb57218236c5220e00570fa47208109ebd34a3eacf965a564ea69d4b32531f552e8673e381fc30e64b50bb605c99220da21ad760c3c6f1bd275055ddd46ebde4fae5cbdcbfdc56de61bcc589352254497764cc1267db0828e1f18b9d06fce54b4af7893ca4a03ed02d64669a24f84784933abf2c089bd2b6a4c6a5d05218de3126be177f50870c506508077e91ca9e63d11a3a0aefecc842ec11beaa3c620dd0fba7f4956f835b58569f91cf5e8a637472ffdbd1a9b7a32eb7757fe8875501c89b1f500f13e90f3879eb64e00b2913c92da911c246108a92e72d457694bc9630977b2eb1a348465007aea1dfed06ed267804019bbf3a7c15cac42c33552c43e5117d239d49bc69681446f60af154c3b1550e8f03e447d1ce3acd89b7e9facbd76ca06ac0149a7b14063070b5a8675225eb05b81936caee2442bc85b39fa25ad505255c96e5b66f1821dcfe1307a2d1d90b8271445b1ef63009758c6dd608bcd855653c4e13260394a52b01bf4d33437011220f7c9167086c32b56c7ae66819d8777eb02490b0305890989f9f32ffa9c16bcecf7d44ba4f2c427f5112ee63ecadba684ff4ec793065ee658a1561d4752cb9e8d91970c7d960fb323f58824e5acff7f13d2db21d3931beb94f795161073c8acd68412f6fbddae27afd11062d4317a2de4d7518a8cf095fc8d36e683f4572ff5ce51e8079eddf8f211163e4642104b3f2ed0380e080fe30d6d00866c2dbce5c691804493de10bdf8b1b620b8a42ed27ebc414beeb824fee2ddec3e37e273ec4d288c7f5544ec108920b2f59716914e82c3c9f34b9b679b4b71805a446141ccaeba0bdde93c15b0cda8c3ef54caab18bc3885b5b5a6d8d176cf962ed928de5bc58c73b853f4048fa4c59d8d6c13b113441b6ef38d78ea2b3ec2a308d69cb79890b3bef8a04682b5e41448a5a1d789cf67a1dfdec36f430374417fc5332968e628d159a49f9865ff430a5d33887a1e024e74ef44ebcc76e6f0142a88d355c13770627a1b6545fdd388ed0a8701967f7c8167a15cf66f45bf9f64bd5ede31853e6e92b828e71398b65d3e4cc9539922e0798e59d6805d812ccd17182f282762e23c21fd3bf8070f118ff37b9ac7342eecf60f9b4b1775ef6e2e838db6d9f90ebc04443f8bb2e42ad4802676d5f6a2922d441c35577c9dbd1b17d3601028373d0bdfcd26d07c40fcbd872fa8c1272d2f5da51d0c98fd21076514596eaf0b86975289a162b1b36a20fcfd69786f2be6d780f35d3f9416a29289a8ce91c582fe27bb68907e0c18cde18d546f3c4dae832505f281d1d08ed2f24dea74aee5507264c1c7c2383f596574312b0095cd46a33433a0451e96e2b9d767dc48b268a5a7bc1becfaf39f765f7b5d69e68f8fda4f0776520e4acdd01168777ecb09293447e1beaea28daea82a5d1ec792191ed0385a2b6d1eeeeebd5ba04be48a21e0651056f35b78f8ce0c94c586197072c66c611eec6d85241e941ed3cd00b66edb53218a5dd6882c0fa6c14a42b6f1664fe99e54a40c13e879aa698c40824d203b3dd0866ec7ee517dd784ca9b8e494581cf5315450719eac02dc891c69653b7b2164b701782d8fc433dd1f4af6e16ff75ac91e546b0c21f85daa20e3e6532be67a149c62649cbd175d60ab7e2df4c7eac039f47fc206e8acdfc6e47af4084ff8c268e83cc489e7ca592f6f402b9f93a2c3254a019007f457dc8617d15ecb2b2c6b7ecff4ad5ae5c12eb69f0c1c8e50dbe79447e2a12da74e1bf4d6f21fc74d85a2ca312c87750b88de2ed9d88a7702cd6bcf0f508b4bb0afce416bd8f9ef62022ea1f0be33c620aea828311adb07b134c78d0bf5eb7035b07be31eb310920f9f6bf294daf9f0f95839587435e85803fafddd1507dfb6bc33e6ef3f166b1aa0386ee812f7478f02b03e9373df6dc5a0e3d1086c4565af5c7f7bda8ff78d6fe8475cdf2bbc74a310b3cd47bb331ad106a8b653cd1eec3759d8408288ee95af91fd66dcbb3b15e351702c6ad38ad6423aea7592e91e773a0191ef4b327924c99fae489e17f00e9a59cb40b715397f115913b991b162870df7624e9a80f76880856f95e523f9d090db89dcf071c030b13ee7be340c624307f03aef977a9f5741e4d43e5f9c0a7f136c96bd696c2aa8485067e8eb218bd7a800e7e4e8b87df4796927d44790e083d3e3901966bb4db4ecc80fc46910765becce4209e912e29d1e8af09bb4a3de058e908c4949264f7541d7df9a099ef2cd54d548748bb5a4d5294d2c4beedd341cac355306c30224084c401665e8bc597fea5eea8ef42d0b49e292cd951a5b27cf9cd0f93c0a735b0440af5717b3ce158848873e7250957c6e20999077d7ff4257af2acdcc95f2e2537361e59297c4cbeb064b2d418ac5a30a1042aab5529f2d4b2ca7d291e190587e467d67bd3f7ad8406f727636cd4fa6e857c014906b8f785950d1ef3e7e5360d2631c6b103427a5c248f810a4a0f70893fff5b316fce833e1d0201b4ab8185580cb836344d9c636877a0f1eb376b06f147a2434ec46d38d9cbb7f4051698e93f48230bb0e3fe84d458031fa1c08b7d11343512fef8a956f56deb74db5a18fbf919cab8f6b27030939d5933315f9f01bfa872fbac2d371e46dd4f6a3ffab9bc00f829ade6a6b3d19451399becd944e8bac438bdcb24319025e71b36663eb692cf1a15c11c0116f527c91529d5fbffa720bca54e07b50c790e327d42afaa96148fd9f45df4c2b33f3d37b7fb8501d4f2ae8bb7fa28285a4c078b5479424a55021b154efc1e34b70a1921df65c326682e82393e9cd3964d154841728319ef7a1d32b2d6a42a8194d5171ed409f6cf57c77adff4fb7423d03bfaba311f58627cdbf6cceb5356c9b7aadca6c7109fe7046f01d12dbf9a60a1b9b1c245474be76827eba4ffdfac16ef34ad60c44b0afc01115fddf2f5d5c333a983e9c6a278c282a9b04674de6e86049ddac1d40977ee526bc1dbaac98ae60ea0aaeb777349871048d0d922f53c03956b4e2dffff2c5fbeaf7de7620382fcc8820d915549a666df65aac7848409e0be113a78c3e7f8ca19ef0786aea8e0f7697098a76107694359dbfbbfced9fe5e2dad8795bef9e95c2e939e23ba54afd1896ecf561746f9b96e556294ae80d4e21ec0948068aa719a154acc157c771ba2e23a3bd87cc7112a515bab2544ead2c4429c7080a86f28546749108ac00cd8a149ca5963f4640589cc1b0624d84090c8c0c0cc3b18372ae91b4172ac7c3ba0bb131ad588aec6f71c0261868d2523e6e1b9ddc7c0053baf1a57004ea8c33333a196d7907492eaa952f650f1b678effea52e7a46c05f29c90693da4226bd126f8786db2f67ef442fc2f39cd15786e1e3832db015d68f1eba51243a5c194d801bf0e949007e7721d2e716c7725f2b39fed32d60c9b89934a7619cbf83fbe807c0145c378abcc08ca275122ce230d35d363c7d871adc844135ef608b44cc7fa3cf46caeefbeb8c8a4ab2d416840115d220645c6d4caa9144261a1768215c3c437a4ab22934bb7777ce10fe04bc24d13c5e71f01264cc0ca060c966785d3242d2ae1e2a1a1a9238815bfa767528fec37a4ff9f30ef3136fe8d98a9053b446dce7613939807c8e458cf24ef7d2acebc1cec</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">美好的每一天～不连续存在～</summary>
    
    
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>周志汇总</title>
    <link href="https://blog.phbeats.cn/posts/acdb8d5c9b7b/"/>
    <id>https://blog.phbeats.cn/posts/acdb8d5c9b7b/</id>
    <published>2024-03-19T14:37:12.000Z</published>
    <updated>2024-04-20T13:06:17.226Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="d6d694879ebb88901b4b319a0c09679ebd411be829060693c8b9e1cb3ce91c9f">e673c8ca06aefc9fd566f76e908c7073bf122394db4047bcd924ce9ea3732824180a4f1db344e311487ba241f1b16c4587f75b861f83fe634c4c300b5ce9c13f6ab2dc51be3173e872c5b9303aab66b98f2d10c9186f542c60bdf6e9e018902100efec3c9b0d9e25eb662a6738083cac0144094eaf56dff4f3d0dac07a1d8fde55b12b81cafe45e830d294450db7709fb63d8646cd7dbfc68602c1aa7bd817e8f76fdfc74c1277e320a30180efe06403a97e6f934d084e4d24a4b565f7c367414397784ed156c305a7ffd132f0e9754e52f1377dc9ab7b8c82e80eb332a9499cad7e6433e805342202368e93c755a7afccbd65b77c0be4e4d18f65b7b251eb790731125c3f694c853c1f69b5e5df409f5bfd03d0949ba954eb996b0623e80bb1ba55a0fcbf1124aba367eca4d5273a2853ae153eb861f18cccc9de081e15f3fdee3195620f6f7f415a7c86f033937b748de82d7f0c9fae37b4882190a3b6dca92202b2d28d07a2a4fa623336ffc9483be1b7b60644593122b61456f3296175f8acac9ddfdfefa420c67c3f063702dbc614d95d49c95d548e1e77d39fdf6eee41b2dc2c79e17a12a021f5166cc9270ec4b3afbeb3e46ae99b1f558961228e7ab7c26f1f33dfec514a525ffa53da17b920e7d71c4ab55378b8d4ffab137706da1bb7b837ec5c15398b66fc0c47b930e8587cea57746eaf2f238ef15f31f03838ffcd40b210347625623f90bd7f4388cf801756e759ba337bab9712a18ba91a92198ce53d51f4d6226f4b3910e0c29a04d2cf04fbd3fc503394d6260482eb681a0b6725bc19b1d3ab3f9588029494893ef2a0bbeeae8df0c09a9ab4cec0196b7456784f64c8949d3445e1b66b2498c1e41a18e005d0a736420a9bcc099520e0a708cc80cc435302ad2dbb09605ea947005199136277c4a5669834488d0742cb6c7b111dbdec1ee66d7fde127e69716789c913d4d0bdf77244e89fd7c5afe3c4403fc2ac7b2e201be680aab46d455ec3ec6a6b087ea4c89475b065ae1273f9ff80b3f371a9b6a126d4c8a2dae839fcf58585516e8d85f671d01b5ce847165bdef1873ff3c3ac6bd684ce142aa520cbfae06b34be0a0744e2942e6d6998603d94e6658dfb0c4982adf0b5555c42d8f37c2d6cd62691a49173cc4893bae04bff6d0108bee0b8d926836a372aa23e1ab0a4edde1ad0b9e9dac941e6861ff5852f0e38b369bdcfc00542489c882eeed49b54971eb600c6b779b3e7937186c7df0f8a84e1837d212c242415aa282ba08ce8b4bb22d6ac11d0f57ed96baa7de95a226eb7a3d2f38449cf8bb9c19df78f265615e2b90ced749240a6bd5fa119e9b1ad7d3e483b24f7cc872e9cbb6db392ca19dcd740a4509ec7a096fdf478475c9645ddece0e6dc8d9bd255a18bc5063fe13181be66c85ac8eafbcb3d35e4ca140acdd2448685322783eef9f7e748e35b2eba06a52eefdef6ea15ca44f8965dfbaa33d22f92d8eeb52c96aa1038c24fcee56b1c09886252b267af2b68c574f6d54a18d8b84d401cd6f95034aee9df97ce9850738046e3351c2956a3960333a73f43c1fbe3d17be3e02de9ebf44dabec2dd4c25e652cb46227ef3686780b95624b07bcc77752f7091cd8b2e2a44251afe13335bb2dc6a89bbde9813f5ea0313669adad8d5cfae786c9280acd77d6d0047d330b1a249dc4a0cde32bbc5f2b37deca3efa4ab035c84228061b732b9af4e152f5130054373a2635a434d8237ec55b78e0a0264512b0d7be4dd26213608e824810e610166378565305f5d7c662c29c0337c5f41f11fcdd6b67bfbfa389541c6e531ecc920f5afd40347a5e7a935fe7703f9c69b6b4bc7c8bcec4528958cee733347733a69e3c50cf8dc9c3bbe9c0de4ca0c55ed39c9b906c575b8ee360681e684584d2736ab69e68d8a19e7ba3fc295397ec2fbe759e0133c8f233d2e7bdffdbfb7aac2f215654a90b3c2978d7c0f804e740a39cfba87efd004ffce6dac392e9d4525df41ff69c53f73048f15f818b2d4581f9dd912787964a0b75b2f28946ace9524c1d348a8c00ff59e6b38b410d84e2cfdb2e847207ed778ac73922742e91b6314f88176fe694824c8729d06bb72c23b3461675ebd960def01a7d82a4de23d75c4acf1062e488d86d7243616ad933f54e7c403aafc3a03ab1a586001dd0f725269b96c8e709bd0341cc3fc45285e9f99c2918aeb2cb9dfcf3e7cfab53ddc6c4c89af2dd96907a6ebdd874744327fe531e91cb94d00e745bd2b6e9c08a25d1afcb98ee7a0dc6f53eab15abcc494856b33434d8aa1211794e8ccedca9ed9f1e56cf36e01165c1885eece260c41b555992037da230da2223eb63bd378519fb574aab16ceb56b5870229f6d953f7a77ce15f127529e1348cc1b586db1bbccf805856c56017d8350b428e7642e638eb8cfc931ec9441162a903fc95e3cfd63d29e5dfcaf4592b4b012ebb7e6cb7e3b30c6eedad194c840f32d90e53752c30aa75312e2257621ec0b38ff9a1182303567139c82d1ff0356a20f0fb8321bd0845641ae3e3823ec4d3e34b275f6c3d7f67ca8d49c5ae08a9722a2b3786a42ee0edbc4734e8629e4f3a24554cab9d520b53e47fa666391dcba820c9b35cb24ba750757edd02ac28c0f76583b43afdc8fb526247f468d339caf75e99dc05aeb3fd05b24fdeb3431db232ecc9fbcc892873aac918600455a692b08d14d487366e7c12500bf69611dc43345d45ccff4593e93253eee81fe0bcd34a3b066a9ee33fe56d37a2704f6ffb5addf7e8b81f22e24a1ce72044381ba23e9d72a98f36b020d783e3e7c07ab55bc0e640f5ba1c344fac94f01d121b2c5067c4d28dd24bb014c501c40838b81ac9b961b7a1ac298904c946070a889cb65f17bbe2b93b66f122d035a3af843caa0c2231395ed7f5b7d5de80304b49e4c41a8521817982b25b4bdf95c1d40c1b48df7c80ba05abb0589f4b79831c34269554a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">周志汇总</summary>
    
    
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
    <category term="周志" scheme="https://blog.phbeats.cn/categories/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/%E5%91%A8%E5%BF%97/"/>
    
    
    <category term="加密" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
    <category term="置顶汇总" scheme="https://blog.phbeats.cn/tags/%E7%BD%AE%E9%A1%B6%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>图-基于邻接表实现</title>
    <link href="https://blog.phbeats.cn/posts/de48a254d011/"/>
    <id>https://blog.phbeats.cn/posts/de48a254d011/</id>
    <published>2023-10-28T06:30:33.000Z</published>
    <updated>2024-04-20T13:06:17.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>使用<code>邻接表</code>作为我的<code>图论算法</code>的基本模板。</p><p><code>图论算法</code>可以使用<code>邻接表</code>和<code>邻接矩阵</code>来作为地基。<br>我选择王道书上的邻接表作为我的模板原因有：</p><ol><li>若要使用<code>邻接矩阵</code>，我有 y 总 的模板。并且也契合，因为可以使用一个<code>二维数组</code>来简化类似邻接矩阵</li><li>我如果是出题人，要指定数据类型，我会选择邻接表，因为考生肯定会优先选择二维数组。</li></ol><h3 id="邻接表的类型描述"><a href="#邻接表的类型描述" class="headerlink" title="邻接表的类型描述"></a>邻接表的类型描述</h3><wavy>我似乎理解错《数据结构》这门考试科目的含义了。它应该重视的是理论，而不是代码的实现，我花费了大量的时间在代码上，这是错误的！因此我打算停更...</wavy>]]></content>
    
    
    <summary type="html">图-基于邻接表实现</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://blog.phbeats.cn/posts/00977ebe8687/"/>
    <id>https://blog.phbeats.cn/posts/00977ebe8687/</id>
    <published>2023-10-27T09:10:02.000Z</published>
    <updated>2024-04-20T13:06:17.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>使用<code>链式存储</code>。</p><p>因为书上的大题使用的都是<code>链式存储</code>。所以我也采取这样的方式，作为我的算法模板。</p><h3 id="二叉树的类型描述"><a href="#二叉树的类型描述" class="headerlink" title="二叉树的类型描述"></a>二叉树的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br><span class="hljs-type">int</span> data; <span class="hljs-comment">// 数据域</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> * lchild, * rchild; <span class="hljs-comment">// 左、右孩子指针</span><br>&#125;BiTNode, * BiTree;<br></code></pre></td></tr></table></figure><h3 id="先序递归建树"><a href="#先序递归建树" class="headerlink" title="先序递归建树"></a>先序递归建树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序递归建树</span><br><span class="hljs-function">BiTree <span class="hljs-title">CreateBiTree</span><span class="hljs-params">()</span></span>&#123;<br>BiTNode * root = (BiTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br><span class="hljs-type">int</span> ch;<br>cin &gt;&gt; ch;<br><br><span class="hljs-keyword">if</span>(ch == <span class="hljs-number">-1</span>)&#123;<br>root = <span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>root -&gt; data = ch;<br>root -&gt; lchild = <span class="hljs-built_in">CreateBiTree</span>();<br>root -&gt; rchild = <span class="hljs-built_in">CreateBiTree</span>();<br>&#125;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">PreOrder</span>(root -&gt; lchild);<br><span class="hljs-built_in">PreOrder</span>(root -&gt; rchild);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br><span class="hljs-built_in">InOrder</span>(root -&gt; lchild);<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">InOrder</span>(root -&gt; rchild);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root)&#123;<br><span class="hljs-built_in">PostOrder</span>(root -&gt; lchild);<br><span class="hljs-built_in">PostOrder</span>(root -&gt; rchild);<br>cout &lt;&lt; root -&gt; data &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="先序遍历的非递归算法"><a href="#先序遍历的非递归算法" class="headerlink" title="先序遍历的非递归算法"></a>先序遍历的非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">// 一路向左</span><br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 出栈，并转向出栈结点的右子树</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>p = p -&gt; rchild;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于先序遍历的非递归算法：<wavy></p><ol><li><code>根左右</code>，先根的性质，决定了在<code>一路向左</code>的过程，是可以<code>边输出边入栈</code>的。</li><li>模拟递归回溯，也就是<code>else</code>部分，此时已经完成了<code>根左</code>。现就只要出栈，并转向出栈结点的右子树。</li></ol><h3 id="中序遍历的非递归算法"><a href="#中序遍历的非递归算法" class="headerlink" title="中序遍历的非递归算法"></a>中序遍历的非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 中序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">// 一路向左</span><br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 出栈，并转向出栈结点的右子树</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br>p = p -&gt; rchild;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于中序遍历的非递归算法：<wavy></p><ol><li>与<code>先序遍历的非递归算法</code>类似，不同的是<code>什么时候访问结点</code>。</li><li><code>左根右</code>，决定了必须要找到最左边的结点再回溯。</li><li><code>else</code>部分，也就是模拟递归回溯过程，必须要先<code>出栈</code>再拿着那个结点的值访问。</li></ol><h3 id="后序遍历非递归算法"><a href="#后序遍历非递归算法" class="headerlink" title="后序遍历非递归算法"></a>后序遍历非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 后序遍历的非递归算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder2</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 需要使用辅助栈，模拟递归</span><br>SqStack s; <span class="hljs-built_in">InitStack</span>(s);<br><span class="hljs-comment">// 遍历指针p</span><br>BiTNode * p = root;<br><span class="hljs-comment">// 还需要借助一个指针r，记录最近访问过的结点</span><br><span class="hljs-comment">// 因为回溯的过程中，可能是从左边回溯，也可能是从右边回溯</span><br><span class="hljs-comment">// 从左边回溯，那么根结点就没被访问过。</span><br><span class="hljs-comment">// 从右边回溯，那么根结点被访问过。</span><br>BiTNode * r = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// p不空 或者 栈不空 循环</span><br><span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">EmptyStack</span>(s))&#123;<br><span class="hljs-keyword">if</span>(p)&#123; <span class="hljs-comment">// 一路向左</span><br><span class="hljs-built_in">Push</span>(s, p);<br>p = p -&gt; lchild;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 转右</span><br><span class="hljs-built_in">GetTop</span>(s, p);<br><span class="hljs-comment">// 右子树存在，且右子树还没被访问过</span><br><span class="hljs-keyword">if</span>(p -&gt; rchild &amp;&amp; p -&gt; rchild != r)&#123;<br>p = p -&gt; rchild;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 否则出栈</span><br><span class="hljs-built_in">Pop</span>(s, p);<br>cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br>r = p; <span class="hljs-comment">// 标记为最近访问过的结点</span><br>p = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 重置p，这样下次循环会直接弹出栈顶元素。</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><wavy>关于后序遍历的非递归算法：<wavy></p><ol><li>指针<code>r</code>：回溯的过程中，可能是从左边回溯，也可能是从右边回溯。<code>∴</code> 从左边回溯，那么根结点就没被访问过。从右边回溯，那么根结点被访问过。根结点被访问过，说明该直接从栈顶弹出一个元素。</li></ol><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 层序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree root)</span></span>&#123;<br><span class="hljs-comment">// 辅助队列</span><br>SqQueue q; <span class="hljs-built_in">InitQueue</span>(q);<br><br><span class="hljs-built_in">EnQueue</span>(q, root);<br><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">EmptyQueue</span>(q))&#123;<br>BiTNode * t; <span class="hljs-built_in">DeQueue</span>(q, t);<br>cout &lt;&lt; t -&gt; data &lt;&lt; endl;<br><br><span class="hljs-keyword">if</span>(t -&gt; lchild) <span class="hljs-built_in">EnQueue</span>(q, t -&gt; lchild);<br><span class="hljs-keyword">if</span>(t -&gt; rchild) <span class="hljs-built_in">EnQueue</span>(q, t -&gt; rchild);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">二叉树</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>顺序队列</title>
    <link href="https://blog.phbeats.cn/posts/54e3f3a21b91/"/>
    <id>https://blog.phbeats.cn/posts/54e3f3a21b91/</id>
    <published>2023-10-27T08:33:53.000Z</published>
    <updated>2024-04-20T13:06:17.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>顺序队列，以<code>循环队列</code>为主。</p><p>因为好写，所以采取它作为我的模板。</p><h3 id="顺序队列的类型描述"><a href="#顺序队列的类型描述" class="headerlink" title="顺序队列的类型描述"></a>顺序队列的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>ElemType data[MaxSize]; <span class="hljs-comment">// 存放队列元素</span><br><span class="hljs-type">int</span> front, rear; <span class="hljs-comment">// 队头、队尾指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化队列 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp; q)</span></span>&#123;<br>q.front = q.rear = <span class="hljs-number">0</span>; <span class="hljs-comment">//初始化队头、队尾指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EmptyQueue</span><span class="hljs-params">(SqQueue q)</span></span>&#123;<br><span class="hljs-keyword">if</span>(q.front == q.rear) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 入队</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp; q, ElemType x)</span></span>&#123;<br><span class="hljs-comment">// 队满,报错</span><br><span class="hljs-keyword">if</span>((q.rear + <span class="hljs-number">1</span>) % MaxSize == q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 入队</span><br>q.data[q.rear] = x;<br>q.rear = (q.rear + <span class="hljs-number">1</span>) % MaxSize;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 出队</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp; q, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 队空, 报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">EmptyQueue</span>(q)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 出队</span><br>x = q.data[q.front];<br>q.front = (q.front + <span class="hljs-number">1</span>) % MaxSize;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获得队头元素"><a href="#获得队头元素" class="headerlink" title="获得队头元素"></a>获得队头元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获得队头元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue q, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 队空，报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">EmptyQueue</span>(q)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 获得队头元素</span><br>x = q.data[q.front];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">静态分配的顺序队列</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>顺序栈</title>
    <link href="https://blog.phbeats.cn/posts/15d79a1a4b3e/"/>
    <id>https://blog.phbeats.cn/posts/15d79a1a4b3e/</id>
    <published>2023-10-27T08:04:26.000Z</published>
    <updated>2024-04-20T13:06:17.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><wavy>顺序栈比较好写,因此我使用它作为我的算法模板</wavy><h3 id="顺序栈的类型描述"><a href="#顺序栈的类型描述" class="headerlink" title="顺序栈的类型描述"></a>顺序栈的类型描述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>ElemType data[MaxSize]; <span class="hljs-comment">// 存放栈中元素</span><br><span class="hljs-type">int</span> top; <span class="hljs-comment">// 栈顶指针</span><br>&#125; SqStack;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp; s)</span></span>&#123;<br>s.top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化栈顶指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断栈空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack s)</span></span>&#123; <br><span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 入栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp; s, ElemType x)</span></span>&#123;<br><span class="hljs-comment">// 看栈是否已满,报错</span><br><span class="hljs-keyword">if</span>(s.top == MaxSize - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 入栈</span><br>s.data[++s.top] = x;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 成功</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 出栈</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp; s, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">StackEmpty</span>(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 先出栈，再减</span><br>x = s.data[s.top--];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获得栈顶元素"><a href="#获得栈顶元素" class="headerlink" title="获得栈顶元素"></a>获得栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获得栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack s, ElemType &amp; x)</span></span>&#123;<br><span class="hljs-comment">// 空栈，报错</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">StackEmpty</span>(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 获取栈顶元素</span><br>x = s.data[s.top];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">静态分配的顺序栈</summary>
    
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="考研笔试自用算法大题模板" scheme="https://blog.phbeats.cn/tags/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师沃卡74110耶加雪菲手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/89001a5236dd/"/>
    <id>https://blog.phbeats.cn/posts/89001a5236dd/</id>
    <published>2023-09-11T14:06:31.000Z</published>
    <updated>2024-04-20T13:06:17.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近又买了两款<code>治光师</code>的咖啡豆。</p><p><img src="https://bu.dusays.com/2023/09/11/64ff1c3e0aee9.webp" alt="Screenshot_20230911_214426_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/09/11/64ff1c53bc299.webp" alt="IMG_20230904_174607"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/09/11/64ff1cbb12663.jpg" alt="IMG_20230910_035340"></p><p><img src="https://bu.dusays.com/2023/09/11/64ff1d1fb1cfc.webp" alt="IMG_20230910_035309"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>冲好后，是红茶和柑橘香味。<br>高温表现为：酸质明亮，甜感十足，但还是酸更为突出。</p><p>温度低一点，甜感增强许多。</p><p>低温时，轻微泛苦，甜感更强，但失去香味，茶感还未失去，有点像吃了烂果子的甜感。</p><p>总体评价：中高温很好喝，让人想一直喝。</p>]]></content>
    
    
    <summary type="html">浅尝治光师沃卡74110耶加雪菲手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝辛鹿号码系列手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/9d745f9baaa9/"/>
    <id>https://blog.phbeats.cn/posts/9d745f9baaa9/</id>
    <published>2023-08-08T08:12:00.000Z</published>
    <updated>2024-04-20T13:06:17.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前买了<code>辛鹿SOE耶加雪菲</code>，然后我去评论了它的风味描述，店家看到了找我售后，表示他们很抱歉。作为顾客，我觉得辛鹿的这个价格，本身我对他家的豆子就不报有很大期望，我基本上是将<code>辛鹿</code>作为行业性价比龙头来看待的，因为学生党时代，我买过辛鹿的咖啡豆，因为便宜，但是味道也就不多提了。</p><p>店家这次给我补偿了一些豆子希望我尝尝，然后表示歉意，所以我还是写一篇评测。</p><p><img src="https://bu.dusays.com/2023/08/08/64d1fa8d9e1e8.png" alt="image-20230808161911377"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p>首先上场的是：<code>辛鹿02意式拼配</code>。</p><p>闻起来就知道是深烘系列了，一如既往的焦味，能喝出些许酸味，整体风味均衡。</p><p>应该算是经典老咖啡风味了。</p><p>总体评价：老咖啡、性价比高。</p><p>然后是：<code>辛鹿04精品罗布斯塔</code>。</p><p>闻起来有种不一样的味道，不是纯烟熏味，更多的是大麦茶的味道，而且气泡超多。</p><p><img src="https://bu.dusays.com/2023/08/08/64d22c610c730.webp" alt="IMG_20230808_194509"></p><p><img src="https://bu.dusays.com/2023/08/08/64d22c60a1944.webp" alt="IMG_20230808_194519"></p><p>喝起来绝了！这尼玛纯纯<code>大麦茶</code>！喝一口，剩下的就不喝了。</p><p>总体评价：大麦茶，不推荐！</p><p>在喝完大麦茶之后，现在是：<code>辛鹿05精选蓝山风味</code>。</p><p>第一口下去纯苦，多喝几口，有浅烘的些许热带水果风味。总体挺均衡，风味不突出。</p><p>总体评价：均衡，均衡得想笑。</p><p>最后，是：<code>辛鹿06精品庄园圆豆</code>。</p><p>闻起来好像是浅烘，呜呜呜，连续喝了那么多深烘，人要死啦。尝尝这个豆子怎么样吧。</p><p>额，喝起来是中烘，风味其实感觉像<code>中烘的耶加雪菲</code>，个人感觉比<code>05</code>好喝，起码这个有风味。</p><p>总体评价：中烘耶加雪菲？性价比高，还行。</p>]]></content>
    
    
    <summary type="html">浅尝辛鹿号码系列手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝四人咖啡粉红佳人手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/b8bb6e256940/"/>
    <id>https://blog.phbeats.cn/posts/b8bb6e256940/</id>
    <published>2023-08-08T07:08:36.000Z</published>
    <updated>2024-04-20T13:06:17.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这次事件挺有意思的，起因是我给了<code>四人咖啡果丁丁</code>一个中评，然后客服来问我要不要售后，退货也行，我表示不需要，并且表示下次要购买他家的<code>粉红佳人</code>，他说给我先送点喝喝，我起初以为给我补发<code>30 g</code>豆子尝尝鲜，谁知道他家诚意满满，发了<code>100 g</code>。</p><p>不过喝了之后，我表示很不错，他家也是发了一个修改评价，我也是改成了好评+空评价。</p><p><img src="https://bu.dusays.com/2023/08/08/64d1ed5b9ac47.webp" alt="Screenshot_20230808_151607_com.taobao.taobao"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/08/64d1edc1c17af.webp" alt="Screenshot_20230808_151830_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/08/64d1ede675129.webp" alt="IMG_20230808_145826"></p><p><img src="https://bu.dusays.com/2023/08/08/64d1edd1322eb.webp" alt="IMG_20230808_145904"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>你知道什么是<code>花香</code>吗？你知道什么是<code>蜜桃</code>吗？我小啜第一口，全是<code>蜜桃和花香</code>，而不是<code>酸或甜</code>。我怀疑店家给我的是<code>A1</code>品质的豆子，几乎喝不出什么负面的味道。</p><p>中高温，蜜桃风味明显，随后才是酸和甜的草莓风味。低温，酸味开始突出，但是蜜桃风味不减，甜感增强。</p><p>继治光师伊迪朵水洗耶加雪菲之后，又一让我眼前一亮的豆子，很惊艳。</p><p>总体评价：蜜桃、草莓、高品质、性价比高、推荐。</p>]]></content>
    
    
    <summary type="html">浅尝四人咖啡粉红佳人手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师野草莓手冲咖啡(整活)</title>
    <link href="https://blog.phbeats.cn/posts/0e42f4daeb32/"/>
    <id>https://blog.phbeats.cn/posts/0e42f4daeb32/</id>
    <published>2023-08-03T03:50:57.000Z</published>
    <updated>2024-04-20T13:06:17.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>买了<code>治光师</code>的另一款咖啡豆，这款咖啡豆是意式拼配，中深烘焙的。之前喝的差不多都是浅烘，不知道这下风味转变能不能接受了呢，应该问题不大，毕竟以前黑咖我都是不加糖的，主打一个不怕苦。</p><p><code>治光师</code>店铺也九周年了，送了一些小玩意，虽然没啥用，姑且也算送了？</p><p><img src="https://bu.dusays.com/2023/08/03/64cb3337d9470.webp" alt="IMG_20230801_181148"></p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/03/64cb32d81bb8a.webp" alt="Screenshot_20230803_114348_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/03/64cb33549edd7.webp" alt="IMG_20230803_114019"></p><p><img src="https://bu.dusays.com/2023/08/03/64cb335dd702a.webp" alt="IMG_20230803_113927"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>豆子看起来棕亮的，冲好之后闻了一下，一股烟熏味，感觉梦回高中了。</p><p>果然，一口下去就知道<code>老咖啡</code>了。整体喝起来十分不错，不对我口味的是那烟熏味！即使是手冲也能感觉到它油脂丰富（别和我说没压就出不来油脂，我说有就有），它入口绵滑，虽然带有烟熏味，但并没有带其它奇奇怪怪的味道，比如<code>焦炭</code>这种。回味能够感受到<code>柑橘</code>风味。草莓酱我倒是没感觉到，不过毕竟是手冲吧。</p><p>这算整活了吧，因为这豆子要用<code>咖啡机</code>来制作，然而我是手冲！因为我现在还没咖啡机，仅仅是手冲爱好者，但是<code>治光师野草莓</code>又十分有名，我抱着试试看的心态买了这款豆子，尝尝鲜。</p><p>总体评价：中深烘焙、油脂丰富、均衡、性价比高。</p>]]></content>
    
    
    <summary type="html">浅尝治光师野草莓手冲咖啡(整活)</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝四人咖啡果丁丁耶加雪菲手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/9c71bc76a9ad/"/>
    <id>https://blog.phbeats.cn/posts/9c71bc76a9ad/</id>
    <published>2023-07-31T22:53:21.000Z</published>
    <updated>2024-04-20T13:06:17.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>四人咖啡送了我一些小玩意，还送了我一包<code>花海</code>，之后我再喝。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/08/01/64c83b62d354b.jpg" alt="Screenshot_20230801_065234_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b71273d0.webp" alt="IMG_20230801_062901"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b8391dae.webp" alt="IMG_20230801_063010"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b951ee47.webp" alt="IMG_20230801_063637"></p><p><img src="https://bu.dusays.com/2023/08/01/64c83b9ea4a2d.webp" alt="IMG_20230801_064028"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>偏高温时，第一口居然是莫名其妙的味道，第二口继续确认，出来的是<code>茶感</code>，随后品<code>茶感</code>的时候容易品出<code>木质</code>和<code>涩味</code>，随后感觉像咬到了一颗焦炭豆子一样，口腔开始发苦。</p><p>温度稍微下来，酸味明亮，茶感明显。但后半段伴随着不好的味道，比如：木质、涩味、烟熏、焦炭。</p><p>其中不好的味道比较突出的是：木质、涩味、焦炭。还是那个问题，喝到瑕疵豆了！</p><p>到了中温才能更好喝出它的风味，耶加雪菲的感觉。不过风味变成：柑橘、焦糖了。</p><p>不过它确实能喝出来，水蜜桃的风味，很神奇哦，不过我是在偏中低温情况喝出来的。高温的表现并不好，因为不好的味道突出太明显了。咖啡豆还真就和运气沾点边，我这批次的豆子应该属于不太理想。去除那些瑕疵风味，我想<code>果丁丁</code>一定非常好喝。</p><p>总体评价：耶加雪菲、些许木质、涩、烟熏焦炭、性价比一般。</p>]]></content>
    
    
    <summary type="html">浅尝四人咖啡果丁丁耶加雪菲手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>王道数据结构链表习题</title>
    <link href="https://blog.phbeats.cn/posts/78005f2f1e1c/"/>
    <id>https://blog.phbeats.cn/posts/78005f2f1e1c/</id>
    <published>2023-07-31T05:32:29.000Z</published>
    <updated>2024-04-20T13:06:17.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表经典大题"><a href="#链表经典大题" class="headerlink" title="链表经典大题"></a>链表经典大题</h3><h4 id="递归删除不带头结点的单链表中所有值为-x-的结点"><a href="#递归删除不带头结点的单链表中所有值为-x-的结点" class="headerlink" title="递归删除不带头结点的单链表中所有值为 x 的结点"></a>递归删除不带头结点的单链表中所有值为 x 的结点</h4><p><img src="https://bu.dusays.com/2023/07/31/64c75c76e2b3a.png" alt="image-20230731150204492"></p><p>题目说了是 L 哦。但是我代码写得是 list。偷懒了。</p><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p>板子</p><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归删除不带头结点单链表中 x 的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del_x</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// 出口</span><br><span class="hljs-keyword">if</span>(!list) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list -&gt; data == x)&#123;<br><span class="hljs-comment">// 如果当前递归中的结点是应该被删除的结点</span><br>LNode * p = list;<br>list = list -&gt; next; <span class="hljs-comment">// 指向下一个结点</span><br><span class="hljs-built_in">free</span>(p);<br><span class="hljs-comment">// 继续寻找</span><br><span class="hljs-built_in">Del_x</span>(list, x);<br><br><span class="hljs-comment">// 下面这三行代码是绝对不能写！！！死循环</span><br><span class="hljs-comment">// LNode * p = list -&gt; next;</span><br><span class="hljs-comment">// free(list);</span><br><span class="hljs-comment">// Del_x(p, x);</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是应该被删除的结点</span><br><span class="hljs-built_in">Del_x</span>(list -&gt; next, x);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="附赠无头结点的尾插法代码"><a href="#附赠无头结点的尾插法代码" class="headerlink" title="附赠无头结点的尾插法代码"></a>附赠无头结点的尾插法代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 无头结点尾插法建立单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TailInsert</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-built_in">InitList</span>(list);<br><br>LNode * r;<br><br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">9999</span>)&#123;<br>LNode * s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>s -&gt; data = x;<br>s -&gt; next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">// 是第一个结点</span><br><span class="hljs-keyword">if</span>(!list) list = s;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 平常的尾插</span><br>s -&gt; next = r -&gt; next;<br>r -&gt; next = s;<br>&#125;<br>r = s;<br>cin &gt;&gt; x;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除带头结点的单链表中所有值为-x-的结点"><a href="#删除带头结点的单链表中所有值为-x-的结点" class="headerlink" title="删除带头结点的单链表中所有值为 x 的结点"></a>删除带头结点的单链表中所有值为 x 的结点</h4><p><img src="https://bu.dusays.com/2023/07/31/64c76dedf2ece.png" alt="image-20230731161643650"></p><h5 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h5><p>板子</p><h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除带头结点单链表中 x 的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del_x</span><span class="hljs-params">(LinkList &amp; list, <span class="hljs-type">int</span> x)</span></span>&#123;<br>LNode * pre = list, * cur = list -&gt; next;<br><br><span class="hljs-keyword">while</span>(cur)&#123;<br><span class="hljs-comment">// 当前结点是应该被删除的结点</span><br><span class="hljs-keyword">if</span>(cur -&gt; data == x)&#123;<br>LNode * q = cur;<br>cur = cur -&gt; next;<br>pre -&gt; next = cur;<br><span class="hljs-built_in">free</span>(q);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 当前结点不是应该被删除的结点</span><br>pre = cur;<br>cur = cur -&gt; next;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="从尾到头反向输出带头结点单链表中每个结点的值"><a href="#从尾到头反向输出带头结点单链表中每个结点的值" class="headerlink" title="从尾到头反向输出带头结点单链表中每个结点的值"></a>从尾到头反向输出带头结点单链表中每个结点的值</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb446b8fd07.png" alt="image-20230803135630640"></p><h5 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h5><p>利用栈的思想</p><h5 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 反向输出链表中每个结点的值</span><br><span class="hljs-comment">// 0.在 main 函数中，调用要注意！</span><br><span class="hljs-comment">// 1.Reverse_Print（list -&gt; next); 带头结点</span><br><span class="hljs-comment">// 2.Reverse_Print（list); 不带头结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reverse_Print</span><span class="hljs-params">(LinkList list)</span></span>&#123;<br><span class="hljs-comment">// 出口</span><br><span class="hljs-keyword">if</span>(!list) <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">// 入栈</span><br><span class="hljs-built_in">Reverse_Print</span>(list -&gt; next);<br><br><span class="hljs-comment">// 出栈</span><br>cout &lt;&lt; list -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除带头结点单链表中的唯一最小值"><a href="#删除带头结点单链表中的唯一最小值" class="headerlink" title="删除带头结点单链表中的唯一最小值"></a>删除带头结点单链表中的唯一最小值</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb4502a04bb.png" alt="image-20230803141117604"></p><h5 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>利用 <code>min_pre</code>、<code>cur</code> 两个指针</li><li>利用线性表寻找最小值算法思想</li><li><code>min_pre</code>用来更新保存，目前已知最小值结点的前一个结点</li></ol><h5 id="核心代码-3"><a href="#核心代码-3" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除单链表中唯一最小值结点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Del_Min</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 如果是空表或只有头节点</span><br><span class="hljs-keyword">if</span>(!list || !list -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 经典前后指针</span><br>LNode * pre = list, * cur = list -&gt; next;<br>    <span class="hljs-comment">// 保存最小值结点的前一个结点</span><br>LNode * min_pre = list;<br><br><span class="hljs-comment">// 假设最小值是第一个节点</span><br>LNode * t = cur;<br><span class="hljs-comment">// 打擂台</span><br><span class="hljs-keyword">while</span>(cur)&#123;<br><span class="hljs-comment">// 如果发现比最小值还要小的</span><br>         <span class="hljs-comment">// 打赢了，新的当 t</span><br><span class="hljs-keyword">if</span>(cur -&gt; data &lt; t -&gt; data)&#123;<br>t = cur;<br>             <span class="hljs-comment">// pre 作为 新的min_pre</span><br>min_pre = pre;<br>&#125;<br><span class="hljs-comment">// 俩指针后移</span><br>pre = cur;<br>cur = cur -&gt; next;<br>&#125;<br><br><span class="hljs-comment">// 删除擂主</span><br>min_pre -&gt; next = t -&gt; next;<br><span class="hljs-built_in">free</span>(t);<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="带头结点的单链表逆置"><a href="#带头结点的单链表逆置" class="headerlink" title="带头结点的单链表逆置"></a>带头结点的单链表逆置</h4><p><img src="https://bu.dusays.com/2023/08/03/64cb637357a20.png" alt="image-20230803162110380"></p><h5 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h5><p>准备<code>pre</code>、<code>cur</code>、<code>r</code> 3个指针，<code>cur</code>指向<code>pre</code>。</p><h5 id="核心代码-4"><a href="#核心代码-4" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表就地逆置</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reverse_LinkList</span><span class="hljs-params">(LinkList &amp; list)</span></span>&#123;<br><span class="hljs-comment">// 空表或者只有头结点或者只有一个元素</span><br><span class="hljs-keyword">if</span>(!list || !list -&gt; next || !list -&gt; next -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>LNode * pre = list , * cur = list -&gt; next;<br>LNode * r = cur -&gt; next;<br><span class="hljs-comment">// NULL &lt;- cur &lt;- r</span><br>cur -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">while</span>(r)&#123;<br>pre = cur;<br>cur = r;<br>r = r -&gt; next;<br>cur -&gt; next = pre;<br>&#125;<br><br><span class="hljs-comment">// cur才是真正的主元素，r只是拿来判断的边界条件</span><br>list -&gt; next = cur;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单链表的插入排序"><a href="#单链表的插入排序" class="headerlink" title="单链表的插入排序"></a>单链表的插入排序</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32c0724c39.png" alt="image-20230809140236810"></p><h5 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h5><p><a href="/posts/f7271c1a5982/">跳转链接</a></p><h5 id="核心代码-5"><a href="#核心代码-5" class="headerlink" title="核心代码"></a>核心代码</h5><p><a href="/posts/f7271c1a5982/">跳转链接</a></p><h4 id="两个单链表的公共结点"><a href="#两个单链表的公共结点" class="headerlink" title="两个单链表的公共结点"></a>两个单链表的公共结点</h4><p><img src="https://bu.dusays.com/2023/08/09/64d32d21a0968.png" alt="image-20230809140728686"></p><h5 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h5><p>假设有两个单链表<code>A</code>和<code>B</code>。</p><p>单链表<code>A</code>长度为：a</p><p>单链表<code>B</code>长度为：b</p><p>无非两种情况：<code>相交</code>和<code>不相交</code></p><p><img src="https://bu.dusays.com/2023/08/09/64d32ff3099be.png" alt="image-20230809141931085"></p><p>可以利用<code>a + c + b</code> ＝ <code>b + c + a</code>。求出交点。</p><p>这是<code>不相交</code>的情况。</p><p><img src="https://bu.dusays.com/2023/08/09/64d330de84da4.png" alt="image-20230809142327260"></p><p><code>a + b</code> ＝ <code>b + a</code>。</p><p>相遇为<code>NULL</code>，返回<code>NULL</code>。</p><p><code>公式恒成立</code>。</p><h5 id="核心代码-6"><a href="#核心代码-6" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LNode * <span class="hljs-title">findFirstCommonNode</span><span class="hljs-params">(LinkList headA, LinkList headB)</span> </span>&#123;<br>    LNode * p = headA , * q = headB;<br>    <br>    <span class="hljs-keyword">while</span>(p != q)&#123;<br>        p = p ? p -&gt; next : headB;<br>        q = q ? q -&gt; next : headA;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将原单链表A分裂为：奇A表和偶B表"><a href="#将原单链表A分裂为：奇A表和偶B表" class="headerlink" title="将原单链表A分裂为：奇A表和偶B表"></a>将原单链表A分裂为：<code>奇A表</code>和<code>偶B表</code></h4><p><img src="https://bu.dusays.com/2023/08/09/64d33587565fd.png" alt="image-20230809144319763"></p><h5 id="核心思想-7"><a href="#核心思想-7" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>奇偶序号计数<code>i</code>。</li><li><code>ra</code>和<code>rb</code>尾指针。</li><li>将<code>A</code>的<code>next</code>先<code>置空</code>，后面会通过<code>ra</code>来增加结点。</li><li>根据<code>i</code>的奇偶，在<code>ra</code>或者<code>rb</code>后面增加结点<code>p</code>，再更新<code>ra</code>或<code>rb</code>。</li><li><code>ra</code>和<code>rb</code>的<code>next</code>需要<code>置空</code>。</li></ol><h5 id="核心代码-7"><a href="#核心代码-7" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将原单链表A分裂为：`奇A表`和`偶B表`</span><br><span class="hljs-function">LinkList <span class="hljs-title">Re_Create</span><span class="hljs-params">(LinkList &amp; A)</span></span>&#123;<br><span class="hljs-comment">// 准备B表</span><br>LinkList B = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>B -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 准备工作</span><br>LNode * ra = A , * rb = B; <span class="hljs-comment">// A 和 B 的尾指针</span><br>LNode * p = A -&gt; next; <span class="hljs-comment">// 遍历准备工作</span><br><br><span class="hljs-comment">// A 表断开</span><br>A -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 奇偶序列计数</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p)&#123;<br>i++;<br><span class="hljs-comment">// 奇</span><br><span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span>)&#123;<br>ra -&gt; next = p;<br>ra = p;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 偶</span><br>rb -&gt; next = p;<br>rb = p;<br>&#125;<br>p = p -&gt; next;<br>&#125;<br><span class="hljs-comment">// 尾指针置空</span><br>ra -&gt; next = <span class="hljs-literal">NULL</span>;<br>rb -&gt; next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> B;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="递增有序的单链表，去除相同的元素"><a href="#递增有序的单链表，去除相同的元素" class="headerlink" title="递增有序的单链表，去除相同的元素"></a>递增有序的单链表，去除相同的元素</h4><p><img src="https://bu.dusays.com/2023/08/09/64d33acd8d1ba.png" alt="image-20230809150548410"></p><h5 id="核心思想-8"><a href="#核心思想-8" class="headerlink" title="核心思想"></a>核心思想</h5><p><a href="448d550da686">跳转链接</a></p><h5 id="核心代码-8"><a href="#核心代码-8" class="headerlink" title="核心代码"></a>核心代码</h5><p><a href="448d550da686">跳转链接</a></p><h4 id="带头结点的循环双链表是否对称"><a href="#带头结点的循环双链表是否对称" class="headerlink" title="带头结点的循环双链表是否对称"></a>带头结点的循环双链表是否对称</h4><p><img src="https://bu.dusays.com/2023/08/09/64d33f2db78aa.png" alt="image-20230809152429784"></p><h5 id="核心思想-9"><a href="#核心思想-9" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>设置两个指针<code>p</code>和<code>q</code>。往两个不同的方向走</li><li>结点数是奇数和偶数，是难点。<code>2n + 1</code>和<code>2n</code>。</li></ol><h5 id="核心代码-9"><a href="#核心代码-9" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Symmetry</span><span class="hljs-params">(DLinkList list)</span></span>&#123;<br>    DNode * p = list -&gt; next , * q = list -&gt; prior;<br>    <span class="hljs-comment">// 第二个条件容易写成 p -&gt; next != q;</span><br>    <span class="hljs-keyword">while</span>(p != q &amp;&amp; q -&gt; next != p)&#123;<br>        <span class="hljs-keyword">if</span>(p -&gt; data == q -&gt; data)&#123;<br>            p = p -&gt; next;<br>            q = q -&gt; prior;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单链表判断是否有环"><a href="#单链表判断是否有环" class="headerlink" title="单链表判断是否有环"></a>单链表判断是否有环</h4><p><img src="https://bu.dusays.com/2023/08/09/64d34b2220fb7.png" alt="image-20230809161529567"></p><h5 id="核心思想-10"><a href="#核心思想-10" class="headerlink" title="核心思想"></a>核心思想</h5><ul><li>慢指针一步一步走，快指针两步两步走</li><li>无环：快指针必定会先到达终点（NULL）</li><li>有环：俩指针会相遇，相遇之后，让慢指针回到起点，再让快慢指针同步速度，一步一步走</li><li>当再次相遇的时候，那个点就是环的入口</li></ul><h5 id="核心代码-10"><a href="#核心代码-10" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">entryNodeOfLoop</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode * slow = head , * fast = head;<br><br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-comment">// 有环，相遇了</span><br>            <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果fast是空，那么代表无环，否则代表有环，并且slow == fast成立</span><br>        <span class="hljs-comment">// 而且，如果while循环条件一开始就没满足，那么代表head是空节点亦或者长度为1</span><br>        <span class="hljs-keyword">if</span>(!fast || !fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// slow == fast ， 有环</span><br>        <span class="hljs-comment">// 让slow回去，fast和slow以同样的速度走，再次相遇就是环的入口结点</span><br>        slow = head;<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            slow = slow -&gt; next;<br>            fast = fast -&gt; next;<br>        &#125;<br>        <span class="hljs-comment">// 再次相遇了</span><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br><br>作者：麦高芬<br>链接：https:<span class="hljs-comment">//www.acwing.com/solution/content/153752/</span><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="单链表倒数第-k-个值"><a href="#单链表倒数第-k-个值" class="headerlink" title="单链表倒数第 k 个值"></a>单链表倒数第 k 个值</h4><p><img src="https://bu.dusays.com/2023/08/09/64d34d9156593.png" alt="image-20230809162553225"></p><h5 id="核心思想-11"><a href="#核心思想-11" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>两个指针<code>p</code>和<code>q</code></li><li>先让它们两个相距<code>k</code></li><li>当<code>q</code>遍历完的时候，<code>p</code>就是倒数第<code>k</code>个节点</li></ol><h5 id="核心代码-11"><a href="#核心代码-11" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_K</span><span class="hljs-params">(LinkList list, <span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-comment">// 计数</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>LNode * p = list -&gt; next, * q = list -&gt; next;<br><br><span class="hljs-keyword">while</span>(q)&#123;<br><span class="hljs-comment">// 先让q走 k 步</span><br><span class="hljs-keyword">if</span>(count &lt; k)&#123;<br>count++;<br>q = q -&gt; next;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>p = p -&gt; next;<br>q = q -&gt; next;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 查找失败</span><br><span class="hljs-keyword">if</span>(count &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> cout &lt;&lt; p -&gt; data &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h4><p><img src="https://bu.dusays.com/2023/08/09/64d35190e4e8b.png" alt="image-20230809164257287"></p><h5 id="核心思想-12"><a href="#核心思想-12" class="headerlink" title="核心思想"></a>核心思想</h5><ol><li>先遍历一遍链表，获取链表的长度。</li><li>根据获取到的链表长度，获取链表中间的结点。(向上取整)</li><li>反转后半段链表。</li><li>合并前半段链表和反转后的后半段链表。</li></ol><h5 id="核心代码-12"><a href="#核心代码-12" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rearrangedList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head-&gt;next) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 获取链表的长度</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = head ; p ; p = p -&gt; next) len++;<br>    <br>        <span class="hljs-comment">// 链表中间的结点</span><br>        <span class="hljs-type">int</span> left = (len + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">auto</span> a = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; left - <span class="hljs-number">1</span> ; i++) a = a -&gt; next;<br>    <span class="hljs-comment">// 反转后半段链表，b在前，c在后  </span><br>        <span class="hljs-keyword">auto</span> b = a -&gt; next , c = b -&gt; next;<br>    <span class="hljs-comment">// a-&gt;next 是为了从中间将链表截断；b-&gt;next 是因为此时的 b 是反转后链表的结尾元素</span><br>        a -&gt; next = b -&gt; next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-keyword">while</span>(c)&#123;<br>            <span class="hljs-keyword">auto</span> p = c -&gt; next;<br>            c -&gt; next = b;<br>            b = c; c = p;<br>        &#125;<br>    <br>        <span class="hljs-comment">// 合并链表，注意此时 b 指向反转链表头部</span><br>        <span class="hljs-keyword">auto</span> p = head;<br>        <span class="hljs-keyword">auto</span> q = b;<br>        <span class="hljs-comment">// o -&gt; o -&gt; o -&gt; NULL (p)</span><br>        <span class="hljs-comment">// o -&gt; o -&gt; o -&gt; NULL (q)</span><br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            <span class="hljs-keyword">auto</span> o = q -&gt; next;<br>            q -&gt; next = p -&gt; next;<br>            p -&gt; next = q;<br>            p = q -&gt; next;<br>            q = o;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">王道数据结构链表习题</summary>
    
    
    
    <category term="王道数据结构习题" scheme="https://blog.phbeats.cn/categories/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    
    
    <category term="王道数据结构习题" scheme="https://blog.phbeats.cn/tags/%E7%8E%8B%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师肯尼亚圆豆手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/bb95ebed2e97/"/>
    <id>https://blog.phbeats.cn/posts/bb95ebed2e97/</id>
    <published>2023-07-29T22:45:30.000Z</published>
    <updated>2024-04-20T13:06:17.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是治光师会员限购9.9包邮的，肯尼亚FCS合作社顶级圆豆批次，水洗处理的浅烘豆子。</p><p>9.9元30g，不妨让我来试试水。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/30/64c5986ae14d5.webp" alt="Screenshot_20230730_064146_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/07/30/64c5987b1a642.webp" alt="IMG_20230730_063602"></p><p><img src="https://bu.dusays.com/2023/07/31/64c74e7532b67.webp" alt="IMG_20230730_063624"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>一到货熟豆闻起来和之前买的<code>菠萝成子危地马拉瑰夏</code>味道差不多。先养养豆。</p><p>第一口下去是它的酸度和甜度，比较突出，酸度明显高于<code>治光师耶加雪菲</code>，最大的亮点是它真的<code>很甜</code>。喝完后回甘有很久很久，感觉喝了蜂蜜一样，不过对于我这种不太喜欢甜的咖啡的人来说，有点偏齁甜了。它的<code>热带水果风味</code>实在太足了，十分好喝，有轻微涩味，不过太能接受了！</p><p>总体评价：烟熏、涩、果酸和甜感突出、性价比高、推荐。</p>]]></content>
    
    
    <summary type="html">浅尝治光师肯尼亚圆豆手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅尝治光师伊迪朵耶加雪菲手冲咖啡</title>
    <link href="https://blog.phbeats.cn/posts/32f6f1e29b78/"/>
    <id>https://blog.phbeats.cn/posts/32f6f1e29b78/</id>
    <published>2023-07-23T00:00:02.000Z</published>
    <updated>2024-04-20T13:06:17.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这款<code>治光师伊迪朵耶加雪菲</code>是群友推荐的，直接无脑买了。<br>写这篇文章，已经过了好些日子了，这是第二次喝的时候写的评价。</p><h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p><img src="https://bu.dusays.com/2023/07/13/64af5071a51a7.webp" alt="Screenshot_20230713_085908_com.taobao.taobao"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf456c60.webp" alt="IMG_20230723_064938"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf52e837.webp" alt="IMG_20230723_065210"></p><p><img src="https://bu.dusays.com/2023/07/23/64bc7cf44e11f.webp" alt="IMG_20230714_081733"></p><h3 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h3><p>首先，从豆子品控来看，是十分优秀的。</p><p>高温下，酸很<code>明亮</code>，基本无涩感，值得一提的是<code>茶感</code>很明显，有些许回甘，带<code>清香的甜</code>。</p><p>低温下，酸更加明显，有<code>SeeSaw 甜橙子</code>那味了。<code>茶感</code>更上一层楼。</p><p>目前喝过<code>最棒的耶加雪菲</code>。</p><p>缺点可能就是100g需要45元，喝几次就无了吧。真的，它就是优秀，挑不出什么刺。非要说的话，喝完后还是有些许烟熏感，不过能够接受。</p><p>不过我觉得这种价格配得上这种品质。</p><p>总体评价：浅烘、水果清香、茶感浓郁、性价比适中、推荐回购。</p>]]></content>
    
    
    <summary type="html">浅尝治光师伊迪朵耶加雪菲手冲咖啡</summary>
    
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.phbeats.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="咖啡" scheme="https://blog.phbeats.cn/tags/%E5%92%96%E5%95%A1/"/>
    
  </entry>
  
</feed>
