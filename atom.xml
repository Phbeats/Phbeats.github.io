<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phbeats-Blog</title>
  
  <subtitle>记录学习历程和生活感悟</subtitle>
  <link href="https://blog.phbeats.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.phbeats.cn/"/>
  <updated>2023-01-22T13:39:43.618Z</updated>
  <id>https://blog.phbeats.cn/</id>
  
  <author>
    <name>Phbeats</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简单选择排序</title>
    <link href="https://blog.phbeats.cn/posts/1421240f22ac/"/>
    <id>https://blog.phbeats.cn/posts/1421240f22ac/</id>
    <published>2023-01-22T07:34:03.000Z</published>
    <updated>2023-01-22T13:39:43.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><div class="note success simple"><p>本文将用图例介绍冒泡排序的过程，和经典的优化板子</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3>]]></content>
    
    
    <summary type="html">简单选择排序图解</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://blog.phbeats.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="https://blog.phbeats.cn/posts/085c695cb1f5/"/>
    <id>https://blog.phbeats.cn/posts/085c695cb1f5/</id>
    <published>2023-01-22T06:15:40.000Z</published>
    <updated>2023-01-22T13:39:43.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><div class="note success simple"><p>本文将用图例介绍冒泡排序的过程，和经典的优化板子</p></div><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><strong>从后往前</strong>（或从前往后），两两比较相邻元素的值，<strong>若为逆序</strong>（q[i - 1] &gt; q[i]），<strong>则交换它们</strong>，直到序列比较完。</p><p>一个简单的例子：</p><p><img src="https://bu.dusays.com/2023/01/22/63ccdf3d64573.png" alt="image-20230122144353880"></p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p><wavy>时间复杂度</wavy>：</p><ul><li>最好情况：O(n)</li><li>平均情况：O(n<sup>2</sup>)</li><li>最坏情况：O(n<sup>2</sup>)</li></ul><p><wavy>空间复杂度</wavy>：O(1)</p><p><wavy>稳定性</wavy>：稳定</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// n个元素，比 n - 1 趟</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n - <span class="hljs-number">1</span> ; i++)&#123;<br>        <span class="hljs-comment">// 优化，这样可以当元素有序时，一趟就退出</span><br>        <span class="hljs-comment">// 有没有交换过</span><br>        <span class="hljs-type">bool</span> has_swap = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 从后往前枚举，由于比较的是相邻元素，j到 i + 1 就行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span> ; j &gt; i ; j--)&#123;<br>            <span class="hljs-comment">// 逆序</span><br>            <span class="hljs-keyword">if</span>(q[j - <span class="hljs-number">1</span>] &gt; q[j])&#123;<br>                <span class="hljs-built_in">swap</span>(q[j - <span class="hljs-number">1</span>], q[j]);<br>                has_swap = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果没有交换过，代表整个序列在第一趟检测出有序，直接退出排序</span><br>        <span class="hljs-keyword">if</span>(!has_swap) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://www.acwing.com/activity/content/code/content/4550243/">我</a></p>]]></content>
    
    
    <summary type="html">冒泡排序图解</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://blog.phbeats.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>2022年度总结</title>
    <link href="https://blog.phbeats.cn/posts/bf74f35b9f99/"/>
    <id>https://blog.phbeats.cn/posts/bf74f35b9f99/</id>
    <published>2023-01-21T12:28:14.000Z</published>
    <updated>2023-01-22T13:39:43.618Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a62bc23f2c085aeb531efc8a8ec67a6bafe72fe72f57304802412d8ec0778877">891a58d5686823e9794bd6b038ea3f747a7ea2278708f5dcd996517890a85d0a1e7535d0772f4e345e653d8793b364743d6a652689c71a2eba3a77033d5e98d73e6b418b213d938c279f588d3f1e388787c0f6f4f058e6e3044fe26c917a852ca1a39c55f0bd3011610f719537df1472b064c3dfc30f6f6b0d34204eb47143fc96ce6278395bf056b2f67dcfa006129c6d02e748c0a96e60d8a04aa80421d7d6479652da7a9924c335566cc7b4bca8209250af32f5340f530331ac424fa40ab9ebf646693c2db79e1a10c3e8e74abb8ca0dcf7aa52eb87949910a3b1ae057715c9b3f4bee88131089f2caf471bb24061409eb89aacb1df01752372487ab3d5253f3b239e2a654209e5f2e11dbb487e1a0c5f918f32994ef672df5d09cd595eca316d979622d7fd17b19b8ea73fbeb896756ce7b5147a7b93249af917c53883c6f3b5987273dc6f28a29f9a5b34506b0d8e4f50b85b18f77aa0b9a377c9cbccae1e0b98de29485561ea29e7b4ae2b4710e1dc47a6ebb1386068fe682e63649bf5359b0e6a214a93791f7ae3ca52dc2b7a996836707969b7c8684710c2986a78eec0d3d76d1683f08bc8aff38cf76309942b133fede10b8e1e2d931fbad10116b89535c79b89cd5c9dcfe83c41c94f3b97ac3a9b4271f477df366785e739d15d094233477310dfd4554c8a628a42572998dd37db672e7d36ba469af3752069ab7750a2c5428860c0acba1206d2b6c196f9f8dcc1e39efa02ced64b10fe53d44f18f38bfddaa99ae834af7e383247ee247dc1ce88de582bd36e8b24a18fc21259d8b6855e72d0eaf0458d05fb109f7a916bb3be97bada52fd810176b9e675f0c2b1caf349bbd92b2a9dd2f0bae44fea584c952d2f777ee12451403b63a8b548fb13c35b26ce60870f7dd3a82eff66c282adf38e927e9e0514439357b56bad71cfb9d794c61cef80050772a53ef87c328e6a51972c67881a0f304828414773d8bdeca78b15b7cc68e34ca37af101ff74e4ba345cf7b88802387379284337b531cb18933e173eb3367528878d2632b9c1d8ff167903717d92f392bc3bd3fafef5a297effe41a2b56099cd03ad605604f27363613394365a584f58f9fe1c2d70ad9d3c576f6f09544b2f9acdf144abc3e1b30617b85afcd36688473261b4ac679f9006390c7df6764b8f9e2ee353ab75429a4c08a714ab14acd22379f8d96aa1c1a21c0f317b517b569ccaf2c17fcdfbc026d68d84b3adeb239df211c16356d58f3d1410f6b95778d8b44d068a7d6f7fa3cbac3ff345e7e99ad7d3916cea6b99e9a90580a8916b5a103acd640ccb260bc09a5cac77c57d0ba1e37e6f291eac4c4630034a3cb140bd434e498507721daa941c84421c045d92da6ad4ba6a8ae9066a1c00d315628695384a29d8e7e1a73d879c26a7d8d8a6f9c07e1c3f7faf159fcbff4b199f3727877a2ebb381b88f9f3c558127b77c5e5328a25ebf2388f29cc0aa11f5c01eb1881a72c9c56d6ffc40391bd4659dab8b0ce694b1afe055fec08560a9eb9f4b0c28f69491f8a1f7e6941a383cbcd27129505ebe38eba60a8a8b68a9bb420e808964362cbb1c66f9b52cb8ee7b5f222001ddcf13d61b8eea8ae02a8f515f2fec150db0d388df6337bf4be37cf9ad5ba928c812ff1745246c1cb58a9af07265b987406d93007d4b09c59fb7edc875e44146eddbf6e3f59ceeab45c01096fd6ea4c043a819895a359afdc28ccb88925a0b7dd611195b8133f7266c087776f09b69fe239a6d8c9b44437f657091d695a2d24c7bb88c1369461c04ab3c2f89af0b8af45c9aaa9c63f17e8bb0c621a253d316aedc3f0102fbe8557e6e4e8974e5e2324ede8cf85ae1fb4ca5f6e2f1a27bd968a3d0d6fa12fcda172a237e17130f5bd572fdf10a2fade9b4058e5dee4efc7b8fb9253818a1eb47e0f88c9ddb7bc179569ec78584d15841123ca5aa0cc81f80634a0339fcd00869613c959af7fa02e4b6aa3699ec67c5ad302dacc72c739751f3ccc2843a9219fa0f480af77803adac34fb9ea51784eac829ffca80f223a9436e24c5ce9c76a57f53743873cd16e27eedf418cc081b884ff0b4ce037443bbfabc500f6e78533ca209ddad62031f1481938b52529907fbcaebc1e35e29e32586db477ef3f0501eb849e7aa2a1acec53c58259ebd0e7e23033bd2550c843a4cc2764c1a9fea3934b1c2b35727971d6f9a385a4d2c682fd370f6452825fe9b6a4ab43c7392fa76dc75754b2f7dba9a8b358da18e0313ad291fb976200b2f7b760ac97e6f1913663704f2c00815e3f57e1e0cabdb4b10a904ee2485a53d199a9de2c33fae58f70a5760484c909160e8b66647be41723e16a5cd577ebec9d1b62239eca3166178f9c48b90f624499e20880a51c3999e8e7ce007decf02a7f07f945383da62a065faccaf90bf38543f0384f4fb10bc74263cc8b9be902285890afd4b53efd07a3809f42ec0334a8933bb38689a930273ec968cef30135dcbf695a0273b19c604eda51e088a3c3c44b342bb2465bb4df360d18d559db077724c770502b26be6abd90ffdd8b13dc4d972d8d237f8f4d8457d4b1a743e295918034e34bb75db42f2189a366478330b55f380e586a8e9046d57466aef42ebf0c244c46108c6224b69f42d4f7adb1f1e1121430a94ad6080b36ff4394d55e7c47929a21ab202803452cafb0ff0ae9aed462b18e7955b7d7d17807b909774d4662cf2f5c4e39d2dcf6fe6417be5f6c2898dd669451ee8ff84b2d078c0d4ec768d0ff6b43c428fe51f79e82e0ed396dbe8b5c0f4d67451788e1cc3fdc25693855617485e0c0c1b34674b196909f4b831a29d293f8c440aed537cc180a14f8d69ce61fd5afcd29496c62af9a07fa0996371a9d325f2e5e6bc53414bd585a772c99f4c5a924bb5dc312b8395d5006a8ef85938e8aff8b9d64220fdc18ad42b16d7ae0e9cf707315a5fcf7bbc008d98ff920d2bb4bf241d0ee3c0cb3baef00983ca651609750968127b9f02c480efedc8a0415c2f4ffe5492b03b6b0283ec8d8ca3f468be6c14d08abf7b39d6243fb000c8a624c01e0da24403a3b91493742b561da7d0cc061faa5e65f14e704d2727e412ca097c14f4b764db356bc81d829f732271ffbdf1f713b08df1ddb2d0977ce4a1560045275cea03bdda959b79316be2479452c8ea370b262dd19b4f51922b090cbb96cef99ec4939fa3e25a2ad92b4f27ad2f0ae407bbe5cf8315e4954d114335d113453a9c1642ea1c4ffbbeda56e317d4ac24706c9738f95f90d66deffe008fd71cf89e447d6e8190fc04ba55a8330848b46f807d02acca4b055ffb9ccafde4ea0d32d52e4b318e3b193787b8d255e542ca10a7a22c2b61d0e7a1c62c636247142237c9ede1e3fc174c39362fee42f160d153b8b793126d214a4f612e0b492dd3a4caf2e33f3f86368fa4e370544e4e03c74f4be3ea1ef426d4c69cba625228bf0c7d87435d5c286aada0de4f9edd2d461746333ca179359de445092552fae0f9e2ebdac1ff0b33529a60d6e475a5664a4631353e30987c26b906d3ebab5a232fa57bc9d2d2679f5cd90615bb5940ca53da37d4c06500dc2529f63a13004c2b4f1d9b3aa973f959606b872b111c37be96bea778f86aa0f9d52e45a31957f4a0aebca1f4936f15c16a7ed8a655f449e0c73a520cc198a3e089ce688fdd10c0363565e3fb50a2f34b38522b09da4179879ff02d7509167bcf956d7ea8137e1339e5cafdfa91de8248a7191436a09e9dd565fd9f00493c1d5e35784113fb203457802e93baf1cd7102d0ab053e8cad4544c091265ef9e816604fe4c49887e544a623dad3aed691e0f37e9a460edfd715becca3ecf9e4f413b90d0b38ccfab59967c5e81f2ca32980b1e81cab3c97270c3d338b50828ac4b2c691e897f94898728e75c22fd82ab718f359b6afc63ed4a2c140ef8a30cb1ee4e3d8d9296edd37bd950ce20cdd0bee48c54e30a42f1a6f7b2d30615dd8f9a35a3ae2cb1826a0830ec90eb38466483d0d16780af58d3372c5dd8771ab6f5df6c03c499349e205f1af33670c92e6b678fffe51a73630e08922aa4461fe878a267d4c6f9a88b09a247482038a848c57babc6e91d7fbe5d50caac729c9a70a6ea41fa8d67d6608848397a056e1e7d9aa9c5e6c7c934a8724a4ed407c00340ba966ff2ead8536ee4268f6f14218eebdf87a0fdf00d9055f75bcb60f73c7b6f07177df80a5dce5a310f137b06ce2282427b81fee53b66353bcd9e1572051923d1c4099bdd82b039be8563ab42e1a43843e3ded9c9648c9e84adb1345a662a3d68c62b2c1a2c2541cd8bd00480a51c623cbaf2468830ebba8b19f33d0db160fa9777bb4028684df4814fa8e51dcd393e6f1cc5dcc3b23d4123e3540ad28a7dee09768e5908c0027d8c0128aa6e760660c841af36255ba9bbbadc52ba52572f747ecaafc367786dfa685d16b156179f58367f70cade46cfbf469079d19e8ae28a33db649fd93a3b6c95c2b9130230f9ff4bb49553036ca229534dc868345cb7868fa6a4dbce7626f0bcd0c5bf8702409fb77a3177cb2a6c39fd9c9e2a81248bf3cd47771097c3c6a1ad96345589e8cf9de017609d0302d3559996aae254ee139b0c250b059f66be52e5ccfe81cc27539cf21b1be0c8827458a15663afde4247c8eed1a6a11bec44189ae706fbaf6a7ca2dfa522505e37d6ad3b6ba214705335be92112735b2a624f7c0dccb665742d4ff0593b7f675b029494b0e652e8f9fad0d0b88572e514a7cb944df38567ec92bbd3fab9eb8c655bcf992be9841d43f70a476bc9d8fb2b9f3ef114d438748253062737237f47f3bc6e5f113115640045f549040a3445e1e52ecb58b88222c878bd3cbe384af37abbce834c2b56a0b5fc734250aacd82cf06044499152bf4f96016137a32c2062341db2efc508b1145e0bc0c9e3788a79597ea3195f87a094ba14535f242a163dec2328a08a68b1b4d9dcace712cc356c34bc20ef5ba431172568d19905431a3fdfc0fe9ec1f0051482d1ad72d9c9c6237ab15a52bfe7c8ec937ad0b81f5ee1fe92f56bad858301f8ba1a8c8e0a3c4a5b09612197c317c8c5f8ad875492264596be3628a62d2962909274588547d2b4f664ab71f1ef4e26b49de5a39ac6d4007ca334628e1f8d2116a3066c697a91eb021ebfa3db46a2652d7701116b656d6073733fc40cbb6d90660b96705576273ee355c8dfa55f82ef3ffc06a53f847e03fa17b10fc546b745fe0b56c524d642104e646226d77de556f9a79fd0f29948b40b4c346ed9774c9ea7c49138e06eb89859f791ceda6a4087b2bb187272be2eea73bb4d5277863e4bb11ecdd58b6c4d2b76136896b14e488e3234ac2453eb665ca450333740452ded7e7986ee2149feba6c7a25c5481151d7a13cb15533f55bb9a3ba707248e218c49e2f20ee1560f6f532538c1b6f5ecf5c491270b5d70a90c8721c231741d26b6374b69ef58fbff78a3b0d6dcb0ab8bc8e27ae77edaa60b35cf7dd9e190274ecccd9f6b28ddefb8b35a0252a152f1e016a3d5a05ae9e2ca2fa11066e604a9477fedfe8193cfc43a78deab4fb75d5995a9c15de8921e8d47564cd6c58595e74f50d79a26d3cfaf91645408f7334c6b6d24b080e6296611a7b4a9a5580e9e090a9f7cf7b291b1029afd111d3282e1e97b132ac5c069c0689dc82cd2a3beb7d25a1e90c5d6687eb1f63073b5da5a52469503a3624a59471d92f842b2e3f1c53c29f594648c36d2e5f92058a8477b914fb950fc794f160f9f42d6dd66a4268e1af2430d64905d4d30e1b85cd98a2c1bcc0e487ee97a24cdf46ab9b0bf770abd82a4cc66e273906f76f77fe5db2dda054f604e9261a7306c9f0ac5167bb7c61e7e8048e85fb25f6b7784fd20a23c01bca31912c1618890a928b5e26b24a1529f5c7cb8abe0a33e13c18151e18abc632a622fb0d43fa09434e96ce4d0abf938ed6fc3d6f6a65b04b414ceb1e6356479e8d76c0c40beb74fee7e7d13a722497b65ed8ee49d27180c68cb1dea7bc0c7ca5aa2cfdc7d1a6afc1db1e6cf645b71619af4706990cf15da7ea60f14b4103060ed4bd1d40d464296401dcf4ed460116fb8cc2a5671430f8ed068299609ba1dbc2b033af7c2c75f1500f6fb81e35291572ddec38b3c84c69a5c47231787c119b79485757bc829f73b42bd9c4cf159434f35dfc0882220e1c2873ce5b151d8854e77d0fc72b222daa929284fc1b5af7a88a05af150864033b62669278eae93d6f6f303199fcc143d0260c09c185e7510d2ff1142e86f5687ab6ac30e85f6828bd618feecb6b1614f030355a3a56f3c850470cdf33627a6f769b5a0b783d31da0ee95c9f70bcee08e47c5dc89a4de662dd6f7019a51a0f454024ba0797fc962372eef057b09d22dd72ee7a45774fc3b241dfe1180d773686014021fd8255385d9964336b09040e2a97cb2d7cd1bd49f921d5ed0dd764a5312cf9e655395529c02604ca71c2ff31bbd18caa42891d04eaaafd1e745e2a4dc837ce5809d7034c00239e04b0142f2cc03f4ef1d5fdfd64f7dd92e959d0bec815ac104663dfb1bae2465c04c7d73844a39f30ae38db93d86eb64c3a9191b7879fc4e64450bc0762c44970f3c7b024eda61972d4056ef832742d338120f7195e1461dace7331469846ff167ef5968cf05122eca26bb6dac39ef9eb7fb7a16a6152f5511c13eda8efcb76d2781546cf9e1678c5e040f3cc59e01aad1e2bce358c7e5442520a55e22720947637c3900db6d58043fa9340cab69fc46316ea9f34e890be5aa226268bc37d3e4dd1bcdbea4e8367a03735934d4d3f3a0a2b79ce80b03fde9bda872a3de5fc16d16e795fde8dcf426c53447830554b9f8db1fb8ceb5efd675c12825496ac9774e0e3d6e4f09948e9ebe4c14eca031249dcc1a192c805234a1d3b4065f9db3b7a8e90ae3ccfff6944d546a1f4fa074878cc0f0426b812fd27b6f82ccc0cf561e0befb46fc57843dfda0345f021d82cd9f70352419e09972c5876f019d181a3079e96d7c982b7190fa1826766c913d5fc0d6e59dccf9b73e6a5580171cfb12b18787bea01c00b830f05b6543e805264033602f5f7e442eb2aedf88e30f65c8282ca4e449c6034f504eefa984f81171cdd44ca6bd54fe35aca8f10652a19ecb0f8efaa8fd3cba3386857466c32eca451bbb43164d81c5d6f0841f633e1d2059ad283c6ea510ba7ec7ce390a17ec549c32ecd7f611b3a7e0f864f5a0617f58cd25ed01a23a9002f7f7ea2478299c4a03f0236481133a2cd5f8f72156a37ab60cdd16907af9c48a5b0e7d12620ceba9ee564467d6f0284217e10f87e1977350a1ee9d48fd0bf8ca475b89b68bcfb79a9a4bf6547681cfc3c612cb1f3d25cf6064f80f2bf423578900555fe1a33a56da99386773b1e670ca53cf6d7f8ee3a00d7cc87607dce40e415c601858d60f132e554b1b28133e384a89d97f2ec5fdf1bcd4fa90c62b360eca8115b6288b0d2fb2c3e13ac79cbbf967efd7f8047de04a2428b63d1519d1d6690f02386453cb2d6d81576b462793d1c808516ab5d3880e7d1bd6d67f9f361022845ad814234ffcb223fcb3ec2671b131127c3595d4922727cc1fd1c2aef3f097dd0f8c9e88cd7758fc807c4b480e9194f8b1d682f4187c02603191b13bfa6ca93dc91e54d5db68f9ac4275e38461726c665f9f065a935ceef4a923a6503572558c93b8090dc50e1cf5193cfb84c12b8ce9c35b583e3318bcbed4c428192ee2efc58c60a7eb44886f9c3f1e754ce32dfa1d724591e34692e1bb5e642830b3368ca1a278dd7ca4e6c001930cf7edc9db40bd2ad0c7150e9628e56e1747b55b35c34c424b672d1e3a1e358e6553be978e824b9fe7e2b4843f3b5a13c3a2e5f351d526ef366ee2ce26dc87e2eedece2a7df5b0ce04ebe6e89db0c2c285604b9911ff53eb9654a290efa78f01cfbe933e34ad268bb08fd4a6e09f49fe6059a9087090914948d2e5870e01ba900cf22b72b28cee23a8d3ed068810cd6e064b4c663fb9a249de468e7ea5aaa5db46e1a98318d738470476e24f7da2a16911f31999aba714712bb2d4deab15c64e828f597ca3478fcec2672cf9beda57f372c65bba7b7dd060115f695b5c77a4ccd9d176ee6218d6e1861e80e539f37853bfbbcdd38e8c160c65953feea05c153c043550dfdcd5756ea0353b5e70905a49a0f8d3269f8a542855f2d2addc47b06028cc4e5936b7768028c37e050c6d50c720bd15d0334fe58321eaffe90aa14f6ca81a2b8406656339b262050e501769650a8529807af57dca60c3dad4814b537ad91344bf57aafedaddfcd695528f859540ec0f1df767c55530cc49817811aae083fa091b2eb6492d86271528101b1bb4fd24904e5dc479304f4aae0339091671a4f553f16bba7921dddccc63cdac88233a31587782e32be14132be4302154d3221e519335350d2a56ec3babc424cddd273496e9eb85cf80159c610396ea19721088284585f61599e832b525613dcb70e2c829af9e63a7a92e51b1ba10136f68054d013c784522112b03b104b51c0305cb15f93e759cb54a814d9ea9bf75b25ab6350f6ff6e8304d5e848433c3f0a20c2d3b0c4f4f0b33f04523938e65ffba4664f01cdf7125389e86a23795a56712fa1a400ffb9d9b74e468ca6bf6d8d9812e4b8c9ac084271f8133e5ac0347c466c6bf921e085b5c50ef5b855051f4c16e2fc3b0fa7a386f5e620f8a1885cf89f8bc215439eef9a364b4b7aa7b5fdb9b23a0e6f4a8bf490a402c2b855e9d5db02cc9b2733eef6c7590be8c52a080335c3c0674ec61ccab594a59cffccc34f2e11f57050e506f7b6d6672889b877da50d49c78feb9da75c214836464ed47e48db5a4f2ee0837eb736ce278bb240291561243df812056a749283ff53392660cb21bb4e2e45ba96ca5e4a4f5c3db43ed628df1198645383a53ca3410025493766b5839b332c089b0bb49cef654ecd46e62f286de1d38cac35fbf134c7d5e59b434d40448382c3b504d559d2d38f8307c89f1faacdfc99595b59928b9e363e7fef324c2db283a5fc9dd51409a356ca3ee8539608d6e8cee8718f204e2b97aa74247b8ce24d4968ff09ce1fdd9dac39d46be8a2f251577a51266a28460f22f33941ee8fdee27dfd9353d79bb9431580718b7fac580d3e0471e174b964844a8596f25a69d4d8c9c354ca9a8e589c66ff6a64a39a25a6bcd7be82e140ef136f918a84fea0d4a3a1b0e812201527b3a1dd62b2344c91fe08e7a3877d108c87aa3e468d1748ea9c04a95c65de220f8fca19e587b8c2e76c6a22ac2eb2bfd3e8117464bc3d25427462867382d1e20533ce0935737af59e8e98ac187ccddeebc44c9ef3d8e180f679da45add4795e28f80ffd4fa3a2b815988333b3862ae73f8f9bcfc90bf0d7006b7dbaaecaa5274bf243aabe9e160bb2f5ace1d2988e78abad09510f920c15863334aeeffbe12a6bb1c1b70db55dcf2839baa6ed779a39e041c8c04fec34eadf11fccc67c09290d1ce8983091e495f66c438d9dd5d4a6ab2819ca559695a7dab86fdbc4273b1aef5c99637cac77c178c2ab133f6a947e2b1465da43ce1f2cae42d7dadf3b14f7cb11429b47366f7bd1a635641a07c4e1837c5b09c389c5c59682f4b6e33984d6701b7cfffb6dde80f2309484cbbd4122577e20352b3e31bb676243657c3c0dd517a8bce07166295b5a253e4f5a2d21b53223efad70ada2d45f2266461032d039f05a26869e399fd20f2fe433d7d6cba5f5745eaa1693dd55ac4dce56ec09330b72278eed4643cbd50f664f478ec1f9ff30645497c72a29743c5f0d2b713ed70ef13c7925efdbad058b121b475bfa3dc5c296e16c5ca1628e3c51a2a227c15205b8bab9eada0835af937ff24214b95393e26bf8288cf9585b8e21571949274176db803d848c9b0db1faf78edd9f7e131249bbcdffab692781082f4c6491c31477fc8da95008833aec151488755169898852332553faa755698787bdd1881e3d74f20be490af1dab229c0dff5d793725dc6a51441efede9ff364ae2ffb84df034e32ad050f31456463276429386fef09daa55f76240f8e341816e17ebc14605aa66d848883325b0d1db2662fdb71638d074f2b202e5c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">2022年度总结</summary>
    
    
    
    <category term="私密" scheme="https://blog.phbeats.cn/categories/%E7%A7%81%E5%AF%86/"/>
    
    
    <category term="年度总结" scheme="https://blog.phbeats.cn/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>折半查找插入排序</title>
    <link href="https://blog.phbeats.cn/posts/122fd3617f53/"/>
    <id>https://blog.phbeats.cn/posts/122fd3617f53/</id>
    <published>2023-01-19T06:38:49.000Z</published>
    <updated>2023-01-22T13:39:43.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="折半查找插入排序"><a href="#折半查找插入排序" class="headerlink" title="折半查找插入排序"></a>折半查找插入排序</h2><div class="note success simple"><p>本文将结合 <code>二分查找</code> 和 <code>直接插入排序</code> 的知识点，介绍折半查找插入排序</p></div><emp>你可以通过点击以往文章回顾知识点:</emp><h3 id="点击-gt-二分查找"><a href="#点击-gt-二分查找" class="headerlink" title="点击 -&gt; 二分查找"></a>点击 -&gt; <a href="/posts/1893f995f535/">二分查找</a></h3><h3 id="点击-gt-直接插入排序"><a href="#点击-gt-直接插入排序" class="headerlink" title="点击 -&gt; 直接插入排序"></a>点击 -&gt; <a href="/posts/15cc1348375f/">直接插入排序</a></h3><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>在维护一个有序序列的过程中，从左往右看，使用二分查找出第一个比 <code>base</code> 大的数的位置 <code>l</code>，然后将元素后移，在 <code>l</code> 处腾出空间，将 <code>base</code> 插入。</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">binary_insert_sort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 维护一个有序序列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i++)&#123;<br>        <span class="hljs-comment">// 相邻元素顺序情况</span><br>        <span class="hljs-keyword">if</span>(q[i - <span class="hljs-number">1</span>] &lt;= q[i]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 相邻元素逆序情况</span><br>        <span class="hljs-comment">// 二分，从左往右找到第一个大于 base 的数</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = i, base = q[i];<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(q[mid] &gt; base) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将 l 空出来</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span> ; j &gt;= l ; j--)<br>            q[j + <span class="hljs-number">1</span>] = q[j]; <span class="hljs-comment">// 元素后移，空出 l 这个位置</span><br>        <span class="hljs-comment">// 插入</span><br>        q[l] = base;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="折半查找插入排序-VS-直接插入排序"><a href="#折半查找插入排序-VS-直接插入排序" class="headerlink" title="折半查找插入排序  VS  直接插入排序"></a>折半查找插入排序  VS  直接插入排序</h3><p><wavy>时间复杂度</wavy>：</p><ul><li>最好情况：O(n)</li><li>平均情况：理论上来说，折半查找插入排序是比直接插入排序要快的，毕竟是直接插入排序的优化版本。折半查找插入排序通过二分来优化比较次数，时间复杂度是O(nlogn)，但是移动次数并没有优化，因此时间复杂度还是O(n<sup>2</sup>)与直接插入排序一样。</li><li>最坏情况：O(n<sup>2</sup>)</li></ul><p><wavy>空间复杂度</wavy>：O(1)(都是常数额外辅助空间)</p><p><wavy>稳定性</wavy>：稳定（相同大小元素不改变相对位置）</p><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://www.acwing.com/problem/content/787/">我自己</a></p>]]></content>
    
    
    <summary type="html">直接插入排序的优化，折半查找插入排序</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://blog.phbeats.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://blog.phbeats.cn/posts/1893f995f535/"/>
    <id>https://blog.phbeats.cn/posts/1893f995f535/</id>
    <published>2023-01-18T12:05:58.000Z</published>
    <updated>2023-01-22T13:39:43.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><div class="note success simple"><p>本文将使用画图来理解二分，并且介绍了经典的二分查找板子，例题。</p></div><p>能够使用二分查找的两个前提：</p><ul><li><wavy>二分查找仅使用于数组</wavy>，这样才能通过判断大小关系来排除一半的搜索区间；</li><li><wavy>要求输入数据是有序的</wavy>，而在链表中使用效率很低，因为其在循环中需要跳跃式（非连续地）访问元素。</li></ul><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p>根据上面两个前提，很多人认为二分的本质是<emp>单调性</emp>，但实际上并不是的，二分的本质是<emp>边界</emp>。</p><p>假设给定一个区间，在这个区间上给定了某种性质，使得在右半区间满足这个性质，左半区间不满足这个性质，那么二分既能够查找左半区间的边界，也可以寻找右半区间的边界。</p><p><img src="https://bu.dusays.com/2023/01/18/63c806098d17f.png" alt="image-20230118203344229"></p><p>现在我们来看一下 <span style="color:red">左半区间二分查找：</span></p><p><img src="https://bu.dusays.com/2023/01/18/63c8060ee4081.png" alt="image-20230118213519331"></p><p>再看一下<span style="color:green">右半区间二分查找：</span></p><p><img src="https://bu.dusays.com/2023/01/18/63c8061474bb0.png" alt="image-20230118214805016"></p><p>那么这里有一个问题，<div class="tip "><p>为什么两种二分，mid的写法有一个 + 1有一个并没有（对应向上取整和向下取整）</p></div></p><p>下面举一个例子：</p><p>看一下为什么要加上1</p><p><img src="https://bu.dusays.com/2023/01/18/63c8061bdaa0f.png" alt="image-20230118221434740"></p><h3 id="整数二分实战思想"><a href="#整数二分实战思想" class="headerlink" title="整数二分实战思想"></a>整数二分实战思想</h3><p>如果你想让<wavy>答案在右边区间</wavy>，<wavy>那么你得让mid满足左区间的性质</wavy>，反之,可求左区间</p><h3 id="整数二分实战模板"><a href="#整数二分实战模板" class="headerlink" title="整数二分实战模板"></a>整数二分实战模板</h3><p>二分模板一共有两个，分别适用于不同情况。</p><h4 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h4><p>其更新操作是r = mid，计算mid时不需要加1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/01/18/63c8061f58820.png" alt="image-20230118224520428"></p><h4 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h4><p>其更新操作是l = mid，此时为了防止死循环，计算mid时需要加1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/01/18/63c8062229fdc.png" alt="image-20230118224158712"></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><emp>时间复杂度：O(logn)</emp>（折半查找树）</p><p><emp>空间复杂度：O(1)</emp>（使用常数大小空间 l, r, mid)</p><div class="tip warning"><p>大数越界处理</p></div><p>当数组长度很大时，加法 (l + r) 的结果可能超出 <code>int</code> 类型的取值范围。可换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 换成</span><br><span class="hljs-type">int</span> mid = l + (r - l) &gt;&gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="整数二分经典例题"><a href="#整数二分经典例题" class="headerlink" title="整数二分经典例题"></a>整数二分经典例题</h3><h4 id="AcWing789-数的范围"><a href="#AcWing789-数的范围" class="headerlink" title="AcWing789.数的范围"></a><a href="https://www.acwing.com/problem/content/791/">AcWing789.数的范围</a></h4><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</p><p>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 q，表示数组长度和询问个数。</p><p>第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。</p><p>接下来 q 行，每行包含一个整数 k，表示一个询问元素。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n ≤ 100000<br>1 ≤ q ≤ 10000<br>1 ≤ k ≤ 10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">6 3<br>1 2 2 3 3 4<br>3<br>4<br>5<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 4<br>5 5<br>-1 -1<br></code></pre></td></tr></table></figure><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n, Q; <span class="hljs-comment">// 整数个数、询问个数</span><br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; Q;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];<br>    <br>    <span class="hljs-keyword">while</span>(Q --)&#123;<br>        <span class="hljs-comment">// 需要查找的数</span><br>        <span class="hljs-type">int</span> x; cin &gt;&gt; x;<br>        <br>        <span class="hljs-comment">// 第一次二分</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span> , r = n - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">// 先找左边开始，第一个出现的 x，那么满足右边性质即可</span><br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(q[mid] &gt;= x) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果没找到</span><br>        <span class="hljs-keyword">if</span>(q[l] != x) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1 -1&quot;</span>);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 如果找到了</span><br>            cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-comment">// 开始找右边开始，第一个出现的x，那么满足左边的性质即可</span><br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span> , r = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(q[mid] &lt;= x) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">//if(q[l] != x) puts(&quot;-1&quot;); </span><br>            <span class="hljs-comment">// else cout &lt;&lt; l &lt;&lt; endl;</span><br>            <span class="hljs-comment">// 就算从右边也一定会找到一个值，它可以是左边开始找，找到的那个x</span><br>            cout &lt;&lt; l &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浮点数二分经典例题"><a href="#浮点数二分经典例题" class="headerlink" title="浮点数二分经典例题"></a>浮点数二分经典例题</h3><h4 id="AcWing-790-数的三次方根"><a href="#AcWing-790-数的三次方根" class="headerlink" title="AcWing 790. 数的三次方根"></a><a href="https://www.acwing.com/problem/content/792/">AcWing 790. 数的三次方根</a></h4><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个浮点数 n，求它的三次方根。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个浮点数 n 。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个浮点数，表示问题的解。</p><p>注意，结果保留 6 位小数。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>−10000 ≤ n ≤ 10000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1000.00<br></code></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">10.000000<br></code></pre></td></tr></table></figure><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-type">double</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-comment">// 依据数据范围取[min, max]</span><br>    <span class="hljs-type">double</span> l = <span class="hljs-number">-10000</span> , r = <span class="hljs-number">10000</span>;<br>    <span class="hljs-comment">// 调整精度</span><br>    <span class="hljs-keyword">while</span>(r - l &gt; <span class="hljs-number">1e-8</span>)&#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid * mid * mid &gt;= n) r = mid; <span class="hljs-comment">// 重点</span><br>        <span class="hljs-keyword">else</span> l = mid; <span class="hljs-comment">// 重点</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span> , l);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h2><p><a href="https://www.hello-algo.com/chapter_searching/binary_search/">hello-algo</a><br><a href="https://www.acwing.com/activity/content/code/content/4690436/">AcWing789.数的范围</a><br><a href="https://www.acwing.com/activity/content/code/content/4690546/">AcWing 790. 数的三次方根</a></p>]]></content>
    
    
    <summary type="html">画图理解二分查找</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="查找算法" scheme="https://blog.phbeats.cn/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>直接插入排序</title>
    <link href="https://blog.phbeats.cn/posts/a1dd46ab1c25/"/>
    <id>https://blog.phbeats.cn/posts/a1dd46ab1c25/</id>
    <published>2023-01-14T13:38:49.000Z</published>
    <updated>2023-01-22T13:39:43.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><div class="note success simple"><p>本文将介绍<strong>基于数组</strong>的直接插入排序和<strong>基于单链表</strong>的直接插入排序。</p></div><p><strong>算法的思想</strong>：<strong>维护一个有序序列</strong>，初始时<strong>有序序列只有一个元素</strong>即为<strong>第1个元素</strong>，随后选定数组的<strong>第2个元素</strong>为<strong>待插入元素</strong> <code>base</code> ，将 <code>base</code> 与其左边的元素依次对比大小，并“插入”到正确位置。每次将一个新的元素插入到有序序列中，将有序序列的长度增加 1，直到全部元素都加入到有序序列中。</p><p><strong>一个简单的例子：</strong><br><img src="https://bu.dusays.com/2023/01/14/63c24f0730913.png" alt="image-20230114144248474"></p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol><li>第1轮先选取排序元素中的<strong>第2个元素</strong>为<code>base</code>，<code>base</code>与它之前的所有元素一一比较，然后执行<span class='p red'>插入</span>操作，至此<strong>元素中前2个元素已完成排序</strong>。</li><li>第2轮先选取排序元素中的<strong>第3个元素</strong>为<code>base</code>，<code>base</code>与它之前的所有元素一一比较，然后执行<span class='p red'>插入</span>操作，至此<strong>元素中前3个元素已完成排序</strong>。</li></ol><p>这样排序就完成了，有序序列长度从1变成了3，这个过程进行了<strong>2轮</strong></p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p><strong>时间复杂度O(n<sup>2</sup>)</strong>：</p><ul><li>最好情况：<strong>O(n)</strong>，比如：[1,2,3,4,5] 有序情况，整个过程<strong>未进行任何插入操作</strong>，<strong>仅进行比较操作</strong></li><li>平均情况：O(n<sup>2</sup>)</li><li>最差情况：各轮插入操作循环n-1，n-2，…，2，1次，求和为 ((n - 1) x n ) / 2，使用<strong>O(n<sup>2</sup>)</strong>时间。</li></ul><p><strong>空间复杂度O(1)</strong>：变量 i , j 使用常数大小的额外空间。</p><p><strong>稳定性</strong>：<strong>稳定</strong>（不交换相等元素）</p><h3 id="直接插入排序-vs-冒泡排序"><a href="#直接插入排序-vs-冒泡排序" class="headerlink" title="直接插入排序 vs 冒泡排序"></a>直接插入排序 vs 冒泡排序</h3><p style="color:red">虽然「直接插入排序」和「冒泡排序」的时间复杂度皆为O(n<sup>2</sup>) ，但实际运行速度却有很大差别，这是为什么呢？</p><p>回顾复杂度分析，两个方法的循环次数都是((n - 1) x n )/2。但不同的是，「冒泡操作」是在做<emp>元素交换</emp>，需要借助一个临时变量实现，共 3 个单元操作；而「插入操作」是在做<emp>赋值</emp>，只需 1 个单元操作；因此，可以粗略估计出冒泡排序的计算开销约为直接插入排序的 3 倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 冒泡排序的 元素交换</span><br><span class="hljs-built_in">swap</span>(q[j], q[j + <span class="hljs-number">1</span>]); <span class="hljs-comment">// 这个函数实现一下就知道了 共3个单元操作</span><br><span class="hljs-comment">// 直接插入排序的 赋值</span><br>q[j + <span class="hljs-number">1</span>] = q[j];<br></code></pre></td></tr></table></figure><p>直接插入排序运行速度快，并且具有原地（指针变量仅使用常数大小额外空间）、稳定（不交换相等元素）、自适应（最佳情况下，时间复杂度为O(n<sup>2</sup>)的优点，因此很受欢迎。实际上，包括 Java 在内的许多编程语言的排序库函数的实现都用到了直接插入排序。库函数的大致思路：</p><ul><li>对于<strong>长数组</strong>，采用基于分治的排序算法，例如<strong>快速排序</strong>，时间复杂度为O(nlogn)</li><li>对于<strong>短数组</strong>，直接使用<strong>直接插入排序</strong>，时间复杂度为O(n<sup>2</sup>)</li></ul><p>在数组较短时，复杂度中的常数项（即每轮中的单元操作数量）占主导作用，此时插入排序运行地更快。</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_sort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 外层循环保证 n - 1 趟的同时</span><br>    <span class="hljs-comment">// 还保证了选取 第2个 元素作为base</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i++)&#123;<br>        <span class="hljs-type">int</span> base = q[i] , j = i;<br>        <span class="hljs-comment">// 如果 j 大于 0 并且 base 比 q[j - 1] 小</span><br>        <span class="hljs-keyword">while</span>(j &amp;&amp; base &lt; q[j - <span class="hljs-number">1</span>])&#123;<br>            q[j] = q[j - <span class="hljs-number">1</span>];<br>            j--;<br>        &#125;<br>        q[j] = base;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="来自LeetCode的一道题对链表进行直接插入排序"><a href="#来自LeetCode的一道题对链表进行直接插入排序" class="headerlink" title="来自LeetCode的一道题对链表进行直接插入排序"></a>来自LeetCode的一道题<a href="https://leetcode.cn/problems/insertion-sort-list/">对链表进行直接插入排序</a></h4><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><ul><li>列表中的节点数在 <code>[1, 5000]</code>范围内</li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><h4 id="输入样例和输出结果"><a href="#输入样例和输出结果" class="headerlink" title="输入样例和输出结果"></a>输入样例和输出结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: head = [4,2,1,3]<br>输出: [1,2,3,4]<br></code></pre></td></tr></table></figure><p>以上面这个输入为例子，下面是表示图：<br><span style="color:green">绿色</span>：代表<strong>已经排序好的有序序列的元素</strong></p><p><span style="color:brown">褐色</span>：代表<code>base</code>即待插入的元素</p><p><span style="color:red">红色</span>：代表变量关系<br><img src="https://bu.dusays.com/2023/01/14/63c2a6500414f.png" alt="image-20230114205541206"></p><h4 id="算法思路图示-表述如下："><a href="#算法思路图示-表述如下：" class="headerlink" title="算法思路图示 + 表述如下："></a>算法思路图示 + 表述如下：</h4><p><img src="https://bu.dusays.com/2023/01/14/63c2a6c171e50.png" alt="image-20230114205746805"></p><wavy>顺序情况很容易理解，因为直接插入排序就是维护一个有序序列的过程。</wavy><p>我们来分析<wavy>逆序情况</wavy>：</p><p><img src="https://bu.dusays.com/2023/01/14/63c2a6f3ce4d3.png" alt="image-20230114205837275"></p><p>画五角星的这轮，实际上是最容易提取出 task 步骤的，请关注这一轮操作。</p><p>转换成<wavy>部分代码</wavy>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(sortedTail -&gt; val &lt;= base -&gt; val)&#123;<br>    <span class="hljs-comment">// 顺序</span><br>    sortedTail = sortedTail -&gt; next; <span class="hljs-comment">// sortedTail 后移一位    </span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// 逆序 （此处也是关注重点）</span><br>    <span class="hljs-comment">// pre处 是插入点（后插），需要循环找出来，因此 dummy 的重要性就体现出来了</span><br>    <span class="hljs-comment">// 毕竟在这个过程有一个极小的数，需要放在第一个位置，你怎么插？</span><br>    ListNode * pre = dummy;<br>    <span class="hljs-comment">// 过滤掉比base小的，使用 pre -&gt; next -&gt; val 的值来过滤，这样就能求出 插入点</span><br>    <span class="hljs-keyword">while</span>(pre -&gt; next -&gt; val &lt;= base -&gt; val) pre = pre -&gt; next;<br>    <span class="hljs-comment">// 现在 pre 处就是插入点了（后插）</span><br>    <span class="hljs-comment">// 插入三部曲，图示很清楚</span><br>    sortedTail -&gt; next = base -&gt; next;<br>    base -&gt; next = pre -&gt; next;<br>    pre -&gt; next = base;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们实现了<code>step 1</code> 和 <code>step 2</code> 了。</p><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果头结点为空或者只有一个结点，则直接返回头结点</span><br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">// 虚拟头结点，方便操作</span><br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <br>        <span class="hljs-comment">// 直接插入排序：① 默认第1个元素有序。② 第2个元素是 base</span><br>        <span class="hljs-comment">// sortedTail: 有序序列中的 最后一个结点, 在这也是元素中第1个结点</span><br>        <span class="hljs-comment">// base：第2个元素，也是待插入元素</span><br>        ListNode * sortedTail = head, * base = head -&gt; next;<br><br>        <span class="hljs-comment">// 当base不为空，则一直是排序状态</span><br>        <span class="hljs-keyword">while</span>(base)&#123;<br>            <span class="hljs-comment">// base 与 sortedTail比较</span><br>            <span class="hljs-comment">// 产生两种情况 (1. 顺序 2. 逆序)</span><br><br>            <br>            <span class="hljs-keyword">if</span>(sortedTail -&gt; val &lt;= base -&gt; val)&#123;<br>                <span class="hljs-comment">// 顺序</span><br>                sortedTail = sortedTail -&gt; next; <span class="hljs-comment">// sortedTail 后移一位    </span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 逆序，执行 task 步骤</span><br>                ListNode * pre = dummy;<br>                <span class="hljs-comment">// 过滤掉比 base 小的值，pre就是插入的位置</span><br>                <span class="hljs-keyword">while</span>(pre -&gt; next -&gt; val &lt;= base -&gt; val) pre = pre -&gt; next;<br><br>                <span class="hljs-comment">// 插入三部曲</span><br>                sortedTail -&gt; next = base -&gt; next;<br>                base -&gt; next = pre -&gt; next;<br>                pre -&gt; next = base;<br>            &#125;<br>            <span class="hljs-comment">// 注意：base总是 sortedTail的next，不能写成 base = base -&gt; next</span><br>            base = sortedTail -&gt; next;<br>        &#125;<br>        <span class="hljs-comment">// 去掉dummy，返回排序后的链表</span><br>        <span class="hljs-keyword">return</span> dummy -&gt; next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ol><li><p>时间复杂度：<br>对于链表而言，插入元素时只要更新相邻节点的指针即可，不需要像数组一样将插入位置后面的元素往后移动，因此插入操作的<strong>时间复杂度</strong>是<strong>O(1)</strong>，但是找到插入位置需要遍历链表中的节点，<strong>时间复杂度是O(n)</strong>，因此链表直接插入排序的总<strong>时间复杂度</strong>仍然是<strong>O(n<sup>2</sup>)</strong>。</p></li><li><p>空间复杂度：<br>整个排序过程中需要的额外辅助空间为 <code>dummy</code>，<code>sortedTail</code>，<code>base</code>，<code>pre</code>。<br>使用常数大小的额外空间，<strong>空间复杂度为O（1）</strong></p></li></ol><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://leetcode.cn/problems/insertion-sort-list/solution/dui-lian-biao-jin-xing-cha-ru-pai-xu-by-leetcode-s/">LeetCode官方解答</a><br><a href="https://www.hello-algo.com/chapter_sorting/insertion_sort/">Hello 算法</a><br><a href="https://www.acwing.com/activity/content/code/content/4550243/">我自己</a></p>]]></content>
    
    
    <summary type="html">数组和单链表的直接插入排序</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://blog.phbeats.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="LeetCode" scheme="https://blog.phbeats.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>加密文章测试</title>
    <link href="https://blog.phbeats.cn/posts/a9fe598e654c/"/>
    <id>https://blog.phbeats.cn/posts/a9fe598e654c/</id>
    <published>2023-01-02T03:08:52.000Z</published>
    <updated>2023-01-22T13:39:43.618Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9b945f47a85f319860038cd6862648a9668611b8e04c910a270cc50a7d59ad03">40006f26432b51246312fba1b7437ee209fde60e0fcf5d58d590a820a18fc4ba792587e80495c836cdb13cdc873d50343cfdc1bca88a0f14e2ea61212af9e61093cb790572e83a216f2fa0a9dc7fd9a912a94964dbcb0967673f5f5b50103735732d19aa84675422c1d09b817fd323d617f01c072ff6852744db6ba0cde5d09b898843fe188cfd5546703ad6b70a7765d096a14bce4c91312e54b96eb82decb2ff2fc3dbbee174d684b0d7b3af5010db</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">我的第一篇加密测试文章</summary>
    
    
    
    <category term="私密" scheme="https://blog.phbeats.cn/categories/%E7%A7%81%E5%AF%86/"/>
    
    
    <category term="加密的文章" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>外挂标签测试</title>
    <link href="https://blog.phbeats.cn/posts/0cb988991ca8/"/>
    <id>https://blog.phbeats.cn/posts/0cb988991ca8/</id>
    <published>2023-01-01T17:10:47.000Z</published>
    <updated>2023-01-22T13:39:43.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="外挂标签小测试"><a href="#外挂标签小测试" class="headerlink" title="外挂标签小测试"></a>外挂标签小测试</h3><p class='p red'>我是红色的！</p><p class='p green'>我是绿色的！</p>]]></content>
    
    
    <summary type="html">我的第一篇外挂标签测试文章</summary>
    
    
    
    <category term="测试" scheme="https://blog.phbeats.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试文章" scheme="https://blog.phbeats.cn/tags/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>测试文章</title>
    <link href="https://blog.phbeats.cn/posts/ae0a40dc1ca9/"/>
    <id>https://blog.phbeats.cn/posts/ae0a40dc1ca9/</id>
    <published>2023-01-01T14:29:29.000Z</published>
    <updated>2023-01-22T13:39:43.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这是我的第一篇测试文章"><a href="#这是我的第一篇测试文章" class="headerlink" title="这是我的第一篇测试文章"></a>这是我的第一篇测试文章</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;这是我的第一篇测试文章&quot;&gt;&lt;a href=&quot;#这是我的第一篇测试文章&quot; class=&quot;headerlink&quot; title=&quot;这是我的第一篇测试文章&quot;&gt;&lt;/a&gt;这是我的第一篇测试文章&lt;/h3&gt;</summary>
      
    
    
    
    <category term="测试" scheme="https://blog.phbeats.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试文章" scheme="https://blog.phbeats.cn/tags/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>测试文章</title>
    <link href="https://blog.phbeats.cn/posts/6df1062bf1dd/"/>
    <id>https://blog.phbeats.cn/posts/6df1062bf1dd/</id>
    <published>2022-01-01T14:18:06.000Z</published>
    <updated>2023-01-22T13:39:43.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这是测试文章"><a href="#这是测试文章" class="headerlink" title="这是测试文章"></a>这是测试文章</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;这是测试文章&quot;&gt;&lt;a href=&quot;#这是测试文章&quot; class=&quot;headerlink&quot; title=&quot;这是测试文章&quot;&gt;&lt;/a&gt;这是测试文章&lt;/h3&gt;</summary>
      
    
    
    
    <category term="测试" scheme="https://blog.phbeats.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试文章" scheme="https://blog.phbeats.cn/tags/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
</feed>
