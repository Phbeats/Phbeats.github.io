<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phbeats-Blog</title>
  
  <subtitle>记录学习历程和生活感悟</subtitle>
  <link href="https://blog.phbeats.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.phbeats.cn/"/>
  <updated>2023-01-21T14:05:53.269Z</updated>
  <id>https://blog.phbeats.cn/</id>
  
  <author>
    <name>Phbeats</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022年度总结</title>
    <link href="https://blog.phbeats.cn/posts/bf74f35b9f99/"/>
    <id>https://blog.phbeats.cn/posts/bf74f35b9f99/</id>
    <published>2023-01-21T12:28:14.000Z</published>
    <updated>2023-01-21T14:05:53.269Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7878c94e2d758ca0ecd5b99614b270c579c50f91c122d233943d4ebf85d2137f">40006f26432b51246312fba1b7437ee21a2e494ae99f0caffe17be68197d90c4dd8fb84a3011bb238927ed9888b0fac10600ea2f16a7d6834c52aa2d91a6e38ed077c77b97af7c074d0e9dd99ca0697e349c760a7f584907fef7455eaeda5684b5b2478fa5c5bb09b21efec557228b855867db92366c17a8d279588625e4dc297888e8b59695fc93e61429bfb2ccc44b91a1437fc28c4d1b9181116b0216335a10ef9dabef5b1f2bb59f0386cabb66666a2e4929f794d42b042255e30ff8ecd61bd116ae76d8983f13cdb8b0821e444a4ae420b2744fd0630166d7dab930afd8705d2066811962ffd84c888dc2b48fa9e395175b0132b7952cfe9dfc6dbb47dfa262fc472ca28af191ab3d5d1803fb0d505c52e0e501b9a3f646c4ee0e35f434fbf40d3d32fdd8ccf44175422734d870414627aa0c3829fc29f5764aede6da706e8c47489cb6d6ea636c75cbf142d48b14fac32db687386a6da9a99e636f223f4664575425f101c5e66fd4d23fbdefc6939b8e49c01c37a24b12a2138dddcfab0c443672ab916e37c9f1f351eeee2da081d74a5303e58fa1dda8f70393943bc30fcfa06b43b952edde8a1dfbbe7688fd5abba8647de38c537a0bb03955548a8f31971787447b811c6018433df27bdb972a94996a0e54e0f70e8f174996ebaaaae4d205e00d014378fb04131a4d3e9c236f21a5fc57dfb266c05c8d8618ffc19566f1b38bbf34cbdb04da0f8dbedd86eda3902afc8750be189dff109aa145453a227092feaf3514f722322a21521f5ec1007652e8f3e170ce72d7e3568a64e8a47788cf686efbd3885fa7850fb6f12c6e21c0c25f82ef52948e222b11f0f2e2503475bf2b8c2edbe1e6137a0a637a0fa66dea03afc0d7136bb5b6095da306be0500b46c8cf6c896a1478f43f7335a054a96baaab86609c3491b96d8ce262b7971648f88a175e12ae56d3268be37235acd23bdc36881a06d76c7e12f2f866f8bbcc6f1ec1b8e77fb45088c44961234cfcd02eb3b5f692ccd5dafd14ac06a977efdd11aaabc48db1ba4853473423b8261b6ede4b596c142aa0d192f6ea199f7b512c68fa7e498d4e21f7cc31b6da87e8f923324666e54f1455dc9aab5c6d6a630f77ac8deb1f1d7ede83a46663b0c9eb66b7a7ce2f4c7a9ce378dccd56785b76e2b812c0cb8b5650a16e149bfa886b8de4576dd6ff74a87c93bbf2191757bbf24cae4d4b0c7d13fb62e63611ba3f73ea28cd5623e055ecc865797ac7aa859807df1ec6305f453c42eeaab1f77f2202b10fee19a90f1bab3c65b967d52daa8fe4668aefd821afbc8b2ba7d7bb33f3873ffe1be0ea3f972ef7e783e48064110589af7a013748bfe592961fec039bbcab48efc0bad9d9d7716798c7eb82cdcbdd018b43221774766c3d6d253a3fb93750cf4350920f026f84dd67f5ce4363aa8456fb9facacf5413f6ba3cc9a277c622bcf5a85b5b29a2c430d7fd9c73011ffbbc2a6aa79a0cd8732c5cbf3231eb49793d711860b94202ac56aef25c3c6d89ac6608cd8cac4744d6afea8604d3a714948de6bb9b6a8795bb8cb5af045ab6536474820032ac84d27e4dfdf4d572a425403a638ac164007dca7075f14eca5c4ddaf7c7d147d2e1abc4c2132c9e9778216ae0c389b2f5c451eac5b35ea2cb15966a916358851a323c60fb857ad780e82bae690aa7df45d2fa596861a7b24fb8d5fcb2c66f1bc71fbfeff01aabdb9d8f86b62f431f32672e71dca5c50231ac39700a8ed01fab8e5a0af798d60324b0cffb10caf55968cdf27f1c3524a1f37dbe6039acf3ec17fb44702202f3ccaa6cf6d3ed8b1c870aa9c5396975e8df432d2861d93e5bf21a16a9832e7d4053314427867bc6b2e8b5afcc5c85e3fd1fda9e747b9cc843bb51a8fe4b9b8e584ff8f6cbb5e55edf9cb93ff3a92b29de78cecf8f7ce1a96a93c7ab7c08145d6d7c5ea7f6a9e2aa02e6eb4ebea35e07d7564898c659f13b05f1435e5960576ad25e0315f0b2498fdae3e08e76a21c638fc9bcaa292310bc397012a758cc286283232f6bf947e2a90c113897d7f90752437db8cf8ad9c370ee04fee5d72b3be89ebfa8d85d2e9431ad15e6e915ca3d2030b03b9de89865714d2f646a0eb44c4dec818c53bba351a5a1788470a0fd31190a80cadc4afeccebeecafb8e93ef0c1da8bc878ae05bf66fbd8dd47b0675a861b51e454d60d598e68cb58f397feb671c20eb9e1c339ab10698839d571f7188bdaafa18a512de47e2f5e101813c14d1120c2c49f3787963752e6658de10677590ba15844d9304e4e7b2dc4051bdf3514a9c91e82522d26f0ffdd2e8eec29273cad31af2123633289aa1c5265692846f634b11ca6a9ac799a5435bfad30f767d0d3f254356ff52212b4cb39af07397d41a49579b495957b5c2b216f818e2baca376a5d347a423ad049be9e370d6a186638e7174ab60090556e1042ceb2d4df40b0ebd543508d20014d4c6be0bdc1523cb2edd637e48fdb13d5621e180be1833313235ba74a14eed5b5dc034aa8dddf36657382d4a33fc0b879c52d56ca176849652870a320b317678d21c7fc4b90c99d7117db6db5a205f6621ec9f4a72e7a998cdfffc8b77cbf964e070fa3ce754b747bea2a01d88c11d097eaed7253e923f8b5cf9ca223b36d5f00c81368ad26278272f9d8f6894f2c13f81a2dd96d8f02fe0c4e4effa9fea9fb7ac2b7f4e2c4f73d8e8a5e8b414934438dd2a75c0e1fd39ea71f841442a9fc4d191ec020c36475850482302d70afead251738721e065332e2c7e09ecbf5fbb87196cb26eda179b136a33f1c5d627b888a117001ce5fa34b6ca82cac535c5fa9ec6b2e67d7a226cb88690ddd326c8f36128429edc2a6aedafaeafcc4951aae84422a072cdf361166a84a04fbf9f3e5be5889ba031d92371553a0e0f1a1b924746683f2a6bbf30ea72f0f56348dabdd8438e64a56f7ef4e9d0864662d2aaece8a5cfdbee</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">2022年度总结</summary>
    
    
    
    <category term="私密" scheme="https://blog.phbeats.cn/categories/%E7%A7%81%E5%AF%86/"/>
    
    
    <category term="加密的文章" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
    <category term="年度总结" scheme="https://blog.phbeats.cn/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>折半查找插入排序</title>
    <link href="https://blog.phbeats.cn/posts/122fd3617f53/"/>
    <id>https://blog.phbeats.cn/posts/122fd3617f53/</id>
    <published>2023-01-19T06:38:49.000Z</published>
    <updated>2023-01-21T14:05:53.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="折半查找插入排序"><a href="#折半查找插入排序" class="headerlink" title="折半查找插入排序"></a>折半查找插入排序</h2><div class="note success simple"><p>本文将结合 <code>二分查找</code> 和 <code>直接插入排序</code> 的知识点，介绍折半查找插入排序</p></div><emp>你可以通过点击以往文章回顾知识点:</emp><h3 id="点击-gt-二分查找"><a href="#点击-gt-二分查找" class="headerlink" title="点击 -&gt; 二分查找"></a>点击 -&gt; <a href="/posts/1893f995f535/">二分查找</a></h3><h3 id="点击-gt-直接插入排序"><a href="#点击-gt-直接插入排序" class="headerlink" title="点击 -&gt; 直接插入排序"></a>点击 -&gt; <a href="/posts/15cc1348375f/">直接插入排序</a></h3><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>在维护一个有序序列的过程中，从左往右看，使用二分查找出第一个比 <code>base</code> 大的数的位置 <code>l</code>，然后将元素后移，在 <code>l</code> 处腾出空间，将 <code>base</code> 插入。</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">binary_insert_sort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 维护一个有序序列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i++)&#123;<br>        <span class="hljs-comment">// 相邻元素顺序情况</span><br>        <span class="hljs-keyword">if</span>(q[i - <span class="hljs-number">1</span>] &lt;= q[i]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 相邻元素逆序情况</span><br>        <span class="hljs-comment">// 二分，从左往右找到第一个大于 base 的数</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = i, base = q[i];<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(q[mid] &gt; base) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将 l 空出来</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span> ; j &gt;= l ; j--)<br>            q[j + <span class="hljs-number">1</span>] = q[j]; <span class="hljs-comment">// 元素后移，空出 l 这个位置</span><br>        <span class="hljs-comment">// 插入</span><br>        q[l] = base;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="折半查找插入排序-VS-直接插入排序"><a href="#折半查找插入排序-VS-直接插入排序" class="headerlink" title="折半查找插入排序  VS  直接插入排序"></a>折半查找插入排序  VS  直接插入排序</h3><p><wavy>时间复杂度</wavy>：理论上来说，折半查找插入排序是比直接插入排序要快的，毕竟是直接插入排序的优化版本。折半查找插入排序通过二分来优化比较次数，时间复杂度是O(nlogn)，但是移动次数并没有优化，因此时间复杂度还是O(n<sup>2</sup>)与直接插入排序一样。</p><p><wavy>空间复杂度</wavy>：O(1)(都是常数额外辅助空间)</p><p><wavy>稳定性</wavy>：稳定（相同大小元素不改变相对位置）</p><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://www.acwing.com/problem/content/787/">我自己</a></p>]]></content>
    
    
    <summary type="html">直接插入排序的优化，折半查找插入排序</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://blog.phbeats.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://blog.phbeats.cn/posts/1893f995f535/"/>
    <id>https://blog.phbeats.cn/posts/1893f995f535/</id>
    <published>2023-01-18T12:05:58.000Z</published>
    <updated>2023-01-21T14:05:53.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><div class="note success simple"><p>本文将使用画图来理解二分，并且介绍了经典的二分查找板子，例题。</p></div><p>能够使用二分查找的两个前提：</p><ul><li><wavy>二分查找仅使用于数组</wavy>，这样才能通过判断大小关系来排除一半的搜索区间；</li><li><wavy>要求输入数据是有序的</wavy>，而在链表中使用效率很低，因为其在循环中需要跳跃式（非连续地）访问元素。</li></ul><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p>根据上面两个前提，很多人认为二分的本质是<emp>单调性</emp>，但实际上并不是的，二分的本质是<emp>边界</emp>。</p><p>假设给定一个区间，在这个区间上给定了某种性质，使得在右半区间满足这个性质，左半区间不满足这个性质，那么二分既能够查找左半区间的边界，也可以寻找右半区间的边界。</p><p><img src="https://bu.dusays.com/2023/01/18/63c806098d17f.png" alt="image-20230118203344229"></p><p>现在我们来看一下 <span style="color:red">左半区间二分查找：</span></p><p><img src="https://bu.dusays.com/2023/01/18/63c8060ee4081.png" alt="image-20230118213519331"></p><p>再看一下<span style="color:green">右半区间二分查找：</span></p><p><img src="https://bu.dusays.com/2023/01/18/63c8061474bb0.png" alt="image-20230118214805016"></p><p>那么这里有一个问题，<div class="tip "><p>为什么两种二分，mid的写法有一个 + 1有一个并没有（对应向上取整和向下取整）</p></div></p><p>下面举一个例子：</p><p>看一下为什么要加上1</p><p><img src="https://bu.dusays.com/2023/01/18/63c8061bdaa0f.png" alt="image-20230118221434740"></p><h3 id="整数二分实战思想"><a href="#整数二分实战思想" class="headerlink" title="整数二分实战思想"></a>整数二分实战思想</h3><p>如果你想让<wavy>答案在右边区间</wavy>，<wavy>那么你得让mid满足左区间的性质</wavy>，反之,可求左区间</p><h3 id="整数二分实战模板"><a href="#整数二分实战模板" class="headerlink" title="整数二分实战模板"></a>整数二分实战模板</h3><p>二分模板一共有两个，分别适用于不同情况。</p><h4 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h4><p>其更新操作是r = mid，计算mid时不需要加1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/01/18/63c8061f58820.png" alt="image-20230118224520428"></p><h4 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h4><p>其更新操作是l = mid，此时为了防止死循环，计算mid时需要加1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/01/18/63c8062229fdc.png" alt="image-20230118224158712"></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><emp>时间复杂度：O(logn)</emp>（折半查找树）</p><p><emp>空间复杂度：O(1)</emp>（使用常数大小空间 l, r, mid)</p><div class="tip warning"><p>大数越界处理</p></div><p>当数组长度很大时，加法 (l + r) 的结果可能超出 <code>int</code> 类型的取值范围。可换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 换成</span><br><span class="hljs-type">int</span> mid = l + (r - l) &gt;&gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="整数二分经典例题"><a href="#整数二分经典例题" class="headerlink" title="整数二分经典例题"></a>整数二分经典例题</h3><h4 id="AcWing789-数的范围"><a href="#AcWing789-数的范围" class="headerlink" title="AcWing789.数的范围"></a><a href="https://www.acwing.com/problem/content/791/">AcWing789.数的范围</a></h4><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</p><p>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 q，表示数组长度和询问个数。</p><p>第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。</p><p>接下来 q 行，每行包含一个整数 k，表示一个询问元素。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n ≤ 100000<br>1 ≤ q ≤ 10000<br>1 ≤ k ≤ 10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">6 3<br>1 2 2 3 3 4<br>3<br>4<br>5<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 4<br>5 5<br>-1 -1<br></code></pre></td></tr></table></figure><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n, Q; <span class="hljs-comment">// 整数个数、询问个数</span><br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; Q;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];<br>    <br>    <span class="hljs-keyword">while</span>(Q --)&#123;<br>        <span class="hljs-comment">// 需要查找的数</span><br>        <span class="hljs-type">int</span> x; cin &gt;&gt; x;<br>        <br>        <span class="hljs-comment">// 第一次二分</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span> , r = n - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">// 先找左边开始，第一个出现的 x，那么满足右边性质即可</span><br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(q[mid] &gt;= x) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果没找到</span><br>        <span class="hljs-keyword">if</span>(q[l] != x) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1 -1&quot;</span>);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 如果找到了</span><br>            cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-comment">// 开始找右边开始，第一个出现的x，那么满足左边的性质即可</span><br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span> , r = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(q[mid] &lt;= x) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">//if(q[l] != x) puts(&quot;-1&quot;); </span><br>            <span class="hljs-comment">// else cout &lt;&lt; l &lt;&lt; endl;</span><br>            <span class="hljs-comment">// 就算从右边也一定会找到一个值，它可以是左边开始找，找到的那个x</span><br>            cout &lt;&lt; l &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浮点数二分经典例题"><a href="#浮点数二分经典例题" class="headerlink" title="浮点数二分经典例题"></a>浮点数二分经典例题</h3><h4 id="AcWing-790-数的三次方根"><a href="#AcWing-790-数的三次方根" class="headerlink" title="AcWing 790. 数的三次方根"></a><a href="https://www.acwing.com/problem/content/792/">AcWing 790. 数的三次方根</a></h4><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个浮点数 n，求它的三次方根。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个浮点数 n 。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个浮点数，表示问题的解。</p><p>注意，结果保留 6 位小数。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>−10000 ≤ n ≤ 10000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1000.00<br></code></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">10.000000<br></code></pre></td></tr></table></figure><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-type">double</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-comment">// 依据数据范围取[min, max]</span><br>    <span class="hljs-type">double</span> l = <span class="hljs-number">-10000</span> , r = <span class="hljs-number">10000</span>;<br>    <span class="hljs-comment">// 调整精度</span><br>    <span class="hljs-keyword">while</span>(r - l &gt; <span class="hljs-number">1e-8</span>)&#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid * mid * mid &gt;= n) r = mid; <span class="hljs-comment">// 重点</span><br>        <span class="hljs-keyword">else</span> l = mid; <span class="hljs-comment">// 重点</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span> , l);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h2><p><a href="https://www.hello-algo.com/chapter_searching/binary_search/">hello-algo</a><br><a href="https://www.acwing.com/activity/content/code/content/4690436/">AcWing789.数的范围</a><br><a href="https://www.acwing.com/activity/content/code/content/4690546/">AcWing 790. 数的三次方根</a></p>]]></content>
    
    
    <summary type="html">画图理解二分查找</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="查找算法" scheme="https://blog.phbeats.cn/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
    <category term="AcWing" scheme="https://blog.phbeats.cn/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>直接插入排序</title>
    <link href="https://blog.phbeats.cn/posts/a1dd46ab1c25/"/>
    <id>https://blog.phbeats.cn/posts/a1dd46ab1c25/</id>
    <published>2023-01-14T13:38:49.000Z</published>
    <updated>2023-01-21T14:05:53.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><div class="note success simple"><p>本文将介绍<strong>基于数组</strong>的直接插入排序和<strong>基于单链表</strong>的直接插入排序。</p></div><p><strong>算法的思想</strong>：<strong>维护一个有序序列</strong>，初始时<strong>有序序列只有一个元素</strong>即为<strong>第1个元素</strong>，随后选定数组的<strong>第2个元素</strong>为<strong>待插入元素</strong> <code>base</code> ，将 <code>base</code> 与其左边的元素依次对比大小，并“插入”到正确位置。每次将一个新的元素插入到有序序列中，将有序序列的长度增加 1，直到全部元素都加入到有序序列中。</p><p><strong>一个简单的例子：</strong><br><img src="https://bu.dusays.com/2023/01/14/63c24f0730913.png" alt="image-20230114144248474"></p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol><li>第1轮先选取排序元素中的<strong>第2个元素</strong>为<code>base</code>，<code>base</code>与它之前的所有元素一一比较，然后执行<span class='p red'>插入</span>操作，至此<strong>元素中前2个元素已完成排序</strong>。</li><li>第2轮先选取排序元素中的<strong>第3个元素</strong>为<code>base</code>，<code>base</code>与它之前的所有元素一一比较，然后执行<span class='p red'>插入</span>操作，至此<strong>元素中前3个元素已完成排序</strong>。</li></ol><p>这样排序就完成了，有序序列长度从1变成了3，这个过程进行了<strong>2轮</strong></p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p><strong>时间复杂度O(n<sup>2</sup>)</strong>：</p><ul><li>最差情况下，各轮插入操作循环n-1，n-2，…，2，1次，求和为 ((n - 1) x n ) / 2，使用<strong>O(n<sup>2</sup>)</strong>时间。</li><li>最好情况：<strong>O(n)</strong>，比如：[1,2,3,4,5] 有序情况，整个过程<strong>未进行任何插入操作</strong>，<strong>仅进行比较操作</strong></li></ul><p><strong>空间复杂度O(1)</strong>：变量 i , j 使用常数大小的额外空间。</p><p><strong>稳定性</strong>：<strong>稳定</strong>（不交换相等元素）</p><h3 id="直接插入排序-vs-冒泡排序"><a href="#直接插入排序-vs-冒泡排序" class="headerlink" title="直接插入排序 vs 冒泡排序"></a>直接插入排序 vs 冒泡排序</h3><p style="color:red">虽然「直接插入排序」和「冒泡排序」的时间复杂度皆为O(n<sup>2</sup>) ，但实际运行速度却有很大差别，这是为什么呢？</p><p>回顾复杂度分析，两个方法的循环次数都是((n - 1) x n )/2。但不同的是，「冒泡操作」是在做<emp>元素交换</emp>，需要借助一个临时变量实现，共 3 个单元操作；而「插入操作」是在做<emp>赋值</emp>，只需 1 个单元操作；因此，可以粗略估计出冒泡排序的计算开销约为直接插入排序的 3 倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 冒泡排序的 元素交换</span><br><span class="hljs-built_in">swap</span>(q[j], q[j + <span class="hljs-number">1</span>]); <span class="hljs-comment">// 这个函数实现一下就知道了 共3个单元操作</span><br><span class="hljs-comment">// 直接插入排序的 赋值</span><br>q[j + <span class="hljs-number">1</span>] = q[j];<br></code></pre></td></tr></table></figure><p>直接插入排序运行速度快，并且具有原地（指针变量仅使用常数大小额外空间）、稳定（不交换相等元素）、自适应（最佳情况下，时间复杂度为O(n<sup>2</sup>)的优点，因此很受欢迎。实际上，包括 Java 在内的许多编程语言的排序库函数的实现都用到了直接插入排序。库函数的大致思路：</p><ul><li>对于<strong>长数组</strong>，采用基于分治的排序算法，例如<strong>快速排序</strong>，时间复杂度为O(nlogn)</li><li>对于<strong>短数组</strong>，直接使用<strong>直接插入排序</strong>，时间复杂度为O(n<sup>2</sup>)</li></ul><p>在数组较短时，复杂度中的常数项（即每轮中的单元操作数量）占主导作用，此时插入排序运行地更快。</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_sort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 外层循环保证 n - 1 趟的同时</span><br>    <span class="hljs-comment">// 还保证了选取 第2个 元素作为base</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i++)&#123;<br>        <span class="hljs-type">int</span> base = q[i] , j = i;<br>        <span class="hljs-comment">// 如果 j 大于 0 并且 base 比 q[j - 1] 小</span><br>        <span class="hljs-keyword">while</span>(j &amp;&amp; base &lt; q[j - <span class="hljs-number">1</span>])&#123;<br>            q[j] = q[j - <span class="hljs-number">1</span>];<br>            j--;<br>        &#125;<br>        q[j] = base;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="来自LeetCode的一道题对链表进行直接插入排序"><a href="#来自LeetCode的一道题对链表进行直接插入排序" class="headerlink" title="来自LeetCode的一道题对链表进行直接插入排序"></a>来自LeetCode的一道题<a href="https://leetcode.cn/problems/insertion-sort-list/">对链表进行直接插入排序</a></h4><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><ul><li>列表中的节点数在 <code>[1, 5000]</code>范围内</li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><h4 id="输入样例和输出结果"><a href="#输入样例和输出结果" class="headerlink" title="输入样例和输出结果"></a>输入样例和输出结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: head = [4,2,1,3]<br>输出: [1,2,3,4]<br></code></pre></td></tr></table></figure><p>以上面这个输入为例子，下面是表示图：<br><span style="color:green">绿色</span>：代表<strong>已经排序好的有序序列的元素</strong></p><p><span style="color:brown">褐色</span>：代表<code>base</code>即待插入的元素</p><p><span style="color:red">红色</span>：代表变量关系<br><img src="https://bu.dusays.com/2023/01/14/63c2a6500414f.png" alt="image-20230114205541206"></p><h4 id="算法思路图示-表述如下："><a href="#算法思路图示-表述如下：" class="headerlink" title="算法思路图示 + 表述如下："></a>算法思路图示 + 表述如下：</h4><p><img src="https://bu.dusays.com/2023/01/14/63c2a6c171e50.png" alt="image-20230114205746805"></p><wavy>顺序情况很容易理解，因为直接插入排序就是维护一个有序序列的过程。</wavy><p>我们来分析<wavy>逆序情况</wavy>：</p><p><img src="https://bu.dusays.com/2023/01/14/63c2a6f3ce4d3.png" alt="image-20230114205837275"></p><p>画五角星的这轮，实际上是最容易提取出 task 步骤的，请关注这一轮操作。</p><p>转换成<wavy>部分代码</wavy>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(sortedTail -&gt; val &lt;= base -&gt; val)&#123;<br>    <span class="hljs-comment">// 顺序</span><br>    sortedTail = sortedTail -&gt; next; <span class="hljs-comment">// sortedTail 后移一位    </span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// 逆序 （此处也是关注重点）</span><br>    <span class="hljs-comment">// pre处 是插入点（后插），需要循环找出来，因此 dummy 的重要性就体现出来了</span><br>    <span class="hljs-comment">// 毕竟在这个过程有一个极小的数，需要放在第一个位置，你怎么插？</span><br>    ListNode * pre = dummy;<br>    <span class="hljs-comment">// 过滤掉比base小的，使用 pre -&gt; next -&gt; val 的值来过滤，这样就能求出 插入点</span><br>    <span class="hljs-keyword">while</span>(pre -&gt; next -&gt; val &lt;= base -&gt; val) pre = pre -&gt; next;<br>    <span class="hljs-comment">// 现在 pre 处就是插入点了（后插）</span><br>    <span class="hljs-comment">// 插入三部曲，图示很清楚</span><br>    sortedTail -&gt; next = base -&gt; next;<br>    base -&gt; next = pre -&gt; next;<br>    pre -&gt; next = base;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们实现了<code>step 1</code> 和 <code>step 2</code> 了。</p><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果头结点为空或者只有一个结点，则直接返回头结点</span><br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">// 虚拟头结点，方便操作</span><br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <br>        <span class="hljs-comment">// 直接插入排序：① 默认第1个元素有序。② 第2个元素是 base</span><br>        <span class="hljs-comment">// sortedTail: 有序序列中的 最后一个结点, 在这也是元素中第1个结点</span><br>        <span class="hljs-comment">// base：第2个元素，也是待插入元素</span><br>        ListNode * sortedTail = head, * base = head -&gt; next;<br><br>        <span class="hljs-comment">// 当base不为空，则一直是排序状态</span><br>        <span class="hljs-keyword">while</span>(base)&#123;<br>            <span class="hljs-comment">// base 与 sortedTail比较</span><br>            <span class="hljs-comment">// 产生两种情况 (1. 顺序 2. 逆序)</span><br><br>            <br>            <span class="hljs-keyword">if</span>(sortedTail -&gt; val &lt;= base -&gt; val)&#123;<br>                <span class="hljs-comment">// 顺序</span><br>                sortedTail = sortedTail -&gt; next; <span class="hljs-comment">// sortedTail 后移一位    </span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 逆序，执行 task 步骤</span><br>                ListNode * pre = dummy;<br>                <span class="hljs-comment">// 过滤掉比 base 小的值，pre就是插入的位置</span><br>                <span class="hljs-keyword">while</span>(pre -&gt; next -&gt; val &lt;= base -&gt; val) pre = pre -&gt; next;<br><br>                <span class="hljs-comment">// 插入三部曲</span><br>                sortedTail -&gt; next = base -&gt; next;<br>                base -&gt; next = pre -&gt; next;<br>                pre -&gt; next = base;<br>            &#125;<br>            <span class="hljs-comment">// 注意：base总是 sortedTail的next，不能写成 base = base -&gt; next</span><br>            base = sortedTail -&gt; next;<br>        &#125;<br>        <span class="hljs-comment">// 去掉dummy，返回排序后的链表</span><br>        <span class="hljs-keyword">return</span> dummy -&gt; next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ol><li><p>时间复杂度：<br>对于链表而言，插入元素时只要更新相邻节点的指针即可，不需要像数组一样将插入位置后面的元素往后移动，因此插入操作的<strong>时间复杂度</strong>是<strong>O(1)</strong>，但是找到插入位置需要遍历链表中的节点，<strong>时间复杂度是O(n)</strong>，因此链表直接插入排序的总<strong>时间复杂度</strong>仍然是<strong>O(n<sup>2</sup>)</strong>。</p></li><li><p>空间复杂度：<br>整个排序过程中需要的额外辅助空间为 <code>dummy</code>，<code>sortedTail</code>，<code>base</code>，<code>pre</code>。<br>使用常数大小的额外空间，<strong>空间复杂度为O（1）</strong></p></li></ol><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p><a href="https://leetcode.cn/problems/insertion-sort-list/solution/dui-lian-biao-jin-xing-cha-ru-pai-xu-by-leetcode-s/">LeetCode官方解答</a><br><a href="https://www.hello-algo.com/chapter_sorting/insertion_sort/">Hello 算法</a><br><a href="https://www.acwing.com/activity/content/code/content/4550243/">我自己</a></p>]]></content>
    
    
    <summary type="html">数组和单链表的直接插入排序</summary>
    
    
    
    <category term="算法" scheme="https://blog.phbeats.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://blog.phbeats.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法模板" scheme="https://blog.phbeats.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="LeetCode" scheme="https://blog.phbeats.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>加密文章测试</title>
    <link href="https://blog.phbeats.cn/posts/a9fe598e654c/"/>
    <id>https://blog.phbeats.cn/posts/a9fe598e654c/</id>
    <published>2023-01-02T03:08:52.000Z</published>
    <updated>2023-01-21T14:05:53.269Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9b945f47a85f319860038cd6862648a9668611b8e04c910a270cc50a7d59ad03">40006f26432b51246312fba1b7437ee209fde60e0fcf5d58d590a820a18fc4ba792587e80495c836cdb13cdc873d50343cfdc1bca88a0f14e2ea61212af9e61093cb790572e83a216f2fa0a9dc7fd9a912a94964dbcb0967673f5f5b50103735732d19aa84675422c1d09b817fd323d617f01c072ff6852744db6ba0cde5d09b898843fe188cfd5546703ad6b70a7765d096a14bce4c91312e54b96eb82decb2ff2fc3dbbee174d684b0d7b3af5010db</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">我的第一篇加密测试文章</summary>
    
    
    
    <category term="私密" scheme="https://blog.phbeats.cn/categories/%E7%A7%81%E5%AF%86/"/>
    
    
    <category term="加密的文章" scheme="https://blog.phbeats.cn/tags/%E5%8A%A0%E5%AF%86%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>外挂标签测试</title>
    <link href="https://blog.phbeats.cn/posts/0cb988991ca8/"/>
    <id>https://blog.phbeats.cn/posts/0cb988991ca8/</id>
    <published>2023-01-01T17:10:47.000Z</published>
    <updated>2023-01-21T14:05:53.269Z</updated>
    
    <content type="html"><![CDATA[<h3 id="外挂标签小测试"><a href="#外挂标签小测试" class="headerlink" title="外挂标签小测试"></a>外挂标签小测试</h3><p class='p red'>我是红色的！</p><p class='p green'>我是绿色的！</p>]]></content>
    
    
    <summary type="html">我的第一篇外挂标签测试文章</summary>
    
    
    
    <category term="测试" scheme="https://blog.phbeats.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试文章" scheme="https://blog.phbeats.cn/tags/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>测试文章</title>
    <link href="https://blog.phbeats.cn/posts/ae0a40dc1ca9/"/>
    <id>https://blog.phbeats.cn/posts/ae0a40dc1ca9/</id>
    <published>2023-01-01T14:29:29.000Z</published>
    <updated>2023-01-21T14:05:53.269Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这是我的第一篇测试文章"><a href="#这是我的第一篇测试文章" class="headerlink" title="这是我的第一篇测试文章"></a>这是我的第一篇测试文章</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;这是我的第一篇测试文章&quot;&gt;&lt;a href=&quot;#这是我的第一篇测试文章&quot; class=&quot;headerlink&quot; title=&quot;这是我的第一篇测试文章&quot;&gt;&lt;/a&gt;这是我的第一篇测试文章&lt;/h3&gt;</summary>
      
    
    
    
    <category term="测试" scheme="https://blog.phbeats.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试文章" scheme="https://blog.phbeats.cn/tags/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>测试文章</title>
    <link href="https://blog.phbeats.cn/posts/6df1062bf1dd/"/>
    <id>https://blog.phbeats.cn/posts/6df1062bf1dd/</id>
    <published>2022-01-01T14:18:06.000Z</published>
    <updated>2023-01-21T14:05:53.269Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这是测试文章"><a href="#这是测试文章" class="headerlink" title="这是测试文章"></a>这是测试文章</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;这是测试文章&quot;&gt;&lt;a href=&quot;#这是测试文章&quot; class=&quot;headerlink&quot; title=&quot;这是测试文章&quot;&gt;&lt;/a&gt;这是测试文章&lt;/h3&gt;</summary>
      
    
    
    
    <category term="测试" scheme="https://blog.phbeats.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试文章" scheme="https://blog.phbeats.cn/tags/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
</feed>
